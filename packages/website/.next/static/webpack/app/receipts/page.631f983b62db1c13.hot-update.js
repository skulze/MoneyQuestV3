"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/receipts/page",{

/***/ "(app-pages-browser)/./services/ocrService.ts":
/*!********************************!*\
  !*** ./services/ocrService.ts ***!
  \********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ocrService: () => (/* binding */ ocrService)\n/* harmony export */ });\n/* harmony import */ var tesseract_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tesseract.js */ \"(app-pages-browser)/../../node_modules/tesseract.js/src/index.js\");\n/* harmony import */ var tesseract_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(tesseract_js__WEBPACK_IMPORTED_MODULE_0__);\n\nclass OCRService {\n    async initialize() {\n        if (this.isInitialized) return;\n        try {\n            console.log('ðŸ” Initializing OCR engine...');\n            this.worker = await (0,tesseract_js__WEBPACK_IMPORTED_MODULE_0__.createWorker)('eng');\n            // Configure Tesseract for better receipt reading\n            await this.worker.setParameters({\n                'tessedit_char_whitelist': '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz.,$/:-# ',\n                'tessedit_pageseg_mode': '6',\n                'preserve_interword_spaces': '1'\n            });\n            this.isInitialized = true;\n            console.log('âœ… OCR engine initialized successfully');\n        } catch (error) {\n            console.error('âŒ Failed to initialize OCR engine:', error);\n            throw new Error('Failed to initialize OCR engine');\n        }\n    }\n    async processReceiptImage(imageFile) {\n        if (!this.worker || !this.isInitialized) {\n            await this.initialize();\n        }\n        try {\n            console.log('ðŸ“„ Processing receipt image with OCR...');\n            const result = await this.worker.recognize(imageFile);\n            console.log('âœ… OCR completed', {\n                confidence: result.data.confidence,\n                textLength: result.data.text.length\n            });\n            return {\n                text: result.data.text,\n                confidence: result.data.confidence\n            };\n        } catch (error) {\n            console.error('âŒ OCR processing failed:', error);\n            throw new Error('Failed to process image with OCR');\n        }\n    }\n    parseReceiptText(ocrText, confidence) {\n        console.log('ðŸ” Parsing receipt text...');\n        console.log('Raw OCR text:', ocrText);\n        const lines = ocrText.split('\\n').map((line)=>line.trim()).filter((line)=>line.length > 0);\n        // Extract merchant name (usually first or second line)\n        const merchant = this.extractMerchant(lines);\n        // Extract total amount\n        const amount = this.extractTotalAmount(lines);\n        // Extract date\n        const date = this.extractDate(lines);\n        // Extract line items\n        const items = this.extractItems(lines);\n        const parsed = {\n            merchant,\n            amount,\n            date,\n            items,\n            rawText: ocrText,\n            confidence: Math.max(confidence * 0.8, 60) // Adjust confidence for parsing uncertainty\n        };\n        console.log('âœ… Receipt parsed successfully:', parsed);\n        return parsed;\n    }\n    extractMerchant(lines) {\n        // Look for merchant name in first few lines\n        for(let i = 0; i < Math.min(5, lines.length); i++){\n            const line = lines[i];\n            // Skip lines that are clearly addresses, phone numbers, or receipt info\n            if (line.match(/^\\d+/) || line.includes('RECEIPT') || line.includes('STORE') || line.includes('#') || line.includes('TEL') || line.includes('WWW')) {\n                continue;\n            }\n            // Look for lines with actual merchant names (letters, possibly with spaces)\n            if (line.match(/^[A-Za-z\\s&'.-]+$/) && line.length > 3 && line.length < 50) {\n                return line.toUpperCase();\n            }\n        }\n        return 'UNKNOWN MERCHANT';\n    }\n    extractTotalAmount(lines) {\n        // Look for total amount patterns\n        const totalPatterns = [\n            /TOTAL.*?\\$?(\\d+\\.?\\d*)/i,\n            /AMOUNT.*?\\$?(\\d+\\.?\\d*)/i,\n            /BALANCE.*?\\$?(\\d+\\.?\\d*)/i,\n            /\\$(\\d+\\.\\d{2})\\s*$/,\n            /(\\d+\\.\\d{2})\\s*TOTAL/i\n        ];\n        // Search from bottom up as totals are usually at the end\n        for(let i = lines.length - 1; i >= 0; i--){\n            const line = lines[i];\n            for (const pattern of totalPatterns){\n                const match = line.match(pattern);\n                if (match) {\n                    const amount = parseFloat(match[1]);\n                    if (!isNaN(amount) && amount > 0 && amount < 10000) {\n                        return amount;\n                    }\n                }\n            }\n        }\n        // If no clear total found, look for largest reasonable amount\n        const amounts = [];\n        lines.forEach((line)=>{\n            const matches = line.match(/\\$?(\\d+\\.\\d{2})/g) || [];\n            matches.forEach((match)=>{\n                const amount = parseFloat(match.replace('$', ''));\n                if (!isNaN(amount) && amount > 0 && amount < 10000) {\n                    amounts.push(amount);\n                }\n            });\n        });\n        return amounts.length > 0 ? Math.max(...amounts) : 0;\n    }\n    extractDate(lines) {\n        const datePatterns = [\n            /(\\d{1,2}\\/\\d{1,2}\\/\\d{2,4})/,\n            /(\\d{1,2}-\\d{1,2}-\\d{2,4})/,\n            /(\\d{4}-\\d{2}-\\d{2})/,\n            /(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec).*?(\\d{1,2}),?\\s*(\\d{4})/i\n        ];\n        for (const line of lines){\n            for (const pattern of datePatterns){\n                const match = line.match(pattern);\n                if (match) {\n                    try {\n                        // Try to parse and normalize the date\n                        const dateStr = match[0];\n                        const date = new Date(dateStr);\n                        if (!isNaN(date.getTime())) {\n                            return date.toISOString().split('T')[0]; // Return YYYY-MM-DD format\n                        }\n                    } catch (e) {\n                        continue;\n                    }\n                }\n            }\n        }\n        // Default to today if no date found\n        return new Date().toISOString().split('T')[0];\n    }\n    extractItems(lines) {\n        const items = [];\n        for (const line of lines){\n            // Look for lines with item name and price\n            // Pattern: \"ITEM NAME    $X.XX\" or \"QTY ITEM NAME $X.XX\"\n            const itemPatterns = [\n                /^(\\d+)\\s+(.+?)\\s+\\$?(\\d+\\.\\d{2})$/,\n                /^(.+?)\\s+\\$?(\\d+\\.\\d{2})$/,\n                /^(.+?)\\s+(\\d+\\.\\d{2})\\s*$/ // \"BANANAS 3.99\"\n            ];\n            for (const pattern of itemPatterns){\n                const match = line.match(pattern);\n                if (match) {\n                    let quantity;\n                    let name;\n                    let price;\n                    if (match.length === 4) {\n                        // Pattern with quantity\n                        quantity = parseInt(match[1]);\n                        name = match[2].trim();\n                        price = parseFloat(match[3]);\n                    } else {\n                        // Pattern without quantity\n                        name = match[1].trim();\n                        price = parseFloat(match[2]);\n                    }\n                    // Filter out obviously non-item lines\n                    if (name && !name.match(/TOTAL|TAX|SUBTOTAL|CHANGE|BALANCE|RECEIPT|STORE|THANK/i) && name.length > 2 && name.length < 50 && price > 0 && price < 1000) {\n                        items.push({\n                            name: name.toUpperCase(),\n                            price,\n                            quantity\n                        });\n                    }\n                    break;\n                }\n            }\n        }\n        return items;\n    }\n    async cleanup() {\n        if (this.worker) {\n            await this.worker.terminate();\n            this.worker = null;\n            this.isInitialized = false;\n            console.log('ðŸ§¹ OCR engine cleaned up');\n        }\n    }\n    constructor(){\n        this.worker = null;\n        this.isInitialized = false;\n    }\n}\n// Export singleton instance\nconst ocrService = new OCRService();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NlcnZpY2VzL29jclNlcnZpY2UudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTRDO0FBb0I1QyxNQUFNQztJQUlKLE1BQU1DLGFBQTRCO1FBQ2hDLElBQUksSUFBSSxDQUFDQyxhQUFhLEVBQUU7UUFFeEIsSUFBSTtZQUNGQyxRQUFRQyxHQUFHLENBQUM7WUFDWixJQUFJLENBQUNDLE1BQU0sR0FBRyxNQUFNTiwwREFBWUEsQ0FBQztZQUVqQyxpREFBaUQ7WUFDakQsTUFBTSxJQUFJLENBQUNNLE1BQU0sQ0FBQ0MsYUFBYSxDQUFDO2dCQUM5QiwyQkFBMkI7Z0JBQzNCLHlCQUF5QjtnQkFDekIsNkJBQTZCO1lBQy9CO1lBRUEsSUFBSSxDQUFDSixhQUFhLEdBQUc7WUFDckJDLFFBQVFDLEdBQUcsQ0FBQztRQUNkLEVBQUUsT0FBT0csT0FBTztZQUNkSixRQUFRSSxLQUFLLENBQUMsc0NBQXNDQTtZQUNwRCxNQUFNLElBQUlDLE1BQU07UUFDbEI7SUFDRjtJQUVBLE1BQU1DLG9CQUFvQkMsU0FBZSxFQUFzQjtRQUM3RCxJQUFJLENBQUMsSUFBSSxDQUFDTCxNQUFNLElBQUksQ0FBQyxJQUFJLENBQUNILGFBQWEsRUFBRTtZQUN2QyxNQUFNLElBQUksQ0FBQ0QsVUFBVTtRQUN2QjtRQUVBLElBQUk7WUFDRkUsUUFBUUMsR0FBRyxDQUFDO1lBQ1osTUFBTU8sU0FBUyxNQUFNLElBQUksQ0FBQ04sTUFBTSxDQUFFTyxTQUFTLENBQUNGO1lBRTVDUCxRQUFRQyxHQUFHLENBQUMsbUJBQW1CO2dCQUM3QlMsWUFBWUYsT0FBT0csSUFBSSxDQUFDRCxVQUFVO2dCQUNsQ0UsWUFBWUosT0FBT0csSUFBSSxDQUFDRSxJQUFJLENBQUNDLE1BQU07WUFDckM7WUFFQSxPQUFPO2dCQUNMRCxNQUFNTCxPQUFPRyxJQUFJLENBQUNFLElBQUk7Z0JBQ3RCSCxZQUFZRixPQUFPRyxJQUFJLENBQUNELFVBQVU7WUFDcEM7UUFDRixFQUFFLE9BQU9O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QixNQUFNLEtBQUssR0FBRzt3QkFDdEIsd0JBQXdCO3dCQUN4QjBDLFdBQVdHLFNBQVN0QixLQUFLLENBQUMsRUFBRTt3QkFDNUJvQixPQUFPcEIsS0FBSyxDQUFDLEVBQUUsQ0FBQ2hCLElBQUk7d0JBQ3BCcUMsUUFBUWhCLFdBQVdMLEtBQUssQ0FBQyxFQUFFO29CQUM3QixPQUFPO3dCQUNMLDJCQUEyQjt3QkFDM0JvQixPQUFPcEIsS0FBSyxDQUFDLEVBQUUsQ0FBQ2hCLElBQUk7d0JBQ3BCcUMsUUFBUWhCLFdBQVdMLEtBQUssQ0FBQyxFQUFFO29CQUM3QjtvQkFFQSxzQ0FBc0M7b0JBQ3RDLElBQUlvQixRQUFRLENBQUNBLEtBQUtwQixLQUFLLENBQUMsNkRBQ3BCb0IsS0FBSzNDLE1BQU0sR0FBRyxLQUFLMkMsS0FBSzNDLE1BQU0sR0FBRyxNQUFNNEMsUUFBUSxLQUFLQSxRQUFRLE1BQU07d0JBRXBFN0IsTUFBTW1CLElBQUksQ0FBQzs0QkFDVFMsTUFBTUEsS0FBS2xCLFdBQVc7NEJBQ3RCbUI7NEJBQ0FGO3dCQUNGO29CQUNGO29CQUNBO2dCQUNGO1lBQ0Y7UUFDRjtRQUVBLE9BQU8zQjtJQUNUO0lBRUEsTUFBTStCLFVBQXlCO1FBQzdCLElBQUksSUFBSSxDQUFDMUQsTUFBTSxFQUFFO1lBQ2YsTUFBTSxJQUFJLENBQUNBLE1BQU0sQ0FBQzJELFNBQVM7WUFDM0IsSUFBSSxDQUFDM0QsTUFBTSxHQUFHO1lBQ2QsSUFBSSxDQUFDSCxhQUFhLEdBQUc7WUFDckJDLFFBQVFDLEdBQUcsQ0FBQztRQUNkO0lBQ0Y7O2FBOU5RQyxTQUFrQzthQUNsQ0gsZ0JBQWdCOztBQThOMUI7QUFFQSw0QkFBNEI7QUFDckIsTUFBTStELGFBQWEsSUFBSWpFLGFBQWEiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbmF0aGFcXE9uZURyaXZlXFxEZXNrdG9wXFxNb25leVF1ZXN0VjNcXHBhY2thZ2VzXFx3ZWJzaXRlXFxzZXJ2aWNlc1xcb2NyU2VydmljZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVXb3JrZXIgfSBmcm9tICd0ZXNzZXJhY3QuanMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIE9DUlJlc3VsdCB7XG4gIHRleHQ6IHN0cmluZztcbiAgY29uZmlkZW5jZTogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFBhcnNlZFJlY2VpcHQge1xuICBtZXJjaGFudDogc3RyaW5nO1xuICBhbW91bnQ6IG51bWJlcjtcbiAgZGF0ZTogc3RyaW5nO1xuICBpdGVtczogQXJyYXk8e1xuICAgIG5hbWU6IHN0cmluZztcbiAgICBwcmljZTogbnVtYmVyO1xuICAgIHF1YW50aXR5PzogbnVtYmVyO1xuICB9PjtcbiAgcmF3VGV4dDogc3RyaW5nO1xuICBjb25maWRlbmNlOiBudW1iZXI7XG59XG5cbmNsYXNzIE9DUlNlcnZpY2Uge1xuICBwcml2YXRlIHdvcmtlcjogVGVzc2VyYWN0LldvcmtlciB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIGlzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcblxuICBhc3luYyBpbml0aWFsaXplKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICh0aGlzLmlzSW5pdGlhbGl6ZWQpIHJldHVybjtcblxuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZygn8J+UjSBJbml0aWFsaXppbmcgT0NSIGVuZ2luZS4uLicpO1xuICAgICAgdGhpcy53b3JrZXIgPSBhd2FpdCBjcmVhdGVXb3JrZXIoJ2VuZycpO1xuXG4gICAgICAvLyBDb25maWd1cmUgVGVzc2VyYWN0IGZvciBiZXR0ZXIgcmVjZWlwdCByZWFkaW5nXG4gICAgICBhd2FpdCB0aGlzLndvcmtlci5zZXRQYXJhbWV0ZXJzKHtcbiAgICAgICAgJ3Rlc3NlZGl0X2NoYXJfd2hpdGVsaXN0JzogJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6LiwkLzotIyAnLFxuICAgICAgICAndGVzc2VkaXRfcGFnZXNlZ19tb2RlJzogJzYnLCAvLyBTaW5nbGUgdW5pZm9ybSBibG9jayBvZiB0ZXh0XG4gICAgICAgICdwcmVzZXJ2ZV9pbnRlcndvcmRfc3BhY2VzJzogJzEnXG4gICAgICB9KTtcblxuICAgICAgdGhpcy5pc0luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgIGNvbnNvbGUubG9nKCfinIUgT0NSIGVuZ2luZSBpbml0aWFsaXplZCBzdWNjZXNzZnVsbHknKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcign4p2MIEZhaWxlZCB0byBpbml0aWFsaXplIE9DUiBlbmdpbmU6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gaW5pdGlhbGl6ZSBPQ1IgZW5naW5lJyk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgcHJvY2Vzc1JlY2VpcHRJbWFnZShpbWFnZUZpbGU6IEZpbGUpOiBQcm9taXNlPE9DUlJlc3VsdD4ge1xuICAgIGlmICghdGhpcy53b3JrZXIgfHwgIXRoaXMuaXNJbml0aWFsaXplZCkge1xuICAgICAgYXdhaXQgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKCfwn5OEIFByb2Nlc3NpbmcgcmVjZWlwdCBpbWFnZSB3aXRoIE9DUi4uLicpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy53b3JrZXIhLnJlY29nbml6ZShpbWFnZUZpbGUpO1xuXG4gICAgICBjb25zb2xlLmxvZygn4pyFIE9DUiBjb21wbGV0ZWQnLCB7XG4gICAgICAgIGNvbmZpZGVuY2U6IHJlc3VsdC5kYXRhLmNvbmZpZGVuY2UsXG4gICAgICAgIHRleHRMZW5ndGg6IHJlc3VsdC5kYXRhLnRleHQubGVuZ3RoXG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGV4dDogcmVzdWx0LmRhdGEudGV4dCxcbiAgICAgICAgY29uZmlkZW5jZTogcmVzdWx0LmRhdGEuY29uZmlkZW5jZVxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcign4p2MIE9DUiBwcm9jZXNzaW5nIGZhaWxlZDonLCBlcnJvcik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBwcm9jZXNzIGltYWdlIHdpdGggT0NSJyk7XG4gICAgfVxuICB9XG5cbiAgcGFyc2VSZWNlaXB0VGV4dChvY3JUZXh0OiBzdHJpbmcsIGNvbmZpZGVuY2U6IG51bWJlcik6IFBhcnNlZFJlY2VpcHQge1xuICAgIGNvbnNvbGUubG9nKCfwn5SNIFBhcnNpbmcgcmVjZWlwdCB0ZXh0Li4uJyk7XG4gICAgY29uc29sZS5sb2coJ1JhdyBPQ1IgdGV4dDonLCBvY3JUZXh0KTtcblxuICAgIGNvbnN0IGxpbmVzID0gb2NyVGV4dC5zcGxpdCgnXFxuJykubWFwKGxpbmUgPT4gbGluZS50cmltKCkpLmZpbHRlcihsaW5lID0+IGxpbmUubGVuZ3RoID4gMCk7XG5cbiAgICAvLyBFeHRyYWN0IG1lcmNoYW50IG5hbWUgKHVzdWFsbHkgZmlyc3Qgb3Igc2Vjb25kIGxpbmUpXG4gICAgY29uc3QgbWVyY2hhbnQgPSB0aGlzLmV4dHJhY3RNZXJjaGFudChsaW5lcyk7XG5cbiAgICAvLyBFeHRyYWN0IHRvdGFsIGFtb3VudFxuICAgIGNvbnN0IGFtb3VudCA9IHRoaXMuZXh0cmFjdFRvdGFsQW1vdW50KGxpbmVzKTtcblxuICAgIC8vIEV4dHJhY3QgZGF0ZVxuICAgIGNvbnN0IGRhdGUgPSB0aGlzLmV4dHJhY3REYXRlKGxpbmVzKTtcblxuICAgIC8vIEV4dHJhY3QgbGluZSBpdGVtc1xuICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5leHRyYWN0SXRlbXMobGluZXMpO1xuXG4gICAgY29uc3QgcGFyc2VkOiBQYXJzZWRSZWNlaXB0ID0ge1xuICAgICAgbWVyY2hhbnQsXG4gICAgICBhbW91bnQsXG4gICAgICBkYXRlLFxuICAgICAgaXRlbXMsXG4gICAgICByYXdUZXh0OiBvY3JUZXh0LFxuICAgICAgY29uZmlkZW5jZTogTWF0aC5tYXgoY29uZmlkZW5jZSAqIDAuOCwgNjApIC8vIEFkanVzdCBjb25maWRlbmNlIGZvciBwYXJzaW5nIHVuY2VydGFpbnR5XG4gICAgfTtcblxuICAgIGNvbnNvbGUubG9nKCfinIUgUmVjZWlwdCBwYXJzZWQgc3VjY2Vzc2Z1bGx5OicsIHBhcnNlZCk7XG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuXG4gIHByaXZhdGUgZXh0cmFjdE1lcmNoYW50KGxpbmVzOiBzdHJpbmdbXSk6IHN0cmluZyB7XG4gICAgLy8gTG9vayBmb3IgbWVyY2hhbnQgbmFtZSBpbiBmaXJzdCBmZXcgbGluZXNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE1hdGgubWluKDUsIGxpbmVzLmxlbmd0aCk7IGkrKykge1xuICAgICAgY29uc3QgbGluZSA9IGxpbmVzW2ldO1xuICAgICAgLy8gU2tpcCBsaW5lcyB0aGF0IGFyZSBjbGVhcmx5IGFkZHJlc3NlcywgcGhvbmUgbnVtYmVycywgb3IgcmVjZWlwdCBpbmZvXG4gICAgICBpZiAobGluZS5tYXRjaCgvXlxcZCsvKSB8fCBsaW5lLmluY2x1ZGVzKCdSRUNFSVBUJykgfHwgbGluZS5pbmNsdWRlcygnU1RPUkUnKSB8fFxuICAgICAgICAgIGxpbmUuaW5jbHVkZXMoJyMnKSB8fCBsaW5lLmluY2x1ZGVzKCdURUwnKSB8fCBsaW5lLmluY2x1ZGVzKCdXV1cnKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIC8vIExvb2sgZm9yIGxpbmVzIHdpdGggYWN0dWFsIG1lcmNoYW50IG5hbWVzIChsZXR0ZXJzLCBwb3NzaWJseSB3aXRoIHNwYWNlcylcbiAgICAgIGlmIChsaW5lLm1hdGNoKC9eW0EtWmEtelxccyYnLi1dKyQvKSAmJiBsaW5lLmxlbmd0aCA+IDMgJiYgbGluZS5sZW5ndGggPCA1MCkge1xuICAgICAgICByZXR1cm4gbGluZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gJ1VOS05PV04gTUVSQ0hBTlQnO1xuICB9XG5cbiAgcHJpdmF0ZSBleHRyYWN0VG90YWxBbW91bnQobGluZXM6IHN0cmluZ1tdKTogbnVtYmVyIHtcbiAgICAvLyBMb29rIGZvciB0b3RhbCBhbW91bnQgcGF0dGVybnNcbiAgICBjb25zdCB0b3RhbFBhdHRlcm5zID0gW1xuICAgICAgL1RPVEFMLio/XFwkPyhcXGQrXFwuP1xcZCopL2ksXG4gICAgICAvQU1PVU5ULio/XFwkPyhcXGQrXFwuP1xcZCopL2ksXG4gICAgICAvQkFMQU5DRS4qP1xcJD8oXFxkK1xcLj9cXGQqKS9pLFxuICAgICAgL1xcJChcXGQrXFwuXFxkezJ9KVxccyokLywgLy8gTGluZSBlbmRpbmcgd2l0aCBjdXJyZW5jeSBhbW91bnRcbiAgICAgIC8oXFxkK1xcLlxcZHsyfSlcXHMqVE9UQUwvaVxuICAgIF07XG5cbiAgICAvLyBTZWFyY2ggZnJvbSBib3R0b20gdXAgYXMgdG90YWxzIGFyZSB1c3VhbGx5IGF0IHRoZSBlbmRcbiAgICBmb3IgKGxldCBpID0gbGluZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGNvbnN0IGxpbmUgPSBsaW5lc1tpXTtcblxuICAgICAgZm9yIChjb25zdCBwYXR0ZXJuIG9mIHRvdGFsUGF0dGVybnMpIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBsaW5lLm1hdGNoKHBhdHRlcm4pO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICBjb25zdCBhbW91bnQgPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgICAgICAgICBpZiAoIWlzTmFOKGFtb3VudCkgJiYgYW1vdW50ID4gMCAmJiBhbW91bnQgPCAxMDAwMCkgeyAvLyBSZWFzb25hYmxlIGJvdW5kc1xuICAgICAgICAgICAgcmV0dXJuIGFtb3VudDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiBubyBjbGVhciB0b3RhbCBmb3VuZCwgbG9vayBmb3IgbGFyZ2VzdCByZWFzb25hYmxlIGFtb3VudFxuICAgIGNvbnN0IGFtb3VudHM6IG51bWJlcltdID0gW107XG4gICAgbGluZXMuZm9yRWFjaChsaW5lID0+IHtcbiAgICAgIGNvbnN0IG1hdGNoZXMgPSBsaW5lLm1hdGNoKC9cXCQ/KFxcZCtcXC5cXGR7Mn0pL2cpIHx8IFtdO1xuICAgICAgbWF0Y2hlcy5mb3JFYWNoKG1hdGNoID0+IHtcbiAgICAgICAgY29uc3QgYW1vdW50ID0gcGFyc2VGbG9hdChtYXRjaC5yZXBsYWNlKCckJywgJycpKTtcbiAgICAgICAgaWYgKCFpc05hTihhbW91bnQpICYmIGFtb3VudCA+IDAgJiYgYW1vdW50IDwgMTAwMDApIHtcbiAgICAgICAgICBhbW91bnRzLnB1c2goYW1vdW50KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gYW1vdW50cy5sZW5ndGggPiAwID8gTWF0aC5tYXgoLi4uYW1vdW50cykgOiAwO1xuICB9XG5cbiAgcHJpdmF0ZSBleHRyYWN0RGF0ZShsaW5lczogc3RyaW5nW10pOiBzdHJpbmcge1xuICAgIGNvbnN0IGRhdGVQYXR0ZXJucyA9IFtcbiAgICAgIC8oXFxkezEsMn1cXC9cXGR7MSwyfVxcL1xcZHsyLDR9KS8sXG4gICAgICAvKFxcZHsxLDJ9LVxcZHsxLDJ9LVxcZHsyLDR9KS8sXG4gICAgICAvKFxcZHs0fS1cXGR7Mn0tXFxkezJ9KS8sXG4gICAgICAvKEphbnxGZWJ8TWFyfEFwcnxNYXl8SnVufEp1bHxBdWd8U2VwfE9jdHxOb3Z8RGVjKS4qPyhcXGR7MSwyfSksP1xccyooXFxkezR9KS9pXG4gICAgXTtcblxuICAgIGZvciAoY29uc3QgbGluZSBvZiBsaW5lcykge1xuICAgICAgZm9yIChjb25zdCBwYXR0ZXJuIG9mIGRhdGVQYXR0ZXJucykge1xuICAgICAgICBjb25zdCBtYXRjaCA9IGxpbmUubWF0Y2gocGF0dGVybik7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBUcnkgdG8gcGFyc2UgYW5kIG5vcm1hbGl6ZSB0aGUgZGF0ZVxuICAgICAgICAgICAgY29uc3QgZGF0ZVN0ciA9IG1hdGNoWzBdO1xuICAgICAgICAgICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKGRhdGVTdHIpO1xuICAgICAgICAgICAgaWYgKCFpc05hTihkYXRlLmdldFRpbWUoKSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGRhdGUudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdOyAvLyBSZXR1cm4gWVlZWS1NTS1ERCBmb3JtYXRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEZWZhdWx0IHRvIHRvZGF5IGlmIG5vIGRhdGUgZm91bmRcbiAgICByZXR1cm4gbmV3IERhdGUoKS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF07XG4gIH1cblxuICBwcml2YXRlIGV4dHJhY3RJdGVtcyhsaW5lczogc3RyaW5nW10pOiBBcnJheTx7IG5hbWU6IHN0cmluZzsgcHJpY2U6IG51bWJlcjsgcXVhbnRpdHk/OiBudW1iZXIgfT4ge1xuICAgIGNvbnN0IGl0ZW1zOiBBcnJheTx7IG5hbWU6IHN0cmluZzsgcHJpY2U6IG51bWJlcjsgcXVhbnRpdHk/OiBudW1iZXIgfT4gPSBbXTtcblxuICAgIGZvciAoY29uc3QgbGluZSBvZiBsaW5lcykge1xuICAgICAgLy8gTG9vayBmb3IgbGluZXMgd2l0aCBpdGVtIG5hbWUgYW5kIHByaWNlXG4gICAgICAvLyBQYXR0ZXJuOiBcIklURU0gTkFNRSAgICAkWC5YWFwiIG9yIFwiUVRZIElURU0gTkFNRSAkWC5YWFwiXG4gICAgICBjb25zdCBpdGVtUGF0dGVybnMgPSBbXG4gICAgICAgIC9eKFxcZCspXFxzKyguKz8pXFxzK1xcJD8oXFxkK1xcLlxcZHsyfSkkLywgIC8vIFwiMiBCQU5BTkFTICQzLjk5XCJcbiAgICAgICAgL14oLis/KVxccytcXCQ/KFxcZCtcXC5cXGR7Mn0pJC8sICAgICAgICAgICAvLyBcIkJBTkFOQVMgJDMuOTlcIlxuICAgICAgICAvXiguKz8pXFxzKyhcXGQrXFwuXFxkezJ9KVxccyokLyAgICAgICAgICAgIC8vIFwiQkFOQU5BUyAzLjk5XCJcbiAgICAgIF07XG5cbiAgICAgIGZvciAoY29uc3QgcGF0dGVybiBvZiBpdGVtUGF0dGVybnMpIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBsaW5lLm1hdGNoKHBhdHRlcm4pO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICBsZXQgcXVhbnRpdHk6IG51bWJlciB8IHVuZGVmaW5lZDtcbiAgICAgICAgICBsZXQgbmFtZTogc3RyaW5nO1xuICAgICAgICAgIGxldCBwcmljZTogbnVtYmVyO1xuXG4gICAgICAgICAgaWYgKG1hdGNoLmxlbmd0aCA9PT0gNCkge1xuICAgICAgICAgICAgLy8gUGF0dGVybiB3aXRoIHF1YW50aXR5XG4gICAgICAgICAgICBxdWFudGl0eSA9IHBhcnNlSW50KG1hdGNoWzFdKTtcbiAgICAgICAgICAgIG5hbWUgPSBtYXRjaFsyXS50cmltKCk7XG4gICAgICAgICAgICBwcmljZSA9IHBhcnNlRmxvYXQobWF0Y2hbM10pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBQYXR0ZXJuIHdpdGhvdXQgcXVhbnRpdHlcbiAgICAgICAgICAgIG5hbWUgPSBtYXRjaFsxXS50cmltKCk7XG4gICAgICAgICAgICBwcmljZSA9IHBhcnNlRmxvYXQobWF0Y2hbMl0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEZpbHRlciBvdXQgb2J2aW91c2x5IG5vbi1pdGVtIGxpbmVzXG4gICAgICAgICAgaWYgKG5hbWUgJiYgIW5hbWUubWF0Y2goL1RPVEFMfFRBWHxTVUJUT1RBTHxDSEFOR0V8QkFMQU5DRXxSRUNFSVBUfFNUT1JFfFRIQU5LL2kpICYmXG4gICAgICAgICAgICAgIG5hbWUubGVuZ3RoID4gMiAmJiBuYW1lLmxlbmd0aCA8IDUwICYmIHByaWNlID4gMCAmJiBwcmljZSA8IDEwMDApIHtcblxuICAgICAgICAgICAgaXRlbXMucHVzaCh7XG4gICAgICAgICAgICAgIG5hbWU6IG5hbWUudG9VcHBlckNhc2UoKSxcbiAgICAgICAgICAgICAgcHJpY2UsXG4gICAgICAgICAgICAgIHF1YW50aXR5XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaXRlbXM7XG4gIH1cblxuICBhc3luYyBjbGVhbnVwKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICh0aGlzLndvcmtlcikge1xuICAgICAgYXdhaXQgdGhpcy53b3JrZXIudGVybWluYXRlKCk7XG4gICAgICB0aGlzLndvcmtlciA9IG51bGw7XG4gICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgIGNvbnNvbGUubG9nKCfwn6e5IE9DUiBlbmdpbmUgY2xlYW5lZCB1cCcpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBFeHBvcnQgc2luZ2xldG9uIGluc3RhbmNlXG5leHBvcnQgY29uc3Qgb2NyU2VydmljZSA9IG5ldyBPQ1JTZXJ2aWNlKCk7Il0sIm5hbWVzIjpbImNyZWF0ZVdvcmtlciIsIk9DUlNlcnZpY2UiLCJpbml0aWFsaXplIiwiaXNJbml0aWFsaXplZCIsImNvbnNvbGUiLCJsb2ciLCJ3b3JrZXIiLCJzZXRQYXJhbWV0ZXJzIiwiZXJyb3IiLCJFcnJvciIsInByb2Nlc3NSZWNlaXB0SW1hZ2UiLCJpbWFnZUZpbGUiLCJyZXN1bHQiLCJyZWNvZ25pemUiLCJjb25maWRlbmNlIiwiZGF0YSIsInRleHRMZW5ndGgiLCJ0ZXh0IiwibGVuZ3RoIiwicGFyc2VSZWNlaXB0VGV4dCIsIm9jclRleHQiLCJsaW5lcyIsInNwbGl0IiwibWFwIiwibGluZSIsInRyaW0iLCJmaWx0ZXIiLCJtZXJjaGFudCIsImV4dHJhY3RNZXJjaGFudCIsImFtb3VudCIsImV4dHJhY3RUb3RhbEFtb3VudCIsImRhdGUiLCJleHRyYWN0RGF0ZSIsIml0ZW1zIiwiZXh0cmFjdEl0ZW1zIiwicGFyc2VkIiwicmF3VGV4dCIsIk1hdGgiLCJtYXgiLCJpIiwibWluIiwibWF0Y2giLCJpbmNsdWRlcyIsInRvVXBwZXJDYXNlIiwidG90YWxQYXR0ZXJucyIsInBhdHRlcm4iLCJwYXJzZUZsb2F0IiwiaXNOYU4iLCJhbW91bnRzIiwiZm9yRWFjaCIsIm1hdGNoZXMiLCJyZXBsYWNlIiwicHVzaCIsImRhdGVQYXR0ZXJucyIsImRhdGVTdHIiLCJEYXRlIiwiZ2V0VGltZSIsInRvSVNPU3RyaW5nIiwiZSIsIml0ZW1QYXR0ZXJucyIsInF1YW50aXR5IiwibmFtZSIsInByaWNlIiwicGFyc2VJbnQiLCJjbGVhbnVwIiwidGVybWluYXRlIiwib2NyU2VydmljZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./services/ocrService.ts\n"));

/***/ })

});