"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/receipts/page",{

/***/ "(app-pages-browser)/./services/ocrService.ts":
/*!********************************!*\
  !*** ./services/ocrService.ts ***!
  \********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ocrService: () => (/* binding */ ocrService)\n/* harmony export */ });\n/* harmony import */ var tesseract_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tesseract.js */ \"(app-pages-browser)/../../node_modules/tesseract.js/src/index.js\");\n/* harmony import */ var tesseract_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(tesseract_js__WEBPACK_IMPORTED_MODULE_0__);\n\nclass OCRService {\n    async initialize() {\n        if (this.isInitialized) return;\n        try {\n            console.log('🔍 Initializing OCR engine...');\n            this.worker = await (0,tesseract_js__WEBPACK_IMPORTED_MODULE_0__.createWorker)('eng');\n            // Configure Tesseract for better receipt reading with more characters\n            await this.worker.setParameters({\n                'tessedit_char_whitelist': '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz.,$/:-#%*()&@+ ',\n                'tessedit_pageseg_mode': '4',\n                'preserve_interword_spaces': '1',\n                'tessedit_create_hocr': '1',\n                'textord_min_linesize': '1.25',\n                'textord_tabfind_find_tables': '1',\n                'textord_tablefind_good_width': '3',\n                'textord_tabfind_show_vlines': '1' // Show vertical lines for debugging\n            });\n            this.isInitialized = true;\n            console.log('✅ OCR engine initialized successfully');\n        } catch (error) {\n            console.error('❌ Failed to initialize OCR engine:', error);\n            throw new Error('Failed to initialize OCR engine');\n        }\n    }\n    async preprocessImage(imageFile) {\n        return new Promise((resolve, reject)=>{\n            const canvas = document.createElement('canvas');\n            const ctx = canvas.getContext('2d');\n            const img = new Image();\n            img.onload = ()=>{\n                // Add padding around the image to prevent edge cropping\n                const padding = 20;\n                canvas.width = img.width + padding * 2;\n                canvas.height = img.height + padding * 2;\n                if (!ctx) {\n                    reject(new Error('Could not get canvas context'));\n                    return;\n                }\n                // Fill with white background\n                ctx.fillStyle = 'white';\n                ctx.fillRect(0, 0, canvas.width, canvas.height);\n                // Draw original image with padding\n                ctx.drawImage(img, padding, padding);\n                // Get image data for processing\n                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n                const data = imageData.data;\n                // Convert to grayscale and increase contrast (more aggressive for small text)\n                for(let i = 0; i < data.length; i += 4){\n                    const gray = Math.round(0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2]);\n                    // More aggressive contrast enhancement for small numbers\n                    const contrast = 2.0; // Increased from 1.5\n                    const factor = 259 * (contrast + 255) / (255 * (259 - contrast));\n                    let enhanced = factor * (gray - 128) + 128;\n                    // Apply threshold to make small text more distinct\n                    if (enhanced < 128) {\n                        enhanced = Math.max(0, enhanced * 0.7); // Make dark areas darker\n                    } else {\n                        enhanced = Math.min(255, enhanced * 1.2); // Make light areas lighter\n                    }\n                    data[i] = enhanced; // Red\n                    data[i + 1] = enhanced; // Green\n                    data[i + 2] = enhanced; // Blue\n                // Alpha stays the same\n                }\n                // Put the processed image data back\n                ctx.putImageData(imageData, 0, 0);\n                // Convert to data URL\n                resolve(canvas.toDataURL('image/png'));\n            };\n            img.onerror = ()=>reject(new Error('Failed to load image'));\n            img.src = URL.createObjectURL(imageFile);\n        });\n    }\n    reconstructAlignedText(ocrData) {\n        if (!ocrData.lines || ocrData.lines.length === 0) {\n            return ocrData.text || '';\n        }\n        console.log('🔧 Reconstructing aligned text from', ocrData.lines.length, 'lines');\n        const lines = [];\n        for (const line of ocrData.lines){\n            if (!line.words || line.words.length === 0) continue;\n            // Sort words by x position (left to right)\n            const sortedWords = [\n                ...line.words\n            ].sort((a, b)=>a.bbox.x0 - b.bbox.x0);\n            let lineText = '';\n            let lastX = 0;\n            for(let i = 0; i < sortedWords.length; i++){\n                const word = sortedWords[i];\n                const wordText = word.text.trim();\n                if (wordText.length === 0) continue;\n                // Calculate spacing needed based on x-position\n                const currentX = word.bbox.x0;\n                const wordWidth = word.bbox.x1 - word.bbox.x0;\n                if (i > 0) {\n                    // Calculate gap between this word and previous word\n                    const gap = currentX - lastX;\n                    const avgCharWidth = 10; // Approximate character width\n                    const spacesNeeded = Math.max(1, Math.floor(gap / avgCharWidth));\n                    // Add appropriate spacing (but cap it to prevent excessive spacing)\n                    lineText += ' '.repeat(Math.min(spacesNeeded, 20));\n                }\n                lineText += wordText;\n                lastX = word.bbox.x1;\n            }\n            if (lineText.trim().length > 0) {\n                lines.push(lineText);\n            }\n        }\n        const reconstructedText = lines.join('\\n');\n        console.log('✅ Reconstructed text with alignment:', reconstructedText.substring(0, 200) + '...');\n        return reconstructedText;\n    }\n    async processReceiptImage(imageFile) {\n        if (!this.worker || !this.isInitialized) {\n            await this.initialize();\n        }\n        try {\n            var _result_data_words;\n            console.log('📄 Preprocessing receipt image...');\n            const preprocessedImage = await this.preprocessImage(imageFile);\n            console.log('🔍 Processing receipt image with OCR...');\n            const result = await this.worker.recognize(preprocessedImage);\n            console.log('✅ OCR completed', {\n                confidence: result.data.confidence,\n                textLength: result.data.text.length,\n                wordsFound: ((_result_data_words = result.data.words) === null || _result_data_words === void 0 ? void 0 : _result_data_words.length) || 0\n            });\n            // Reconstruct text with better alignment using word positions\n            const alignedText = this.reconstructAlignedText(result.data);\n            return {\n                text: alignedText,\n                confidence: result.data.confidence\n            };\n        } catch (error) {\n            console.error('❌ OCR processing failed:', error);\n            throw new Error('Failed to process image with OCR');\n        }\n    }\n    parseReceiptText(ocrText, confidence) {\n        console.log('🔍 Parsing receipt text...');\n        console.log('Raw OCR text:', ocrText);\n        const lines = ocrText.split('\\n').map((line)=>line.trim()).filter((line)=>line.length > 0);\n        // Extract merchant name (usually first or second line)\n        const merchant = this.extractMerchant(lines);\n        // Extract line items FIRST (including tax)\n        const items = this.extractItems(lines);\n        // Extract total amount using the new rule\n        const amount = this.extractValidatedTotal(lines, items);\n        // Extract date\n        const date = this.extractDate(lines);\n        const parsed = {\n            merchant,\n            amount,\n            date,\n            items,\n            rawText: ocrText,\n            confidence: Math.max(confidence * 0.8, 60) // Adjust confidence for parsing uncertainty\n        };\n        console.log('✅ Receipt parsed successfully:', parsed);\n        return parsed;\n    }\n    extractMerchant(lines) {\n        // Common merchant patterns to look for\n        const merchantPatterns = [\n            /^([A-Za-z\\s&'.-]{3,40})$/,\n            /^([A-Z\\s&'.-]{3,40})\\s+STORE/,\n            /^([A-Z\\s&'.-]{3,40})\\s+MARKET/,\n            /^([A-Z\\s&'.-]{3,40})\\s+INC/\n        ];\n        // Look for merchant name in first 7 lines\n        for(let i = 0; i < Math.min(7, lines.length); i++){\n            const line = lines[i].trim();\n            // Skip obviously non-merchant lines\n            if (line.match(/^\\d+/) || line.includes('RECEIPT') || line.includes('INVOICE') || line.includes('#') || line.includes('TEL') || line.includes('WWW') || line.includes('@') || line.includes('.COM') || line.includes('STREET') || line.includes('AVE') || line.includes('BLVD') || line.includes('RD') || line.length < 3 || line.length > 50) {\n                continue;\n            }\n            // Try merchant patterns\n            for (const pattern of merchantPatterns){\n                const match = line.match(pattern);\n                if (match) {\n                    return match[1].trim().toUpperCase();\n                }\n            }\n            // If no pattern matches but line looks like merchant name\n            if (line.match(/^[A-Za-z\\s&'.-]+$/) && line.length >= 3 && line.length <= 40) {\n                // Check if it's not a common non-merchant word\n                const nonMerchantWords = [\n                    'THANK',\n                    'YOU',\n                    'VISIT',\n                    'AGAIN',\n                    'CUSTOMER',\n                    'COPY'\n                ];\n                if (!nonMerchantWords.some((word)=>line.includes(word))) {\n                    return line.toUpperCase();\n                }\n            }\n        }\n        return 'UNKNOWN MERCHANT';\n    }\n    extractValidatedTotal(lines, items) {\n        console.log('🔍 Looking for total that matches item sum...');\n        // Calculate expected total from items\n        const itemsTotal = items.reduce((sum, item)=>sum + item.price, 0);\n        console.log(\"Items sum to: $\".concat(itemsTotal.toFixed(2)));\n        // Look specifically for \"Total\" followed by dollar amount\n        const totalPatterns = [\n            /TOTAL\\s+[$]?(\\d+\\.\\d{2})/i,\n            /TOTAL\\s*:\\s*[$]?(\\d+\\.\\d{2})/i,\n            /TOTAL.*?[$](\\d+\\.\\d{2})/i\n        ];\n        const foundTotals = [];\n        // Find all potential totals\n        for(let i = 0; i < lines.length; i++){\n            const line = lines[i].trim();\n            for (const pattern of totalPatterns){\n                const match = line.match(pattern);\n                if (match) {\n                    const amount = parseFloat(match[1]);\n                    if (!isNaN(amount) && amount > 0) {\n                        foundTotals.push({\n                            amount,\n                            line\n                        });\n                        console.log(\"Found potential total: $\".concat(amount, ' in \"').concat(line, '\"'));\n                    }\n                }\n            }\n        }\n        // If we have items, try to match total to items sum\n        if (itemsTotal > 0 && foundTotals.length > 0) {\n            console.log('Validating totals against items sum...');\n            for (const total of foundTotals){\n                const difference = Math.abs(total.amount - itemsTotal);\n                console.log(\"Total $\".concat(total.amount, \" vs Items $\").concat(itemsTotal.toFixed(2), \" - difference: $\").concat(difference.toFixed(2)));\n                // Allow small rounding differences (±$0.05)\n                if (difference <= 0.05) {\n                    console.log(\"✅ Found matching total: $\".concat(total.amount));\n                    return total.amount;\n                }\n            }\n            // If no exact match, look for closest total that's reasonable\n            const sortedByCloseness = foundTotals.sort((a, b)=>Math.abs(a.amount - itemsTotal) - Math.abs(b.amount - itemsTotal));\n            const closest = sortedByCloseness[0];\n            if (closest && Math.abs(closest.amount - itemsTotal) <= itemsTotal * 0.1) {\n                console.log(\"⚠️ Using closest total: $\".concat(closest.amount, \" (\").concat(Math.abs(closest.amount - itemsTotal).toFixed(2), \" difference)\"));\n                return closest.amount;\n            }\n        }\n        // Fallback: use any \"Total\" we found\n        if (foundTotals.length > 0) {\n            console.log(\"⚠️ Using first total found: $\".concat(foundTotals[0].amount));\n            return foundTotals[0].amount;\n        }\n        // Final fallback: use items sum if we have items\n        if (itemsTotal > 0) {\n            console.log(\"⚠️ No total found, using items sum: $\".concat(itemsTotal.toFixed(2)));\n            return itemsTotal;\n        }\n        // Last resort: use old method\n        console.log('⚠️ Falling back to old total extraction method');\n        return this.extractTotalAmount(lines);\n    }\n    extractTotalAmount(lines) {\n        // Enhanced total amount patterns\n        const totalPatterns = [\n            /TOTAL.*?[$]?(\\d+\\.?\\d{2})/i,\n            /AMOUNT\\s+DUE.*?[$]?(\\d+\\.?\\d{2})/i,\n            /BALANCE.*?[$]?(\\d+\\.?\\d{2})/i,\n            /GRAND\\s+TOTAL.*?[$]?(\\d+\\.?\\d{2})/i,\n            /FINAL\\s+TOTAL.*?[$]?(\\d+\\.?\\d{2})/i,\n            /[$](\\d+\\.\\d{2})\\s*$/,\n            /(\\d+\\.\\d{2})\\s*TOTAL/i,\n            /TOTAL\\s+[$]?(\\d+\\.\\d{2})/i,\n            /[$]\\s*(\\d+\\.\\d{2})\\s*TOTAL/i\n        ];\n        console.log('🔍 Looking for total amount in lines:', lines.slice(-10));\n        // Search from bottom up as totals are usually at the end\n        for(let i = lines.length - 1; i >= Math.max(0, lines.length - 15); i--){\n            const line = lines[i].trim();\n            if (line.length === 0) continue;\n            console.log(\"Checking line \".concat(i, ': \"').concat(line, '\"'));\n            for (const pattern of totalPatterns){\n                const match = line.match(pattern);\n                if (match) {\n                    const amount = parseFloat(match[1]);\n                    console.log(\"Found potential total: \".concat(amount, \" from pattern: \").concat(pattern));\n                    if (!isNaN(amount) && amount > 0 && amount < 10000) {\n                        console.log(\"✅ Using total amount: \".concat(amount));\n                        return amount;\n                    }\n                }\n            }\n        }\n        console.log('⚠️ No clear total found, looking for largest amount');\n        // If no clear total found, look for largest reasonable amount\n        const amounts = [];\n        lines.forEach((line, index)=>{\n            // Look for money amounts: $X.XX or X.XX\n            const matches = line.match(/[$]?(\\d+\\.\\d{2})/g) || [];\n            matches.forEach((match)=>{\n                const amount = parseFloat(match.replace('$', ''));\n                if (!isNaN(amount) && amount > 0 && amount < 10000) {\n                    console.log(\"Found amount \".concat(amount, \" on line \").concat(index, ': \"').concat(line, '\"'));\n                    amounts.push(amount);\n                }\n            });\n        });\n        const maxAmount = amounts.length > 0 ? Math.max(...amounts) : 0;\n        console.log(\"Using largest amount found: \".concat(maxAmount));\n        return maxAmount;\n    }\n    extractDate(lines) {\n        const datePatterns = [\n            /(\\d{1,2}\\/\\d{1,2}\\/\\d{2,4})/,\n            /(\\d{1,2}-\\d{1,2}-\\d{2,4})/,\n            /(\\d{4}-\\d{2}-\\d{2})/,\n            /(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec).*?(\\d{1,2}),?\\s*(\\d{4})/i\n        ];\n        for (const line of lines){\n            for (const pattern of datePatterns){\n                const match = line.match(pattern);\n                if (match) {\n                    try {\n                        // Try to parse and normalize the date\n                        const dateStr = match[0];\n                        const date = new Date(dateStr);\n                        if (!isNaN(date.getTime())) {\n                            return date.toISOString().split('T')[0]; // Return YYYY-MM-DD format\n                        }\n                    } catch (e) {\n                        continue;\n                    }\n                }\n            }\n        }\n        // Default to today if no date found\n        return new Date().toISOString().split('T')[0];\n    }\n    extractItems(lines) {\n        const items = [];\n        console.log('🔍 Extracting items from lines...');\n        for(let i = 0; i < lines.length; i++){\n            const line = lines[i].trim();\n            if (line.length === 0) continue;\n            // Enhanced item patterns\n            const itemPatterns = [\n                /^(\\d+)\\s+(.+?)\\s+[$]?(\\d+\\.\\d{2})$/,\n                /^(\\d+)\\s+(.+?)\\s+(\\d+\\.\\d{2})\\s*$/,\n                /^(.+?)\\s{2,}[$]?(\\d+\\.\\d{2})$/,\n                /^(.+?)\\s+[$](\\d+\\.\\d{2})$/,\n                /^(.+?)\\s+(\\d+\\.\\d{2})\\s*$/,\n                /^(.{3,30}?)\\s+(\\d{1,3}\\.\\d{2})$/ // Generic: name followed by price\n            ];\n            for (const pattern of itemPatterns){\n                const match = line.match(pattern);\n                if (match) {\n                    let quantity;\n                    let name;\n                    let price;\n                    if (match.length === 4) {\n                        // Pattern with quantity\n                        quantity = parseInt(match[1]);\n                        name = match[2].trim();\n                        price = parseFloat(match[3]);\n                    } else {\n                        // Pattern without quantity\n                        name = match[1].trim();\n                        price = parseFloat(match[2]);\n                    }\n                    // Check if this is a tax item (include it!)\n                    const isTaxItem = /TAX|HST|GST|PST|VAT/i.test(name) || /TAX|HST|GST|PST|VAT/i.test(line);\n                    // Enhanced filtering for non-item lines (but allow tax items)\n                    const excludePatterns = [\n                        /TOTAL|SUBTOTAL|CHANGE|BALANCE|RECEIPT|STORE|THANK|VISIT|AGAIN|CUSTOMER|COPY/i,\n                        /^(SUB|GRAND|FINAL)/i,\n                        /PAYMENT|CASH|CREDIT|DEBIT|CARD/i,\n                        /^(DATE|TIME|CLERK|CASHIER)/i,\n                        /^\\d{1,2}\\/\\d{1,2}\\/\\d{2,4}/,\n                        /^\\d{2}:\\d{2}/\n                    ];\n                    const shouldExclude = !isTaxItem && (excludePatterns.some((pattern)=>pattern.test(name)) || excludePatterns.some((pattern)=>pattern.test(line)));\n                    if (name && !shouldExclude && name.length >= 2 && name.length <= 50 && price > 0 && price <= 1000 && !name.match(/^\\d+$/) && // Not just numbers\n                    name.match(/[A-Za-z]/) // Contains at least one letter\n                    ) {\n                        const itemType = isTaxItem ? ' [TAX]' : '';\n                        console.log('✅ Found item: \"'.concat(name, '\" - $').concat(price) + (quantity ? \" (qty: \".concat(quantity, \")\") : '') + itemType);\n                        items.push({\n                            name: name.toUpperCase(),\n                            price,\n                            quantity\n                        });\n                    }\n                    break;\n                }\n            }\n        }\n        console.log(\"Found \".concat(items.length, \" items total\"));\n        return items;\n    }\n    async cleanup() {\n        if (this.worker) {\n            await this.worker.terminate();\n            this.worker = null;\n            this.isInitialized = false;\n            console.log('🧹 OCR engine cleaned up');\n        }\n    }\n    constructor(){\n        this.worker = null;\n        this.isInitialized = false;\n    }\n}\n// Export singleton instance\nconst ocrService = new OCRService();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NlcnZpY2VzL29jclNlcnZpY2UudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTRDO0FBb0I1QyxNQUFNQztJQUlKLE1BQU1DLGFBQTRCO1FBQ2hDLElBQUksSUFBSSxDQUFDQyxhQUFhLEVBQUU7UUFFeEIsSUFBSTtZQUNGQyxRQUFRQyxHQUFHLENBQUM7WUFDWixJQUFJLENBQUNDLE1BQU0sR0FBRyxNQUFNTiwwREFBWUEsQ0FBQztZQUVqQyxzRUFBc0U7WUFDdEUsTUFBTSxJQUFJLENBQUNNLE1BQU0sQ0FBQ0MsYUFBYSxDQUFDO2dCQUM5QiwyQkFBMkI7Z0JBQzNCLHlCQUF5QjtnQkFDekIsNkJBQTZCO2dCQUM3Qix3QkFBd0I7Z0JBQ3hCLHdCQUF3QjtnQkFDeEIsK0JBQStCO2dCQUMvQixnQ0FBZ0M7Z0JBQ2hDLCtCQUErQixJQUFJLG9DQUFvQztZQUN6RTtZQUVBLElBQUksQ0FBQ0osYUFBYSxHQUFHO1lBQ3JCQyxRQUFRQyxHQUFHLENBQUM7UUFDZCxFQUFFLE9BQU9HLE9BQU87WUFDZEosUUFBUUksS0FBSyxDQUFDLHNDQUFzQ0E7WUFDcEQsTUFBTSxJQUFJQyxNQUFNO1FBQ2xCO0lBQ0Y7SUFFQSxNQUFjQyxnQkFBZ0JDLFNBQWUsRUFBbUI7UUFDOUQsT0FBTyxJQUFJQyxRQUFRLENBQUNDLFNBQVNDO1lBQzNCLE1BQU1DLFNBQVNDLFNBQVNDLGFBQWEsQ0FBQztZQUN0QyxNQUFNQyxNQUFNSCxPQUFPSSxVQUFVLENBQUM7WUFDOUIsTUFBTUMsTUFBTSxJQUFJQztZQUVoQkQsSUFBSUUsTUFBTSxHQUFHO2dCQUNYLHdEQUF3RDtnQkFDeEQsTUFBTUMsVUFBVTtnQkFDaEJSLE9BQU9TLEtBQUssR0FBR0osSUFBSUksS0FBSyxHQUFJRCxVQUFVO2dCQUN0Q1IsT0FBT1UsTUFBTSxHQUFHTCxJQUFJSyxNQUFNLEdBQUlGLFVBQVU7Z0JBRXhDLElBQUksQ0FBQ0wsS0FBSztvQkFDUkosT0FBTyxJQUFJTCxNQUFNO29C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O2dCQUNGO1lBQ0Y7UUFDRjtRQUVBckksUUFBUUMsR0FBRyxDQUFDLFNBQXNCLE9BQWJ1RixNQUFNM0QsTUFBTSxFQUFDO1FBQ2xDLE9BQU8yRDtJQUNUO0lBRUEsTUFBTXFELFVBQXlCO1FBQzdCLElBQUksSUFBSSxDQUFDM0ksTUFBTSxFQUFFO1lBQ2YsTUFBTSxJQUFJLENBQUNBLE1BQU0sQ0FBQzRJLFNBQVM7WUFDM0IsSUFBSSxDQUFDNUksTUFBTSxHQUFHO1lBQ2QsSUFBSSxDQUFDSCxhQUFhLEdBQUc7WUFDckJDLFFBQVFDLEdBQUcsQ0FBQztRQUNkO0lBQ0Y7O2FBcGZRQyxTQUFrQzthQUNsQ0gsZ0JBQWdCOztBQW9mMUI7QUFFQSw0QkFBNEI7QUFDckIsTUFBTWdKLGFBQWEsSUFBSWxKLGFBQWEiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbmF0aGFcXE9uZURyaXZlXFxEZXNrdG9wXFxNb25leVF1ZXN0VjNcXHBhY2thZ2VzXFx3ZWJzaXRlXFxzZXJ2aWNlc1xcb2NyU2VydmljZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVXb3JrZXIgfSBmcm9tICd0ZXNzZXJhY3QuanMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIE9DUlJlc3VsdCB7XG4gIHRleHQ6IHN0cmluZztcbiAgY29uZmlkZW5jZTogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFBhcnNlZFJlY2VpcHQge1xuICBtZXJjaGFudDogc3RyaW5nO1xuICBhbW91bnQ6IG51bWJlcjtcbiAgZGF0ZTogc3RyaW5nO1xuICBpdGVtczogQXJyYXk8e1xuICAgIG5hbWU6IHN0cmluZztcbiAgICBwcmljZTogbnVtYmVyO1xuICAgIHF1YW50aXR5PzogbnVtYmVyO1xuICB9PjtcbiAgcmF3VGV4dDogc3RyaW5nO1xuICBjb25maWRlbmNlOiBudW1iZXI7XG59XG5cbmNsYXNzIE9DUlNlcnZpY2Uge1xuICBwcml2YXRlIHdvcmtlcjogVGVzc2VyYWN0LldvcmtlciB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIGlzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcblxuICBhc3luYyBpbml0aWFsaXplKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICh0aGlzLmlzSW5pdGlhbGl6ZWQpIHJldHVybjtcblxuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZygn8J+UjSBJbml0aWFsaXppbmcgT0NSIGVuZ2luZS4uLicpO1xuICAgICAgdGhpcy53b3JrZXIgPSBhd2FpdCBjcmVhdGVXb3JrZXIoJ2VuZycpO1xuXG4gICAgICAvLyBDb25maWd1cmUgVGVzc2VyYWN0IGZvciBiZXR0ZXIgcmVjZWlwdCByZWFkaW5nIHdpdGggbW9yZSBjaGFyYWN0ZXJzXG4gICAgICBhd2FpdCB0aGlzLndvcmtlci5zZXRQYXJhbWV0ZXJzKHtcbiAgICAgICAgJ3Rlc3NlZGl0X2NoYXJfd2hpdGVsaXN0JzogJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6LiwkLzotIyUqKCkmQCsgJyxcbiAgICAgICAgJ3Rlc3NlZGl0X3BhZ2VzZWdfbW9kZSc6ICc0JywgLy8gQXNzdW1lIHNpbmdsZSBjb2x1bW4gb2YgdGV4dCBvZiB2YXJpYWJsZSBzaXplc1xuICAgICAgICAncHJlc2VydmVfaW50ZXJ3b3JkX3NwYWNlcyc6ICcxJyxcbiAgICAgICAgJ3Rlc3NlZGl0X2NyZWF0ZV9ob2NyJzogJzEnLCAvLyBFbmFibGUgZGV0YWlsZWQgcG9zaXRpb24gZGF0YVxuICAgICAgICAndGV4dG9yZF9taW5fbGluZXNpemUnOiAnMS4yNScsIC8vIE1pbmltdW0gbGluZSBzaXplIChoZWxwcyB3aXRoIHNtYWxsIG51bWJlcnMpXG4gICAgICAgICd0ZXh0b3JkX3RhYmZpbmRfZmluZF90YWJsZXMnOiAnMScsIC8vIEVuYWJsZSB0YWJsZSBkZXRlY3Rpb24gZm9yIHJlY2VpcHQgY29sdW1uc1xuICAgICAgICAndGV4dG9yZF90YWJsZWZpbmRfZ29vZF93aWR0aCc6ICczJywgLy8gQmV0dGVyIGNvbHVtbiBkZXRlY3Rpb25cbiAgICAgICAgJ3RleHRvcmRfdGFiZmluZF9zaG93X3ZsaW5lcyc6ICcxJyAvLyBTaG93IHZlcnRpY2FsIGxpbmVzIGZvciBkZWJ1Z2dpbmdcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgY29uc29sZS5sb2coJ+KchSBPQ1IgZW5naW5lIGluaXRpYWxpemVkIHN1Y2Nlc3NmdWxseScpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgRmFpbGVkIHRvIGluaXRpYWxpemUgT0NSIGVuZ2luZTonLCBlcnJvcik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBpbml0aWFsaXplIE9DUiBlbmdpbmUnKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIHByZXByb2Nlc3NJbWFnZShpbWFnZUZpbGU6IEZpbGUpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgY29uc3QgaW1nID0gbmV3IEltYWdlKCk7XG5cbiAgICAgIGltZy5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgIC8vIEFkZCBwYWRkaW5nIGFyb3VuZCB0aGUgaW1hZ2UgdG8gcHJldmVudCBlZGdlIGNyb3BwaW5nXG4gICAgICAgIGNvbnN0IHBhZGRpbmcgPSAyMDtcbiAgICAgICAgY2FudmFzLndpZHRoID0gaW1nLndpZHRoICsgKHBhZGRpbmcgKiAyKTtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IGltZy5oZWlnaHQgKyAocGFkZGluZyAqIDIpO1xuXG4gICAgICAgIGlmICghY3R4KSB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignQ291bGQgbm90IGdldCBjYW52YXMgY29udGV4dCcpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGaWxsIHdpdGggd2hpdGUgYmFja2dyb3VuZFxuICAgICAgICBjdHguZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG5cbiAgICAgICAgLy8gRHJhdyBvcmlnaW5hbCBpbWFnZSB3aXRoIHBhZGRpbmdcbiAgICAgICAgY3R4LmRyYXdJbWFnZShpbWcsIHBhZGRpbmcsIHBhZGRpbmcpO1xuXG4gICAgICAgIC8vIEdldCBpbWFnZSBkYXRhIGZvciBwcm9jZXNzaW5nXG4gICAgICAgIGNvbnN0IGltYWdlRGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgY29uc3QgZGF0YSA9IGltYWdlRGF0YS5kYXRhO1xuXG4gICAgICAgIC8vIENvbnZlcnQgdG8gZ3JheXNjYWxlIGFuZCBpbmNyZWFzZSBjb250cmFzdCAobW9yZSBhZ2dyZXNzaXZlIGZvciBzbWFsbCB0ZXh0KVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpICs9IDQpIHtcbiAgICAgICAgICBjb25zdCBncmF5ID0gTWF0aC5yb3VuZCgwLjI5OSAqIGRhdGFbaV0gKyAwLjU4NyAqIGRhdGFbaSArIDFdICsgMC4xMTQgKiBkYXRhW2kgKyAyXSk7XG5cbiAgICAgICAgICAvLyBNb3JlIGFnZ3Jlc3NpdmUgY29udHJhc3QgZW5oYW5jZW1lbnQgZm9yIHNtYWxsIG51bWJlcnNcbiAgICAgICAgICBjb25zdCBjb250cmFzdCA9IDIuMDsgLy8gSW5jcmVhc2VkIGZyb20gMS41XG4gICAgICAgICAgY29uc3QgZmFjdG9yID0gKDI1OSAqIChjb250cmFzdCArIDI1NSkpIC8gKDI1NSAqICgyNTkgLSBjb250cmFzdCkpO1xuICAgICAgICAgIGxldCBlbmhhbmNlZCA9IGZhY3RvciAqIChncmF5IC0gMTI4KSArIDEyODtcblxuICAgICAgICAgIC8vIEFwcGx5IHRocmVzaG9sZCB0byBtYWtlIHNtYWxsIHRleHQgbW9yZSBkaXN0aW5jdFxuICAgICAgICAgIGlmIChlbmhhbmNlZCA8IDEyOCkge1xuICAgICAgICAgICAgZW5oYW5jZWQgPSBNYXRoLm1heCgwLCBlbmhhbmNlZCAqIDAuNyk7IC8vIE1ha2UgZGFyayBhcmVhcyBkYXJrZXJcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZW5oYW5jZWQgPSBNYXRoLm1pbigyNTUsIGVuaGFuY2VkICogMS4yKTsgLy8gTWFrZSBsaWdodCBhcmVhcyBsaWdodGVyXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGF0YVtpXSA9IGVuaGFuY2VkOyAgICAgLy8gUmVkXG4gICAgICAgICAgZGF0YVtpICsgMV0gPSBlbmhhbmNlZDsgLy8gR3JlZW5cbiAgICAgICAgICBkYXRhW2kgKyAyXSA9IGVuaGFuY2VkOyAvLyBCbHVlXG4gICAgICAgICAgLy8gQWxwaGEgc3RheXMgdGhlIHNhbWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFB1dCB0aGUgcHJvY2Vzc2VkIGltYWdlIGRhdGEgYmFja1xuICAgICAgICBjdHgucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSwgMCwgMCk7XG5cbiAgICAgICAgLy8gQ29udmVydCB0byBkYXRhIFVSTFxuICAgICAgICByZXNvbHZlKGNhbnZhcy50b0RhdGFVUkwoJ2ltYWdlL3BuZycpKTtcbiAgICAgIH07XG5cbiAgICAgIGltZy5vbmVycm9yID0gKCkgPT4gcmVqZWN0KG5ldyBFcnJvcignRmFpbGVkIHRvIGxvYWQgaW1hZ2UnKSk7XG4gICAgICBpbWcuc3JjID0gVVJMLmNyZWF0ZU9iamVjdFVSTChpbWFnZUZpbGUpO1xuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSByZWNvbnN0cnVjdEFsaWduZWRUZXh0KG9jckRhdGE6IGFueSk6IHN0cmluZyB7XG4gICAgaWYgKCFvY3JEYXRhLmxpbmVzIHx8IG9jckRhdGEubGluZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gb2NyRGF0YS50ZXh0IHx8ICcnO1xuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKCfwn5SnIFJlY29uc3RydWN0aW5nIGFsaWduZWQgdGV4dCBmcm9tJywgb2NyRGF0YS5saW5lcy5sZW5ndGgsICdsaW5lcycpO1xuXG4gICAgY29uc3QgbGluZXM6IHN0cmluZ1tdID0gW107XG5cbiAgICBmb3IgKGNvbnN0IGxpbmUgb2Ygb2NyRGF0YS5saW5lcykge1xuICAgICAgaWYgKCFsaW5lLndvcmRzIHx8IGxpbmUud29yZHMubGVuZ3RoID09PSAwKSBjb250aW51ZTtcblxuICAgICAgLy8gU29ydCB3b3JkcyBieSB4IHBvc2l0aW9uIChsZWZ0IHRvIHJpZ2h0KVxuICAgICAgY29uc3Qgc29ydGVkV29yZHMgPSBbLi4ubGluZS53b3Jkc10uc29ydCgoYSwgYikgPT4gYS5iYm94LngwIC0gYi5iYm94LngwKTtcblxuICAgICAgbGV0IGxpbmVUZXh0ID0gJyc7XG4gICAgICBsZXQgbGFzdFggPSAwO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNvcnRlZFdvcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHdvcmQgPSBzb3J0ZWRXb3Jkc1tpXTtcbiAgICAgICAgY29uc3Qgd29yZFRleHQgPSB3b3JkLnRleHQudHJpbSgpO1xuXG4gICAgICAgIGlmICh3b3JkVGV4dC5sZW5ndGggPT09IDApIGNvbnRpbnVlO1xuXG4gICAgICAgIC8vIENhbGN1bGF0ZSBzcGFjaW5nIG5lZWRlZCBiYXNlZCBvbiB4LXBvc2l0aW9uXG4gICAgICAgIGNvbnN0IGN1cnJlbnRYID0gd29yZC5iYm94LngwO1xuICAgICAgICBjb25zdCB3b3JkV2lkdGggPSB3b3JkLmJib3gueDEgLSB3b3JkLmJib3gueDA7XG5cbiAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgLy8gQ2FsY3VsYXRlIGdhcCBiZXR3ZWVuIHRoaXMgd29yZCBhbmQgcHJldmlvdXMgd29yZFxuICAgICAgICAgIGNvbnN0IGdhcCA9IGN1cnJlbnRYIC0gbGFzdFg7XG4gICAgICAgICAgY29uc3QgYXZnQ2hhcldpZHRoID0gMTA7IC8vIEFwcHJveGltYXRlIGNoYXJhY3RlciB3aWR0aFxuICAgICAgICAgIGNvbnN0IHNwYWNlc05lZWRlZCA9IE1hdGgubWF4KDEsIE1hdGguZmxvb3IoZ2FwIC8gYXZnQ2hhcldpZHRoKSk7XG5cbiAgICAgICAgICAvLyBBZGQgYXBwcm9wcmlhdGUgc3BhY2luZyAoYnV0IGNhcCBpdCB0byBwcmV2ZW50IGV4Y2Vzc2l2ZSBzcGFjaW5nKVxuICAgICAgICAgIGxpbmVUZXh0ICs9ICcgJy5yZXBlYXQoTWF0aC5taW4oc3BhY2VzTmVlZGVkLCAyMCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGluZVRleHQgKz0gd29yZFRleHQ7XG4gICAgICAgIGxhc3RYID0gd29yZC5iYm94LngxO1xuICAgICAgfVxuXG4gICAgICBpZiAobGluZVRleHQudHJpbSgpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgbGluZXMucHVzaChsaW5lVGV4dCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcmVjb25zdHJ1Y3RlZFRleHQgPSBsaW5lcy5qb2luKCdcXG4nKTtcbiAgICBjb25zb2xlLmxvZygn4pyFIFJlY29uc3RydWN0ZWQgdGV4dCB3aXRoIGFsaWdubWVudDonLCByZWNvbnN0cnVjdGVkVGV4dC5zdWJzdHJpbmcoMCwgMjAwKSArICcuLi4nKTtcbiAgICByZXR1cm4gcmVjb25zdHJ1Y3RlZFRleHQ7XG4gIH1cblxuICBhc3luYyBwcm9jZXNzUmVjZWlwdEltYWdlKGltYWdlRmlsZTogRmlsZSk6IFByb21pc2U8T0NSUmVzdWx0PiB7XG4gICAgaWYgKCF0aGlzLndvcmtlciB8fCAhdGhpcy5pc0luaXRpYWxpemVkKSB7XG4gICAgICBhd2FpdCB0aGlzLmluaXRpYWxpemUoKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coJ/Cfk4QgUHJlcHJvY2Vzc2luZyByZWNlaXB0IGltYWdlLi4uJyk7XG4gICAgICBjb25zdCBwcmVwcm9jZXNzZWRJbWFnZSA9IGF3YWl0IHRoaXMucHJlcHJvY2Vzc0ltYWdlKGltYWdlRmlsZSk7XG5cbiAgICAgIGNvbnNvbGUubG9nKCfwn5SNIFByb2Nlc3NpbmcgcmVjZWlwdCBpbWFnZSB3aXRoIE9DUi4uLicpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy53b3JrZXIhLnJlY29nbml6ZShwcmVwcm9jZXNzZWRJbWFnZSk7XG5cbiAgICAgIGNvbnNvbGUubG9nKCfinIUgT0NSIGNvbXBsZXRlZCcsIHtcbiAgICAgICAgY29uZmlkZW5jZTogcmVzdWx0LmRhdGEuY29uZmlkZW5jZSxcbiAgICAgICAgdGV4dExlbmd0aDogcmVzdWx0LmRhdGEudGV4dC5sZW5ndGgsXG4gICAgICAgIHdvcmRzRm91bmQ6IHJlc3VsdC5kYXRhLndvcmRzPy5sZW5ndGggfHwgMFxuICAgICAgfSk7XG5cbiAgICAgIC8vIFJlY29uc3RydWN0IHRleHQgd2l0aCBiZXR0ZXIgYWxpZ25tZW50IHVzaW5nIHdvcmQgcG9zaXRpb25zXG4gICAgICBjb25zdCBhbGlnbmVkVGV4dCA9IHRoaXMucmVjb25zdHJ1Y3RBbGlnbmVkVGV4dChyZXN1bHQuZGF0YSk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRleHQ6IGFsaWduZWRUZXh0LFxuICAgICAgICBjb25maWRlbmNlOiByZXN1bHQuZGF0YS5jb25maWRlbmNlXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgT0NSIHByb2Nlc3NpbmcgZmFpbGVkOicsIGVycm9yKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHByb2Nlc3MgaW1hZ2Ugd2l0aCBPQ1InKTtcbiAgICB9XG4gIH1cblxuICBwYXJzZVJlY2VpcHRUZXh0KG9jclRleHQ6IHN0cmluZywgY29uZmlkZW5jZTogbnVtYmVyKTogUGFyc2VkUmVjZWlwdCB7XG4gICAgY29uc29sZS5sb2coJ/CflI0gUGFyc2luZyByZWNlaXB0IHRleHQuLi4nKTtcbiAgICBjb25zb2xlLmxvZygnUmF3IE9DUiB0ZXh0OicsIG9jclRleHQpO1xuXG4gICAgY29uc3QgbGluZXMgPSBvY3JUZXh0LnNwbGl0KCdcXG4nKS5tYXAobGluZSA9PiBsaW5lLnRyaW0oKSkuZmlsdGVyKGxpbmUgPT4gbGluZS5sZW5ndGggPiAwKTtcblxuICAgIC8vIEV4dHJhY3QgbWVyY2hhbnQgbmFtZSAodXN1YWxseSBmaXJzdCBvciBzZWNvbmQgbGluZSlcbiAgICBjb25zdCBtZXJjaGFudCA9IHRoaXMuZXh0cmFjdE1lcmNoYW50KGxpbmVzKTtcblxuICAgIC8vIEV4dHJhY3QgbGluZSBpdGVtcyBGSVJTVCAoaW5jbHVkaW5nIHRheClcbiAgICBjb25zdCBpdGVtcyA9IHRoaXMuZXh0cmFjdEl0ZW1zKGxpbmVzKTtcblxuICAgIC8vIEV4dHJhY3QgdG90YWwgYW1vdW50IHVzaW5nIHRoZSBuZXcgcnVsZVxuICAgIGNvbnN0IGFtb3VudCA9IHRoaXMuZXh0cmFjdFZhbGlkYXRlZFRvdGFsKGxpbmVzLCBpdGVtcyk7XG5cbiAgICAvLyBFeHRyYWN0IGRhdGVcbiAgICBjb25zdCBkYXRlID0gdGhpcy5leHRyYWN0RGF0ZShsaW5lcyk7XG5cbiAgICBjb25zdCBwYXJzZWQ6IFBhcnNlZFJlY2VpcHQgPSB7XG4gICAgICBtZXJjaGFudCxcbiAgICAgIGFtb3VudCxcbiAgICAgIGRhdGUsXG4gICAgICBpdGVtcyxcbiAgICAgIHJhd1RleHQ6IG9jclRleHQsXG4gICAgICBjb25maWRlbmNlOiBNYXRoLm1heChjb25maWRlbmNlICogMC44LCA2MCkgLy8gQWRqdXN0IGNvbmZpZGVuY2UgZm9yIHBhcnNpbmcgdW5jZXJ0YWludHlcbiAgICB9O1xuXG4gICAgY29uc29sZS5sb2coJ+KchSBSZWNlaXB0IHBhcnNlZCBzdWNjZXNzZnVsbHk6JywgcGFyc2VkKTtcbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG5cbiAgcHJpdmF0ZSBleHRyYWN0TWVyY2hhbnQobGluZXM6IHN0cmluZ1tdKTogc3RyaW5nIHtcbiAgICAvLyBDb21tb24gbWVyY2hhbnQgcGF0dGVybnMgdG8gbG9vayBmb3JcbiAgICBjb25zdCBtZXJjaGFudFBhdHRlcm5zID0gW1xuICAgICAgL14oW0EtWmEtelxccyYnLi1dezMsNDB9KSQvLFxuICAgICAgL14oW0EtWlxccyYnLi1dezMsNDB9KVxccytTVE9SRS8sXG4gICAgICAvXihbQS1aXFxzJicuLV17Myw0MH0pXFxzK01BUktFVC8sXG4gICAgICAvXihbQS1aXFxzJicuLV17Myw0MH0pXFxzK0lOQy9cbiAgICBdO1xuXG4gICAgLy8gTG9vayBmb3IgbWVyY2hhbnQgbmFtZSBpbiBmaXJzdCA3IGxpbmVzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBNYXRoLm1pbig3LCBsaW5lcy5sZW5ndGgpOyBpKyspIHtcbiAgICAgIGNvbnN0IGxpbmUgPSBsaW5lc1tpXS50cmltKCk7XG5cbiAgICAgIC8vIFNraXAgb2J2aW91c2x5IG5vbi1tZXJjaGFudCBsaW5lc1xuICAgICAgaWYgKGxpbmUubWF0Y2goL15cXGQrLykgfHwgbGluZS5pbmNsdWRlcygnUkVDRUlQVCcpIHx8IGxpbmUuaW5jbHVkZXMoJ0lOVk9JQ0UnKSB8fFxuICAgICAgICAgIGxpbmUuaW5jbHVkZXMoJyMnKSB8fCBsaW5lLmluY2x1ZGVzKCdURUwnKSB8fCBsaW5lLmluY2x1ZGVzKCdXV1cnKSB8fFxuICAgICAgICAgIGxpbmUuaW5jbHVkZXMoJ0AnKSB8fCBsaW5lLmluY2x1ZGVzKCcuQ09NJykgfHwgbGluZS5pbmNsdWRlcygnU1RSRUVUJykgfHxcbiAgICAgICAgICBsaW5lLmluY2x1ZGVzKCdBVkUnKSB8fCBsaW5lLmluY2x1ZGVzKCdCTFZEJykgfHwgbGluZS5pbmNsdWRlcygnUkQnKSB8fFxuICAgICAgICAgIGxpbmUubGVuZ3RoIDwgMyB8fCBsaW5lLmxlbmd0aCA+IDUwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBUcnkgbWVyY2hhbnQgcGF0dGVybnNcbiAgICAgIGZvciAoY29uc3QgcGF0dGVybiBvZiBtZXJjaGFudFBhdHRlcm5zKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gbGluZS5tYXRjaChwYXR0ZXJuKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgcmV0dXJuIG1hdGNoWzFdLnRyaW0oKS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIElmIG5vIHBhdHRlcm4gbWF0Y2hlcyBidXQgbGluZSBsb29rcyBsaWtlIG1lcmNoYW50IG5hbWVcbiAgICAgIGlmIChsaW5lLm1hdGNoKC9eW0EtWmEtelxccyYnLi1dKyQvKSAmJiBsaW5lLmxlbmd0aCA+PSAzICYmIGxpbmUubGVuZ3RoIDw9IDQwKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIGl0J3Mgbm90IGEgY29tbW9uIG5vbi1tZXJjaGFudCB3b3JkXG4gICAgICAgIGNvbnN0IG5vbk1lcmNoYW50V29yZHMgPSBbJ1RIQU5LJywgJ1lPVScsICdWSVNJVCcsICdBR0FJTicsICdDVVNUT01FUicsICdDT1BZJ107XG4gICAgICAgIGlmICghbm9uTWVyY2hhbnRXb3Jkcy5zb21lKHdvcmQgPT4gbGluZS5pbmNsdWRlcyh3b3JkKSkpIHtcbiAgICAgICAgICByZXR1cm4gbGluZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuICdVTktOT1dOIE1FUkNIQU5UJztcbiAgfVxuXG4gIHByaXZhdGUgZXh0cmFjdFZhbGlkYXRlZFRvdGFsKGxpbmVzOiBzdHJpbmdbXSwgaXRlbXM6IEFycmF5PHsgbmFtZTogc3RyaW5nOyBwcmljZTogbnVtYmVyOyBxdWFudGl0eT86IG51bWJlciB9Pik6IG51bWJlciB7XG4gICAgY29uc29sZS5sb2coJ/CflI0gTG9va2luZyBmb3IgdG90YWwgdGhhdCBtYXRjaGVzIGl0ZW0gc3VtLi4uJyk7XG5cbiAgICAvLyBDYWxjdWxhdGUgZXhwZWN0ZWQgdG90YWwgZnJvbSBpdGVtc1xuICAgIGNvbnN0IGl0ZW1zVG90YWwgPSBpdGVtcy5yZWR1Y2UoKHN1bSwgaXRlbSkgPT4gc3VtICsgaXRlbS5wcmljZSwgMCk7XG4gICAgY29uc29sZS5sb2coYEl0ZW1zIHN1bSB0bzogJCR7aXRlbXNUb3RhbC50b0ZpeGVkKDIpfWApO1xuXG4gICAgLy8gTG9vayBzcGVjaWZpY2FsbHkgZm9yIFwiVG90YWxcIiBmb2xsb3dlZCBieSBkb2xsYXIgYW1vdW50XG4gICAgY29uc3QgdG90YWxQYXR0ZXJucyA9IFtcbiAgICAgIC9UT1RBTFxccytbJF0/KFxcZCtcXC5cXGR7Mn0pL2ksICAgICAgICAgICAvLyBcIlRPVEFMICQxMi4zNFwiXG4gICAgICAvVE9UQUxcXHMqOlxccypbJF0/KFxcZCtcXC5cXGR7Mn0pL2ksICAgICAgLy8gXCJUT1RBTDogJDEyLjM0XCJcbiAgICAgIC9UT1RBTC4qP1skXShcXGQrXFwuXFxkezJ9KS9pLCAgICAgICAgICAgLy8gXCJUT1RBTCB4eHggJDEyLjM0XCJcbiAgICBdO1xuXG4gICAgY29uc3QgZm91bmRUb3RhbHM6IEFycmF5PHsgYW1vdW50OiBudW1iZXI7IGxpbmU6IHN0cmluZyB9PiA9IFtdO1xuXG4gICAgLy8gRmluZCBhbGwgcG90ZW50aWFsIHRvdGFsc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGxpbmUgPSBsaW5lc1tpXS50cmltKCk7XG5cbiAgICAgIGZvciAoY29uc3QgcGF0dGVybiBvZiB0b3RhbFBhdHRlcm5zKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gbGluZS5tYXRjaChwYXR0ZXJuKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgY29uc3QgYW1vdW50ID0gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG4gICAgICAgICAgaWYgKCFpc05hTihhbW91bnQpICYmIGFtb3VudCA+IDApIHtcbiAgICAgICAgICAgIGZvdW5kVG90YWxzLnB1c2goeyBhbW91bnQsIGxpbmUgfSk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgRm91bmQgcG90ZW50aWFsIHRvdGFsOiAkJHthbW91bnR9IGluIFwiJHtsaW5lfVwiYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgaGF2ZSBpdGVtcywgdHJ5IHRvIG1hdGNoIHRvdGFsIHRvIGl0ZW1zIHN1bVxuICAgIGlmIChpdGVtc1RvdGFsID4gMCAmJiBmb3VuZFRvdGFscy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zb2xlLmxvZygnVmFsaWRhdGluZyB0b3RhbHMgYWdhaW5zdCBpdGVtcyBzdW0uLi4nKTtcblxuICAgICAgZm9yIChjb25zdCB0b3RhbCBvZiBmb3VuZFRvdGFscykge1xuICAgICAgICBjb25zdCBkaWZmZXJlbmNlID0gTWF0aC5hYnModG90YWwuYW1vdW50IC0gaXRlbXNUb3RhbCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGBUb3RhbCAkJHt0b3RhbC5hbW91bnR9IHZzIEl0ZW1zICQke2l0ZW1zVG90YWwudG9GaXhlZCgyKX0gLSBkaWZmZXJlbmNlOiAkJHtkaWZmZXJlbmNlLnRvRml4ZWQoMil9YCk7XG5cbiAgICAgICAgLy8gQWxsb3cgc21hbGwgcm91bmRpbmcgZGlmZmVyZW5jZXMgKMKxJDAuMDUpXG4gICAgICAgIGlmIChkaWZmZXJlbmNlIDw9IDAuMDUpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhg4pyFIEZvdW5kIG1hdGNoaW5nIHRvdGFsOiAkJHt0b3RhbC5hbW91bnR9YCk7XG4gICAgICAgICAgcmV0dXJuIHRvdGFsLmFtb3VudDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBJZiBubyBleGFjdCBtYXRjaCwgbG9vayBmb3IgY2xvc2VzdCB0b3RhbCB0aGF0J3MgcmVhc29uYWJsZVxuICAgICAgY29uc3Qgc29ydGVkQnlDbG9zZW5lc3MgPSBmb3VuZFRvdGFscy5zb3J0KChhLCBiKSA9PlxuICAgICAgICBNYXRoLmFicyhhLmFtb3VudCAtIGl0ZW1zVG90YWwpIC0gTWF0aC5hYnMoYi5hbW91bnQgLSBpdGVtc1RvdGFsKVxuICAgICAgKTtcblxuICAgICAgY29uc3QgY2xvc2VzdCA9IHNvcnRlZEJ5Q2xvc2VuZXNzWzBdO1xuICAgICAgaWYgKGNsb3Nlc3QgJiYgTWF0aC5hYnMoY2xvc2VzdC5hbW91bnQgLSBpdGVtc1RvdGFsKSA8PSBpdGVtc1RvdGFsICogMC4xKSB7IC8vIFdpdGhpbiAxMCVcbiAgICAgICAgY29uc29sZS5sb2coYOKaoO+4jyBVc2luZyBjbG9zZXN0IHRvdGFsOiAkJHtjbG9zZXN0LmFtb3VudH0gKCR7TWF0aC5hYnMoY2xvc2VzdC5hbW91bnQgLSBpdGVtc1RvdGFsKS50b0ZpeGVkKDIpfSBkaWZmZXJlbmNlKWApO1xuICAgICAgICByZXR1cm4gY2xvc2VzdC5hbW91bnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRmFsbGJhY2s6IHVzZSBhbnkgXCJUb3RhbFwiIHdlIGZvdW5kXG4gICAgaWYgKGZvdW5kVG90YWxzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnNvbGUubG9nKGDimqDvuI8gVXNpbmcgZmlyc3QgdG90YWwgZm91bmQ6ICQke2ZvdW5kVG90YWxzWzBdLmFtb3VudH1gKTtcbiAgICAgIHJldHVybiBmb3VuZFRvdGFsc1swXS5hbW91bnQ7XG4gICAgfVxuXG4gICAgLy8gRmluYWwgZmFsbGJhY2s6IHVzZSBpdGVtcyBzdW0gaWYgd2UgaGF2ZSBpdGVtc1xuICAgIGlmIChpdGVtc1RvdGFsID4gMCkge1xuICAgICAgY29uc29sZS5sb2coYOKaoO+4jyBObyB0b3RhbCBmb3VuZCwgdXNpbmcgaXRlbXMgc3VtOiAkJHtpdGVtc1RvdGFsLnRvRml4ZWQoMil9YCk7XG4gICAgICByZXR1cm4gaXRlbXNUb3RhbDtcbiAgICB9XG5cbiAgICAvLyBMYXN0IHJlc29ydDogdXNlIG9sZCBtZXRob2RcbiAgICBjb25zb2xlLmxvZygn4pqg77iPIEZhbGxpbmcgYmFjayB0byBvbGQgdG90YWwgZXh0cmFjdGlvbiBtZXRob2QnKTtcbiAgICByZXR1cm4gdGhpcy5leHRyYWN0VG90YWxBbW91bnQobGluZXMpO1xuICB9XG5cbiAgcHJpdmF0ZSBleHRyYWN0VG90YWxBbW91bnQobGluZXM6IHN0cmluZ1tdKTogbnVtYmVyIHtcbiAgICAvLyBFbmhhbmNlZCB0b3RhbCBhbW91bnQgcGF0dGVybnNcbiAgICBjb25zdCB0b3RhbFBhdHRlcm5zID0gW1xuICAgICAgL1RPVEFMLio/WyRdPyhcXGQrXFwuP1xcZHsyfSkvaSxcbiAgICAgIC9BTU9VTlRcXHMrRFVFLio/WyRdPyhcXGQrXFwuP1xcZHsyfSkvaSxcbiAgICAgIC9CQUxBTkNFLio/WyRdPyhcXGQrXFwuP1xcZHsyfSkvaSxcbiAgICAgIC9HUkFORFxccytUT1RBTC4qP1skXT8oXFxkK1xcLj9cXGR7Mn0pL2ksXG4gICAgICAvRklOQUxcXHMrVE9UQUwuKj9bJF0/KFxcZCtcXC4/XFxkezJ9KS9pLFxuICAgICAgL1skXShcXGQrXFwuXFxkezJ9KVxccyokLywgLy8gTGluZSBlbmRpbmcgd2l0aCBjdXJyZW5jeSBhbW91bnRcbiAgICAgIC8oXFxkK1xcLlxcZHsyfSlcXHMqVE9UQUwvaSxcbiAgICAgIC9UT1RBTFxccytbJF0/KFxcZCtcXC5cXGR7Mn0pL2ksXG4gICAgICAvWyRdXFxzKihcXGQrXFwuXFxkezJ9KVxccypUT1RBTC9pXG4gICAgXTtcblxuICAgIGNvbnNvbGUubG9nKCfwn5SNIExvb2tpbmcgZm9yIHRvdGFsIGFtb3VudCBpbiBsaW5lczonLCBsaW5lcy5zbGljZSgtMTApKTtcblxuICAgIC8vIFNlYXJjaCBmcm9tIGJvdHRvbSB1cCBhcyB0b3RhbHMgYXJlIHVzdWFsbHkgYXQgdGhlIGVuZFxuICAgIGZvciAobGV0IGkgPSBsaW5lcy5sZW5ndGggLSAxOyBpID49IE1hdGgubWF4KDAsIGxpbmVzLmxlbmd0aCAtIDE1KTsgaS0tKSB7XG4gICAgICBjb25zdCBsaW5lID0gbGluZXNbaV0udHJpbSgpO1xuXG4gICAgICBpZiAobGluZS5sZW5ndGggPT09IDApIGNvbnRpbnVlO1xuXG4gICAgICBjb25zb2xlLmxvZyhgQ2hlY2tpbmcgbGluZSAke2l9OiBcIiR7bGluZX1cImApO1xuXG4gICAgICBmb3IgKGNvbnN0IHBhdHRlcm4gb2YgdG90YWxQYXR0ZXJucykge1xuICAgICAgICBjb25zdCBtYXRjaCA9IGxpbmUubWF0Y2gocGF0dGVybik7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgIGNvbnN0IGFtb3VudCA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBGb3VuZCBwb3RlbnRpYWwgdG90YWw6ICR7YW1vdW50fSBmcm9tIHBhdHRlcm46ICR7cGF0dGVybn1gKTtcbiAgICAgICAgICBpZiAoIWlzTmFOKGFtb3VudCkgJiYgYW1vdW50ID4gMCAmJiBhbW91bnQgPCAxMDAwMCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYOKchSBVc2luZyB0b3RhbCBhbW91bnQ6ICR7YW1vdW50fWApO1xuICAgICAgICAgICAgcmV0dXJuIGFtb3VudDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZygn4pqg77iPIE5vIGNsZWFyIHRvdGFsIGZvdW5kLCBsb29raW5nIGZvciBsYXJnZXN0IGFtb3VudCcpO1xuXG4gICAgLy8gSWYgbm8gY2xlYXIgdG90YWwgZm91bmQsIGxvb2sgZm9yIGxhcmdlc3QgcmVhc29uYWJsZSBhbW91bnRcbiAgICBjb25zdCBhbW91bnRzOiBudW1iZXJbXSA9IFtdO1xuICAgIGxpbmVzLmZvckVhY2goKGxpbmUsIGluZGV4KSA9PiB7XG4gICAgICAvLyBMb29rIGZvciBtb25leSBhbW91bnRzOiAkWC5YWCBvciBYLlhYXG4gICAgICBjb25zdCBtYXRjaGVzID0gbGluZS5tYXRjaCgvWyRdPyhcXGQrXFwuXFxkezJ9KS9nKSB8fCBbXTtcbiAgICAgIG1hdGNoZXMuZm9yRWFjaChtYXRjaCA9PiB7XG4gICAgICAgIGNvbnN0IGFtb3VudCA9IHBhcnNlRmxvYXQobWF0Y2gucmVwbGFjZSgnJCcsICcnKSk7XG4gICAgICAgIGlmICghaXNOYU4oYW1vdW50KSAmJiBhbW91bnQgPiAwICYmIGFtb3VudCA8IDEwMDAwKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYEZvdW5kIGFtb3VudCAke2Ftb3VudH0gb24gbGluZSAke2luZGV4fTogXCIke2xpbmV9XCJgKTtcbiAgICAgICAgICBhbW91bnRzLnB1c2goYW1vdW50KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBjb25zdCBtYXhBbW91bnQgPSBhbW91bnRzLmxlbmd0aCA+IDAgPyBNYXRoLm1heCguLi5hbW91bnRzKSA6IDA7XG4gICAgY29uc29sZS5sb2coYFVzaW5nIGxhcmdlc3QgYW1vdW50IGZvdW5kOiAke21heEFtb3VudH1gKTtcbiAgICByZXR1cm4gbWF4QW1vdW50O1xuICB9XG5cbiAgcHJpdmF0ZSBleHRyYWN0RGF0ZShsaW5lczogc3RyaW5nW10pOiBzdHJpbmcge1xuICAgIGNvbnN0IGRhdGVQYXR0ZXJucyA9IFtcbiAgICAgIC8oXFxkezEsMn1cXC9cXGR7MSwyfVxcL1xcZHsyLDR9KS8sXG4gICAgICAvKFxcZHsxLDJ9LVxcZHsxLDJ9LVxcZHsyLDR9KS8sXG4gICAgICAvKFxcZHs0fS1cXGR7Mn0tXFxkezJ9KS8sXG4gICAgICAvKEphbnxGZWJ8TWFyfEFwcnxNYXl8SnVufEp1bHxBdWd8U2VwfE9jdHxOb3Z8RGVjKS4qPyhcXGR7MSwyfSksP1xccyooXFxkezR9KS9pXG4gICAgXTtcblxuICAgIGZvciAoY29uc3QgbGluZSBvZiBsaW5lcykge1xuICAgICAgZm9yIChjb25zdCBwYXR0ZXJuIG9mIGRhdGVQYXR0ZXJucykge1xuICAgICAgICBjb25zdCBtYXRjaCA9IGxpbmUubWF0Y2gocGF0dGVybik7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBUcnkgdG8gcGFyc2UgYW5kIG5vcm1hbGl6ZSB0aGUgZGF0ZVxuICAgICAgICAgICAgY29uc3QgZGF0ZVN0ciA9IG1hdGNoWzBdO1xuICAgICAgICAgICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKGRhdGVTdHIpO1xuICAgICAgICAgICAgaWYgKCFpc05hTihkYXRlLmdldFRpbWUoKSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGRhdGUudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdOyAvLyBSZXR1cm4gWVlZWS1NTS1ERCBmb3JtYXRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEZWZhdWx0IHRvIHRvZGF5IGlmIG5vIGRhdGUgZm91bmRcbiAgICByZXR1cm4gbmV3IERhdGUoKS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF07XG4gIH1cblxuICBwcml2YXRlIGV4dHJhY3RJdGVtcyhsaW5lczogc3RyaW5nW10pOiBBcnJheTx7IG5hbWU6IHN0cmluZzsgcHJpY2U6IG51bWJlcjsgcXVhbnRpdHk/OiBudW1iZXIgfT4ge1xuICAgIGNvbnN0IGl0ZW1zOiBBcnJheTx7IG5hbWU6IHN0cmluZzsgcHJpY2U6IG51bWJlcjsgcXVhbnRpdHk/OiBudW1iZXIgfT4gPSBbXTtcblxuICAgIGNvbnNvbGUubG9nKCfwn5SNIEV4dHJhY3RpbmcgaXRlbXMgZnJvbSBsaW5lcy4uLicpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgbGluZSA9IGxpbmVzW2ldLnRyaW0oKTtcbiAgICAgIGlmIChsaW5lLmxlbmd0aCA9PT0gMCkgY29udGludWU7XG5cbiAgICAgIC8vIEVuaGFuY2VkIGl0ZW0gcGF0dGVybnNcbiAgICAgIGNvbnN0IGl0ZW1QYXR0ZXJucyA9IFtcbiAgICAgICAgL14oXFxkKylcXHMrKC4rPylcXHMrWyRdPyhcXGQrXFwuXFxkezJ9KSQvLCAgICAgICAgLy8gXCIyIEJBTkFOQVMgJDMuOTlcIlxuICAgICAgICAvXihcXGQrKVxccysoLis/KVxccysoXFxkK1xcLlxcZHsyfSlcXHMqJC8sICAgICAgICAgLy8gXCIyIEJBTkFOQVMgMy45OVwiXG4gICAgICAgIC9eKC4rPylcXHN7Mix9WyRdPyhcXGQrXFwuXFxkezJ9KSQvLCAgICAgICAgICAgICAvLyBcIkJBTkFOQVMgICAgJDMuOTlcIiAobXVsdGlwbGUgc3BhY2VzKVxuICAgICAgICAvXiguKz8pXFxzK1skXShcXGQrXFwuXFxkezJ9KSQvLCAgICAgICAgICAgICAgICAgLy8gXCJCQU5BTkFTICQzLjk5XCJcbiAgICAgICAgL14oLis/KVxccysoXFxkK1xcLlxcZHsyfSlcXHMqJC8sICAgICAgICAgICAgICAgICAvLyBcIkJBTkFOQVMgMy45OVwiXG4gICAgICAgIC9eKC57MywzMH0/KVxccysoXFxkezEsM31cXC5cXGR7Mn0pJC8gICAgICAgICAgICAvLyBHZW5lcmljOiBuYW1lIGZvbGxvd2VkIGJ5IHByaWNlXG4gICAgICBdO1xuXG4gICAgICBmb3IgKGNvbnN0IHBhdHRlcm4gb2YgaXRlbVBhdHRlcm5zKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gbGluZS5tYXRjaChwYXR0ZXJuKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgbGV0IHF1YW50aXR5OiBudW1iZXIgfCB1bmRlZmluZWQ7XG4gICAgICAgICAgbGV0IG5hbWU6IHN0cmluZztcbiAgICAgICAgICBsZXQgcHJpY2U6IG51bWJlcjtcblxuICAgICAgICAgIGlmIChtYXRjaC5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgICAgIC8vIFBhdHRlcm4gd2l0aCBxdWFudGl0eVxuICAgICAgICAgICAgcXVhbnRpdHkgPSBwYXJzZUludChtYXRjaFsxXSk7XG4gICAgICAgICAgICBuYW1lID0gbWF0Y2hbMl0udHJpbSgpO1xuICAgICAgICAgICAgcHJpY2UgPSBwYXJzZUZsb2F0KG1hdGNoWzNdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gUGF0dGVybiB3aXRob3V0IHF1YW50aXR5XG4gICAgICAgICAgICBuYW1lID0gbWF0Y2hbMV0udHJpbSgpO1xuICAgICAgICAgICAgcHJpY2UgPSBwYXJzZUZsb2F0KG1hdGNoWzJdKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBDaGVjayBpZiB0aGlzIGlzIGEgdGF4IGl0ZW0gKGluY2x1ZGUgaXQhKVxuICAgICAgICAgIGNvbnN0IGlzVGF4SXRlbSA9IC9UQVh8SFNUfEdTVHxQU1R8VkFUL2kudGVzdChuYW1lKSB8fCAvVEFYfEhTVHxHU1R8UFNUfFZBVC9pLnRlc3QobGluZSk7XG5cbiAgICAgICAgICAvLyBFbmhhbmNlZCBmaWx0ZXJpbmcgZm9yIG5vbi1pdGVtIGxpbmVzIChidXQgYWxsb3cgdGF4IGl0ZW1zKVxuICAgICAgICAgIGNvbnN0IGV4Y2x1ZGVQYXR0ZXJucyA9IFtcbiAgICAgICAgICAgIC9UT1RBTHxTVUJUT1RBTHxDSEFOR0V8QkFMQU5DRXxSRUNFSVBUfFNUT1JFfFRIQU5LfFZJU0lUfEFHQUlOfENVU1RPTUVSfENPUFkvaSxcbiAgICAgICAgICAgIC9eKFNVQnxHUkFORHxGSU5BTCkvaSxcbiAgICAgICAgICAgIC9QQVlNRU5UfENBU0h8Q1JFRElUfERFQklUfENBUkQvaSxcbiAgICAgICAgICAgIC9eKERBVEV8VElNRXxDTEVSS3xDQVNISUVSKS9pLFxuICAgICAgICAgICAgL15cXGR7MSwyfVxcL1xcZHsxLDJ9XFwvXFxkezIsNH0vLCAvLyBEYXRlIHBhdHRlcm5zXG4gICAgICAgICAgICAvXlxcZHsyfTpcXGR7Mn0vLCAvLyBUaW1lIHBhdHRlcm5zXG4gICAgICAgICAgXTtcblxuICAgICAgICAgIGNvbnN0IHNob3VsZEV4Y2x1ZGUgPSAhaXNUYXhJdGVtICYmIChcbiAgICAgICAgICAgIGV4Y2x1ZGVQYXR0ZXJucy5zb21lKHBhdHRlcm4gPT4gcGF0dGVybi50ZXN0KG5hbWUpKSB8fFxuICAgICAgICAgICAgZXhjbHVkZVBhdHRlcm5zLnNvbWUocGF0dGVybiA9PiBwYXR0ZXJuLnRlc3QobGluZSkpXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGlmIChuYW1lICYmICFzaG91bGRFeGNsdWRlICYmXG4gICAgICAgICAgICAgIG5hbWUubGVuZ3RoID49IDIgJiYgbmFtZS5sZW5ndGggPD0gNTAgJiZcbiAgICAgICAgICAgICAgcHJpY2UgPiAwICYmIHByaWNlIDw9IDEwMDAgJiZcbiAgICAgICAgICAgICAgIW5hbWUubWF0Y2goL15cXGQrJC8pICYmIC8vIE5vdCBqdXN0IG51bWJlcnNcbiAgICAgICAgICAgICAgbmFtZS5tYXRjaCgvW0EtWmEtel0vKSAgLy8gQ29udGFpbnMgYXQgbGVhc3Qgb25lIGxldHRlclxuICAgICAgICAgICkge1xuXG4gICAgICAgICAgICBjb25zdCBpdGVtVHlwZSA9IGlzVGF4SXRlbSA/ICcgW1RBWF0nIDogJyc7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg4pyFIEZvdW5kIGl0ZW06IFwiJHtuYW1lfVwiIC0gJCR7cHJpY2V9YCArIChxdWFudGl0eSA/IGAgKHF0eTogJHtxdWFudGl0eX0pYCA6ICcnKSArIGl0ZW1UeXBlKTtcblxuICAgICAgICAgICAgaXRlbXMucHVzaCh7XG4gICAgICAgICAgICAgIG5hbWU6IG5hbWUudG9VcHBlckNhc2UoKSxcbiAgICAgICAgICAgICAgcHJpY2UsXG4gICAgICAgICAgICAgIHF1YW50aXR5XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZyhgRm91bmQgJHtpdGVtcy5sZW5ndGh9IGl0ZW1zIHRvdGFsYCk7XG4gICAgcmV0dXJuIGl0ZW1zO1xuICB9XG5cbiAgYXN5bmMgY2xlYW51cCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAodGhpcy53b3JrZXIpIHtcbiAgICAgIGF3YWl0IHRoaXMud29ya2VyLnRlcm1pbmF0ZSgpO1xuICAgICAgdGhpcy53b3JrZXIgPSBudWxsO1xuICAgICAgdGhpcy5pc0luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICBjb25zb2xlLmxvZygn8J+nuSBPQ1IgZW5naW5lIGNsZWFuZWQgdXAnKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gRXhwb3J0IHNpbmdsZXRvbiBpbnN0YW5jZVxuZXhwb3J0IGNvbnN0IG9jclNlcnZpY2UgPSBuZXcgT0NSU2VydmljZSgpOyJdLCJuYW1lcyI6WyJjcmVhdGVXb3JrZXIiLCJPQ1JTZXJ2aWNlIiwiaW5pdGlhbGl6ZSIsImlzSW5pdGlhbGl6ZWQiLCJjb25zb2xlIiwibG9nIiwid29ya2VyIiwic2V0UGFyYW1ldGVycyIsImVycm9yIiwiRXJyb3IiLCJwcmVwcm9jZXNzSW1hZ2UiLCJpbWFnZUZpbGUiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImNhbnZhcyIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImN0eCIsImdldENvbnRleHQiLCJpbWciLCJJbWFnZSIsIm9ubG9hZCIsInBhZGRpbmciLCJ3aWR0aCIsImhlaWdodCIsImZpbGxTdHlsZSIsImZpbGxSZWN0IiwiZHJhd0ltYWdlIiwiaW1hZ2VEYXRhIiwiZ2V0SW1hZ2VEYXRhIiwiZGF0YSIsImkiLCJsZW5ndGgiLCJncmF5IiwiTWF0aCIsInJvdW5kIiwiY29udHJhc3QiLCJmYWN0b3IiLCJlbmhhbmNlZCIsIm1heCIsIm1pbiIsInB1dEltYWdlRGF0YSIsInRvRGF0YVVSTCIsIm9uZXJyb3IiLCJzcmMiLCJVUkwiLCJjcmVhdGVPYmplY3RVUkwiLCJyZWNvbnN0cnVjdEFsaWduZWRUZXh0Iiwib2NyRGF0YSIsImxpbmVzIiwidGV4dCIsImxpbmUiLCJ3b3JkcyIsInNvcnRlZFdvcmRzIiwic29ydCIsImEiLCJiIiwiYmJveCIsIngwIiwibGluZVRleHQiLCJsYXN0WCIsIndvcmQiLCJ3b3JkVGV4dCIsInRyaW0iLCJjdXJyZW50WCIsIndvcmRXaWR0aCIsIngxIiwiZ2FwIiwiYXZnQ2hhcldpZHRoIiwic3BhY2VzTmVlZGVkIiwiZmxvb3IiLCJyZXBlYXQiLCJwdXNoIiwicmVjb25zdHJ1Y3RlZFRleHQiLCJqb2luIiwic3Vic3RyaW5nIiwicHJvY2Vzc1JlY2VpcHRJbWFnZSIsInJlc3VsdCIsInByZXByb2Nlc3NlZEltYWdlIiwicmVjb2duaXplIiwiY29uZmlkZW5jZSIsInRleHRMZW5ndGgiLCJ3b3Jkc0ZvdW5kIiwiYWxpZ25lZFRleHQiLCJwYXJzZVJlY2VpcHRUZXh0Iiwib2NyVGV4dCIsInNwbGl0IiwibWFwIiwiZmlsdGVyIiwibWVyY2hhbnQiLCJleHRyYWN0TWVyY2hhbnQiLCJpdGVtcyIsImV4dHJhY3RJdGVtcyIsImFtb3VudCIsImV4dHJhY3RWYWxpZGF0ZWRUb3RhbCIsImRhdGUiLCJleHRyYWN0RGF0ZSIsInBhcnNlZCIsInJhd1RleHQiLCJtZXJjaGFudFBhdHRlcm5zIiwibWF0Y2giLCJpbmNsdWRlcyIsInBhdHRlcm4iLCJ0b1VwcGVyQ2FzZSIsIm5vbk1lcmNoYW50V29yZHMiLCJzb21lIiwiaXRlbXNUb3RhbCIsInJlZHVjZSIsInN1bSIsIml0ZW0iLCJwcmljZSIsInRvRml4ZWQiLCJ0b3RhbFBhdHRlcm5zIiwiZm91bmRUb3RhbHMiLCJwYXJzZUZsb2F0IiwiaXNOYU4iLCJ0b3RhbCIsImRpZmZlcmVuY2UiLCJhYnMiLCJzb3J0ZWRCeUNsb3NlbmVzcyIsImNsb3Nlc3QiLCJleHRyYWN0VG90YWxBbW91bnQiLCJzbGljZSIsImFtb3VudHMiLCJmb3JFYWNoIiwiaW5kZXgiLCJtYXRjaGVzIiwicmVwbGFjZSIsIm1heEFtb3VudCIsImRhdGVQYXR0ZXJucyIsImRhdGVTdHIiLCJEYXRlIiwiZ2V0VGltZSIsInRvSVNPU3RyaW5nIiwiZSIsIml0ZW1QYXR0ZXJucyIsInF1YW50aXR5IiwibmFtZSIsInBhcnNlSW50IiwiaXNUYXhJdGVtIiwidGVzdCIsImV4Y2x1ZGVQYXR0ZXJucyIsInNob3VsZEV4Y2x1ZGUiLCJpdGVtVHlwZSIsImNsZWFudXAiLCJ0ZXJtaW5hdGUiLCJvY3JTZXJ2aWNlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./services/ocrService.ts\n"));

/***/ })

});