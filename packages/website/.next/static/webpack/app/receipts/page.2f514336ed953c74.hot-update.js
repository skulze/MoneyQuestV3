/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/receipts/page",{

/***/ "(app-pages-browser)/../../node_modules/dexie/dist/dexie.js":
/*!**********************************************!*\
  !*** ../../node_modules/dexie/dist/dexie.js ***!
  \**********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/*\n * Dexie.js - a minimalistic wrapper for IndexedDB\n * ===============================================\n *\n * By David Fahlander, david.fahlander@gmail.com\n *\n * Version 4.2.0, Wed Aug 13 2025\n *\n * https://dexie.org\n *\n * Apache License Version 2.0, January 2004, http://www.apache.org/licenses/\n */\n \n(function (global, factory) {\n     true ? module.exports = factory() :\n    0;\n})(this, (function () { 'use strict';\n\n    /*! *****************************************************************************\n    Copyright (c) Microsoft Corporation.\n    Permission to use, copy, modify, and/or distribute this software for any\n    purpose with or without fee is hereby granted.\n    THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\n    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n    PERFORMANCE OF THIS SOFTWARE.\n    ***************************************************************************** */\n    var extendStatics = function(d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    function __extends(d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    }\n    var __assign = function() {\n        __assign = Object.assign || function __assign(t) {\n            for (var s, i = 1, n = arguments.length; i < n; i++) {\n                s = arguments[i];\n                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n            }\n            return t;\n        };\n        return __assign.apply(this, arguments);\n    };\n    function __spreadArray(to, from, pack) {\n        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n            if (ar || !(i in from)) {\n                if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n                ar[i] = from[i];\n            }\n        }\n        return to.concat(ar || Array.prototype.slice.call(from));\n    }\n\n    var _global = typeof globalThis !== 'undefined' ? globalThis :\n        typeof self !== 'undefined' ? self :\n            typeof window !== 'undefined' ? window :\n                __webpack_require__.g;\n\n    var keys = Object.keys;\n    var isArray = Array.isArray;\n    if (typeof Promise !== 'undefined' && !_global.Promise) {\n        _global.Promise = Promise;\n    }\n    function extend(obj, extension) {\n        if (typeof extension !== 'object')\n            return obj;\n        keys(extension).forEach(function (key) {\n            obj[key] = extension[key];\n        });\n        return obj;\n    }\n    var getProto = Object.getPrototypeOf;\n    var _hasOwn = {}.hasOwnProperty;\n    function hasOwn(obj, prop) {\n        return _hasOwn.call(obj, prop);\n    }\n    function props(proto, extension) {\n        if (typeof extension === 'function')\n            extension = extension(getProto(proto));\n        (typeof Reflect === \"undefined\" ? keys : Reflect.ownKeys)(extension).forEach(function (key) {\n            setProp(proto, key, extension[key]);\n        });\n    }\n    var defineProperty = Object.defineProperty;\n    function setProp(obj, prop, functionOrGetSet, options) {\n        defineProperty(obj, prop, extend(functionOrGetSet && hasOwn(functionOrGetSet, \"get\") && typeof functionOrGetSet.get === 'function' ?\n            { get: functionOrGetSet.get, set: functionOrGetSet.set, configurable: true } :\n            { value: functionOrGetSet, configurable: true, writable: true }, options));\n    }\n    function derive(Child) {\n        return {\n            from: function (Parent) {\n                Child.prototype = Object.create(Parent.prototype);\n                setProp(Child.prototype, \"constructor\", Child);\n                return {\n                    extend: props.bind(null, Child.prototype)\n                };\n            }\n        };\n    }\n    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n    function getPropertyDescriptor(obj, prop) {\n        var pd = getOwnPropertyDescriptor(obj, prop);\n        var proto;\n        return pd || (proto = getProto(obj)) && getPropertyDescriptor(proto, prop);\n    }\n    var _slice = [].slice;\n    function slice(args, start, end) {\n        return _slice.call(args, start, end);\n    }\n    function override(origFunc, overridedFactory) {\n        return overridedFactory(origFunc);\n    }\n    function assert(b) {\n        if (!b)\n            throw new Error(\"Assertion Failed\");\n    }\n    function asap$1(fn) {\n        if (_global.setImmediate)\n            setImmediate(fn);\n        else\n            setTimeout(fn, 0);\n    }\n    function arrayToObject(array, extractor) {\n        return array.reduce(function (result, item, i) {\n            var nameAndValue = extractor(item, i);\n            if (nameAndValue)\n                result[nameAndValue[0]] = nameAndValue[1];\n            return result;\n        }, {});\n    }\n    function getByKeyPath(obj, keyPath) {\n        if (typeof keyPath === 'string' && hasOwn(obj, keyPath))\n            return obj[keyPath];\n        if (!keyPath)\n            return obj;\n        if (typeof keyPath !== 'string') {\n            var rv = [];\n            for (var i = 0, l = keyPath.length; i < l; ++i) {\n                var val = getByKeyPath(obj, keyPath[i]);\n                rv.push(val);\n            }\n            return rv;\n        }\n        var period = keyPath.indexOf('.');\n        if (period !== -1) {\n            var innerObj = obj[keyPath.substr(0, period)];\n            return innerObj == null ? undefined : getByKeyPath(innerObj, keyPath.substr(period + 1));\n        }\n        return undefined;\n    }\n    function setByKeyPath(obj, keyPath, value) {\n        if (!obj || keyPath === undefined)\n            return;\n        if ('isFrozen' in Object && Object.isFrozen(obj))\n            return;\n        if (typeof keyPath !== 'string' && 'length' in keyPath) {\n            assert(typeof value !== 'string' && 'length' in value);\n            for (var i = 0, l = keyPath.length; i < l; ++i) {\n                setByKeyPath(obj, keyPath[i], value[i]);\n            }\n        }\n        else {\n            var period = keyPath.indexOf('.');\n            if (period !== -1) {\n                var currentKeyPath = keyPath.substr(0, period);\n                var remainingKeyPath = keyPath.substr(period + 1);\n                if (remainingKeyPath === \"\")\n                    if (value === undefined) {\n                        if (isArray(obj) && !isNaN(parseInt(currentKeyPath)))\n                            obj.splice(currentKeyPath, 1);\n                        else\n                            delete obj[currentKeyPath];\n                    }\n                    else\n                        obj[currentKeyPath] = value;\n                else {\n                    var innerObj = obj[currentKeyPath];\n                    if (!innerObj || !hasOwn(obj, currentKeyPath))\n                        innerObj = (obj[currentKeyPath] = {});\n                    setByKeyPath(innerObj, remainingKeyPath, value);\n                }\n            }\n            else {\n                if (value === undefined) {\n                    if (isArray(obj) && !isNaN(parseInt(keyPath)))\n                        obj.splice(keyPath, 1);\n                    else\n                        delete obj[keyPath];\n                }\n                else\n                    obj[keyPath] = value;\n            }\n        }\n    }\n    function delByKeyPath(obj, keyPath) {\n        if (typeof keyPath === 'string')\n            setByKeyPath(obj, keyPath, undefined);\n        else if ('length' in keyPath)\n            [].map.call(keyPath, function (kp) {\n                setByKeyPath(obj, kp, undefined);\n            });\n    }\n    function shallowClone(obj) {\n        var rv = {};\n        for (var m in obj) {\n            if (hasOwn(obj, m))\n                rv[m] = obj[m];\n        }\n        return rv;\n    }\n    var concat = [].concat;\n    function flatten(a) {\n        return concat.apply([], a);\n    }\n    var intrinsicTypeNames = \"BigUint64Array,BigInt64Array,Array,Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,FileSystemDirectoryHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey\"\n        .split(',').concat(flatten([8, 16, 32, 64].map(function (num) { return [\"Int\", \"Uint\", \"Float\"].map(function (t) { return t + num + \"Array\"; }); }))).filter(function (t) { return _global[t]; });\n    var intrinsicTypes = new Set(intrinsicTypeNames.map(function (t) { return _global[t]; }));\n    function cloneSimpleObjectTree(o) {\n        var rv = {};\n        for (var k in o)\n            if (hasOwn(o, k)) {\n                var v = o[k];\n                rv[k] = !v || typeof v !== 'object' || intrinsicTypes.has(v.constructor) ? v : cloneSimpleObjectTree(v);\n            }\n        return rv;\n    }\n    function objectIsEmpty(o) {\n        for (var k in o)\n            if (hasOwn(o, k))\n                return false;\n        return true;\n    }\n    var circularRefs = null;\n    function deepClone(any) {\n        circularRefs = new WeakMap();\n        var rv = innerDeepClone(any);\n        circularRefs = null;\n        return rv;\n    }\n    function innerDeepClone(x) {\n        if (!x || typeof x !== 'object')\n            return x;\n        var rv = circularRefs.get(x);\n        if (rv)\n            return rv;\n        if (isArray(x)) {\n            rv = [];\n            circularRefs.set(x, rv);\n            for (var i = 0, l = x.length; i < l; ++i) {\n                rv.push(innerDeepClone(x[i]));\n            }\n        }\n        else if (intrinsicTypes.has(x.constructor)) {\n            rv = x;\n        }\n        else {\n            var proto = getProto(x);\n            rv = proto === Object.prototype ? {} : Object.create(proto);\n            circularRefs.set(x, rv);\n            for (var prop in x) {\n                if (hasOwn(x, prop)) {\n                    rv[prop] = innerDeepClone(x[prop]);\n                }\n            }\n        }\n        return rv;\n    }\n    var toString = {}.toString;\n    function toStringTag(o) {\n        return toString.call(o).slice(8, -1);\n    }\n    var iteratorSymbol = typeof Symbol !== 'undefined' ?\n        Symbol.iterator :\n        '@@iterator';\n    var getIteratorOf = typeof iteratorSymbol === \"symbol\" ? function (x) {\n        var i;\n        return x != null && (i = x[iteratorSymbol]) && i.apply(x);\n    } : function () { return null; };\n    function delArrayItem(a, x) {\n        var i = a.indexOf(x);\n        if (i >= 0)\n            a.splice(i, 1);\n        return i >= 0;\n    }\n    var NO_CHAR_ARRAY = {};\n    function getArrayOf(arrayLike) {\n        var i, a, x, it;\n        if (arguments.length === 1) {\n            if (isArray(arrayLike))\n                return arrayLike.slice();\n            if (this === NO_CHAR_ARRAY && typeof arrayLike === 'string')\n                return [arrayLike];\n            if ((it = getIteratorOf(arrayLike))) {\n                a = [];\n                while ((x = it.next()), !x.done)\n                    a.push(x.value);\n                return a;\n            }\n            if (arrayLike == null)\n                return [arrayLike];\n            i = arrayLike.length;\n            if (typeof i === 'number') {\n                a = new Array(i);\n                while (i--)\n                    a[i] = arrayLike[i];\n                return a;\n            }\n            return [arrayLike];\n        }\n        i = arguments.length;\n        a = new Array(i);\n        while (i--)\n            a[i] = arguments[i];\n        return a;\n    }\n    var isAsyncFunction = typeof Symbol !== 'undefined'\n        ? function (fn) { return fn[Symbol.toStringTag] === 'AsyncFunction'; }\n        : function () { return false; };\n\n    var dexieErrorNames = [\n        'Modify',\n        'Bulk',\n        'OpenFailed',\n        'VersionChange',\n        'Schema',\n        'Upgrade',\n        'InvalidTable',\n        'MissingAPI',\n        'NoSuchDatabase',\n        'InvalidArgument',\n        'SubTransaction',\n        'Unsupported',\n        'Internal',\n        'DatabaseClosed',\n        'PrematureCommit',\n        'ForeignAwait'\n    ];\n    var idbDomErrorNames = [\n        'Unknown',\n        'Constraint',\n        'Data',\n        'TransactionInactive',\n        'ReadOnly',\n        'Version',\n        'NotFound',\n        'InvalidState',\n        'InvalidAccess',\n        'Abort',\n        'Timeout',\n        'QuotaExceeded',\n        'Syntax',\n        'DataClone'\n    ];\n    var errorList = dexieErrorNames.concat(idbDomErrorNames);\n    var defaultTexts = {\n        VersionChanged: \"Database version changed by other database connection\",\n        DatabaseClosed: \"Database has been closed\",\n        Abort: \"Transaction aborted\",\n        TransactionInactive: \"Transaction has already completed or failed\",\n        MissingAPI: \"IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb\"\n    };\n    function DexieError(name, msg) {\n        this.name = name;\n        this.message = msg;\n    }\n    derive(DexieError).from(Error).extend({\n        toString: function () { return this.name + \": \" + this.message; }\n    });\n    function getMultiErrorMessage(msg, failures) {\n        return msg + \". Errors: \" + Object.keys(failures)\n            .map(function (key) { return failures[key].toString(); })\n            .filter(function (v, i, s) { return s.indexOf(v) === i; })\n            .join('\\n');\n    }\n    function ModifyError(msg, failures, successCount, failedKeys) {\n        this.failures = failures;\n        this.failedKeys = failedKeys;\n        this.successCount = successCount;\n        this.message = getMultiErrorMessage(msg, failures);\n    }\n    derive(ModifyError).from(DexieError);\n    function BulkError(msg, failures) {\n        this.name = \"BulkError\";\n        this.failures = Object.keys(failures).map(function (pos) { return failures[pos]; });\n        this.failuresByPos = failures;\n        this.message = getMultiErrorMessage(msg, this.failures);\n    }\n    derive(BulkError).from(DexieError);\n    var errnames = errorList.reduce(function (obj, name) { return (obj[name] = name + \"Error\", obj); }, {});\n    var BaseException = DexieError;\n    var exceptions = errorList.reduce(function (obj, name) {\n        var fullName = name + \"Error\";\n        function DexieError(msgOrInner, inner) {\n            this.name = fullName;\n            if (!msgOrInner) {\n                this.message = defaultTexts[name] || fullName;\n                this.inner = null;\n            }\n            else if (typeof msgOrInner === 'string') {\n                this.message = \"\".concat(msgOrInner).concat(!inner ? '' : '\\n ' + inner);\n                this.inner = inner || null;\n            }\n            else if (typeof msgOrInner === 'object') {\n                this.message = \"\".concat(msgOrInner.name, \" \").concat(msgOrInner.message);\n                this.inner = msgOrInner;\n            }\n        }\n        derive(DexieError).from(BaseException);\n        obj[name] = DexieError;\n        return obj;\n    }, {});\n    exceptions.Syntax = SyntaxError;\n    exceptions.Type = TypeError;\n    exceptions.Range = RangeError;\n    var exceptionMap = idbDomErrorNames.reduce(function (obj, name) {\n        obj[name + \"Error\"] = exceptions[name];\n        return obj;\n    }, {});\n    function mapError(domError, message) {\n        if (!domError || domError instanceof DexieError || domError instanceof TypeError || domError instanceof SyntaxError || !domError.name || !exceptionMap[domError.name])\n            return domError;\n        var rv = new exceptionMap[domError.name](message || domError.message, domError);\n        if (\"stack\" in domError) {\n            setProp(rv, \"stack\", { get: function () {\n                    return this.inner.stack;\n                } });\n        }\n        return rv;\n    }\n    var fullNameExceptions = errorList.reduce(function (obj, name) {\n        if ([\"Syntax\", \"Type\", \"Range\"].indexOf(name) === -1)\n            obj[name + \"Error\"] = exceptions[name];\n        return obj;\n    }, {});\n    fullNameExceptions.ModifyError = ModifyError;\n    fullNameExceptions.DexieError = DexieError;\n    fullNameExceptions.BulkError = BulkError;\n\n    function nop() { }\n    function mirror(val) { return val; }\n    function pureFunctionChain(f1, f2) {\n        if (f1 == null || f1 === mirror)\n            return f2;\n        return function (val) {\n            return f2(f1(val));\n        };\n    }\n    function callBoth(on1, on2) {\n        return function () {\n            on1.apply(this, arguments);\n            on2.apply(this, arguments);\n        };\n    }\n    function hookCreatingChain(f1, f2) {\n        if (f1 === nop)\n            return f2;\n        return function () {\n            var res = f1.apply(this, arguments);\n            if (res !== undefined)\n                arguments[0] = res;\n            var onsuccess = this.onsuccess,\n            onerror = this.onerror;\n            this.onsuccess = null;\n            this.onerror = null;\n            var res2 = f2.apply(this, arguments);\n            if (onsuccess)\n                this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n            if (onerror)\n                this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n            return res2 !== undefined ? res2 : res;\n        };\n    }\n    function hookDeletingChain(f1, f2) {\n        if (f1 === nop)\n            return f2;\n        return function () {\n            f1.apply(this, arguments);\n            var onsuccess = this.onsuccess,\n            onerror = this.onerror;\n            this.onsuccess = this.onerror = null;\n            f2.apply(this, arguments);\n            if (onsuccess)\n                this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n            if (onerror)\n                this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n        };\n    }\n    function hookUpdatingChain(f1, f2) {\n        if (f1 === nop)\n            return f2;\n        return function (modifications) {\n            var res = f1.apply(this, arguments);\n            extend(modifications, res);\n            var onsuccess = this.onsuccess,\n            onerror = this.onerror;\n            this.onsuccess = null;\n            this.onerror = null;\n            var res2 = f2.apply(this, arguments);\n            if (onsuccess)\n                this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n            if (onerror)\n                this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n            return res === undefined ?\n                (res2 === undefined ? undefined : res2) :\n                (extend(res, res2));\n        };\n    }\n    function reverseStoppableEventChain(f1, f2) {\n        if (f1 === nop)\n            return f2;\n        return function () {\n            if (f2.apply(this, arguments) === false)\n                return false;\n            return f1.apply(this, arguments);\n        };\n    }\n    function promisableChain(f1, f2) {\n        if (f1 === nop)\n            return f2;\n        return function () {\n            var res = f1.apply(this, arguments);\n            if (res && typeof res.then === 'function') {\n                var thiz = this, i = arguments.length, args = new Array(i);\n                while (i--)\n                    args[i] = arguments[i];\n                return res.then(function () {\n                    return f2.apply(thiz, args);\n                });\n            }\n            return f2.apply(this, arguments);\n        };\n    }\n\n    var debug = typeof location !== 'undefined' &&\n        /^(http|https):\\/\\/(localhost|127\\.0\\.0\\.1)/.test(location.href);\n    function setDebug(value, filter) {\n        debug = value;\n    }\n\n    var INTERNAL = {};\n    var ZONE_ECHO_LIMIT = 100, _a$1 = typeof Promise === 'undefined' ?\n        [] :\n        (function () {\n            var globalP = Promise.resolve();\n            if (typeof crypto === 'undefined' || !crypto.subtle)\n                return [globalP, getProto(globalP), globalP];\n            var nativeP = crypto.subtle.digest(\"SHA-512\", new Uint8Array([0]));\n            return [\n                nativeP,\n                getProto(nativeP),\n                globalP\n            ];\n        })(), resolvedNativePromise = _a$1[0], nativePromiseProto = _a$1[1], resolvedGlobalPromise = _a$1[2], nativePromiseThen = nativePromiseProto && nativePromiseProto.then;\n    var NativePromise = resolvedNativePromise && resolvedNativePromise.constructor;\n    var patchGlobalPromise = !!resolvedGlobalPromise;\n    function schedulePhysicalTick() {\n        queueMicrotask(physicalTick);\n    }\n    var asap = function (callback, args) {\n        microtickQueue.push([callback, args]);\n        if (needsNewPhysicalTick) {\n            schedulePhysicalTick();\n            needsNewPhysicalTick = false;\n        }\n    };\n    var isOutsideMicroTick = true,\n    needsNewPhysicalTick = true,\n    unhandledErrors = [],\n    rejectingErrors = [],\n    rejectionMapper = mirror;\n    var globalPSD = {\n        id: 'global',\n        global: true,\n        ref: 0,\n        unhandleds: [],\n        onunhandled: nop,\n        pgp: false,\n        env: {},\n        finalize: nop\n    };\n    var PSD = globalPSD;\n    var microtickQueue = [];\n    var numScheduledCalls = 0;\n    var tickFinalizers = [];\n    function DexiePromise(fn) {\n        if (typeof this !== 'object')\n            throw new TypeError('Promises must be constructed via new');\n        this._listeners = [];\n        this._lib = false;\n        var psd = (this._PSD = PSD);\n        if (typeof fn !== 'function') {\n            if (fn !== INTERNAL)\n                throw new TypeError('Not a function');\n            this._state = arguments[1];\n            this._value = arguments[2];\n            if (this._state === false)\n                handleRejection(this, this._value);\n            return;\n        }\n        this._state = null;\n        this._value = null;\n        ++psd.ref;\n        executePromiseTask(this, fn);\n    }\n    var thenProp = {\n        get: function () {\n            var psd = PSD, microTaskId = totalEchoes;\n            function then(onFulfilled, onRejected) {\n                var _this = this;\n                var possibleAwait = !psd.global && (psd !== PSD || microTaskId !== totalEchoes);\n                var cleanup = possibleAwait && !decrementExpectedAwaits();\n                var rv = new DexiePromise(function (resolve, reject) {\n                    propagateToListener(_this, new Listener(nativeAwaitCompatibleWrap(onFulfilled, psd, possibleAwait, cleanup), nativeAwaitCompatibleWrap(onRejected, psd, possibleAwait, cleanup), resolve, reject, psd));\n                });\n                if (this._consoleTask)\n                    rv._consoleTask = this._consoleTask;\n                return rv;\n            }\n            then.prototype = INTERNAL;\n            return then;\n        },\n        set: function (value) {\n            setProp(this, 'then', value && value.prototype === INTERNAL ?\n                thenProp :\n                {\n                    get: function () {\n                        return value;\n                    },\n                    set: thenProp.set\n                });\n        }\n    };\n    props(DexiePromise.prototype, {\n        then: thenProp,\n        _then: function (onFulfilled, onRejected) {\n            propagateToListener(this, new Listener(null, null, onFulfilled, onRejected, PSD));\n        },\n        catch: function (onRejected) {\n            if (arguments.length === 1)\n                return this.then(null, onRejected);\n            var type = arguments[0], handler = arguments[1];\n            return typeof type === 'function' ? this.then(null, function (err) {\n                return err instanceof type ? handler(err) : PromiseReject(err);\n            })\n                : this.then(null, function (err) {\n                    return err && err.name === type ? handler(err) : PromiseReject(err);\n                });\n        },\n        finally: function (onFinally) {\n            return this.then(function (value) {\n                return DexiePromise.resolve(onFinally()).then(function () { return value; });\n            }, function (err) {\n                return DexiePromise.resolve(onFinally()).then(function () { return PromiseReject(err); });\n            });\n        },\n        timeout: function (ms, msg) {\n            var _this = this;\n            return ms < Infinity ?\n                new DexiePromise(function (resolve, reject) {\n                    var handle = setTimeout(function () { return reject(new exceptions.Timeout(msg)); }, ms);\n                    _this.then(resolve, reject).finally(clearTimeout.bind(null, handle));\n                }) : this;\n        }\n    });\n    if (typeof Symbol !== 'undefined' && Symbol.toStringTag)\n        setProp(DexiePromise.prototype, Symbol.toStringTag, 'Dexie.Promise');\n    globalPSD.env = snapShot();\n    function Listener(onFulfilled, onRejected, resolve, reject, zone) {\n        this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n        this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n        this.resolve = resolve;\n        this.reject = reject;\n        this.psd = zone;\n    }\n    props(DexiePromise, {\n        all: function () {\n            var values = getArrayOf.apply(null, arguments)\n                .map(onPossibleParallellAsync);\n            return new DexiePromise(function (resolve, reject) {\n                if (values.length === 0)\n                    resolve([]);\n                var remaining = values.length;\n                values.forEach(function (a, i) { return DexiePromise.resolve(a).then(function (x) {\n                    values[i] = x;\n                    if (!--remaining)\n                        resolve(values);\n                }, reject); });\n            });\n        },\n        resolve: function (value) {\n            if (value instanceof DexiePromise)\n                return value;\n            if (value && typeof value.then === 'function')\n                return new DexiePromise(function (resolve, reject) {\n                    value.then(resolve, reject);\n                });\n            var rv = new DexiePromise(INTERNAL, true, value);\n            return rv;\n        },\n        reject: PromiseReject,\n        race: function () {\n            var values = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n            return new DexiePromise(function (resolve, reject) {\n                values.map(function (value) { return DexiePromise.resolve(value).then(resolve, reject); });\n            });\n        },\n        PSD: {\n            get: function () { return PSD; },\n            set: function (value) { return PSD = value; }\n        },\n        totalEchoes: { get: function () { return totalEchoes; } },\n        newPSD: newScope,\n        usePSD: usePSD,\n        scheduler: {\n            get: function () { return asap; },\n            set: function (value) { asap = value; }\n        },\n        rejectionMapper: {\n            get: function () { return rejectionMapper; },\n            set: function (value) { rejectionMapper = value; }\n        },\n        follow: function (fn, zoneProps) {\n            return new DexiePromise(function (resolve, reject) {\n                return newScope(function (resolve, reject) {\n                    var psd = PSD;\n                    psd.unhandleds = [];\n                    psd.onunhandled = reject;\n                    psd.finalize = callBoth(function () {\n                        var _this = this;\n                        run_at_end_of_this_or_next_physical_tick(function () {\n                            _this.unhandleds.length === 0 ? resolve() : reject(_this.unhandleds[0]);\n                        });\n                    }, psd.finalize);\n                    fn();\n                }, zoneProps, resolve, reject);\n            });\n        }\n    });\n    if (NativePromise) {\n        if (NativePromise.allSettled)\n            setProp(DexiePromise, \"allSettled\", function () {\n                var possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n                return new DexiePromise(function (resolve) {\n                    if (possiblePromises.length === 0)\n                        resolve([]);\n                    var remaining = possiblePromises.length;\n                    var results = new Array(remaining);\n                    possiblePromises.forEach(function (p, i) { return DexiePromise.resolve(p).then(function (value) { return results[i] = { status: \"fulfilled\", value: value }; }, function (reason) { return results[i] = { status: \"rejected\", reason: reason }; })\n                        .then(function () { return --remaining || resolve(results); }); });\n                });\n            });\n        if (NativePromise.any && typeof AggregateError !== 'undefined')\n            setProp(DexiePromise, \"any\", function () {\n                var possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n                return new DexiePromise(function (resolve, reject) {\n                    if (possiblePromises.length === 0)\n                        reject(new AggregateError([]));\n                    var remaining = possiblePromises.length;\n                    var failures = new Array(remaining);\n                    possiblePromises.forEach(function (p, i) { return DexiePromise.resolve(p).then(function (value) { return resolve(value); }, function (failure) {\n                        failures[i] = failure;\n                        if (!--remaining)\n                            reject(new AggregateError(failures));\n                    }); });\n                });\n            });\n        if (NativePromise.withResolvers)\n            DexiePromise.withResolvers = NativePromise.withResolvers;\n    }\n    function executePromiseTask(promise, fn) {\n        try {\n            fn(function (value) {\n                if (promise._state !== null)\n                    return;\n                if (value === promise)\n                    throw new TypeError('A promise cannot be resolved with itself.');\n                var shouldExecuteTick = promise._lib && beginMicroTickScope();\n                if (value && typeof value.then === 'function') {\n                    executePromiseTask(promise, function (resolve, reject) {\n                        value instanceof DexiePromise ?\n                            value._then(resolve, reject) :\n                            value.then(resolve, reject);\n                    });\n                }\n                else {\n                    promise._state = true;\n                    promise._value = value;\n                    propagateAllListeners(promise);\n                }\n                if (shouldExecuteTick)\n                    endMicroTickScope();\n            }, handleRejection.bind(null, promise));\n        }\n        catch (ex) {\n            handleRejection(promise, ex);\n        }\n    }\n    function handleRejection(promise, reason) {\n        rejectingErrors.push(reason);\n        if (promise._state !== null)\n            return;\n        var shouldExecuteTick = promise._lib && beginMicroTickScope();\n        reason = rejectionMapper(reason);\n        promise._state = false;\n        promise._value = reason;\n        addPossiblyUnhandledError(promise);\n        propagateAllListeners(promise);\n        if (shouldExecuteTick)\n            endMicroTickScope();\n    }\n    function propagateAllListeners(promise) {\n        var listeners = promise._listeners;\n        promise._listeners = [];\n        for (var i = 0, len = listeners.length; i < len; ++i) {\n            propagateToListener(promise, listeners[i]);\n        }\n        var psd = promise._PSD;\n        --psd.ref || psd.finalize();\n        if (numScheduledCalls === 0) {\n            ++numScheduledCalls;\n            asap(function () {\n                if (--numScheduledCalls === 0)\n                    finalizePhysicalTick();\n            }, []);\n        }\n    }\n    function propagateToListener(promise, listener) {\n        if (promise._state === null) {\n            promise._listeners.push(listener);\n            return;\n        }\n        var cb = promise._state ? listener.onFulfilled : listener.onRejected;\n        if (cb === null) {\n            return (promise._state ? listener.resolve : listener.reject)(promise._value);\n        }\n        ++listener.psd.ref;\n        ++numScheduledCalls;\n        asap(callListener, [cb, promise, listener]);\n    }\n    function callListener(cb, promise, listener) {\n        try {\n            var ret, value = promise._value;\n            if (!promise._state && rejectingErrors.length)\n                rejectingErrors = [];\n            ret = debug && promise._consoleTask ? promise._consoleTask.run(function () { return cb(value); }) : cb(value);\n            if (!promise._state && rejectingErrors.indexOf(value) === -1) {\n                markErrorAsHandled(promise);\n            }\n            listener.resolve(ret);\n        }\n        catch (e) {\n            listener.reject(e);\n        }\n        finally {\n            if (--numScheduledCalls === 0)\n                finalizePhysicalTick();\n            --listener.psd.ref || listener.psd.finalize();\n        }\n    }\n    function physicalTick() {\n        usePSD(globalPSD, function () {\n            beginMicroTickScope() && endMicroTickScope();\n        });\n    }\n    function beginMicroTickScope() {\n        var wasRootExec = isOutsideMicroTick;\n        isOutsideMicroTick = false;\n        needsNewPhysicalTick = false;\n        return wasRootExec;\n    }\n    function endMicroTickScope() {\n        var callbacks, i, l;\n        do {\n            while (microtickQueue.length > 0) {\n                callbacks = microtickQueue;\n                microtickQueue = [];\n                l = callbacks.length;\n                for (i = 0; i < l; ++i) {\n                    var item = callbacks[i];\n                    item[0].apply(null, item[1]);\n                }\n            }\n        } while (microtickQueue.length > 0);\n        isOutsideMicroTick = true;\n        needsNewPhysicalTick = true;\n    }\n    function finalizePhysicalTick() {\n        var unhandledErrs = unhandledErrors;\n        unhandledErrors = [];\n        unhandledErrs.forEach(function (p) {\n            p._PSD.onunhandled.call(null, p._value, p);\n        });\n        var finalizers = tickFinalizers.slice(0);\n        var i = finalizers.length;\n        while (i)\n            finalizers[--i]();\n    }\n    function run_at_end_of_this_or_next_physical_tick(fn) {\n        function finalizer() {\n            fn();\n            tickFinalizers.splice(tickFinalizers.indexOf(finalizer), 1);\n        }\n        tickFinalizers.push(finalizer);\n        ++numScheduledCalls;\n        asap(function () {\n            if (--numScheduledCalls === 0)\n                finalizePhysicalTick();\n        }, []);\n    }\n    function addPossiblyUnhandledError(promise) {\n        if (!unhandledErrors.some(function (p) { return p._value === promise._value; }))\n            unhandledErrors.push(promise);\n    }\n    function markErrorAsHandled(promise) {\n        var i = unhandledErrors.length;\n        while (i)\n            if (unhandledErrors[--i]._value === promise._value) {\n                unhandledErrors.splice(i, 1);\n                return;\n            }\n    }\n    function PromiseReject(reason) {\n        return new DexiePromise(INTERNAL, false, reason);\n    }\n    function wrap(fn, errorCatcher) {\n        var psd = PSD;\n        return function () {\n            var wasRootExec = beginMicroTickScope(), outerScope = PSD;\n            try {\n                switchToZone(psd, true);\n                return fn.apply(this, arguments);\n            }\n            catch (e) {\n                errorCatcher && errorCatcher(e);\n            }\n            finally {\n                switchToZone(outerScope, false);\n                if (wasRootExec)\n                    endMicroTickScope();\n            }\n        };\n    }\n    var task = { awaits: 0, echoes: 0, id: 0 };\n    var taskCounter = 0;\n    var zoneStack = [];\n    var zoneEchoes = 0;\n    var totalEchoes = 0;\n    var zone_id_counter = 0;\n    function newScope(fn, props, a1, a2) {\n        var parent = PSD, psd = Object.create(parent);\n        psd.parent = parent;\n        psd.ref = 0;\n        psd.global = false;\n        psd.id = ++zone_id_counter;\n        globalPSD.env;\n        psd.env = patchGlobalPromise ? {\n            Promise: DexiePromise,\n            PromiseProp: { value: DexiePromise, configurable: true, writable: true },\n            all: DexiePromise.all,\n            race: DexiePromise.race,\n            allSettled: DexiePromise.allSettled,\n            any: DexiePromise.any,\n            resolve: DexiePromise.resolve,\n            reject: DexiePromise.reject,\n        } : {};\n        if (props)\n            extend(psd, props);\n        ++parent.ref;\n        psd.finalize = function () {\n            --this.parent.ref || this.parent.finalize();\n        };\n        var rv = usePSD(psd, fn, a1, a2);\n        if (psd.ref === 0)\n            psd.finalize();\n        return rv;\n    }\n    function incrementExpectedAwaits() {\n        if (!task.id)\n            task.id = ++taskCounter;\n        ++task.awaits;\n        task.echoes += ZONE_ECHO_LIMIT;\n        return task.id;\n    }\n    function decrementExpectedAwaits() {\n        if (!task.awaits)\n            return false;\n        if (--task.awaits === 0)\n            task.id = 0;\n        task.echoes = task.awaits * ZONE_ECHO_LIMIT;\n        return true;\n    }\n    if (('' + nativePromiseThen).indexOf('[native code]') === -1) {\n        incrementExpectedAwaits = decrementExpectedAwaits = nop;\n    }\n    function onPossibleParallellAsync(possiblePromise) {\n        if (task.echoes && possiblePromise && possiblePromise.constructor === NativePromise) {\n            incrementExpectedAwaits();\n            return possiblePromise.then(function (x) {\n                decrementExpectedAwaits();\n                return x;\n            }, function (e) {\n                decrementExpectedAwaits();\n                return rejection(e);\n            });\n        }\n        return possiblePromise;\n    }\n    function zoneEnterEcho(targetZone) {\n        ++totalEchoes;\n        if (!task.echoes || --task.echoes === 0) {\n            task.echoes = task.awaits = task.id = 0;\n        }\n        zoneStack.push(PSD);\n        switchToZone(targetZone, true);\n    }\n    function zoneLeaveEcho() {\n        var zone = zoneStack[zoneStack.length - 1];\n        zoneStack.pop();\n        switchToZone(zone, false);\n    }\n    function switchToZone(targetZone, bEnteringZone) {\n        var currentZone = PSD;\n        if (bEnteringZone ? task.echoes && (!zoneEchoes++ || targetZone !== PSD) : zoneEchoes && (!--zoneEchoes || targetZone !== PSD)) {\n            queueMicrotask(bEnteringZone ? zoneEnterEcho.bind(null, targetZone) : zoneLeaveEcho);\n        }\n        if (targetZone === PSD)\n            return;\n        PSD = targetZone;\n        if (currentZone === globalPSD)\n            globalPSD.env = snapShot();\n        if (patchGlobalPromise) {\n            var GlobalPromise = globalPSD.env.Promise;\n            var targetEnv = targetZone.env;\n            if (currentZone.global || targetZone.global) {\n                Object.defineProperty(_global, 'Promise', targetEnv.PromiseProp);\n                GlobalPromise.all = targetEnv.all;\n                GlobalPromise.race = targetEnv.race;\n                GlobalPromise.resolve = targetEnv.resolve;\n                GlobalPromise.reject = targetEnv.reject;\n                if (targetEnv.allSettled)\n                    GlobalPromise.allSettled = targetEnv.allSettled;\n                if (targetEnv.any)\n                    GlobalPromise.any = targetEnv.any;\n            }\n        }\n    }\n    function snapShot() {\n        var GlobalPromise = _global.Promise;\n        return patchGlobalPromise ? {\n            Promise: GlobalPromise,\n            PromiseProp: Object.getOwnPropertyDescriptor(_global, \"Promise\"),\n            all: GlobalPromise.all,\n            race: GlobalPromise.race,\n            allSettled: GlobalPromise.allSettled,\n            any: GlobalPromise.any,\n            resolve: GlobalPromise.resolve,\n            reject: GlobalPromise.reject,\n        } : {};\n    }\n    function usePSD(psd, fn, a1, a2, a3) {\n        var outerScope = PSD;\n        try {\n            switchToZone(psd, true);\n            return fn(a1, a2, a3);\n        }\n        finally {\n            switchToZone(outerScope, false);\n        }\n    }\n    function nativeAwaitCompatibleWrap(fn, zone, possibleAwait, cleanup) {\n        return typeof fn !== 'function' ? fn : function () {\n            var outerZone = PSD;\n            if (possibleAwait)\n                incrementExpectedAwaits();\n            switchToZone(zone, true);\n            try {\n                return fn.apply(this, arguments);\n            }\n            finally {\n                switchToZone(outerZone, false);\n                if (cleanup)\n                    queueMicrotask(decrementExpectedAwaits);\n            }\n        };\n    }\n    function execInGlobalContext(cb) {\n        if (Promise === NativePromise && task.echoes === 0) {\n            if (zoneEchoes === 0) {\n                cb();\n            }\n            else {\n                enqueueNativeMicroTask(cb);\n            }\n        }\n        else {\n            setTimeout(cb, 0);\n        }\n    }\n    var rejection = DexiePromise.reject;\n\n    function tempTransaction(db, mode, storeNames, fn) {\n        if (!db.idbdb || (!db._state.openComplete && (!PSD.letThrough && !db._vip))) {\n            if (db._state.openComplete) {\n                return rejection(new exceptions.DatabaseClosed(db._state.dbOpenError));\n            }\n            if (!db._state.isBeingOpened) {\n                if (!db._state.autoOpen)\n                    return rejection(new exceptions.DatabaseClosed());\n                db.open().catch(nop);\n            }\n            return db._state.dbReadyPromise.then(function () { return tempTransaction(db, mode, storeNames, fn); });\n        }\n        else {\n            var trans = db._createTransaction(mode, storeNames, db._dbSchema);\n            try {\n                trans.create();\n                db._state.PR1398_maxLoop = 3;\n            }\n            catch (ex) {\n                if (ex.name === errnames.InvalidState && db.isOpen() && --db._state.PR1398_maxLoop > 0) {\n                    console.warn('Dexie: Need to reopen db');\n                    db.close({ disableAutoOpen: false });\n                    return db.open().then(function () { return tempTransaction(db, mode, storeNames, fn); });\n                }\n                return rejection(ex);\n            }\n            return trans._promise(mode, function (resolve, reject) {\n                return newScope(function () {\n                    PSD.trans = trans;\n                    return fn(resolve, reject, trans);\n                });\n            }).then(function (result) {\n                if (mode === 'readwrite')\n                    try {\n                        trans.idbtrans.commit();\n                    }\n                    catch (_a) { }\n                return mode === 'readonly' ? result : trans._completion.then(function () { return result; });\n            });\n        }\n    }\n\n    var DEXIE_VERSION = '4.2.0';\n    var maxString = String.fromCharCode(65535);\n    var minKey = -Infinity;\n    var INVALID_KEY_ARGUMENT = \"Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.\";\n    var STRING_EXPECTED = \"String expected.\";\n    var connections = [];\n    var DBNAMES_DB = '__dbnames';\n    var READONLY = 'readonly';\n    var READWRITE = 'readwrite';\n\n    function combine(filter1, filter2) {\n        return filter1 ?\n            filter2 ?\n                function () { return filter1.apply(this, arguments) && filter2.apply(this, arguments); } :\n                filter1 :\n            filter2;\n    }\n\n    var AnyRange = {\n        type: 3 ,\n        lower: -Infinity,\n        lowerOpen: false,\n        upper: [[]],\n        upperOpen: false\n    };\n\n    function workaroundForUndefinedPrimKey(keyPath) {\n        return typeof keyPath === \"string\" && !/\\./.test(keyPath)\n            ? function (obj) {\n                if (obj[keyPath] === undefined && (keyPath in obj)) {\n                    obj = deepClone(obj);\n                    delete obj[keyPath];\n                }\n                return obj;\n            }\n            : function (obj) { return obj; };\n    }\n\n    function Entity() {\n        throw exceptions.Type(\"Entity instances must never be new:ed. Instances are generated by the framework bypassing the constructor.\");\n    }\n\n    function cmp(a, b) {\n        try {\n            var ta = type(a);\n            var tb = type(b);\n            if (ta !== tb) {\n                if (ta === 'Array')\n                    return 1;\n                if (tb === 'Array')\n                    return -1;\n                if (ta === 'binary')\n                    return 1;\n                if (tb === 'binary')\n                    return -1;\n                if (ta === 'string')\n                    return 1;\n                if (tb === 'string')\n                    return -1;\n                if (ta === 'Date')\n                    return 1;\n                if (tb !== 'Date')\n                    return NaN;\n                return -1;\n            }\n            switch (ta) {\n                case 'number':\n                case 'Date':\n                case 'string':\n                    return a > b ? 1 : a < b ? -1 : 0;\n                case 'binary': {\n                    return compareUint8Arrays(getUint8Array(a), getUint8Array(b));\n                }\n                case 'Array':\n                    return compareArrays(a, b);\n            }\n        }\n        catch (_a) { }\n        return NaN;\n    }\n    function compareArrays(a, b) {\n        var al = a.length;\n        var bl = b.length;\n        var l = al < bl ? al : bl;\n        for (var i = 0; i < l; ++i) {\n            var res = cmp(a[i], b[i]);\n            if (res !== 0)\n                return res;\n        }\n        return al === bl ? 0 : al < bl ? -1 : 1;\n    }\n    function compareUint8Arrays(a, b) {\n        var al = a.length;\n        var bl = b.length;\n        var l = al < bl ? al : bl;\n        for (var i = 0; i < l; ++i) {\n            if (a[i] !== b[i])\n                return a[i] < b[i] ? -1 : 1;\n        }\n        return al === bl ? 0 : al < bl ? -1 : 1;\n    }\n    function type(x) {\n        var t = typeof x;\n        if (t !== 'object')\n            return t;\n        if (ArrayBuffer.isView(x))\n            return 'binary';\n        var tsTag = toStringTag(x);\n        return tsTag === 'ArrayBuffer' ? 'binary' : tsTag;\n    }\n    function getUint8Array(a) {\n        if (a instanceof Uint8Array)\n            return a;\n        if (ArrayBuffer.isView(a))\n            return new Uint8Array(a.buffer, a.byteOffset, a.byteLength);\n        return new Uint8Array(a);\n    }\n\n    function builtInDeletionTrigger(table, keys, res) {\n        var yProps = table.schema.yProps;\n        if (!yProps)\n            return res;\n        if (keys && res.numFailures > 0)\n            keys = keys.filter(function (_, i) { return !res.failures[i]; });\n        return Promise.all(yProps.map(function (_a) {\n            var updatesTable = _a.updatesTable;\n            return keys\n                ? table.db.table(updatesTable).where('k').anyOf(keys).delete()\n                : table.db.table(updatesTable).clear();\n        })).then(function () { return res; });\n    }\n\n    var Table =  (function () {\n        function Table() {\n        }\n        Table.prototype._trans = function (mode, fn, writeLocked) {\n            var trans = this._tx || PSD.trans;\n            var tableName = this.name;\n            var task = debug && typeof console !== 'undefined' && console.createTask && console.createTask(\"Dexie: \".concat(mode === 'readonly' ? 'read' : 'write', \" \").concat(this.name));\n            function checkTableInTransaction(resolve, reject, trans) {\n                if (!trans.schema[tableName])\n                    throw new exceptions.NotFound(\"Table \" + tableName + \" not part of transaction\");\n                return fn(trans.idbtrans, trans);\n            }\n            var wasRootExec = beginMicroTickScope();\n            try {\n                var p = trans && trans.db._novip === this.db._novip ?\n                    trans === PSD.trans ?\n                        trans._promise(mode, checkTableInTransaction, writeLocked) :\n                        newScope(function () { return trans._promise(mode, checkTableInTransaction, writeLocked); }, { trans: trans, transless: PSD.transless || PSD }) :\n                    tempTransaction(this.db, mode, [this.name], checkTableInTransaction);\n                if (task) {\n                    p._consoleTask = task;\n                    p = p.catch(function (err) {\n                        console.trace(err);\n                        return rejection(err);\n                    });\n                }\n                return p;\n            }\n            finally {\n                if (wasRootExec)\n                    endMicroTickScope();\n            }\n        };\n        Table.prototype.get = function (keyOrCrit, cb) {\n            var _this = this;\n            if (keyOrCrit && keyOrCrit.constructor === Object)\n                return this.where(keyOrCrit).first(cb);\n            if (keyOrCrit == null)\n                return rejection(new exceptions.Type(\"Invalid argument to Table.get()\"));\n            return this._trans('readonly', function (trans) {\n                return _this.core.get({ trans: trans, key: keyOrCrit })\n                    .then(function (res) { return _this.hook.reading.fire(res); });\n            }).then(cb);\n        };\n        Table.prototype.where = function (indexOrCrit) {\n            if (typeof indexOrCrit === 'string')\n                return new this.db.WhereClause(this, indexOrCrit);\n            if (isArray(indexOrCrit))\n                return new this.db.WhereClause(this, \"[\".concat(indexOrCrit.join('+'), \"]\"));\n            var keyPaths = keys(indexOrCrit);\n            if (keyPaths.length === 1)\n                return this\n                    .where(keyPaths[0])\n                    .equals(indexOrCrit[keyPaths[0]]);\n            var compoundIndex = this.schema.indexes.concat(this.schema.primKey).filter(function (ix) {\n                if (ix.compound &&\n                    keyPaths.every(function (keyPath) { return ix.keyPath.indexOf(keyPath) >= 0; })) {\n                    for (var i = 0; i < keyPaths.length; ++i) {\n                        if (keyPaths.indexOf(ix.keyPath[i]) === -1)\n                            return false;\n                    }\n                    return true;\n                }\n                return false;\n            }).sort(function (a, b) { return a.keyPath.length - b.keyPath.length; })[0];\n            if (compoundIndex && this.db._maxKey !== maxString) {\n                var keyPathsInValidOrder = compoundIndex.keyPath.slice(0, keyPaths.length);\n                return this\n                    .where(keyPathsInValidOrder)\n                    .equals(keyPathsInValidOrder.map(function (kp) { return indexOrCrit[kp]; }));\n            }\n            if (!compoundIndex && debug)\n                console.warn(\"The query \".concat(JSON.stringify(indexOrCrit), \" on \").concat(this.name, \" would benefit from a \") +\n                    \"compound index [\".concat(keyPaths.join('+'), \"]\"));\n            var idxByName = this.schema.idxByName;\n            function equals(a, b) {\n                return cmp(a, b) === 0;\n            }\n            var _a = keyPaths.reduce(function (_a, keyPath) {\n                var prevIndex = _a[0], prevFilterFn = _a[1];\n                var index = idxByName[keyPath];\n                var value = indexOrCrit[keyPath];\n                return [\n                    prevIndex || index,\n                    prevIndex || !index ?\n                        combine(prevFilterFn, index && index.multi ?\n                            function (x) {\n                                var prop = getByKeyPath(x, keyPath);\n                                return isArray(prop) && prop.some(function (item) { return equals(value, item); });\n                            } : function (x) { return equals(value, getByKeyPath(x, keyPath)); })\n                        : prevFilterFn\n                ];\n            }, [null, null]), idx = _a[0], filterFunction = _a[1];\n            return idx ?\n                this.where(idx.name).equals(indexOrCrit[idx.keyPath])\n                    .filter(filterFunction) :\n                compoundIndex ?\n                    this.filter(filterFunction) :\n                    this.where(keyPaths).equals('');\n        };\n        Table.prototype.filter = function (filterFunction) {\n            return this.toCollection().and(filterFunction);\n        };\n        Table.prototype.count = function (thenShortcut) {\n            return this.toCollection().count(thenShortcut);\n        };\n        Table.prototype.offset = function (offset) {\n            return this.toCollection().offset(offset);\n        };\n        Table.prototype.limit = function (numRows) {\n            return this.toCollection().limit(numRows);\n        };\n        Table.prototype.each = function (callback) {\n            return this.toCollection().each(callback);\n        };\n        Table.prototype.toArray = function (thenShortcut) {\n            return this.toCollection().toArray(thenShortcut);\n        };\n        Table.prototype.toCollection = function () {\n            return new this.db.Collection(new this.db.WhereClause(this));\n        };\n        Table.prototype.orderBy = function (index) {\n            return new this.db.Collection(new this.db.WhereClause(this, isArray(index) ?\n                \"[\".concat(index.join('+'), \"]\") :\n                index));\n        };\n        Table.prototype.reverse = function () {\n            return this.toCollection().reverse();\n        };\n        Table.prototype.mapToClass = function (constructor) {\n            var _a = this, db = _a.db, tableName = _a.name;\n            this.schema.mappedClass = constructor;\n            if (constructor.prototype instanceof Entity) {\n                constructor =  (function (_super) {\n                    __extends(class_1, _super);\n                    function class_1() {\n                        return _super !== null && _super.apply(this, arguments) || this;\n                    }\n                    Object.defineProperty(class_1.prototype, \"db\", {\n                        get: function () { return db; },\n                        enumerable: false,\n                        configurable: true\n                    });\n                    class_1.prototype.table = function () { return tableName; };\n                    return class_1;\n                }(constructor));\n            }\n            var inheritedProps = new Set();\n            for (var proto = constructor.prototype; proto; proto = getProto(proto)) {\n                Object.getOwnPropertyNames(proto).forEach(function (propName) { return inheritedProps.add(propName); });\n            }\n            var readHook = function (obj) {\n                if (!obj)\n                    return obj;\n                var res = Object.create(constructor.prototype);\n                for (var m in obj)\n                    if (!inheritedProps.has(m))\n                        try {\n                            res[m] = obj[m];\n                        }\n                        catch (_) { }\n                return res;\n            };\n            if (this.schema.readHook) {\n                this.hook.reading.unsubscribe(this.schema.readHook);\n            }\n            this.schema.readHook = readHook;\n            this.hook(\"reading\", readHook);\n            return constructor;\n        };\n        Table.prototype.defineClass = function () {\n            function Class(content) {\n                extend(this, content);\n            }\n            return this.mapToClass(Class);\n        };\n        Table.prototype.add = function (obj, key) {\n            var _this = this;\n            var _a = this.schema.primKey, auto = _a.auto, keyPath = _a.keyPath;\n            var objToAdd = obj;\n            if (keyPath && auto) {\n                objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);\n            }\n            return this._trans('readwrite', function (trans) {\n                return _this.core.mutate({ trans: trans, type: 'add', keys: key != null ? [key] : null, values: [objToAdd] });\n            }).then(function (res) { return res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult; })\n                .then(function (lastResult) {\n                if (keyPath) {\n                    try {\n                        setByKeyPath(obj, keyPath, lastResult);\n                    }\n                    catch (_) { }\n                }\n                return lastResult;\n            });\n        };\n        Table.prototype.update = function (keyOrObject, modifications) {\n            if (typeof keyOrObject === 'object' && !isArray(keyOrObject)) {\n                var key = getByKeyPath(keyOrObject, this.schema.primKey.keyPath);\n                if (key === undefined)\n                    return rejection(new exceptions.InvalidArgument(\"Given object does not contain its primary key\"));\n                return this.where(\":id\").equals(key).modify(modifications);\n            }\n            else {\n                return this.where(\":id\").equals(keyOrObject).modify(modifications);\n            }\n        };\n        Table.prototype.put = function (obj, key) {\n            var _this = this;\n            var _a = this.schema.primKey, auto = _a.auto, keyPath = _a.keyPath;\n            var objToAdd = obj;\n            if (keyPath && auto) {\n                objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);\n            }\n            return this._trans('readwrite', function (trans) { return _this.core.mutate({ trans: trans, type: 'put', values: [objToAdd], keys: key != null ? [key] : null }); })\n                .then(function (res) { return res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult; })\n                .then(function (lastResult) {\n                if (keyPath) {\n                    try {\n                        setByKeyPath(obj, keyPath, lastResult);\n                    }\n                    catch (_) { }\n                }\n                return lastResult;\n            });\n        };\n        Table.prototype.delete = function (key) {\n            var _this = this;\n            return this._trans('readwrite', function (trans) { return _this.core.mutate({ trans: trans, type: 'delete', keys: [key] })\n                .then(function (res) { return builtInDeletionTrigger(_this, [key], res); })\n                .then(function (res) { return res.numFailures ? DexiePromise.reject(res.failures[0]) : undefined; }); });\n        };\n        Table.prototype.clear = function () {\n            var _this = this;\n            return this._trans('readwrite', function (trans) { return _this.core.mutate({ trans: trans, type: 'deleteRange', range: AnyRange })\n                .then(function (res) { return builtInDeletionTrigger(_this, null, res); }); })\n                .then(function (res) { return res.numFailures ? DexiePromise.reject(res.failures[0]) : undefined; });\n        };\n        Table.prototype.bulkGet = function (keys) {\n            var _this = this;\n            return this._trans('readonly', function (trans) {\n                return _this.core.getMany({\n                    keys: keys,\n                    trans: trans\n                }).then(function (result) { return result.map(function (res) { return _this.hook.reading.fire(res); }); });\n            });\n        };\n        Table.prototype.bulkAdd = function (objects, keysOrOptions, options) {\n            var _this = this;\n            var keys = Array.isArray(keysOrOptions) ? keysOrOptions : undefined;\n            options = options || (keys ? undefined : keysOrOptions);\n            var wantResults = options ? options.allKeys : undefined;\n            return this._trans('readwrite', function (trans) {\n                var _a = _this.schema.primKey, auto = _a.auto, keyPath = _a.keyPath;\n                if (keyPath && keys)\n                    throw new exceptions.InvalidArgument(\"bulkAdd(): keys argument invalid on tables with inbound keys\");\n                if (keys && keys.length !== objects.length)\n                    throw new exceptions.InvalidArgument(\"Arguments objects and keys must have the same length\");\n                var numObjects = objects.length;\n                var objectsToAdd = keyPath && auto ?\n                    objects.map(workaroundForUndefinedPrimKey(keyPath)) :\n                    objects;\n                return _this.core.mutate({ trans: trans, type: 'add', keys: keys, values: objectsToAdd, wantResults: wantResults })\n                    .then(function (_a) {\n                    var numFailures = _a.numFailures, results = _a.results, lastResult = _a.lastResult, failures = _a.failures;\n                    var result = wantResults ? results : lastResult;\n                    if (numFailures === 0)\n                        return result;\n                    throw new BulkError(\"\".concat(_this.name, \".bulkAdd(): \").concat(numFailures, \" of \").concat(numObjects, \" operations failed\"), failures);\n                });\n            });\n        };\n        Table.prototype.bulkPut = function (objects, keysOrOptions, options) {\n            var _this = this;\n            var keys = Array.isArray(keysOrOptions) ? keysOrOptions : undefined;\n            options = options || (keys ? undefined : keysOrOptions);\n            var wantResults = options ? options.allKeys : undefined;\n            return this._trans('readwrite', function (trans) {\n                var _a = _this.schema.primKey, auto = _a.auto, keyPath = _a.keyPath;\n                if (keyPath && keys)\n                    throw new exceptions.InvalidArgument(\"bulkPut(): keys argument invalid on tables with inbound keys\");\n                if (keys && keys.length !== objects.length)\n                    throw new exceptions.InvalidArgument(\"Arguments objects and keys must have the same length\");\n                var numObjects = objects.length;\n                var objectsToPut = keyPath && auto ?\n                    objects.map(workaroundForUndefinedPrimKey(keyPath)) :\n                    objects;\n                return _this.core.mutate({ trans: trans, type: 'put', keys: keys, values: objectsToPut, wantResults: wantResults })\n                    .then(function (_a) {\n                    var numFailures = _a.numFailures, results = _a.results, lastResult = _a.lastResult, failures = _a.failures;\n                    var result = wantResults ? results : lastResult;\n                    if (numFailures === 0)\n                        return result;\n                    throw new BulkError(\"\".concat(_this.name, \".bulkPut(): \").concat(numFailures, \" of \").concat(numObjects, \" operations failed\"), failures);\n                });\n            });\n        };\n        Table.prototype.bulkUpdate = function (keysAndChanges) {\n            var _this = this;\n            var coreTable = this.core;\n            var keys = keysAndChanges.map(function (entry) { return entry.key; });\n            var changeSpecs = keysAndChanges.map(function (entry) { return entry.changes; });\n            var offsetMap = [];\n            return this._trans('readwrite', function (trans) {\n                return coreTable.getMany({ trans: trans, keys: keys, cache: 'clone' }).then(function (objs) {\n                    var resultKeys = [];\n                    var resultObjs = [];\n                    keysAndChanges.forEach(function (_a, idx) {\n                        var key = _a.key, changes = _a.changes;\n                        var obj = objs[idx];\n                        if (obj) {\n                            for (var _i = 0, _b = Object.keys(changes); _i < _b.length; _i++) {\n                                var keyPath = _b[_i];\n                                var value = changes[keyPath];\n                                if (keyPath === _this.schema.primKey.keyPath) {\n                                    if (cmp(value, key) !== 0) {\n                                        throw new exceptions.Constraint(\"Cannot update primary key in bulkUpdate()\");\n                                    }\n                                }\n                                else {\n                                    setByKeyPath(obj, keyPath, value);\n                                }\n                            }\n                            offsetMap.push(idx);\n                            resultKeys.push(key);\n                            resultObjs.push(obj);\n                        }\n                    });\n                    var numEntries = resultKeys.length;\n                    return coreTable\n                        .mutate({\n                        trans: trans,\n                        type: 'put',\n                        keys: resultKeys,\n                        values: resultObjs,\n                        updates: {\n                            keys: keys,\n                            changeSpecs: changeSpecs\n                        }\n                    })\n                        .then(function (_a) {\n                        var numFailures = _a.numFailures, failures = _a.failures;\n                        if (numFailures === 0)\n                            return numEntries;\n                        for (var _i = 0, _b = Object.keys(failures); _i < _b.length; _i++) {\n                            var offset = _b[_i];\n                            var mappedOffset = offsetMap[Number(offset)];\n                            if (mappedOffset != null) {\n                                var failure = failures[offset];\n                                delete failures[offset];\n                                failures[mappedOffset] = failure;\n                            }\n                        }\n                        throw new BulkError(\"\".concat(_this.name, \".bulkUpdate(): \").concat(numFailures, \" of \").concat(numEntries, \" operations failed\"), failures);\n                    });\n                });\n            });\n        };\n        Table.prototype.bulkDelete = function (keys) {\n            var _this = this;\n            var numKeys = keys.length;\n            return this._trans('readwrite', function (trans) {\n                return _this.core.mutate({ trans: trans, type: 'delete', keys: keys })\n                    .then(function (res) { return builtInDeletionTrigger(_this, keys, res); });\n            }).then(function (_a) {\n                var numFailures = _a.numFailures, lastResult = _a.lastResult, failures = _a.failures;\n                if (numFailures === 0)\n                    return lastResult;\n                throw new BulkError(\"\".concat(_this.name, \".bulkDelete(): \").concat(numFailures, \" of \").concat(numKeys, \" operations failed\"), failures);\n            });\n        };\n        return Table;\n    }());\n\n    function Events(ctx) {\n        var evs = {};\n        var rv = function (eventName, subscriber) {\n            if (subscriber) {\n                var i = arguments.length, args = new Array(i - 1);\n                while (--i)\n                    args[i - 1] = arguments[i];\n                evs[eventName].subscribe.apply(null, args);\n                return ctx;\n            }\n            else if (typeof (eventName) === 'string') {\n                return evs[eventName];\n            }\n        };\n        rv.addEventType = add;\n        for (var i = 1, l = arguments.length; i < l; ++i) {\n            add(arguments[i]);\n        }\n        return rv;\n        function add(eventName, chainFunction, defaultFunction) {\n            if (typeof eventName === 'object')\n                return addConfiguredEvents(eventName);\n            if (!chainFunction)\n                chainFunction = reverseStoppableEventChain;\n            if (!defaultFunction)\n                defaultFunction = nop;\n            var context = {\n                subscribers: [],\n                fire: defaultFunction,\n                subscribe: function (cb) {\n                    if (context.subscribers.indexOf(cb) === -1) {\n                        context.subscribers.push(cb);\n                        context.fire = chainFunction(context.fire, cb);\n                    }\n                },\n                unsubscribe: function (cb) {\n                    context.subscribers = context.subscribers.filter(function (fn) { return fn !== cb; });\n                    context.fire = context.subscribers.reduce(chainFunction, defaultFunction);\n                }\n            };\n            evs[eventName] = rv[eventName] = context;\n            return context;\n        }\n        function addConfiguredEvents(cfg) {\n            keys(cfg).forEach(function (eventName) {\n                var args = cfg[eventName];\n                if (isArray(args)) {\n                    add(eventName, cfg[eventName][0], cfg[eventName][1]);\n                }\n                else if (args === 'asap') {\n                    var context = add(eventName, mirror, function fire() {\n                        var i = arguments.length, args = new Array(i);\n                        while (i--)\n                            args[i] = arguments[i];\n                        context.subscribers.forEach(function (fn) {\n                            asap$1(function fireEvent() {\n                                fn.apply(null, args);\n                            });\n                        });\n                    });\n                }\n                else\n                    throw new exceptions.InvalidArgument(\"Invalid event config\");\n            });\n        }\n    }\n\n    function makeClassConstructor(prototype, constructor) {\n        derive(constructor).from({ prototype: prototype });\n        return constructor;\n    }\n\n    function createTableConstructor(db) {\n        return makeClassConstructor(Table.prototype, function Table(name, tableSchema, trans) {\n            this.db = db;\n            this._tx = trans;\n            this.name = name;\n            this.schema = tableSchema;\n            this.hook = db._allTables[name] ? db._allTables[name].hook : Events(null, {\n                \"creating\": [hookCreatingChain, nop],\n                \"reading\": [pureFunctionChain, mirror],\n                \"updating\": [hookUpdatingChain, nop],\n                \"deleting\": [hookDeletingChain, nop]\n            });\n        });\n    }\n\n    function isPlainKeyRange(ctx, ignoreLimitFilter) {\n        return !(ctx.filter || ctx.algorithm || ctx.or) &&\n            (ignoreLimitFilter ? ctx.justLimit : !ctx.replayFilter);\n    }\n    function addFilter(ctx, fn) {\n        ctx.filter = combine(ctx.filter, fn);\n    }\n    function addReplayFilter(ctx, factory, isLimitFilter) {\n        var curr = ctx.replayFilter;\n        ctx.replayFilter = curr ? function () { return combine(curr(), factory()); } : factory;\n        ctx.justLimit = isLimitFilter && !curr;\n    }\n    function addMatchFilter(ctx, fn) {\n        ctx.isMatch = combine(ctx.isMatch, fn);\n    }\n    function getIndexOrStore(ctx, coreSchema) {\n        if (ctx.isPrimKey)\n            return coreSchema.primaryKey;\n        var index = coreSchema.getIndexByKeyPath(ctx.index);\n        if (!index)\n            throw new exceptions.Schema(\"KeyPath \" + ctx.index + \" on object store \" + coreSchema.name + \" is not indexed\");\n        return index;\n    }\n    function openCursor(ctx, coreTable, trans) {\n        var index = getIndexOrStore(ctx, coreTable.schema);\n        return coreTable.openCursor({\n            trans: trans,\n            values: !ctx.keysOnly,\n            reverse: ctx.dir === 'prev',\n            unique: !!ctx.unique,\n            query: {\n                index: index,\n                range: ctx.range\n            }\n        });\n    }\n    function iter(ctx, fn, coreTrans, coreTable) {\n        var filter = ctx.replayFilter ? combine(ctx.filter, ctx.replayFilter()) : ctx.filter;\n        if (!ctx.or) {\n            return iterate(openCursor(ctx, coreTable, coreTrans), combine(ctx.algorithm, filter), fn, !ctx.keysOnly && ctx.valueMapper);\n        }\n        else {\n            var set_1 = {};\n            var union = function (item, cursor, advance) {\n                if (!filter || filter(cursor, advance, function (result) { return cursor.stop(result); }, function (err) { return cursor.fail(err); })) {\n                    var primaryKey = cursor.primaryKey;\n                    var key = '' + primaryKey;\n                    if (key === '[object ArrayBuffer]')\n                        key = '' + new Uint8Array(primaryKey);\n                    if (!hasOwn(set_1, key)) {\n                        set_1[key] = true;\n                        fn(item, cursor, advance);\n                    }\n                }\n            };\n            return Promise.all([\n                ctx.or._iterate(union, coreTrans),\n                iterate(openCursor(ctx, coreTable, coreTrans), ctx.algorithm, union, !ctx.keysOnly && ctx.valueMapper)\n            ]);\n        }\n    }\n    function iterate(cursorPromise, filter, fn, valueMapper) {\n        var mappedFn = valueMapper ? function (x, c, a) { return fn(valueMapper(x), c, a); } : fn;\n        var wrappedFn = wrap(mappedFn);\n        return cursorPromise.then(function (cursor) {\n            if (cursor) {\n                return cursor.start(function () {\n                    var c = function () { return cursor.continue(); };\n                    if (!filter || filter(cursor, function (advancer) { return c = advancer; }, function (val) { cursor.stop(val); c = nop; }, function (e) { cursor.fail(e); c = nop; }))\n                        wrappedFn(cursor.value, cursor, function (advancer) { return c = advancer; });\n                    c();\n                });\n            }\n        });\n    }\n\n    var PropModification =  (function () {\n        function PropModification(spec) {\n            this[\"@@propmod\"] = spec;\n        }\n        PropModification.prototype.execute = function (value) {\n            var _a;\n            var spec = this[\"@@propmod\"];\n            if (spec.add !== undefined) {\n                var term = spec.add;\n                if (isArray(term)) {\n                    return __spreadArray(__spreadArray([], (isArray(value) ? value : []), true), term, true).sort();\n                }\n                if (typeof term === 'number')\n                    return (Number(value) || 0) + term;\n                if (typeof term === 'bigint') {\n                    try {\n                        return BigInt(value) + term;\n                    }\n                    catch (_b) {\n                        return BigInt(0) + term;\n                    }\n                }\n                throw new TypeError(\"Invalid term \".concat(term));\n            }\n            if (spec.remove !== undefined) {\n                var subtrahend_1 = spec.remove;\n                if (isArray(subtrahend_1)) {\n                    return isArray(value) ? value.filter(function (item) { return !subtrahend_1.includes(item); }).sort() : [];\n                }\n                if (typeof subtrahend_1 === 'number')\n                    return Number(value) - subtrahend_1;\n                if (typeof subtrahend_1 === 'bigint') {\n                    try {\n                        return BigInt(value) - subtrahend_1;\n                    }\n                    catch (_c) {\n                        return BigInt(0) - subtrahend_1;\n                    }\n                }\n                throw new TypeError(\"Invalid subtrahend \".concat(subtrahend_1));\n            }\n            var prefixToReplace = (_a = spec.replacePrefix) === null || _a === void 0 ? void 0 : _a[0];\n            if (prefixToReplace && typeof value === 'string' && value.startsWith(prefixToReplace)) {\n                return spec.replacePrefix[1] + value.substring(prefixToReplace.length);\n            }\n            return value;\n        };\n        return PropModification;\n    }());\n\n    var Collection =  (function () {\n        function Collection() {\n        }\n        Collection.prototype._read = function (fn, cb) {\n            var ctx = this._ctx;\n            return ctx.error ?\n                ctx.table._trans(null, rejection.bind(null, ctx.error)) :\n                ctx.table._trans('readonly', fn).then(cb);\n        };\n        Collection.prototype._write = function (fn) {\n            var ctx = this._ctx;\n            return ctx.error ?\n                ctx.table._trans(null, rejection.bind(null, ctx.error)) :\n                ctx.table._trans('readwrite', fn, \"locked\");\n        };\n        Collection.prototype._addAlgorithm = function (fn) {\n            var ctx = this._ctx;\n            ctx.algorithm = combine(ctx.algorithm, fn);\n        };\n        Collection.prototype._iterate = function (fn, coreTrans) {\n            return iter(this._ctx, fn, coreTrans, this._ctx.table.core);\n        };\n        Collection.prototype.clone = function (props) {\n            var rv = Object.create(this.constructor.prototype), ctx = Object.create(this._ctx);\n            if (props)\n                extend(ctx, props);\n            rv._ctx = ctx;\n            return rv;\n        };\n        Collection.prototype.raw = function () {\n            this._ctx.valueMapper = null;\n            return this;\n        };\n        Collection.prototype.each = function (fn) {\n            var ctx = this._ctx;\n            return this._read(function (trans) { return iter(ctx, fn, trans, ctx.table.core); });\n        };\n        Collection.prototype.count = function (cb) {\n            var _this = this;\n            return this._read(function (trans) {\n                var ctx = _this._ctx;\n                var coreTable = ctx.table.core;\n                if (isPlainKeyRange(ctx, true)) {\n                    return coreTable.count({\n                        trans: trans,\n                        query: {\n                            index: getIndexOrStore(ctx, coreTable.schema),\n                            range: ctx.range\n                        }\n                    }).then(function (count) { return Math.min(count, ctx.limit); });\n                }\n                else {\n                    var count = 0;\n                    return iter(ctx, function () { ++count; return false; }, trans, coreTable)\n                        .then(function () { return count; });\n                }\n            }).then(cb);\n        };\n        Collection.prototype.sortBy = function (keyPath, cb) {\n            var parts = keyPath.split('.').reverse(), lastPart = parts[0], lastIndex = parts.length - 1;\n            function getval(obj, i) {\n                if (i)\n                    return getval(obj[parts[i]], i - 1);\n                return obj[lastPart];\n            }\n            var order = this._ctx.dir === \"next\" ? 1 : -1;\n            function sorter(a, b) {\n                var aVal = getval(a, lastIndex), bVal = getval(b, lastIndex);\n                return cmp(aVal, bVal) * order;\n            }\n            return this.toArray(function (a) {\n                return a.sort(sorter);\n            }).then(cb);\n        };\n        Collection.prototype.toArray = function (cb) {\n            var _this = this;\n            return this._read(function (trans) {\n                var ctx = _this._ctx;\n                if (ctx.dir === 'next' && isPlainKeyRange(ctx, true) && ctx.limit > 0) {\n                    var valueMapper_1 = ctx.valueMapper;\n                    var index = getIndexOrStore(ctx, ctx.table.core.schema);\n                    return ctx.table.core.query({\n                        trans: trans,\n                        limit: ctx.limit,\n                        values: true,\n                        query: {\n                            index: index,\n                            range: ctx.range\n                        }\n                    }).then(function (_a) {\n                        var result = _a.result;\n                        return valueMapper_1 ? result.map(valueMapper_1) : result;\n                    });\n                }\n                else {\n                    var a_1 = [];\n                    return iter(ctx, function (item) { return a_1.push(item); }, trans, ctx.table.core).then(function () { return a_1; });\n                }\n            }, cb);\n        };\n        Collection.prototype.offset = function (offset) {\n            var ctx = this._ctx;\n            if (offset <= 0)\n                return this;\n            ctx.offset += offset;\n            if (isPlainKeyRange(ctx)) {\n                addReplayFilter(ctx, function () {\n                    var offsetLeft = offset;\n                    return function (cursor, advance) {\n                        if (offsetLeft === 0)\n                            return true;\n                        if (offsetLeft === 1) {\n                            --offsetLeft;\n                            return false;\n                        }\n                        advance(function () {\n                            cursor.advance(offsetLeft);\n                            offsetLeft = 0;\n                        });\n                        return false;\n                    };\n                });\n            }\n            else {\n                addReplayFilter(ctx, function () {\n                    var offsetLeft = offset;\n                    return function () { return (--offsetLeft < 0); };\n                });\n            }\n            return this;\n        };\n        Collection.prototype.limit = function (numRows) {\n            this._ctx.limit = Math.min(this._ctx.limit, numRows);\n            addReplayFilter(this._ctx, function () {\n                var rowsLeft = numRows;\n                return function (cursor, advance, resolve) {\n                    if (--rowsLeft <= 0)\n                        advance(resolve);\n                    return rowsLeft >= 0;\n                };\n            }, true);\n            return this;\n        };\n        Collection.prototype.until = function (filterFunction, bIncludeStopEntry) {\n            addFilter(this._ctx, function (cursor, advance, resolve) {\n                if (filterFunction(cursor.value)) {\n                    advance(resolve);\n                    return bIncludeStopEntry;\n                }\n                else {\n                    return true;\n                }\n            });\n            return this;\n        };\n        Collection.prototype.first = function (cb) {\n            return this.limit(1).toArray(function (a) { return a[0]; }).then(cb);\n        };\n        Collection.prototype.last = function (cb) {\n            return this.reverse().first(cb);\n        };\n        Collection.prototype.filter = function (filterFunction) {\n            addFilter(this._ctx, function (cursor) {\n                return filterFunction(cursor.value);\n            });\n            addMatchFilter(this._ctx, filterFunction);\n            return this;\n        };\n        Collection.prototype.and = function (filter) {\n            return this.filter(filter);\n        };\n        Collection.prototype.or = function (indexName) {\n            return new this.db.WhereClause(this._ctx.table, indexName, this);\n        };\n        Collection.prototype.reverse = function () {\n            this._ctx.dir = (this._ctx.dir === \"prev\" ? \"next\" : \"prev\");\n            if (this._ondirectionchange)\n                this._ondirectionchange(this._ctx.dir);\n            return this;\n        };\n        Collection.prototype.desc = function () {\n            return this.reverse();\n        };\n        Collection.prototype.eachKey = function (cb) {\n            var ctx = this._ctx;\n            ctx.keysOnly = !ctx.isMatch;\n            return this.each(function (val, cursor) { cb(cursor.key, cursor); });\n        };\n        Collection.prototype.eachUniqueKey = function (cb) {\n            this._ctx.unique = \"unique\";\n            return this.eachKey(cb);\n        };\n        Collection.prototype.eachPrimaryKey = function (cb) {\n            var ctx = this._ctx;\n            ctx.keysOnly = !ctx.isMatch;\n            return this.each(function (val, cursor) { cb(cursor.primaryKey, cursor); });\n        };\n        Collection.prototype.keys = function (cb) {\n            var ctx = this._ctx;\n            ctx.keysOnly = !ctx.isMatch;\n            var a = [];\n            return this.each(function (item, cursor) {\n                a.push(cursor.key);\n            }).then(function () {\n                return a;\n            }).then(cb);\n        };\n        Collection.prototype.primaryKeys = function (cb) {\n            var ctx = this._ctx;\n            if (ctx.dir === 'next' && isPlainKeyRange(ctx, true) && ctx.limit > 0) {\n                return this._read(function (trans) {\n                    var index = getIndexOrStore(ctx, ctx.table.core.schema);\n                    return ctx.table.core.query({\n                        trans: trans,\n                        values: false,\n                        limit: ctx.limit,\n                        query: {\n                            index: index,\n                            range: ctx.range\n                        }\n                    });\n                }).then(function (_a) {\n                    var result = _a.result;\n                    return result;\n                }).then(cb);\n            }\n            ctx.keysOnly = !ctx.isMatch;\n            var a = [];\n            return this.each(function (item, cursor) {\n                a.push(cursor.primaryKey);\n            }).then(function () {\n                return a;\n            }).then(cb);\n        };\n        Collection.prototype.uniqueKeys = function (cb) {\n            this._ctx.unique = \"unique\";\n            return this.keys(cb);\n        };\n        Collection.prototype.firstKey = function (cb) {\n            return this.limit(1).keys(function (a) { return a[0]; }).then(cb);\n        };\n        Collection.prototype.lastKey = function (cb) {\n            return this.reverse().firstKey(cb);\n        };\n        Collection.prototype.distinct = function () {\n            var ctx = this._ctx, idx = ctx.index && ctx.table.schema.idxByName[ctx.index];\n            if (!idx || !idx.multi)\n                return this;\n            var set = {};\n            addFilter(this._ctx, function (cursor) {\n                var strKey = cursor.primaryKey.toString();\n                var found = hasOwn(set, strKey);\n                set[strKey] = true;\n                return !found;\n            });\n            return this;\n        };\n        Collection.prototype.modify = function (changes) {\n            var _this = this;\n            var ctx = this._ctx;\n            return this._write(function (trans) {\n                var modifyer;\n                if (typeof changes === 'function') {\n                    modifyer = changes;\n                }\n                else {\n                    var keyPaths = keys(changes);\n                    var numKeys = keyPaths.length;\n                    modifyer = function (item) {\n                        var anythingModified = false;\n                        for (var i = 0; i < numKeys; ++i) {\n                            var keyPath = keyPaths[i];\n                            var val = changes[keyPath];\n                            var origVal = getByKeyPath(item, keyPath);\n                            if (val instanceof PropModification) {\n                                setByKeyPath(item, keyPath, val.execute(origVal));\n                                anythingModified = true;\n                            }\n                            else if (origVal !== val) {\n                                setByKeyPath(item, keyPath, val);\n                                anythingModified = true;\n                            }\n                        }\n                        return anythingModified;\n                    };\n                }\n                var coreTable = ctx.table.core;\n                var _a = coreTable.schema.primaryKey, outbound = _a.outbound, extractKey = _a.extractKey;\n                var limit = 200;\n                var modifyChunkSize = _this.db._options.modifyChunkSize;\n                if (modifyChunkSize) {\n                    if (typeof modifyChunkSize == 'object') {\n                        limit = modifyChunkSize[coreTable.name] || modifyChunkSize['*'] || 200;\n                    }\n                    else {\n                        limit = modifyChunkSize;\n                    }\n                }\n                var totalFailures = [];\n                var successCount = 0;\n                var failedKeys = [];\n                var applyMutateResult = function (expectedCount, res) {\n                    var failures = res.failures, numFailures = res.numFailures;\n                    successCount += expectedCount - numFailures;\n                    for (var _i = 0, _a = keys(failures); _i < _a.length; _i++) {\n                        var pos = _a[_i];\n                        totalFailures.push(failures[pos]);\n                    }\n                };\n                var isUnconditionalDelete = changes === deleteCallback;\n                return _this.clone().primaryKeys().then(function (keys) {\n                    var criteria = isPlainKeyRange(ctx) &&\n                        ctx.limit === Infinity &&\n                        (typeof changes !== 'function' || isUnconditionalDelete) && {\n                        index: ctx.index,\n                        range: ctx.range\n                    };\n                    var nextChunk = function (offset) {\n                        var count = Math.min(limit, keys.length - offset);\n                        var keysInChunk = keys.slice(offset, offset + count);\n                        return (isUnconditionalDelete ? Promise.resolve([]) : coreTable.getMany({\n                            trans: trans,\n                            keys: keysInChunk,\n                            cache: \"immutable\"\n                        })).then(function (values) {\n                            var addValues = [];\n                            var putValues = [];\n                            var putKeys = outbound ? [] : null;\n                            var deleteKeys = isUnconditionalDelete ? keysInChunk : [];\n                            if (!isUnconditionalDelete)\n                                for (var i = 0; i < count; ++i) {\n                                    var origValue = values[i];\n                                    var ctx_1 = {\n                                        value: deepClone(origValue),\n                                        primKey: keys[offset + i]\n                                    };\n                                    if (modifyer.call(ctx_1, ctx_1.value, ctx_1) !== false) {\n                                        if (ctx_1.value == null) {\n                                            deleteKeys.push(keys[offset + i]);\n                                        }\n                                        else if (!outbound && cmp(extractKey(origValue), extractKey(ctx_1.value)) !== 0) {\n                                            deleteKeys.push(keys[offset + i]);\n                                            addValues.push(ctx_1.value);\n                                        }\n                                        else {\n                                            putValues.push(ctx_1.value);\n                                            if (outbound)\n                                                putKeys.push(keys[offset + i]);\n                                        }\n                                    }\n                                }\n                            return Promise.resolve(addValues.length > 0 &&\n                                coreTable.mutate({ trans: trans, type: 'add', values: addValues })\n                                    .then(function (res) {\n                                    for (var pos in res.failures) {\n                                        deleteKeys.splice(parseInt(pos), 1);\n                                    }\n                                    applyMutateResult(addValues.length, res);\n                                })).then(function () { return (putValues.length > 0 || (criteria && typeof changes === 'object')) &&\n                                coreTable.mutate({\n                                    trans: trans,\n                                    type: 'put',\n                                    keys: putKeys,\n                                    values: putValues,\n                                    criteria: criteria,\n                                    changeSpec: typeof changes !== 'function'\n                                        && changes,\n                                    isAdditionalChunk: offset > 0\n                                }).then(function (res) { return applyMutateResult(putValues.length, res); }); }).then(function () { return (deleteKeys.length > 0 || (criteria && isUnconditionalDelete)) &&\n                                coreTable.mutate({\n                                    trans: trans,\n                                    type: 'delete',\n                                    keys: deleteKeys,\n                                    criteria: criteria,\n                                    isAdditionalChunk: offset > 0\n                                }).then(function (res) { return builtInDeletionTrigger(ctx.table, deleteKeys, res); })\n                                    .then(function (res) { return applyMutateResult(deleteKeys.length, res); }); }).then(function () {\n                                return keys.length > offset + count && nextChunk(offset + limit);\n                            });\n                        });\n                    };\n                    return nextChunk(0).then(function () {\n                        if (totalFailures.length > 0)\n                            throw new ModifyError(\"Error modifying one or more objects\", totalFailures, successCount, failedKeys);\n                        return keys.length;\n                    });\n                });\n            });\n        };\n        Collection.prototype.delete = function () {\n            var ctx = this._ctx, range = ctx.range;\n            if (isPlainKeyRange(ctx) &&\n                !ctx.table.schema.yProps &&\n                (ctx.isPrimKey || range.type === 3 ))\n             {\n                return this._write(function (trans) {\n                    var primaryKey = ctx.table.core.schema.primaryKey;\n                    var coreRange = range;\n                    return ctx.table.core.count({ trans: trans, query: { index: primaryKey, range: coreRange } }).then(function (count) {\n                        return ctx.table.core.mutate({ trans: trans, type: 'deleteRange', range: coreRange })\n                            .then(function (_a) {\n                            var failures = _a.failures, numFailures = _a.numFailures;\n                            if (numFailures)\n                                throw new ModifyError(\"Could not delete some values\", Object.keys(failures).map(function (pos) { return failures[pos]; }), count - numFailures);\n                            return count - numFailures;\n                        });\n                    });\n                });\n            }\n            return this.modify(deleteCallback);\n        };\n        return Collection;\n    }());\n    var deleteCallback = function (value, ctx) { return ctx.value = null; };\n\n    function createCollectionConstructor(db) {\n        return makeClassConstructor(Collection.prototype, function Collection(whereClause, keyRangeGenerator) {\n            this.db = db;\n            var keyRange = AnyRange, error = null;\n            if (keyRangeGenerator)\n                try {\n                    keyRange = keyRangeGenerator();\n                }\n                catch (ex) {\n                    error = ex;\n                }\n            var whereCtx = whereClause._ctx;\n            var table = whereCtx.table;\n            var readingHook = table.hook.reading.fire;\n            this._ctx = {\n                table: table,\n                index: whereCtx.index,\n                isPrimKey: (!whereCtx.index || (table.schema.primKey.keyPath && whereCtx.index === table.schema.primKey.name)),\n                range: keyRange,\n                keysOnly: false,\n                dir: \"next\",\n                unique: \"\",\n                algorithm: null,\n                filter: null,\n                replayFilter: null,\n                justLimit: true,\n                isMatch: null,\n                offset: 0,\n                limit: Infinity,\n                error: error,\n                or: whereCtx.or,\n                valueMapper: readingHook !== mirror ? readingHook : null\n            };\n        });\n    }\n\n    function simpleCompare(a, b) {\n        return a < b ? -1 : a === b ? 0 : 1;\n    }\n    function simpleCompareReverse(a, b) {\n        return a > b ? -1 : a === b ? 0 : 1;\n    }\n\n    function fail(collectionOrWhereClause, err, T) {\n        var collection = collectionOrWhereClause instanceof WhereClause ?\n            new collectionOrWhereClause.Collection(collectionOrWhereClause) :\n            collectionOrWhereClause;\n        collection._ctx.error = T ? new T(err) : new TypeError(err);\n        return collection;\n    }\n    function emptyCollection(whereClause) {\n        return new whereClause.Collection(whereClause, function () { return rangeEqual(\"\"); }).limit(0);\n    }\n    function upperFactory(dir) {\n        return dir === \"next\" ?\n            function (s) { return s.toUpperCase(); } :\n            function (s) { return s.toLowerCase(); };\n    }\n    function lowerFactory(dir) {\n        return dir === \"next\" ?\n            function (s) { return s.toLowerCase(); } :\n            function (s) { return s.toUpperCase(); };\n    }\n    function nextCasing(key, lowerKey, upperNeedle, lowerNeedle, cmp, dir) {\n        var length = Math.min(key.length, lowerNeedle.length);\n        var llp = -1;\n        for (var i = 0; i < length; ++i) {\n            var lwrKeyChar = lowerKey[i];\n            if (lwrKeyChar !== lowerNeedle[i]) {\n                if (cmp(key[i], upperNeedle[i]) < 0)\n                    return key.substr(0, i) + upperNeedle[i] + upperNeedle.substr(i + 1);\n                if (cmp(key[i], lowerNeedle[i]) < 0)\n                    return key.substr(0, i) + lowerNeedle[i] + upperNeedle.substr(i + 1);\n                if (llp >= 0)\n                    return key.substr(0, llp) + lowerKey[llp] + upperNeedle.substr(llp + 1);\n                return null;\n            }\n            if (cmp(key[i], lwrKeyChar) < 0)\n                llp = i;\n        }\n        if (length < lowerNeedle.length && dir === \"next\")\n            return key + upperNeedle.substr(key.length);\n        if (length < key.length && dir === \"prev\")\n            return key.substr(0, upperNeedle.length);\n        return (llp < 0 ? null : key.substr(0, llp) + lowerNeedle[llp] + upperNeedle.substr(llp + 1));\n    }\n    function addIgnoreCaseAlgorithm(whereClause, match, needles, suffix) {\n        var upper, lower, compare, upperNeedles, lowerNeedles, direction, nextKeySuffix, needlesLen = needles.length;\n        if (!needles.every(function (s) { return typeof s === 'string'; })) {\n            return fail(whereClause, STRING_EXPECTED);\n        }\n        function initDirection(dir) {\n            upper = upperFactory(dir);\n            lower = lowerFactory(dir);\n            compare = (dir === \"next\" ? simpleCompare : simpleCompareReverse);\n            var needleBounds = needles.map(function (needle) {\n                return { lower: lower(needle), upper: upper(needle) };\n            }).sort(function (a, b) {\n                return compare(a.lower, b.lower);\n            });\n            upperNeedles = needleBounds.map(function (nb) { return nb.upper; });\n            lowerNeedles = needleBounds.map(function (nb) { return nb.lower; });\n            direction = dir;\n            nextKeySuffix = (dir === \"next\" ? \"\" : suffix);\n        }\n        initDirection(\"next\");\n        var c = new whereClause.Collection(whereClause, function () { return createRange(upperNeedles[0], lowerNeedles[needlesLen - 1] + suffix); });\n        c._ondirectionchange = function (direction) {\n            initDirection(direction);\n        };\n        var firstPossibleNeedle = 0;\n        c._addAlgorithm(function (cursor, advance, resolve) {\n            var key = cursor.key;\n            if (typeof key !== 'string')\n                return false;\n            var lowerKey = lower(key);\n            if (match(lowerKey, lowerNeedles, firstPossibleNeedle)) {\n                return true;\n            }\n            else {\n                var lowestPossibleCasing = null;\n                for (var i = firstPossibleNeedle; i < needlesLen; ++i) {\n                    var casing = nextCasing(key, lowerKey, upperNeedles[i], lowerNeedles[i], compare, direction);\n                    if (casing === null && lowestPossibleCasing === null)\n                        firstPossibleNeedle = i + 1;\n                    else if (lowestPossibleCasing === null || compare(lowestPossibleCasing, casing) > 0) {\n                        lowestPossibleCasing = casing;\n                    }\n                }\n                if (lowestPossibleCasing !== null) {\n                    advance(function () { cursor.continue(lowestPossibleCasing + nextKeySuffix); });\n                }\n                else {\n                    advance(resolve);\n                }\n                return false;\n            }\n        });\n        return c;\n    }\n    function createRange(lower, upper, lowerOpen, upperOpen) {\n        return {\n            type: 2 ,\n            lower: lower,\n            upper: upper,\n            lowerOpen: lowerOpen,\n            upperOpen: upperOpen\n        };\n    }\n    function rangeEqual(value) {\n        return {\n            type: 1 ,\n            lower: value,\n            upper: value\n        };\n    }\n\n    var WhereClause =  (function () {\n        function WhereClause() {\n        }\n        Object.defineProperty(WhereClause.prototype, \"Collection\", {\n            get: function () {\n                return this._ctx.table.db.Collection;\n            },\n            enumerable: false,\n            configurable: true\n        });\n        WhereClause.prototype.between = function (lower, upper, includeLower, includeUpper) {\n            includeLower = includeLower !== false;\n            includeUpper = includeUpper === true;\n            try {\n                if ((this._cmp(lower, upper) > 0) ||\n                    (this._cmp(lower, upper) === 0 && (includeLower || includeUpper) && !(includeLower && includeUpper)))\n                    return emptyCollection(this);\n                return new this.Collection(this, function () { return createRange(lower, upper, !includeLower, !includeUpper); });\n            }\n            catch (e) {\n                return fail(this, INVALID_KEY_ARGUMENT);\n            }\n        };\n        WhereClause.prototype.equals = function (value) {\n            if (value == null)\n                return fail(this, INVALID_KEY_ARGUMENT);\n            return new this.Collection(this, function () { return rangeEqual(value); });\n        };\n        WhereClause.prototype.above = function (value) {\n            if (value == null)\n                return fail(this, INVALID_KEY_ARGUMENT);\n            return new this.Collection(this, function () { return createRange(value, undefined, true); });\n        };\n        WhereClause.prototype.aboveOrEqual = function (value) {\n            if (value == null)\n                return fail(this, INVALID_KEY_ARGUMENT);\n            return new this.Collection(this, function () { return createRange(value, undefined, false); });\n        };\n        WhereClause.prototype.below = function (value) {\n            if (value == null)\n                return fail(this, INVALID_KEY_ARGUMENT);\n            return new this.Collection(this, function () { return createRange(undefined, value, false, true); });\n        };\n        WhereClause.prototype.belowOrEqual = function (value) {\n            if (value == null)\n                return fail(this, INVALID_KEY_ARGUMENT);\n            return new this.Collection(this, function () { return createRange(undefined, value); });\n        };\n        WhereClause.prototype.startsWith = function (str) {\n            if (typeof str !== 'string')\n                return fail(this, STRING_EXPECTED);\n            return this.between(str, str + maxString, true, true);\n        };\n        WhereClause.prototype.startsWithIgnoreCase = function (str) {\n            if (str === \"\")\n                return this.startsWith(str);\n            return addIgnoreCaseAlgorithm(this, function (x, a) { return x.indexOf(a[0]) === 0; }, [str], maxString);\n        };\n        WhereClause.prototype.equalsIgnoreCase = function (str) {\n            return addIgnoreCaseAlgorithm(this, function (x, a) { return x === a[0]; }, [str], \"\");\n        };\n        WhereClause.prototype.anyOfIgnoreCase = function () {\n            var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n            if (set.length === 0)\n                return emptyCollection(this);\n            return addIgnoreCaseAlgorithm(this, function (x, a) { return a.indexOf(x) !== -1; }, set, \"\");\n        };\n        WhereClause.prototype.startsWithAnyOfIgnoreCase = function () {\n            var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n            if (set.length === 0)\n                return emptyCollection(this);\n            return addIgnoreCaseAlgorithm(this, function (x, a) { return a.some(function (n) { return x.indexOf(n) === 0; }); }, set, maxString);\n        };\n        WhereClause.prototype.anyOf = function () {\n            var _this = this;\n            var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n            var compare = this._cmp;\n            try {\n                set.sort(compare);\n            }\n            catch (e) {\n                return fail(this, INVALID_KEY_ARGUMENT);\n            }\n            if (set.length === 0)\n                return emptyCollection(this);\n            var c = new this.Collection(this, function () { return createRange(set[0], set[set.length - 1]); });\n            c._ondirectionchange = function (direction) {\n                compare = (direction === \"next\" ?\n                    _this._ascending :\n                    _this._descending);\n                set.sort(compare);\n            };\n            var i = 0;\n            c._addAlgorithm(function (cursor, advance, resolve) {\n                var key = cursor.key;\n                while (compare(key, set[i]) > 0) {\n                    ++i;\n                    if (i === set.length) {\n                        advance(resolve);\n                        return false;\n                    }\n                }\n                if (compare(key, set[i]) === 0) {\n                    return true;\n                }\n                else {\n                    advance(function () { cursor.continue(set[i]); });\n                    return false;\n                }\n            });\n            return c;\n        };\n        WhereClause.prototype.notEqual = function (value) {\n            return this.inAnyRange([[minKey, value], [value, this.db._maxKey]], { includeLowers: false, includeUppers: false });\n        };\n        WhereClause.prototype.noneOf = function () {\n            var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n            if (set.length === 0)\n                return new this.Collection(this);\n            try {\n                set.sort(this._ascending);\n            }\n            catch (e) {\n                return fail(this, INVALID_KEY_ARGUMENT);\n            }\n            var ranges = set.reduce(function (res, val) { return res ?\n                res.concat([[res[res.length - 1][1], val]]) :\n                [[minKey, val]]; }, null);\n            ranges.push([set[set.length - 1], this.db._maxKey]);\n            return this.inAnyRange(ranges, { includeLowers: false, includeUppers: false });\n        };\n        WhereClause.prototype.inAnyRange = function (ranges, options) {\n            var _this = this;\n            var cmp = this._cmp, ascending = this._ascending, descending = this._descending, min = this._min, max = this._max;\n            if (ranges.length === 0)\n                return emptyCollection(this);\n            if (!ranges.every(function (range) {\n                return range[0] !== undefined &&\n                    range[1] !== undefined &&\n                    ascending(range[0], range[1]) <= 0;\n            })) {\n                return fail(this, \"First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower\", exceptions.InvalidArgument);\n            }\n            var includeLowers = !options || options.includeLowers !== false;\n            var includeUppers = options && options.includeUppers === true;\n            function addRange(ranges, newRange) {\n                var i = 0, l = ranges.length;\n                for (; i < l; ++i) {\n                    var range = ranges[i];\n                    if (cmp(newRange[0], range[1]) < 0 && cmp(newRange[1], range[0]) > 0) {\n                        range[0] = min(range[0], newRange[0]);\n                        range[1] = max(range[1], newRange[1]);\n                        break;\n                    }\n                }\n                if (i === l)\n                    ranges.push(newRange);\n                return ranges;\n            }\n            var sortDirection = ascending;\n            function rangeSorter(a, b) { return sortDirection(a[0], b[0]); }\n            var set;\n            try {\n                set = ranges.reduce(addRange, []);\n                set.sort(rangeSorter);\n            }\n            catch (ex) {\n                return fail(this, INVALID_KEY_ARGUMENT);\n            }\n            var rangePos = 0;\n            var keyIsBeyondCurrentEntry = includeUppers ?\n                function (key) { return ascending(key, set[rangePos][1]) > 0; } :\n                function (key) { return ascending(key, set[rangePos][1]) >= 0; };\n            var keyIsBeforeCurrentEntry = includeLowers ?\n                function (key) { return descending(key, set[rangePos][0]) > 0; } :\n                function (key) { return descending(key, set[rangePos][0]) >= 0; };\n            function keyWithinCurrentRange(key) {\n                return !keyIsBeyondCurrentEntry(key) && !keyIsBeforeCurrentEntry(key);\n            }\n            var checkKey = keyIsBeyondCurrentEntry;\n            var c = new this.Collection(this, function () { return createRange(set[0][0], set[set.length - 1][1], !includeLowers, !includeUppers); });\n            c._ondirectionchange = function (direction) {\n                if (direction === \"next\") {\n                    checkKey = keyIsBeyondCurrentEntry;\n                    sortDirection = ascending;\n                }\n                else {\n                    checkKey = keyIsBeforeCurrentEntry;\n                    sortDirection = descending;\n                }\n                set.sort(rangeSorter);\n            };\n            c._addAlgorithm(function (cursor, advance, resolve) {\n                var key = cursor.key;\n                while (checkKey(key)) {\n                    ++rangePos;\n                    if (rangePos === set.length) {\n                        advance(resolve);\n                        return false;\n                    }\n                }\n                if (keyWithinCurrentRange(key)) {\n                    return true;\n                }\n                else if (_this._cmp(key, set[rangePos][1]) === 0 || _this._cmp(key, set[rangePos][0]) === 0) {\n                    return false;\n                }\n                else {\n                    advance(function () {\n                        if (sortDirection === ascending)\n                            cursor.continue(set[rangePos][0]);\n                        else\n                            cursor.continue(set[rangePos][1]);\n                    });\n                    return false;\n                }\n            });\n            return c;\n        };\n        WhereClause.prototype.startsWithAnyOf = function () {\n            var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n            if (!set.every(function (s) { return typeof s === 'string'; })) {\n                return fail(this, \"startsWithAnyOf() only works with strings\");\n            }\n            if (set.length === 0)\n                return emptyCollection(this);\n            return this.inAnyRange(set.map(function (str) { return [str, str + maxString]; }));\n        };\n        return WhereClause;\n    }());\n\n    function createWhereClauseConstructor(db) {\n        return makeClassConstructor(WhereClause.prototype, function WhereClause(table, index, orCollection) {\n            this.db = db;\n            this._ctx = {\n                table: table,\n                index: index === \":id\" ? null : index,\n                or: orCollection\n            };\n            this._cmp = this._ascending = cmp;\n            this._descending = function (a, b) { return cmp(b, a); };\n            this._max = function (a, b) { return cmp(a, b) > 0 ? a : b; };\n            this._min = function (a, b) { return cmp(a, b) < 0 ? a : b; };\n            this._IDBKeyRange = db._deps.IDBKeyRange;\n            if (!this._IDBKeyRange)\n                throw new exceptions.MissingAPI();\n        });\n    }\n\n    function eventRejectHandler(reject) {\n        return wrap(function (event) {\n            preventDefault(event);\n            reject(event.target.error);\n            return false;\n        });\n    }\n    function preventDefault(event) {\n        if (event.stopPropagation)\n            event.stopPropagation();\n        if (event.preventDefault)\n            event.preventDefault();\n    }\n\n    var DEXIE_STORAGE_MUTATED_EVENT_NAME = 'storagemutated';\n    var STORAGE_MUTATED_DOM_EVENT_NAME = 'x-storagemutated-1';\n    var globalEvents = Events(null, DEXIE_STORAGE_MUTATED_EVENT_NAME);\n\n    var Transaction =  (function () {\n        function Transaction() {\n        }\n        Transaction.prototype._lock = function () {\n            assert(!PSD.global);\n            ++this._reculock;\n            if (this._reculock === 1 && !PSD.global)\n                PSD.lockOwnerFor = this;\n            return this;\n        };\n        Transaction.prototype._unlock = function () {\n            assert(!PSD.global);\n            if (--this._reculock === 0) {\n                if (!PSD.global)\n                    PSD.lockOwnerFor = null;\n                while (this._blockedFuncs.length > 0 && !this._locked()) {\n                    var fnAndPSD = this._blockedFuncs.shift();\n                    try {\n                        usePSD(fnAndPSD[1], fnAndPSD[0]);\n                    }\n                    catch (e) { }\n                }\n            }\n            return this;\n        };\n        Transaction.prototype._locked = function () {\n            return this._reculock && PSD.lockOwnerFor !== this;\n        };\n        Transaction.prototype.create = function (idbtrans) {\n            var _this = this;\n            if (!this.mode)\n                return this;\n            var idbdb = this.db.idbdb;\n            var dbOpenError = this.db._state.dbOpenError;\n            assert(!this.idbtrans);\n            if (!idbtrans && !idbdb) {\n                switch (dbOpenError && dbOpenError.name) {\n                    case \"DatabaseClosedError\":\n                        throw new exceptions.DatabaseClosed(dbOpenError);\n                    case \"MissingAPIError\":\n                        throw new exceptions.MissingAPI(dbOpenError.message, dbOpenError);\n                    default:\n                        throw new exceptions.OpenFailed(dbOpenError);\n                }\n            }\n            if (!this.active)\n                throw new exceptions.TransactionInactive();\n            assert(this._completion._state === null);\n            idbtrans = this.idbtrans = idbtrans ||\n                (this.db.core\n                    ? this.db.core.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability })\n                    : idbdb.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability }));\n            idbtrans.onerror = wrap(function (ev) {\n                preventDefault(ev);\n                _this._reject(idbtrans.error);\n            });\n            idbtrans.onabort = wrap(function (ev) {\n                preventDefault(ev);\n                _this.active && _this._reject(new exceptions.Abort(idbtrans.error));\n                _this.active = false;\n                _this.on(\"abort\").fire(ev);\n            });\n            idbtrans.oncomplete = wrap(function () {\n                _this.active = false;\n                _this._resolve();\n                if ('mutatedParts' in idbtrans) {\n                    globalEvents.storagemutated.fire(idbtrans[\"mutatedParts\"]);\n                }\n            });\n            return this;\n        };\n        Transaction.prototype._promise = function (mode, fn, bWriteLock) {\n            var _this = this;\n            if (mode === 'readwrite' && this.mode !== 'readwrite')\n                return rejection(new exceptions.ReadOnly(\"Transaction is readonly\"));\n            if (!this.active)\n                return rejection(new exceptions.TransactionInactive());\n            if (this._locked()) {\n                return new DexiePromise(function (resolve, reject) {\n                    _this._blockedFuncs.push([function () {\n                            _this._promise(mode, fn, bWriteLock).then(resolve, reject);\n                        }, PSD]);\n                });\n            }\n            else if (bWriteLock) {\n                return newScope(function () {\n                    var p = new DexiePromise(function (resolve, reject) {\n                        _this._lock();\n                        var rv = fn(resolve, reject, _this);\n                        if (rv && rv.then)\n                            rv.then(resolve, reject);\n                    });\n                    p.finally(function () { return _this._unlock(); });\n                    p._lib = true;\n                    return p;\n                });\n            }\n            else {\n                var p = new DexiePromise(function (resolve, reject) {\n                    var rv = fn(resolve, reject, _this);\n                    if (rv && rv.then)\n                        rv.then(resolve, reject);\n                });\n                p._lib = true;\n                return p;\n            }\n        };\n        Transaction.prototype._root = function () {\n            return this.parent ? this.parent._root() : this;\n        };\n        Transaction.prototype.waitFor = function (promiseLike) {\n            var root = this._root();\n            var promise = DexiePromise.resolve(promiseLike);\n            if (root._waitingFor) {\n                root._waitingFor = root._waitingFor.then(function () { return promise; });\n            }\n            else {\n                root._waitingFor = promise;\n                root._waitingQueue = [];\n                var store = root.idbtrans.objectStore(root.storeNames[0]);\n                (function spin() {\n                    ++root._spinCount;\n                    while (root._waitingQueue.length)\n                        (root._waitingQueue.shift())();\n                    if (root._waitingFor)\n                        store.get(-Infinity).onsuccess = spin;\n                }());\n            }\n            var currentWaitPromise = root._waitingFor;\n            return new DexiePromise(function (resolve, reject) {\n                promise.then(function (res) { return root._waitingQueue.push(wrap(resolve.bind(null, res))); }, function (err) { return root._waitingQueue.push(wrap(reject.bind(null, err))); }).finally(function () {\n                    if (root._waitingFor === currentWaitPromise) {\n                        root._waitingFor = null;\n                    }\n                });\n            });\n        };\n        Transaction.prototype.abort = function () {\n            if (this.active) {\n                this.active = false;\n                if (this.idbtrans)\n                    this.idbtrans.abort();\n                this._reject(new exceptions.Abort());\n            }\n        };\n        Transaction.prototype.table = function (tableName) {\n            var memoizedTables = (this._memoizedTables || (this._memoizedTables = {}));\n            if (hasOwn(memoizedTables, tableName))\n                return memoizedTables[tableName];\n            var tableSchema = this.schema[tableName];\n            if (!tableSchema) {\n                throw new exceptions.NotFound(\"Table \" + tableName + \" not part of transaction\");\n            }\n            var transactionBoundTable = new this.db.Table(tableName, tableSchema, this);\n            transactionBoundTable.core = this.db.core.table(tableName);\n            memoizedTables[tableName] = transactionBoundTable;\n            return transactionBoundTable;\n        };\n        return Transaction;\n    }());\n\n    function createTransactionConstructor(db) {\n        return makeClassConstructor(Transaction.prototype, function Transaction(mode, storeNames, dbschema, chromeTransactionDurability, parent) {\n            var _this = this;\n            if (mode !== 'readonly')\n                storeNames.forEach(function (storeName) {\n                    var _a;\n                    var yProps = (_a = dbschema[storeName]) === null || _a === void 0 ? void 0 : _a.yProps;\n                    if (yProps)\n                        storeNames = storeNames.concat(yProps.map(function (p) { return p.updatesTable; }));\n                });\n            this.db = db;\n            this.mode = mode;\n            this.storeNames = storeNames;\n            this.schema = dbschema;\n            this.chromeTransactionDurability = chromeTransactionDurability;\n            this.idbtrans = null;\n            this.on = Events(this, \"complete\", \"error\", \"abort\");\n            this.parent = parent || null;\n            this.active = true;\n            this._reculock = 0;\n            this._blockedFuncs = [];\n            this._resolve = null;\n            this._reject = null;\n            this._waitingFor = null;\n            this._waitingQueue = null;\n            this._spinCount = 0;\n            this._completion = new DexiePromise(function (resolve, reject) {\n                _this._resolve = resolve;\n                _this._reject = reject;\n            });\n            this._completion.then(function () {\n                _this.active = false;\n                _this.on.complete.fire();\n            }, function (e) {\n                var wasActive = _this.active;\n                _this.active = false;\n                _this.on.error.fire(e);\n                _this.parent ?\n                    _this.parent._reject(e) :\n                    wasActive && _this.idbtrans && _this.idbtrans.abort();\n                return rejection(e);\n            });\n        });\n    }\n\n    function createIndexSpec(name, keyPath, unique, multi, auto, compound, isPrimKey, type) {\n        return {\n            name: name,\n            keyPath: keyPath,\n            unique: unique,\n            multi: multi,\n            auto: auto,\n            compound: compound,\n            src: (unique && !isPrimKey ? '&' : '') + (multi ? '*' : '') + (auto ? \"++\" : \"\") + nameFromKeyPath(keyPath),\n            type: type\n        };\n    }\n    function nameFromKeyPath(keyPath) {\n        return typeof keyPath === 'string' ?\n            keyPath :\n            keyPath ? ('[' + [].join.call(keyPath, '+') + ']') : \"\";\n    }\n\n    function createTableSchema(name, primKey, indexes) {\n        return {\n            name: name,\n            primKey: primKey,\n            indexes: indexes,\n            mappedClass: null,\n            idxByName: arrayToObject(indexes, function (index) { return [index.name, index]; }),\n        };\n    }\n\n    function safariMultiStoreFix(storeNames) {\n        return storeNames.length === 1 ? storeNames[0] : storeNames;\n    }\n    var getMaxKey = function (IdbKeyRange) {\n        try {\n            IdbKeyRange.only([[]]);\n            getMaxKey = function () { return [[]]; };\n            return [[]];\n        }\n        catch (e) {\n            getMaxKey = function () { return maxString; };\n            return maxString;\n        }\n    };\n\n    function getKeyExtractor(keyPath) {\n        if (keyPath == null) {\n            return function () { return undefined; };\n        }\n        else if (typeof keyPath === 'string') {\n            return getSinglePathKeyExtractor(keyPath);\n        }\n        else {\n            return function (obj) { return getByKeyPath(obj, keyPath); };\n        }\n    }\n    function getSinglePathKeyExtractor(keyPath) {\n        var split = keyPath.split('.');\n        if (split.length === 1) {\n            return function (obj) { return obj[keyPath]; };\n        }\n        else {\n            return function (obj) { return getByKeyPath(obj, keyPath); };\n        }\n    }\n\n    function arrayify(arrayLike) {\n        return [].slice.call(arrayLike);\n    }\n    var _id_counter = 0;\n    function getKeyPathAlias(keyPath) {\n        return keyPath == null ?\n            \":id\" :\n            typeof keyPath === 'string' ?\n                keyPath :\n                \"[\".concat(keyPath.join('+'), \"]\");\n    }\n    function createDBCore(db, IdbKeyRange, tmpTrans) {\n        function extractSchema(db, trans) {\n            var tables = arrayify(db.objectStoreNames);\n            return {\n                schema: {\n                    name: db.name,\n                    tables: tables.map(function (table) { return trans.objectStore(table); }).map(function (store) {\n                        var keyPath = store.keyPath, autoIncrement = store.autoIncrement;\n                        var compound = isArray(keyPath);\n                        var outbound = keyPath == null;\n                        var indexByKeyPath = {};\n                        var result = {\n                            name: store.name,\n                            primaryKey: {\n                                name: null,\n                                isPrimaryKey: true,\n                                outbound: outbound,\n                                compound: compound,\n                                keyPath: keyPath,\n                                autoIncrement: autoIncrement,\n                                unique: true,\n                                extractKey: getKeyExtractor(keyPath)\n                            },\n                            indexes: arrayify(store.indexNames).map(function (indexName) { return store.index(indexName); })\n                                .map(function (index) {\n                                var name = index.name, unique = index.unique, multiEntry = index.multiEntry, keyPath = index.keyPath;\n                                var compound = isArray(keyPath);\n                                var result = {\n                                    name: name,\n                                    compound: compound,\n                                    keyPath: keyPath,\n                                    unique: unique,\n                                    multiEntry: multiEntry,\n                                    extractKey: getKeyExtractor(keyPath)\n                                };\n                                indexByKeyPath[getKeyPathAlias(keyPath)] = result;\n                                return result;\n                            }),\n                            getIndexByKeyPath: function (keyPath) { return indexByKeyPath[getKeyPathAlias(keyPath)]; }\n                        };\n                        indexByKeyPath[\":id\"] = result.primaryKey;\n                        if (keyPath != null) {\n                            indexByKeyPath[getKeyPathAlias(keyPath)] = result.primaryKey;\n                        }\n                        return result;\n                    })\n                },\n                hasGetAll: tables.length > 0 && ('getAll' in trans.objectStore(tables[0])) &&\n                    !(typeof navigator !== 'undefined' && /Safari/.test(navigator.userAgent) &&\n                        !/(Chrome\\/|Edge\\/)/.test(navigator.userAgent) &&\n                        [].concat(navigator.userAgent.match(/Safari\\/(\\d*)/))[1] < 604)\n            };\n        }\n        function makeIDBKeyRange(range) {\n            if (range.type === 3 )\n                return null;\n            if (range.type === 4 )\n                throw new Error(\"Cannot convert never type to IDBKeyRange\");\n            var lower = range.lower, upper = range.upper, lowerOpen = range.lowerOpen, upperOpen = range.upperOpen;\n            var idbRange = lower === undefined ?\n                upper === undefined ?\n                    null :\n                    IdbKeyRange.upperBound(upper, !!upperOpen) :\n                upper === undefined ?\n                    IdbKeyRange.lowerBound(lower, !!lowerOpen) :\n                    IdbKeyRange.bound(lower, upper, !!lowerOpen, !!upperOpen);\n            return idbRange;\n        }\n        function createDbCoreTable(tableSchema) {\n            var tableName = tableSchema.name;\n            function mutate(_a) {\n                var trans = _a.trans, type = _a.type, keys = _a.keys, values = _a.values, range = _a.range;\n                return new Promise(function (resolve, reject) {\n                    resolve = wrap(resolve);\n                    var store = trans.objectStore(tableName);\n                    var outbound = store.keyPath == null;\n                    var isAddOrPut = type === \"put\" || type === \"add\";\n                    if (!isAddOrPut && type !== 'delete' && type !== 'deleteRange')\n                        throw new Error(\"Invalid operation type: \" + type);\n                    var length = (keys || values || { length: 1 }).length;\n                    if (keys && values && keys.length !== values.length) {\n                        throw new Error(\"Given keys array must have same length as given values array.\");\n                    }\n                    if (length === 0)\n                        return resolve({ numFailures: 0, failures: {}, results: [], lastResult: undefined });\n                    var req;\n                    var reqs = [];\n                    var failures = [];\n                    var numFailures = 0;\n                    var errorHandler = function (event) {\n                        ++numFailures;\n                        preventDefault(event);\n                    };\n                    if (type === 'deleteRange') {\n                        if (range.type === 4 )\n                            return resolve({ numFailures: numFailures, failures: failures, results: [], lastResult: undefined });\n                        if (range.type === 3 )\n                            reqs.push(req = store.clear());\n                        else\n                            reqs.push(req = store.delete(makeIDBKeyRange(range)));\n                    }\n                    else {\n                        var _a = isAddOrPut ?\n                            outbound ?\n                                [values, keys] :\n                                [values, null] :\n                            [keys, null], args1 = _a[0], args2 = _a[1];\n                        if (isAddOrPut) {\n                            for (var i = 0; i < length; ++i) {\n                                reqs.push(req = (args2 && args2[i] !== undefined ?\n                                    store[type](args1[i], args2[i]) :\n                                    store[type](args1[i])));\n                                req.onerror = errorHandler;\n                            }\n                        }\n                        else {\n                            for (var i = 0; i < length; ++i) {\n                                reqs.push(req = store[type](args1[i]));\n                                req.onerror = errorHandler;\n                            }\n                        }\n                    }\n                    var done = function (event) {\n                        var lastResult = event.target.result;\n                        reqs.forEach(function (req, i) { return req.error != null && (failures[i] = req.error); });\n                        resolve({\n                            numFailures: numFailures,\n                            failures: failures,\n                            results: type === \"delete\" ? keys : reqs.map(function (req) { return req.result; }),\n                            lastResult: lastResult\n                        });\n                    };\n                    req.onerror = function (event) {\n                        errorHandler(event);\n                        done(event);\n                    };\n                    req.onsuccess = done;\n                });\n            }\n            function openCursor(_a) {\n                var trans = _a.trans, values = _a.values, query = _a.query, reverse = _a.reverse, unique = _a.unique;\n                return new Promise(function (resolve, reject) {\n                    resolve = wrap(resolve);\n                    var index = query.index, range = query.range;\n                    var store = trans.objectStore(tableName);\n                    var source = index.isPrimaryKey ?\n                        store :\n                        store.index(index.name);\n                    var direction = reverse ?\n                        unique ?\n                            \"prevunique\" :\n                            \"prev\" :\n                        unique ?\n                            \"nextunique\" :\n                            \"next\";\n                    var req = values || !('openKeyCursor' in source) ?\n                        source.openCursor(makeIDBKeyRange(range), direction) :\n                        source.openKeyCursor(makeIDBKeyRange(range), direction);\n                    req.onerror = eventRejectHandler(reject);\n                    req.onsuccess = wrap(function (ev) {\n                        var cursor = req.result;\n                        if (!cursor) {\n                            resolve(null);\n                            return;\n                        }\n                        cursor.___id = ++_id_counter;\n                        cursor.done = false;\n                        var _cursorContinue = cursor.continue.bind(cursor);\n                        var _cursorContinuePrimaryKey = cursor.continuePrimaryKey;\n                        if (_cursorContinuePrimaryKey)\n                            _cursorContinuePrimaryKey = _cursorContinuePrimaryKey.bind(cursor);\n                        var _cursorAdvance = cursor.advance.bind(cursor);\n                        var doThrowCursorIsNotStarted = function () { throw new Error(\"Cursor not started\"); };\n                        var doThrowCursorIsStopped = function () { throw new Error(\"Cursor not stopped\"); };\n                        cursor.trans = trans;\n                        cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsNotStarted;\n                        cursor.fail = wrap(reject);\n                        cursor.next = function () {\n                            var _this = this;\n                            var gotOne = 1;\n                            return this.start(function () { return gotOne-- ? _this.continue() : _this.stop(); }).then(function () { return _this; });\n                        };\n                        cursor.start = function (callback) {\n                            var iterationPromise = new Promise(function (resolveIteration, rejectIteration) {\n                                resolveIteration = wrap(resolveIteration);\n                                req.onerror = eventRejectHandler(rejectIteration);\n                                cursor.fail = rejectIteration;\n                                cursor.stop = function (value) {\n                                    cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsStopped;\n                                    resolveIteration(value);\n                                };\n                            });\n                            var guardedCallback = function () {\n                                if (req.result) {\n                                    try {\n                                        callback();\n                                    }\n                                    catch (err) {\n                                        cursor.fail(err);\n                                    }\n                                }\n                                else {\n                                    cursor.done = true;\n                                    cursor.start = function () { throw new Error(\"Cursor behind last entry\"); };\n                                    cursor.stop();\n                                }\n                            };\n                            req.onsuccess = wrap(function (ev) {\n                                req.onsuccess = guardedCallback;\n                                guardedCallback();\n                            });\n                            cursor.continue = _cursorContinue;\n                            cursor.continuePrimaryKey = _cursorContinuePrimaryKey;\n                            cursor.advance = _cursorAdvance;\n                            guardedCallback();\n                            return iterationPromise;\n                        };\n                        resolve(cursor);\n                    }, reject);\n                });\n            }\n            function query(hasGetAll) {\n                return function (request) {\n                    return new Promise(function (resolve, reject) {\n                        resolve = wrap(resolve);\n                        var trans = request.trans, values = request.values, limit = request.limit, query = request.query;\n                        var nonInfinitLimit = limit === Infinity ? undefined : limit;\n                        var index = query.index, range = query.range;\n                        var store = trans.objectStore(tableName);\n                        var source = index.isPrimaryKey ? store : store.index(index.name);\n                        var idbKeyRange = makeIDBKeyRange(range);\n                        if (limit === 0)\n                            return resolve({ result: [] });\n                        if (hasGetAll) {\n                            var req = values ?\n                                source.getAll(idbKeyRange, nonInfinitLimit) :\n                                source.getAllKeys(idbKeyRange, nonInfinitLimit);\n                            req.onsuccess = function (event) { return resolve({ result: event.target.result }); };\n                            req.onerror = eventRejectHandler(reject);\n                        }\n                        else {\n                            var count_1 = 0;\n                            var req_1 = values || !('openKeyCursor' in source) ?\n                                source.openCursor(idbKeyRange) :\n                                source.openKeyCursor(idbKeyRange);\n                            var result_1 = [];\n                            req_1.onsuccess = function (event) {\n                                var cursor = req_1.result;\n                                if (!cursor)\n                                    return resolve({ result: result_1 });\n                                result_1.push(values ? cursor.value : cursor.primaryKey);\n                                if (++count_1 === limit)\n                                    return resolve({ result: result_1 });\n                                cursor.continue();\n                            };\n                            req_1.onerror = eventRejectHandler(reject);\n                        }\n                    });\n                };\n            }\n            return {\n                name: tableName,\n                schema: tableSchema,\n                mutate: mutate,\n                getMany: function (_a) {\n                    var trans = _a.trans, keys = _a.keys;\n                    return new Promise(function (resolve, reject) {\n                        resolve = wrap(resolve);\n                        var store = trans.objectStore(tableName);\n                        var length = keys.length;\n                        var result = new Array(length);\n                        var keyCount = 0;\n                        var callbackCount = 0;\n                        var req;\n                        var successHandler = function (event) {\n                            var req = event.target;\n                            if ((result[req._pos] = req.result) != null)\n                                ;\n                            if (++callbackCount === keyCount)\n                                resolve(result);\n                        };\n                        var errorHandler = eventRejectHandler(reject);\n                        for (var i = 0; i < length; ++i) {\n                            var key = keys[i];\n                            if (key != null) {\n                                req = store.get(keys[i]);\n                                req._pos = i;\n                                req.onsuccess = successHandler;\n                                req.onerror = errorHandler;\n                                ++keyCount;\n                            }\n                        }\n                        if (keyCount === 0)\n                            resolve(result);\n                    });\n                },\n                get: function (_a) {\n                    var trans = _a.trans, key = _a.key;\n                    return new Promise(function (resolve, reject) {\n                        resolve = wrap(resolve);\n                        var store = trans.objectStore(tableName);\n                        var req = store.get(key);\n                        req.onsuccess = function (event) { return resolve(event.target.result); };\n                        req.onerror = eventRejectHandler(reject);\n                    });\n                },\n                query: query(hasGetAll),\n                openCursor: openCursor,\n                count: function (_a) {\n                    var query = _a.query, trans = _a.trans;\n                    var index = query.index, range = query.range;\n                    return new Promise(function (resolve, reject) {\n                        var store = trans.objectStore(tableName);\n                        var source = index.isPrimaryKey ? store : store.index(index.name);\n                        var idbKeyRange = makeIDBKeyRange(range);\n                        var req = idbKeyRange ? source.count(idbKeyRange) : source.count();\n                        req.onsuccess = wrap(function (ev) { return resolve(ev.target.result); });\n                        req.onerror = eventRejectHandler(reject);\n                    });\n                }\n            };\n        }\n        var _a = extractSchema(db, tmpTrans), schema = _a.schema, hasGetAll = _a.hasGetAll;\n        var tables = schema.tables.map(function (tableSchema) { return createDbCoreTable(tableSchema); });\n        var tableMap = {};\n        tables.forEach(function (table) { return tableMap[table.name] = table; });\n        return {\n            stack: \"dbcore\",\n            transaction: db.transaction.bind(db),\n            table: function (name) {\n                var result = tableMap[name];\n                if (!result)\n                    throw new Error(\"Table '\".concat(name, \"' not found\"));\n                return tableMap[name];\n            },\n            MIN_KEY: -Infinity,\n            MAX_KEY: getMaxKey(IdbKeyRange),\n            schema: schema\n        };\n    }\n\n    function createMiddlewareStack(stackImpl, middlewares) {\n        return middlewares.reduce(function (down, _a) {\n            var create = _a.create;\n            return (__assign(__assign({}, down), create(down)));\n        }, stackImpl);\n    }\n    function createMiddlewareStacks(middlewares, idbdb, _a, tmpTrans) {\n        var IDBKeyRange = _a.IDBKeyRange; _a.indexedDB;\n        var dbcore = createMiddlewareStack(createDBCore(idbdb, IDBKeyRange, tmpTrans), middlewares.dbcore);\n        return {\n            dbcore: dbcore\n        };\n    }\n    function generateMiddlewareStacks(db, tmpTrans) {\n        var idbdb = tmpTrans.db;\n        var stacks = createMiddlewareStacks(db._middlewares, idbdb, db._deps, tmpTrans);\n        db.core = stacks.dbcore;\n        db.tables.forEach(function (table) {\n            var tableName = table.name;\n            if (db.core.schema.tables.some(function (tbl) { return tbl.name === tableName; })) {\n                table.core = db.core.table(tableName);\n                if (db[tableName] instanceof db.Table) {\n                    db[tableName].core = table.core;\n                }\n            }\n        });\n    }\n\n    function setApiOnPlace(db, objs, tableNames, dbschema) {\n        tableNames.forEach(function (tableName) {\n            var schema = dbschema[tableName];\n            objs.forEach(function (obj) {\n                var propDesc = getPropertyDescriptor(obj, tableName);\n                if (!propDesc || (\"value\" in propDesc && propDesc.value === undefined)) {\n                    if (obj === db.Transaction.prototype || obj instanceof db.Transaction) {\n                        setProp(obj, tableName, {\n                            get: function () { return this.table(tableName); },\n                            set: function (value) {\n                                defineProperty(this, tableName, { value: value, writable: true, configurable: true, enumerable: true });\n                            }\n                        });\n                    }\n                    else {\n                        obj[tableName] = new db.Table(tableName, schema);\n                    }\n                }\n            });\n        });\n    }\n    function removeTablesApi(db, objs) {\n        objs.forEach(function (obj) {\n            for (var key in obj) {\n                if (obj[key] instanceof db.Table)\n                    delete obj[key];\n            }\n        });\n    }\n    function lowerVersionFirst(a, b) {\n        return a._cfg.version - b._cfg.version;\n    }\n    function runUpgraders(db, oldVersion, idbUpgradeTrans, reject) {\n        var globalSchema = db._dbSchema;\n        if (idbUpgradeTrans.objectStoreNames.contains('$meta') && !globalSchema.$meta) {\n            globalSchema.$meta = createTableSchema(\"$meta\", parseIndexSyntax(\"\")[0], []);\n            db._storeNames.push('$meta');\n        }\n        var trans = db._createTransaction('readwrite', db._storeNames, globalSchema);\n        trans.create(idbUpgradeTrans);\n        trans._completion.catch(reject);\n        var rejectTransaction = trans._reject.bind(trans);\n        var transless = PSD.transless || PSD;\n        newScope(function () {\n            PSD.trans = trans;\n            PSD.transless = transless;\n            if (oldVersion === 0) {\n                keys(globalSchema).forEach(function (tableName) {\n                    createTable(idbUpgradeTrans, tableName, globalSchema[tableName].primKey, globalSchema[tableName].indexes);\n                });\n                generateMiddlewareStacks(db, idbUpgradeTrans);\n                DexiePromise.follow(function () { return db.on.populate.fire(trans); }).catch(rejectTransaction);\n            }\n            else {\n                generateMiddlewareStacks(db, idbUpgradeTrans);\n                return getExistingVersion(db, trans, oldVersion)\n                    .then(function (oldVersion) { return updateTablesAndIndexes(db, oldVersion, trans, idbUpgradeTrans); })\n                    .catch(rejectTransaction);\n            }\n        });\n    }\n    function patchCurrentVersion(db, idbUpgradeTrans) {\n        createMissingTables(db._dbSchema, idbUpgradeTrans);\n        if (idbUpgradeTrans.db.version % 10 === 0 && !idbUpgradeTrans.objectStoreNames.contains('$meta')) {\n            idbUpgradeTrans.db.createObjectStore('$meta').add(Math.ceil((idbUpgradeTrans.db.version / 10) - 1), 'version');\n        }\n        var globalSchema = buildGlobalSchema(db, db.idbdb, idbUpgradeTrans);\n        adjustToExistingIndexNames(db, db._dbSchema, idbUpgradeTrans);\n        var diff = getSchemaDiff(globalSchema, db._dbSchema);\n        var _loop_1 = function (tableChange) {\n            if (tableChange.change.length || tableChange.recreate) {\n                console.warn(\"Unable to patch indexes of table \".concat(tableChange.name, \" because it has changes on the type of index or primary key.\"));\n                return { value: void 0 };\n            }\n            var store = idbUpgradeTrans.objectStore(tableChange.name);\n            tableChange.add.forEach(function (idx) {\n                if (debug)\n                    console.debug(\"Dexie upgrade patch: Creating missing index \".concat(tableChange.name, \".\").concat(idx.src));\n                addIndex(store, idx);\n            });\n        };\n        for (var _i = 0, _a = diff.change; _i < _a.length; _i++) {\n            var tableChange = _a[_i];\n            var state_1 = _loop_1(tableChange);\n            if (typeof state_1 === \"object\")\n                return state_1.value;\n        }\n    }\n    function getExistingVersion(db, trans, oldVersion) {\n        if (trans.storeNames.includes('$meta')) {\n            return trans.table('$meta').get('version').then(function (metaVersion) {\n                return metaVersion != null ? metaVersion : oldVersion;\n            });\n        }\n        else {\n            return DexiePromise.resolve(oldVersion);\n        }\n    }\n    function updateTablesAndIndexes(db, oldVersion, trans, idbUpgradeTrans) {\n        var queue = [];\n        var versions = db._versions;\n        var globalSchema = db._dbSchema = buildGlobalSchema(db, db.idbdb, idbUpgradeTrans);\n        var versToRun = versions.filter(function (v) { return v._cfg.version >= oldVersion; });\n        if (versToRun.length === 0) {\n            return DexiePromise.resolve();\n        }\n        versToRun.forEach(function (version) {\n            queue.push(function () {\n                var oldSchema = globalSchema;\n                var newSchema = version._cfg.dbschema;\n                adjustToExistingIndexNames(db, oldSchema, idbUpgradeTrans);\n                adjustToExistingIndexNames(db, newSchema, idbUpgradeTrans);\n                globalSchema = db._dbSchema = newSchema;\n                var diff = getSchemaDiff(oldSchema, newSchema);\n                diff.add.forEach(function (tuple) {\n                    createTable(idbUpgradeTrans, tuple[0], tuple[1].primKey, tuple[1].indexes);\n                });\n                diff.change.forEach(function (change) {\n                    if (change.recreate) {\n                        throw new exceptions.Upgrade(\"Not yet support for changing primary key\");\n                    }\n                    else {\n                        var store_1 = idbUpgradeTrans.objectStore(change.name);\n                        change.add.forEach(function (idx) { return addIndex(store_1, idx); });\n                        change.change.forEach(function (idx) {\n                            store_1.deleteIndex(idx.name);\n                            addIndex(store_1, idx);\n                        });\n                        change.del.forEach(function (idxName) { return store_1.deleteIndex(idxName); });\n                    }\n                });\n                var contentUpgrade = version._cfg.contentUpgrade;\n                if (contentUpgrade && version._cfg.version > oldVersion) {\n                    generateMiddlewareStacks(db, idbUpgradeTrans);\n                    trans._memoizedTables = {};\n                    var upgradeSchema_1 = shallowClone(newSchema);\n                    diff.del.forEach(function (table) {\n                        upgradeSchema_1[table] = oldSchema[table];\n                    });\n                    removeTablesApi(db, [db.Transaction.prototype]);\n                    setApiOnPlace(db, [db.Transaction.prototype], keys(upgradeSchema_1), upgradeSchema_1);\n                    trans.schema = upgradeSchema_1;\n                    var contentUpgradeIsAsync_1 = isAsyncFunction(contentUpgrade);\n                    if (contentUpgradeIsAsync_1) {\n                        incrementExpectedAwaits();\n                    }\n                    var returnValue_1;\n                    var promiseFollowed = DexiePromise.follow(function () {\n                        returnValue_1 = contentUpgrade(trans);\n                        if (returnValue_1) {\n                            if (contentUpgradeIsAsync_1) {\n                                var decrementor = decrementExpectedAwaits.bind(null, null);\n                                returnValue_1.then(decrementor, decrementor);\n                            }\n                        }\n                    });\n                    return (returnValue_1 && typeof returnValue_1.then === 'function' ?\n                        DexiePromise.resolve(returnValue_1) : promiseFollowed.then(function () { return returnValue_1; }));\n                }\n            });\n            queue.push(function (idbtrans) {\n                var newSchema = version._cfg.dbschema;\n                deleteRemovedTables(newSchema, idbtrans);\n                removeTablesApi(db, [db.Transaction.prototype]);\n                setApiOnPlace(db, [db.Transaction.prototype], db._storeNames, db._dbSchema);\n                trans.schema = db._dbSchema;\n            });\n            queue.push(function (idbtrans) {\n                if (db.idbdb.objectStoreNames.contains('$meta')) {\n                    if (Math.ceil(db.idbdb.version / 10) === version._cfg.version) {\n                        db.idbdb.deleteObjectStore('$meta');\n                        delete db._dbSchema.$meta;\n                        db._storeNames = db._storeNames.filter(function (name) { return name !== '$meta'; });\n                    }\n                    else {\n                        idbtrans.objectStore('$meta').put(version._cfg.version, 'version');\n                    }\n                }\n            });\n        });\n        function runQueue() {\n            return queue.length ? DexiePromise.resolve(queue.shift()(trans.idbtrans)).then(runQueue) :\n                DexiePromise.resolve();\n        }\n        return runQueue().then(function () {\n            createMissingTables(globalSchema, idbUpgradeTrans);\n        });\n    }\n    function getSchemaDiff(oldSchema, newSchema) {\n        var diff = {\n            del: [],\n            add: [],\n            change: []\n        };\n        var table;\n        for (table in oldSchema) {\n            if (!newSchema[table])\n                diff.del.push(table);\n        }\n        for (table in newSchema) {\n            var oldDef = oldSchema[table], newDef = newSchema[table];\n            if (!oldDef) {\n                diff.add.push([table, newDef]);\n            }\n            else {\n                var change = {\n                    name: table,\n                    def: newDef,\n                    recreate: false,\n                    del: [],\n                    add: [],\n                    change: []\n                };\n                if ((\n                '' + (oldDef.primKey.keyPath || '')) !== ('' + (newDef.primKey.keyPath || '')) ||\n                    (oldDef.primKey.auto !== newDef.primKey.auto)) {\n                    change.recreate = true;\n                    diff.change.push(change);\n                }\n                else {\n                    var oldIndexes = oldDef.idxByName;\n                    var newIndexes = newDef.idxByName;\n                    var idxName = void 0;\n                    for (idxName in oldIndexes) {\n                        if (!newIndexes[idxName])\n                            change.del.push(idxName);\n                    }\n                    for (idxName in newIndexes) {\n                        var oldIdx = oldIndexes[idxName], newIdx = newIndexes[idxName];\n                        if (!oldIdx)\n                            change.add.push(newIdx);\n                        else if (oldIdx.src !== newIdx.src)\n                            change.change.push(newIdx);\n                    }\n                    if (change.del.length > 0 || change.add.length > 0 || change.change.length > 0) {\n                        diff.change.push(change);\n                    }\n                }\n            }\n        }\n        return diff;\n    }\n    function createTable(idbtrans, tableName, primKey, indexes) {\n        var store = idbtrans.db.createObjectStore(tableName, primKey.keyPath ?\n            { keyPath: primKey.keyPath, autoIncrement: primKey.auto } :\n            { autoIncrement: primKey.auto });\n        indexes.forEach(function (idx) { return addIndex(store, idx); });\n        return store;\n    }\n    function createMissingTables(newSchema, idbtrans) {\n        keys(newSchema).forEach(function (tableName) {\n            if (!idbtrans.db.objectStoreNames.contains(tableName)) {\n                if (debug)\n                    console.debug('Dexie: Creating missing table', tableName);\n                createTable(idbtrans, tableName, newSchema[tableName].primKey, newSchema[tableName].indexes);\n            }\n        });\n    }\n    function deleteRemovedTables(newSchema, idbtrans) {\n        [].slice.call(idbtrans.db.objectStoreNames).forEach(function (storeName) {\n            return newSchema[storeName] == null && idbtrans.db.deleteObjectStore(storeName);\n        });\n    }\n    function addIndex(store, idx) {\n        store.createIndex(idx.name, idx.keyPath, { unique: idx.unique, multiEntry: idx.multi });\n    }\n    function buildGlobalSchema(db, idbdb, tmpTrans) {\n        var globalSchema = {};\n        var dbStoreNames = slice(idbdb.objectStoreNames, 0);\n        dbStoreNames.forEach(function (storeName) {\n            var store = tmpTrans.objectStore(storeName);\n            var keyPath = store.keyPath;\n            var primKey = createIndexSpec(nameFromKeyPath(keyPath), keyPath || \"\", true, false, !!store.autoIncrement, keyPath && typeof keyPath !== \"string\", true);\n            var indexes = [];\n            for (var j = 0; j < store.indexNames.length; ++j) {\n                var idbindex = store.index(store.indexNames[j]);\n                keyPath = idbindex.keyPath;\n                var index = createIndexSpec(idbindex.name, keyPath, !!idbindex.unique, !!idbindex.multiEntry, false, keyPath && typeof keyPath !== \"string\", false);\n                indexes.push(index);\n            }\n            globalSchema[storeName] = createTableSchema(storeName, primKey, indexes);\n        });\n        return globalSchema;\n    }\n    function readGlobalSchema(db, idbdb, tmpTrans) {\n        db.verno = idbdb.version / 10;\n        var globalSchema = db._dbSchema = buildGlobalSchema(db, idbdb, tmpTrans);\n        db._storeNames = slice(idbdb.objectStoreNames, 0);\n        setApiOnPlace(db, [db._allTables], keys(globalSchema), globalSchema);\n    }\n    function verifyInstalledSchema(db, tmpTrans) {\n        var installedSchema = buildGlobalSchema(db, db.idbdb, tmpTrans);\n        var diff = getSchemaDiff(installedSchema, db._dbSchema);\n        return !(diff.add.length || diff.change.some(function (ch) { return ch.add.length || ch.change.length; }));\n    }\n    function adjustToExistingIndexNames(db, schema, idbtrans) {\n        var storeNames = idbtrans.db.objectStoreNames;\n        for (var i = 0; i < storeNames.length; ++i) {\n            var storeName = storeNames[i];\n            var store = idbtrans.objectStore(storeName);\n            db._hasGetAll = 'getAll' in store;\n            for (var j = 0; j < store.indexNames.length; ++j) {\n                var indexName = store.indexNames[j];\n                var keyPath = store.index(indexName).keyPath;\n                var dexieName = typeof keyPath === 'string' ? keyPath : \"[\" + slice(keyPath).join('+') + \"]\";\n                if (schema[storeName]) {\n                    var indexSpec = schema[storeName].idxByName[dexieName];\n                    if (indexSpec) {\n                        indexSpec.name = indexName;\n                        delete schema[storeName].idxByName[dexieName];\n                        schema[storeName].idxByName[indexName] = indexSpec;\n                    }\n                }\n            }\n        }\n        if (typeof navigator !== 'undefined' && /Safari/.test(navigator.userAgent) &&\n            !/(Chrome\\/|Edge\\/)/.test(navigator.userAgent) &&\n            _global.WorkerGlobalScope && _global instanceof _global.WorkerGlobalScope &&\n            [].concat(navigator.userAgent.match(/Safari\\/(\\d*)/))[1] < 604) {\n            db._hasGetAll = false;\n        }\n    }\n    function parseIndexSyntax(primKeyAndIndexes) {\n        return primKeyAndIndexes.split(',').map(function (index, indexNum) {\n            var _a;\n            var typeSplit = index.split(':');\n            var type = (_a = typeSplit[1]) === null || _a === void 0 ? void 0 : _a.trim();\n            index = typeSplit[0].trim();\n            var name = index.replace(/([&*]|\\+\\+)/g, \"\");\n            var keyPath = /^\\[/.test(name) ? name.match(/^\\[(.*)\\]$/)[1].split('+') : name;\n            return createIndexSpec(name, keyPath || null, /\\&/.test(index), /\\*/.test(index), /\\+\\+/.test(index), isArray(keyPath), indexNum === 0, type);\n        });\n    }\n\n    var Version =  (function () {\n        function Version() {\n        }\n        Version.prototype._createTableSchema = function (name, primKey, indexes) {\n            return createTableSchema(name, primKey, indexes);\n        };\n        Version.prototype._parseIndexSyntax = function (primKeyAndIndexes) {\n            return parseIndexSyntax(primKeyAndIndexes);\n        };\n        Version.prototype._parseStoresSpec = function (stores, outSchema) {\n            var _this = this;\n            keys(stores).forEach(function (tableName) {\n                if (stores[tableName] !== null) {\n                    var indexes = _this._parseIndexSyntax(stores[tableName]);\n                    var primKey = indexes.shift();\n                    if (!primKey) {\n                        throw new exceptions.Schema('Invalid schema for table ' + tableName + ': ' + stores[tableName]);\n                    }\n                    primKey.unique = true;\n                    if (primKey.multi)\n                        throw new exceptions.Schema('Primary key cannot be multiEntry*');\n                    indexes.forEach(function (idx) {\n                        if (idx.auto)\n                            throw new exceptions.Schema('Only primary key can be marked as autoIncrement (++)');\n                        if (!idx.keyPath)\n                            throw new exceptions.Schema('Index must have a name and cannot be an empty string');\n                    });\n                    var tblSchema = _this._createTableSchema(tableName, primKey, indexes);\n                    outSchema[tableName] = tblSchema;\n                }\n            });\n        };\n        Version.prototype.stores = function (stores) {\n            var db = this.db;\n            this._cfg.storesSource = this._cfg.storesSource\n                ? extend(this._cfg.storesSource, stores)\n                : stores;\n            var versions = db._versions;\n            var storesSpec = {};\n            var dbschema = {};\n            versions.forEach(function (version) {\n                extend(storesSpec, version._cfg.storesSource);\n                dbschema = version._cfg.dbschema = {};\n                version._parseStoresSpec(storesSpec, dbschema);\n            });\n            db._dbSchema = dbschema;\n            removeTablesApi(db, [db._allTables, db, db.Transaction.prototype]);\n            setApiOnPlace(db, [db._allTables, db, db.Transaction.prototype, this._cfg.tables], keys(dbschema), dbschema);\n            db._storeNames = keys(dbschema);\n            return this;\n        };\n        Version.prototype.upgrade = function (upgradeFunction) {\n            this._cfg.contentUpgrade = promisableChain(this._cfg.contentUpgrade || nop, upgradeFunction);\n            return this;\n        };\n        return Version;\n    }());\n\n    function createVersionConstructor(db) {\n        return makeClassConstructor(Version.prototype, function Version(versionNumber) {\n            this.db = db;\n            this._cfg = {\n                version: versionNumber,\n                storesSource: null,\n                dbschema: {},\n                tables: {},\n                contentUpgrade: null\n            };\n        });\n    }\n\n    function getDbNamesTable(indexedDB, IDBKeyRange) {\n        var dbNamesDB = indexedDB[\"_dbNamesDB\"];\n        if (!dbNamesDB) {\n            dbNamesDB = indexedDB[\"_dbNamesDB\"] = new Dexie$1(DBNAMES_DB, {\n                addons: [],\n                indexedDB: indexedDB,\n                IDBKeyRange: IDBKeyRange,\n            });\n            dbNamesDB.version(1).stores({ dbnames: \"name\" });\n        }\n        return dbNamesDB.table(\"dbnames\");\n    }\n    function hasDatabasesNative(indexedDB) {\n        return indexedDB && typeof indexedDB.databases === \"function\";\n    }\n    function getDatabaseNames(_a) {\n        var indexedDB = _a.indexedDB, IDBKeyRange = _a.IDBKeyRange;\n        return hasDatabasesNative(indexedDB)\n            ? Promise.resolve(indexedDB.databases()).then(function (infos) {\n                return infos\n                    .map(function (info) { return info.name; })\n                    .filter(function (name) { return name !== DBNAMES_DB; });\n            })\n            : getDbNamesTable(indexedDB, IDBKeyRange).toCollection().primaryKeys();\n    }\n    function _onDatabaseCreated(_a, name) {\n        var indexedDB = _a.indexedDB, IDBKeyRange = _a.IDBKeyRange;\n        !hasDatabasesNative(indexedDB) &&\n            name !== DBNAMES_DB &&\n            getDbNamesTable(indexedDB, IDBKeyRange).put({ name: name }).catch(nop);\n    }\n    function _onDatabaseDeleted(_a, name) {\n        var indexedDB = _a.indexedDB, IDBKeyRange = _a.IDBKeyRange;\n        !hasDatabasesNative(indexedDB) &&\n            name !== DBNAMES_DB &&\n            getDbNamesTable(indexedDB, IDBKeyRange).delete(name).catch(nop);\n    }\n\n    function vip(fn) {\n        return newScope(function () {\n            PSD.letThrough = true;\n            return fn();\n        });\n    }\n\n    function idbReady() {\n        var isSafari = !navigator.userAgentData &&\n            /Safari\\//.test(navigator.userAgent) &&\n            !/Chrom(e|ium)\\//.test(navigator.userAgent);\n        if (!isSafari || !indexedDB.databases)\n            return Promise.resolve();\n        var intervalId;\n        return new Promise(function (resolve) {\n            var tryIdb = function () { return indexedDB.databases().finally(resolve); };\n            intervalId = setInterval(tryIdb, 100);\n            tryIdb();\n        }).finally(function () { return clearInterval(intervalId); });\n    }\n\n    var _a;\n    function isEmptyRange(node) {\n        return !(\"from\" in node);\n    }\n    var RangeSet = function (fromOrTree, to) {\n        if (this) {\n            extend(this, arguments.length ? { d: 1, from: fromOrTree, to: arguments.length > 1 ? to : fromOrTree } : { d: 0 });\n        }\n        else {\n            var rv = new RangeSet();\n            if (fromOrTree && (\"d\" in fromOrTree)) {\n                extend(rv, fromOrTree);\n            }\n            return rv;\n        }\n    };\n    props(RangeSet.prototype, (_a = {\n            add: function (rangeSet) {\n                mergeRanges(this, rangeSet);\n                return this;\n            },\n            addKey: function (key) {\n                addRange(this, key, key);\n                return this;\n            },\n            addKeys: function (keys) {\n                var _this = this;\n                keys.forEach(function (key) { return addRange(_this, key, key); });\n                return this;\n            },\n            hasKey: function (key) {\n                var node = getRangeSetIterator(this).next(key).value;\n                return node && cmp(node.from, key) <= 0 && cmp(node.to, key) >= 0;\n            }\n        },\n        _a[iteratorSymbol] = function () {\n            return getRangeSetIterator(this);\n        },\n        _a));\n    function addRange(target, from, to) {\n        var diff = cmp(from, to);\n        if (isNaN(diff))\n            return;\n        if (diff > 0)\n            throw RangeError();\n        if (isEmptyRange(target))\n            return extend(target, { from: from, to: to, d: 1 });\n        var left = target.l;\n        var right = target.r;\n        if (cmp(to, target.from) < 0) {\n            left\n                ? addRange(left, from, to)\n                : (target.l = { from: from, to: to, d: 1, l: null, r: null });\n            return rebalance(target);\n        }\n        if (cmp(from, target.to) > 0) {\n            right\n                ? addRange(right, from, to)\n                : (target.r = { from: from, to: to, d: 1, l: null, r: null });\n            return rebalance(target);\n        }\n        if (cmp(from, target.from) < 0) {\n            target.from = from;\n            target.l = null;\n            target.d = right ? right.d + 1 : 1;\n        }\n        if (cmp(to, target.to) > 0) {\n            target.to = to;\n            target.r = null;\n            target.d = target.l ? target.l.d + 1 : 1;\n        }\n        var rightWasCutOff = !target.r;\n        if (left && !target.l) {\n            mergeRanges(target, left);\n        }\n        if (right && rightWasCutOff) {\n            mergeRanges(target, right);\n        }\n    }\n    function mergeRanges(target, newSet) {\n        function _addRangeSet(target, _a) {\n            var from = _a.from, to = _a.to, l = _a.l, r = _a.r;\n            addRange(target, from, to);\n            if (l)\n                _addRangeSet(target, l);\n            if (r)\n                _addRangeSet(target, r);\n        }\n        if (!isEmptyRange(newSet))\n            _addRangeSet(target, newSet);\n    }\n    function rangesOverlap(rangeSet1, rangeSet2) {\n        var i1 = getRangeSetIterator(rangeSet2);\n        var nextResult1 = i1.next();\n        if (nextResult1.done)\n            return false;\n        var a = nextResult1.value;\n        var i2 = getRangeSetIterator(rangeSet1);\n        var nextResult2 = i2.next(a.from);\n        var b = nextResult2.value;\n        while (!nextResult1.done && !nextResult2.done) {\n            if (cmp(b.from, a.to) <= 0 && cmp(b.to, a.from) >= 0)\n                return true;\n            cmp(a.from, b.from) < 0\n                ? (a = (nextResult1 = i1.next(b.from)).value)\n                : (b = (nextResult2 = i2.next(a.from)).value);\n        }\n        return false;\n    }\n    function getRangeSetIterator(node) {\n        var state = isEmptyRange(node) ? null : { s: 0, n: node };\n        return {\n            next: function (key) {\n                var keyProvided = arguments.length > 0;\n                while (state) {\n                    switch (state.s) {\n                        case 0:\n                            state.s = 1;\n                            if (keyProvided) {\n                                while (state.n.l && cmp(key, state.n.from) < 0)\n                                    state = { up: state, n: state.n.l, s: 1 };\n                            }\n                            else {\n                                while (state.n.l)\n                                    state = { up: state, n: state.n.l, s: 1 };\n                            }\n                        case 1:\n                            state.s = 2;\n                            if (!keyProvided || cmp(key, state.n.to) <= 0)\n                                return { value: state.n, done: false };\n                        case 2:\n                            if (state.n.r) {\n                                state.s = 3;\n                                state = { up: state, n: state.n.r, s: 0 };\n                                continue;\n                            }\n                        case 3:\n                            state = state.up;\n                    }\n                }\n                return { done: true };\n            },\n        };\n    }\n    function rebalance(target) {\n        var _a, _b;\n        var diff = (((_a = target.r) === null || _a === void 0 ? void 0 : _a.d) || 0) - (((_b = target.l) === null || _b === void 0 ? void 0 : _b.d) || 0);\n        var r = diff > 1 ? \"r\" : diff < -1 ? \"l\" : \"\";\n        if (r) {\n            var l = r === \"r\" ? \"l\" : \"r\";\n            var rootClone = __assign({}, target);\n            var oldRootRight = target[r];\n            target.from = oldRootRight.from;\n            target.to = oldRootRight.to;\n            target[r] = oldRootRight[r];\n            rootClone[r] = oldRootRight[l];\n            target[l] = rootClone;\n            rootClone.d = computeDepth(rootClone);\n        }\n        target.d = computeDepth(target);\n    }\n    function computeDepth(_a) {\n        var r = _a.r, l = _a.l;\n        return (r ? (l ? Math.max(r.d, l.d) : r.d) : l ? l.d : 0) + 1;\n    }\n\n    function extendObservabilitySet(target, newSet) {\n        keys(newSet).forEach(function (part) {\n            if (target[part])\n                mergeRanges(target[part], newSet[part]);\n            else\n                target[part] = cloneSimpleObjectTree(newSet[part]);\n        });\n        return target;\n    }\n\n    function obsSetsOverlap(os1, os2) {\n        return os1.all || os2.all || Object.keys(os1).some(function (key) { return os2[key] && rangesOverlap(os2[key], os1[key]); });\n    }\n\n    var cache = {};\n\n    var unsignaledParts = {};\n    var isTaskEnqueued = false;\n    function signalSubscribersLazily(part, optimistic) {\n        extendObservabilitySet(unsignaledParts, part);\n        if (!isTaskEnqueued) {\n            isTaskEnqueued = true;\n            setTimeout(function () {\n                isTaskEnqueued = false;\n                var parts = unsignaledParts;\n                unsignaledParts = {};\n                signalSubscribersNow(parts, false);\n            }, 0);\n        }\n    }\n    function signalSubscribersNow(updatedParts, deleteAffectedCacheEntries) {\n        if (deleteAffectedCacheEntries === void 0) { deleteAffectedCacheEntries = false; }\n        var queriesToSignal = new Set();\n        if (updatedParts.all) {\n            for (var _i = 0, _a = Object.values(cache); _i < _a.length; _i++) {\n                var tblCache = _a[_i];\n                collectTableSubscribers(tblCache, updatedParts, queriesToSignal, deleteAffectedCacheEntries);\n            }\n        }\n        else {\n            for (var key in updatedParts) {\n                var parts = /^idb\\:\\/\\/(.*)\\/(.*)\\//.exec(key);\n                if (parts) {\n                    var dbName = parts[1], tableName = parts[2];\n                    var tblCache = cache[\"idb://\".concat(dbName, \"/\").concat(tableName)];\n                    if (tblCache)\n                        collectTableSubscribers(tblCache, updatedParts, queriesToSignal, deleteAffectedCacheEntries);\n                }\n            }\n        }\n        queriesToSignal.forEach(function (requery) { return requery(); });\n    }\n    function collectTableSubscribers(tblCache, updatedParts, outQueriesToSignal, deleteAffectedCacheEntries) {\n        var updatedEntryLists = [];\n        for (var _i = 0, _a = Object.entries(tblCache.queries.query); _i < _a.length; _i++) {\n            var _b = _a[_i], indexName = _b[0], entries = _b[1];\n            var filteredEntries = [];\n            for (var _c = 0, entries_1 = entries; _c < entries_1.length; _c++) {\n                var entry = entries_1[_c];\n                if (obsSetsOverlap(updatedParts, entry.obsSet)) {\n                    entry.subscribers.forEach(function (requery) { return outQueriesToSignal.add(requery); });\n                }\n                else if (deleteAffectedCacheEntries) {\n                    filteredEntries.push(entry);\n                }\n            }\n            if (deleteAffectedCacheEntries)\n                updatedEntryLists.push([indexName, filteredEntries]);\n        }\n        if (deleteAffectedCacheEntries) {\n            for (var _d = 0, updatedEntryLists_1 = updatedEntryLists; _d < updatedEntryLists_1.length; _d++) {\n                var _e = updatedEntryLists_1[_d], indexName = _e[0], filteredEntries = _e[1];\n                tblCache.queries.query[indexName] = filteredEntries;\n            }\n        }\n    }\n\n    function dexieOpen(db) {\n        var state = db._state;\n        var indexedDB = db._deps.indexedDB;\n        if (state.isBeingOpened || db.idbdb)\n            return state.dbReadyPromise.then(function () { return state.dbOpenError ?\n                rejection(state.dbOpenError) :\n                db; });\n        state.isBeingOpened = true;\n        state.dbOpenError = null;\n        state.openComplete = false;\n        var openCanceller = state.openCanceller;\n        var nativeVerToOpen = Math.round(db.verno * 10);\n        var schemaPatchMode = false;\n        function throwIfCancelled() {\n            if (state.openCanceller !== openCanceller)\n                throw new exceptions.DatabaseClosed('db.open() was cancelled');\n        }\n        var resolveDbReady = state.dbReadyResolve,\n        upgradeTransaction = null, wasCreated = false;\n        var tryOpenDB = function () { return new DexiePromise(function (resolve, reject) {\n            throwIfCancelled();\n            if (!indexedDB)\n                throw new exceptions.MissingAPI();\n            var dbName = db.name;\n            var req = state.autoSchema || !nativeVerToOpen ?\n                indexedDB.open(dbName) :\n                indexedDB.open(dbName, nativeVerToOpen);\n            if (!req)\n                throw new exceptions.MissingAPI();\n            req.onerror = eventRejectHandler(reject);\n            req.onblocked = wrap(db._fireOnBlocked);\n            req.onupgradeneeded = wrap(function (e) {\n                upgradeTransaction = req.transaction;\n                if (state.autoSchema && !db._options.allowEmptyDB) {\n                    req.onerror = preventDefault;\n                    upgradeTransaction.abort();\n                    req.result.close();\n                    var delreq = indexedDB.deleteDatabase(dbName);\n                    delreq.onsuccess = delreq.onerror = wrap(function () {\n                        reject(new exceptions.NoSuchDatabase(\"Database \".concat(dbName, \" doesnt exist\")));\n                    });\n                }\n                else {\n                    upgradeTransaction.onerror = eventRejectHandler(reject);\n                    var oldVer = e.oldVersion > Math.pow(2, 62) ? 0 : e.oldVersion;\n                    wasCreated = oldVer < 1;\n                    db.idbdb = req.result;\n                    if (schemaPatchMode) {\n                        patchCurrentVersion(db, upgradeTransaction);\n                    }\n                    runUpgraders(db, oldVer / 10, upgradeTransaction, reject);\n                }\n            }, reject);\n            req.onsuccess = wrap(function () {\n                upgradeTransaction = null;\n                var idbdb = db.idbdb = req.result;\n                var objectStoreNames = slice(idbdb.objectStoreNames);\n                if (objectStoreNames.length > 0)\n                    try {\n                        var tmpTrans = idbdb.transaction(safariMultiStoreFix(objectStoreNames), 'readonly');\n                        if (state.autoSchema)\n                            readGlobalSchema(db, idbdb, tmpTrans);\n                        else {\n                            adjustToExistingIndexNames(db, db._dbSchema, tmpTrans);\n                            if (!verifyInstalledSchema(db, tmpTrans) && !schemaPatchMode) {\n                                console.warn(\"Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Dexie will add missing parts and increment native version number to workaround this.\");\n                                idbdb.close();\n                                nativeVerToOpen = idbdb.version + 1;\n                                schemaPatchMode = true;\n                                return resolve(tryOpenDB());\n                            }\n                        }\n                        generateMiddlewareStacks(db, tmpTrans);\n                    }\n                    catch (e) {\n                    }\n                connections.push(db);\n                idbdb.onversionchange = wrap(function (ev) {\n                    state.vcFired = true;\n                    db.on(\"versionchange\").fire(ev);\n                });\n                idbdb.onclose = wrap(function (ev) {\n                    db.on(\"close\").fire(ev);\n                });\n                if (wasCreated)\n                    _onDatabaseCreated(db._deps, dbName);\n                resolve();\n            }, reject);\n        }).catch(function (err) {\n            switch (err === null || err === void 0 ? void 0 : err.name) {\n                case \"UnknownError\":\n                    if (state.PR1398_maxLoop > 0) {\n                        state.PR1398_maxLoop--;\n                        console.warn('Dexie: Workaround for Chrome UnknownError on open()');\n                        return tryOpenDB();\n                    }\n                    break;\n                case \"VersionError\":\n                    if (nativeVerToOpen > 0) {\n                        nativeVerToOpen = 0;\n                        return tryOpenDB();\n                    }\n                    break;\n            }\n            return DexiePromise.reject(err);\n        }); };\n        return DexiePromise.race([\n            openCanceller,\n            (typeof navigator === 'undefined' ? DexiePromise.resolve() : idbReady()).then(tryOpenDB)\n        ]).then(function () {\n            throwIfCancelled();\n            state.onReadyBeingFired = [];\n            return DexiePromise.resolve(vip(function () { return db.on.ready.fire(db.vip); })).then(function fireRemainders() {\n                if (state.onReadyBeingFired.length > 0) {\n                    var remainders_1 = state.onReadyBeingFired.reduce(promisableChain, nop);\n                    state.onReadyBeingFired = [];\n                    return DexiePromise.resolve(vip(function () { return remainders_1(db.vip); })).then(fireRemainders);\n                }\n            });\n        }).finally(function () {\n            if (state.openCanceller === openCanceller) {\n                state.onReadyBeingFired = null;\n                state.isBeingOpened = false;\n            }\n        }).catch(function (err) {\n            state.dbOpenError = err;\n            try {\n                upgradeTransaction && upgradeTransaction.abort();\n            }\n            catch (_a) { }\n            if (openCanceller === state.openCanceller) {\n                db._close();\n            }\n            return rejection(err);\n        }).finally(function () {\n            state.openComplete = true;\n            resolveDbReady();\n        }).then(function () {\n            if (wasCreated) {\n                var everything_1 = {};\n                db.tables.forEach(function (table) {\n                    table.schema.indexes.forEach(function (idx) {\n                        if (idx.name)\n                            everything_1[\"idb://\".concat(db.name, \"/\").concat(table.name, \"/\").concat(idx.name)] = new RangeSet(-Infinity, [[[]]]);\n                    });\n                    everything_1[\"idb://\".concat(db.name, \"/\").concat(table.name, \"/\")] = everything_1[\"idb://\".concat(db.name, \"/\").concat(table.name, \"/:dels\")] = new RangeSet(-Infinity, [[[]]]);\n                });\n                globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME).fire(everything_1);\n                signalSubscribersNow(everything_1, true);\n            }\n            return db;\n        });\n    }\n\n    function awaitIterator(iterator) {\n        var callNext = function (result) { return iterator.next(result); }, doThrow = function (error) { return iterator.throw(error); }, onSuccess = step(callNext), onError = step(doThrow);\n        function step(getNext) {\n            return function (val) {\n                var next = getNext(val), value = next.value;\n                return next.done ? value :\n                    (!value || typeof value.then !== 'function' ?\n                        isArray(value) ? Promise.all(value).then(onSuccess, onError) : onSuccess(value) :\n                        value.then(onSuccess, onError));\n            };\n        }\n        return step(callNext)();\n    }\n\n    function extractTransactionArgs(mode, _tableArgs_, scopeFunc) {\n        var i = arguments.length;\n        if (i < 2)\n            throw new exceptions.InvalidArgument(\"Too few arguments\");\n        var args = new Array(i - 1);\n        while (--i)\n            args[i - 1] = arguments[i];\n        scopeFunc = args.pop();\n        var tables = flatten(args);\n        return [mode, tables, scopeFunc];\n    }\n    function enterTransactionScope(db, mode, storeNames, parentTransaction, scopeFunc) {\n        return DexiePromise.resolve().then(function () {\n            var transless = PSD.transless || PSD;\n            var trans = db._createTransaction(mode, storeNames, db._dbSchema, parentTransaction);\n            trans.explicit = true;\n            var zoneProps = {\n                trans: trans,\n                transless: transless\n            };\n            if (parentTransaction) {\n                trans.idbtrans = parentTransaction.idbtrans;\n            }\n            else {\n                try {\n                    trans.create();\n                    trans.idbtrans._explicit = true;\n                    db._state.PR1398_maxLoop = 3;\n                }\n                catch (ex) {\n                    if (ex.name === errnames.InvalidState && db.isOpen() && --db._state.PR1398_maxLoop > 0) {\n                        console.warn('Dexie: Need to reopen db');\n                        db.close({ disableAutoOpen: false });\n                        return db.open().then(function () { return enterTransactionScope(db, mode, storeNames, null, scopeFunc); });\n                    }\n                    return rejection(ex);\n                }\n            }\n            var scopeFuncIsAsync = isAsyncFunction(scopeFunc);\n            if (scopeFuncIsAsync) {\n                incrementExpectedAwaits();\n            }\n            var returnValue;\n            var promiseFollowed = DexiePromise.follow(function () {\n                returnValue = scopeFunc.call(trans, trans);\n                if (returnValue) {\n                    if (scopeFuncIsAsync) {\n                        var decrementor = decrementExpectedAwaits.bind(null, null);\n                        returnValue.then(decrementor, decrementor);\n                    }\n                    else if (typeof returnValue.next === 'function' && typeof returnValue.throw === 'function') {\n                        returnValue = awaitIterator(returnValue);\n                    }\n                }\n            }, zoneProps);\n            return (returnValue && typeof returnValue.then === 'function' ?\n                DexiePromise.resolve(returnValue).then(function (x) { return trans.active ?\n                    x\n                    : rejection(new exceptions.PrematureCommit(\"Transaction committed too early. See http://bit.ly/2kdckMn\")); })\n                : promiseFollowed.then(function () { return returnValue; })).then(function (x) {\n                if (parentTransaction)\n                    trans._resolve();\n                return trans._completion.then(function () { return x; });\n            }).catch(function (e) {\n                trans._reject(e);\n                return rejection(e);\n            });\n        });\n    }\n\n    function pad(a, value, count) {\n        var result = isArray(a) ? a.slice() : [a];\n        for (var i = 0; i < count; ++i)\n            result.push(value);\n        return result;\n    }\n    function createVirtualIndexMiddleware(down) {\n        return __assign(__assign({}, down), { table: function (tableName) {\n                var table = down.table(tableName);\n                var schema = table.schema;\n                var indexLookup = {};\n                var allVirtualIndexes = [];\n                function addVirtualIndexes(keyPath, keyTail, lowLevelIndex) {\n                    var keyPathAlias = getKeyPathAlias(keyPath);\n                    var indexList = (indexLookup[keyPathAlias] = indexLookup[keyPathAlias] || []);\n                    var keyLength = keyPath == null ? 0 : typeof keyPath === 'string' ? 1 : keyPath.length;\n                    var isVirtual = keyTail > 0;\n                    var virtualIndex = __assign(__assign({}, lowLevelIndex), { name: isVirtual\n                            ? \"\".concat(keyPathAlias, \"(virtual-from:\").concat(lowLevelIndex.name, \")\")\n                            : lowLevelIndex.name, lowLevelIndex: lowLevelIndex, isVirtual: isVirtual, keyTail: keyTail, keyLength: keyLength, extractKey: getKeyExtractor(keyPath), unique: !isVirtual && lowLevelIndex.unique });\n                    indexList.push(virtualIndex);\n                    if (!virtualIndex.isPrimaryKey) {\n                        allVirtualIndexes.push(virtualIndex);\n                    }\n                    if (keyLength > 1) {\n                        var virtualKeyPath = keyLength === 2 ?\n                            keyPath[0] :\n                            keyPath.slice(0, keyLength - 1);\n                        addVirtualIndexes(virtualKeyPath, keyTail + 1, lowLevelIndex);\n                    }\n                    indexList.sort(function (a, b) { return a.keyTail - b.keyTail; });\n                    return virtualIndex;\n                }\n                var primaryKey = addVirtualIndexes(schema.primaryKey.keyPath, 0, schema.primaryKey);\n                indexLookup[\":id\"] = [primaryKey];\n                for (var _i = 0, _a = schema.indexes; _i < _a.length; _i++) {\n                    var index = _a[_i];\n                    addVirtualIndexes(index.keyPath, 0, index);\n                }\n                function findBestIndex(keyPath) {\n                    var result = indexLookup[getKeyPathAlias(keyPath)];\n                    return result && result[0];\n                }\n                function translateRange(range, keyTail) {\n                    return {\n                        type: range.type === 1  ?\n                            2  :\n                            range.type,\n                        lower: pad(range.lower, range.lowerOpen ? down.MAX_KEY : down.MIN_KEY, keyTail),\n                        lowerOpen: true,\n                        upper: pad(range.upper, range.upperOpen ? down.MIN_KEY : down.MAX_KEY, keyTail),\n                        upperOpen: true\n                    };\n                }\n                function translateRequest(req) {\n                    var index = req.query.index;\n                    return index.isVirtual ? __assign(__assign({}, req), { query: {\n                            index: index.lowLevelIndex,\n                            range: translateRange(req.query.range, index.keyTail)\n                        } }) : req;\n                }\n                var result = __assign(__assign({}, table), { schema: __assign(__assign({}, schema), { primaryKey: primaryKey, indexes: allVirtualIndexes, getIndexByKeyPath: findBestIndex }), count: function (req) {\n                        return table.count(translateRequest(req));\n                    }, query: function (req) {\n                        return table.query(translateRequest(req));\n                    }, openCursor: function (req) {\n                        var _a = req.query.index, keyTail = _a.keyTail, isVirtual = _a.isVirtual, keyLength = _a.keyLength;\n                        if (!isVirtual)\n                            return table.openCursor(req);\n                        function createVirtualCursor(cursor) {\n                            function _continue(key) {\n                                key != null ?\n                                    cursor.continue(pad(key, req.reverse ? down.MAX_KEY : down.MIN_KEY, keyTail)) :\n                                    req.unique ?\n                                        cursor.continue(cursor.key.slice(0, keyLength)\n                                            .concat(req.reverse\n                                            ? down.MIN_KEY\n                                            : down.MAX_KEY, keyTail)) :\n                                        cursor.continue();\n                            }\n                            var virtualCursor = Object.create(cursor, {\n                                continue: { value: _continue },\n                                continuePrimaryKey: {\n                                    value: function (key, primaryKey) {\n                                        cursor.continuePrimaryKey(pad(key, down.MAX_KEY, keyTail), primaryKey);\n                                    }\n                                },\n                                primaryKey: {\n                                    get: function () {\n                                        return cursor.primaryKey;\n                                    }\n                                },\n                                key: {\n                                    get: function () {\n                                        var key = cursor.key;\n                                        return keyLength === 1 ?\n                                            key[0] :\n                                            key.slice(0, keyLength);\n                                    }\n                                },\n                                value: {\n                                    get: function () {\n                                        return cursor.value;\n                                    }\n                                }\n                            });\n                            return virtualCursor;\n                        }\n                        return table.openCursor(translateRequest(req))\n                            .then(function (cursor) { return cursor && createVirtualCursor(cursor); });\n                    } });\n                return result;\n            } });\n    }\n    var virtualIndexMiddleware = {\n        stack: \"dbcore\",\n        name: \"VirtualIndexMiddleware\",\n        level: 1,\n        create: createVirtualIndexMiddleware\n    };\n\n    function getObjectDiff(a, b, rv, prfx) {\n        rv = rv || {};\n        prfx = prfx || '';\n        keys(a).forEach(function (prop) {\n            if (!hasOwn(b, prop)) {\n                rv[prfx + prop] = undefined;\n            }\n            else {\n                var ap = a[prop], bp = b[prop];\n                if (typeof ap === 'object' && typeof bp === 'object' && ap && bp) {\n                    var apTypeName = toStringTag(ap);\n                    var bpTypeName = toStringTag(bp);\n                    if (apTypeName !== bpTypeName) {\n                        rv[prfx + prop] = b[prop];\n                    }\n                    else if (apTypeName === 'Object') {\n                        getObjectDiff(ap, bp, rv, prfx + prop + '.');\n                    }\n                    else if (ap !== bp) {\n                        rv[prfx + prop] = b[prop];\n                    }\n                }\n                else if (ap !== bp)\n                    rv[prfx + prop] = b[prop];\n            }\n        });\n        keys(b).forEach(function (prop) {\n            if (!hasOwn(a, prop)) {\n                rv[prfx + prop] = b[prop];\n            }\n        });\n        return rv;\n    }\n\n    function getEffectiveKeys(primaryKey, req) {\n        if (req.type === 'delete')\n            return req.keys;\n        return req.keys || req.values.map(primaryKey.extractKey);\n    }\n\n    var hooksMiddleware = {\n        stack: \"dbcore\",\n        name: \"HooksMiddleware\",\n        level: 2,\n        create: function (downCore) { return (__assign(__assign({}, downCore), { table: function (tableName) {\n                var downTable = downCore.table(tableName);\n                var primaryKey = downTable.schema.primaryKey;\n                var tableMiddleware = __assign(__assign({}, downTable), { mutate: function (req) {\n                        var dxTrans = PSD.trans;\n                        var _a = dxTrans.table(tableName).hook, deleting = _a.deleting, creating = _a.creating, updating = _a.updating;\n                        switch (req.type) {\n                            case 'add':\n                                if (creating.fire === nop)\n                                    break;\n                                return dxTrans._promise('readwrite', function () { return addPutOrDelete(req); }, true);\n                            case 'put':\n                                if (creating.fire === nop && updating.fire === nop)\n                                    break;\n                                return dxTrans._promise('readwrite', function () { return addPutOrDelete(req); }, true);\n                            case 'delete':\n                                if (deleting.fire === nop)\n                                    break;\n                                return dxTrans._promise('readwrite', function () { return addPutOrDelete(req); }, true);\n                            case 'deleteRange':\n                                if (deleting.fire === nop)\n                                    break;\n                                return dxTrans._promise('readwrite', function () { return deleteRange(req); }, true);\n                        }\n                        return downTable.mutate(req);\n                        function addPutOrDelete(req) {\n                            var dxTrans = PSD.trans;\n                            var keys = req.keys || getEffectiveKeys(primaryKey, req);\n                            if (!keys)\n                                throw new Error(\"Keys missing\");\n                            req = req.type === 'add' || req.type === 'put' ? __assign(__assign({}, req), { keys: keys }) : __assign({}, req);\n                            if (req.type !== 'delete')\n                                req.values = __spreadArray([], req.values, true);\n                            if (req.keys)\n                                req.keys = __spreadArray([], req.keys, true);\n                            return getExistingValues(downTable, req, keys).then(function (existingValues) {\n                                var contexts = keys.map(function (key, i) {\n                                    var existingValue = existingValues[i];\n                                    var ctx = { onerror: null, onsuccess: null };\n                                    if (req.type === 'delete') {\n                                        deleting.fire.call(ctx, key, existingValue, dxTrans);\n                                    }\n                                    else if (req.type === 'add' || existingValue === undefined) {\n                                        var generatedPrimaryKey = creating.fire.call(ctx, key, req.values[i], dxTrans);\n                                        if (key == null && generatedPrimaryKey != null) {\n                                            key = generatedPrimaryKey;\n                                            req.keys[i] = key;\n                                            if (!primaryKey.outbound) {\n                                                setByKeyPath(req.values[i], primaryKey.keyPath, key);\n                                            }\n                                        }\n                                    }\n                                    else {\n                                        var objectDiff = getObjectDiff(existingValue, req.values[i]);\n                                        var additionalChanges_1 = updating.fire.call(ctx, objectDiff, key, existingValue, dxTrans);\n                                        if (additionalChanges_1) {\n                                            var requestedValue_1 = req.values[i];\n                                            Object.keys(additionalChanges_1).forEach(function (keyPath) {\n                                                if (hasOwn(requestedValue_1, keyPath)) {\n                                                    requestedValue_1[keyPath] = additionalChanges_1[keyPath];\n                                                }\n                                                else {\n                                                    setByKeyPath(requestedValue_1, keyPath, additionalChanges_1[keyPath]);\n                                                }\n                                            });\n                                        }\n                                    }\n                                    return ctx;\n                                });\n                                return downTable.mutate(req).then(function (_a) {\n                                    var failures = _a.failures, results = _a.results, numFailures = _a.numFailures, lastResult = _a.lastResult;\n                                    for (var i = 0; i < keys.length; ++i) {\n                                        var primKey = results ? results[i] : keys[i];\n                                        var ctx = contexts[i];\n                                        if (primKey == null) {\n                                            ctx.onerror && ctx.onerror(failures[i]);\n                                        }\n                                        else {\n                                            ctx.onsuccess && ctx.onsuccess(req.type === 'put' && existingValues[i] ?\n                                                req.values[i] :\n                                                primKey\n                                            );\n                                        }\n                                    }\n                                    return { failures: failures, results: results, numFailures: numFailures, lastResult: lastResult };\n                                }).catch(function (error) {\n                                    contexts.forEach(function (ctx) { return ctx.onerror && ctx.onerror(error); });\n                                    return Promise.reject(error);\n                                });\n                            });\n                        }\n                        function deleteRange(req) {\n                            return deleteNextChunk(req.trans, req.range, 10000);\n                        }\n                        function deleteNextChunk(trans, range, limit) {\n                            return downTable.query({ trans: trans, values: false, query: { index: primaryKey, range: range }, limit: limit })\n                                .then(function (_a) {\n                                var result = _a.result;\n                                return addPutOrDelete({ type: 'delete', keys: result, trans: trans }).then(function (res) {\n                                    if (res.numFailures > 0)\n                                        return Promise.reject(res.failures[0]);\n                                    if (result.length < limit) {\n                                        return { failures: [], numFailures: 0, lastResult: undefined };\n                                    }\n                                    else {\n                                        return deleteNextChunk(trans, __assign(__assign({}, range), { lower: result[result.length - 1], lowerOpen: true }), limit);\n                                    }\n                                });\n                            });\n                        }\n                    } });\n                return tableMiddleware;\n            } })); }\n    };\n    function getExistingValues(table, req, effectiveKeys) {\n        return req.type === \"add\"\n            ? Promise.resolve([])\n            : table.getMany({ trans: req.trans, keys: effectiveKeys, cache: \"immutable\" });\n    }\n\n    function getFromTransactionCache(keys, cache, clone) {\n        try {\n            if (!cache)\n                return null;\n            if (cache.keys.length < keys.length)\n                return null;\n            var result = [];\n            for (var i = 0, j = 0; i < cache.keys.length && j < keys.length; ++i) {\n                if (cmp(cache.keys[i], keys[j]) !== 0)\n                    continue;\n                result.push(clone ? deepClone(cache.values[i]) : cache.values[i]);\n                ++j;\n            }\n            return result.length === keys.length ? result : null;\n        }\n        catch (_a) {\n            return null;\n        }\n    }\n    var cacheExistingValuesMiddleware = {\n        stack: \"dbcore\",\n        level: -1,\n        create: function (core) {\n            return {\n                table: function (tableName) {\n                    var table = core.table(tableName);\n                    return __assign(__assign({}, table), { getMany: function (req) {\n                            if (!req.cache) {\n                                return table.getMany(req);\n                            }\n                            var cachedResult = getFromTransactionCache(req.keys, req.trans[\"_cache\"], req.cache === \"clone\");\n                            if (cachedResult) {\n                                return DexiePromise.resolve(cachedResult);\n                            }\n                            return table.getMany(req).then(function (res) {\n                                req.trans[\"_cache\"] = {\n                                    keys: req.keys,\n                                    values: req.cache === \"clone\" ? deepClone(res) : res,\n                                };\n                                return res;\n                            });\n                        }, mutate: function (req) {\n                            if (req.type !== \"add\")\n                                req.trans[\"_cache\"] = null;\n                            return table.mutate(req);\n                        } });\n                },\n            };\n        },\n    };\n\n    function isCachableContext(ctx, table) {\n        return (ctx.trans.mode === 'readonly' &&\n            !!ctx.subscr &&\n            !ctx.trans.explicit &&\n            ctx.trans.db._options.cache !== 'disabled' &&\n            !table.schema.primaryKey.outbound);\n    }\n\n    function isCachableRequest(type, req) {\n        switch (type) {\n            case 'query':\n                return req.values && !req.unique;\n            case 'get':\n                return false;\n            case 'getMany':\n                return false;\n            case 'count':\n                return false;\n            case 'openCursor':\n                return false;\n        }\n    }\n\n    var observabilityMiddleware = {\n        stack: \"dbcore\",\n        level: 0,\n        name: \"Observability\",\n        create: function (core) {\n            var dbName = core.schema.name;\n            var FULL_RANGE = new RangeSet(core.MIN_KEY, core.MAX_KEY);\n            return __assign(__assign({}, core), { transaction: function (stores, mode, options) {\n                    if (PSD.subscr && mode !== 'readonly') {\n                        throw new exceptions.ReadOnly(\"Readwrite transaction in liveQuery context. Querier source: \".concat(PSD.querier));\n                    }\n                    return core.transaction(stores, mode, options);\n                }, table: function (tableName) {\n                    var table = core.table(tableName);\n                    var schema = table.schema;\n                    var primaryKey = schema.primaryKey, indexes = schema.indexes;\n                    var extractKey = primaryKey.extractKey, outbound = primaryKey.outbound;\n                    var indexesWithAutoIncPK = primaryKey.autoIncrement && indexes.filter(function (index) { return index.compound && index.keyPath.includes(primaryKey.keyPath); });\n                    var tableClone = __assign(__assign({}, table), { mutate: function (req) {\n                            var _a, _b;\n                            var trans = req.trans;\n                            var mutatedParts = req.mutatedParts || (req.mutatedParts = {});\n                            var getRangeSet = function (indexName) {\n                                var part = \"idb://\".concat(dbName, \"/\").concat(tableName, \"/\").concat(indexName);\n                                return (mutatedParts[part] ||\n                                    (mutatedParts[part] = new RangeSet()));\n                            };\n                            var pkRangeSet = getRangeSet(\"\");\n                            var delsRangeSet = getRangeSet(\":dels\");\n                            var type = req.type;\n                            var _c = req.type === \"deleteRange\"\n                                ? [req.range]\n                                : req.type === \"delete\"\n                                    ? [req.keys]\n                                    : req.values.length < 50\n                                        ? [getEffectiveKeys(primaryKey, req).filter(function (id) { return id; }), req.values]\n                                        : [], keys = _c[0], newObjs = _c[1];\n                            var oldCache = req.trans[\"_cache\"];\n                            if (isArray(keys)) {\n                                pkRangeSet.addKeys(keys);\n                                var oldObjs = type === 'delete' || keys.length === newObjs.length ? getFromTransactionCache(keys, oldCache) : null;\n                                if (!oldObjs) {\n                                    delsRangeSet.addKeys(keys);\n                                }\n                                if (oldObjs || newObjs) {\n                                    trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs);\n                                }\n                            }\n                            else if (keys) {\n                                var range = {\n                                    from: (_a = keys.lower) !== null && _a !== void 0 ? _a : core.MIN_KEY,\n                                    to: (_b = keys.upper) !== null && _b !== void 0 ? _b : core.MAX_KEY\n                                };\n                                delsRangeSet.add(range);\n                                pkRangeSet.add(range);\n                            }\n                            else {\n                                pkRangeSet.add(FULL_RANGE);\n                                delsRangeSet.add(FULL_RANGE);\n                                schema.indexes.forEach(function (idx) { return getRangeSet(idx.name).add(FULL_RANGE); });\n                            }\n                            return table.mutate(req).then(function (res) {\n                                if (keys && (req.type === 'add' || req.type === 'put')) {\n                                    pkRangeSet.addKeys(res.results);\n                                    if (indexesWithAutoIncPK) {\n                                        indexesWithAutoIncPK.forEach(function (idx) {\n                                            var idxVals = req.values.map(function (v) { return idx.extractKey(v); });\n                                            var pkPos = idx.keyPath.findIndex(function (prop) { return prop === primaryKey.keyPath; });\n                                            for (var i = 0, len = res.results.length; i < len; ++i) {\n                                                idxVals[i][pkPos] = res.results[i];\n                                            }\n                                            getRangeSet(idx.name).addKeys(idxVals);\n                                        });\n                                    }\n                                }\n                                trans.mutatedParts = extendObservabilitySet(trans.mutatedParts || {}, mutatedParts);\n                                return res;\n                            });\n                        } });\n                    var getRange = function (_a) {\n                        var _b, _c;\n                        var _d = _a.query, index = _d.index, range = _d.range;\n                        return [\n                            index,\n                            new RangeSet((_b = range.lower) !== null && _b !== void 0 ? _b : core.MIN_KEY, (_c = range.upper) !== null && _c !== void 0 ? _c : core.MAX_KEY),\n                        ];\n                    };\n                    var readSubscribers = {\n                        get: function (req) { return [primaryKey, new RangeSet(req.key)]; },\n                        getMany: function (req) { return [primaryKey, new RangeSet().addKeys(req.keys)]; },\n                        count: getRange,\n                        query: getRange,\n                        openCursor: getRange,\n                    };\n                    keys(readSubscribers).forEach(function (method) {\n                        tableClone[method] = function (req) {\n                            var subscr = PSD.subscr;\n                            var isLiveQuery = !!subscr;\n                            var cachable = isCachableContext(PSD, table) && isCachableRequest(method, req);\n                            var obsSet = cachable\n                                ? req.obsSet = {}\n                                : subscr;\n                            if (isLiveQuery) {\n                                var getRangeSet = function (indexName) {\n                                    var part = \"idb://\".concat(dbName, \"/\").concat(tableName, \"/\").concat(indexName);\n                                    return (obsSet[part] ||\n                                        (obsSet[part] = new RangeSet()));\n                                };\n                                var pkRangeSet_1 = getRangeSet(\"\");\n                                var delsRangeSet_1 = getRangeSet(\":dels\");\n                                var _a = readSubscribers[method](req), queriedIndex = _a[0], queriedRanges = _a[1];\n                                if (method === 'query' && queriedIndex.isPrimaryKey && !req.values) {\n                                    delsRangeSet_1.add(queriedRanges);\n                                }\n                                else {\n                                    getRangeSet(queriedIndex.name || \"\").add(queriedRanges);\n                                }\n                                if (!queriedIndex.isPrimaryKey) {\n                                    if (method === \"count\") {\n                                        delsRangeSet_1.add(FULL_RANGE);\n                                    }\n                                    else {\n                                        var keysPromise_1 = method === \"query\" &&\n                                            outbound &&\n                                            req.values &&\n                                            table.query(__assign(__assign({}, req), { values: false }));\n                                        return table[method].apply(this, arguments).then(function (res) {\n                                            if (method === \"query\") {\n                                                if (outbound && req.values) {\n                                                    return keysPromise_1.then(function (_a) {\n                                                        var resultingKeys = _a.result;\n                                                        pkRangeSet_1.addKeys(resultingKeys);\n                                                        return res;\n                                                    });\n                                                }\n                                                var pKeys = req.values\n                                                    ? res.result.map(extractKey)\n                                                    : res.result;\n                                                if (req.values) {\n                                                    pkRangeSet_1.addKeys(pKeys);\n                                                }\n                                                else {\n                                                    delsRangeSet_1.addKeys(pKeys);\n                                                }\n                                            }\n                                            else if (method === \"openCursor\") {\n                                                var cursor_1 = res;\n                                                var wantValues_1 = req.values;\n                                                return (cursor_1 &&\n                                                    Object.create(cursor_1, {\n                                                        key: {\n                                                            get: function () {\n                                                                delsRangeSet_1.addKey(cursor_1.primaryKey);\n                                                                return cursor_1.key;\n                                                            },\n                                                        },\n                                                        primaryKey: {\n                                                            get: function () {\n                                                                var pkey = cursor_1.primaryKey;\n                                                                delsRangeSet_1.addKey(pkey);\n                                                                return pkey;\n                                                            },\n                                                        },\n                                                        value: {\n                                                            get: function () {\n                                                                wantValues_1 && pkRangeSet_1.addKey(cursor_1.primaryKey);\n                                                                return cursor_1.value;\n                                                            },\n                                                        },\n                                                    }));\n                                            }\n                                            return res;\n                                        });\n                                    }\n                                }\n                            }\n                            return table[method].apply(this, arguments);\n                        };\n                    });\n                    return tableClone;\n                } });\n        },\n    };\n    function trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs) {\n        function addAffectedIndex(ix) {\n            var rangeSet = getRangeSet(ix.name || \"\");\n            function extractKey(obj) {\n                return obj != null ? ix.extractKey(obj) : null;\n            }\n            var addKeyOrKeys = function (key) { return ix.multiEntry && isArray(key)\n                ? key.forEach(function (key) { return rangeSet.addKey(key); })\n                : rangeSet.addKey(key); };\n            (oldObjs || newObjs).forEach(function (_, i) {\n                var oldKey = oldObjs && extractKey(oldObjs[i]);\n                var newKey = newObjs && extractKey(newObjs[i]);\n                if (cmp(oldKey, newKey) !== 0) {\n                    if (oldKey != null)\n                        addKeyOrKeys(oldKey);\n                    if (newKey != null)\n                        addKeyOrKeys(newKey);\n                }\n            });\n        }\n        schema.indexes.forEach(addAffectedIndex);\n    }\n\n    function adjustOptimisticFromFailures(tblCache, req, res) {\n        if (res.numFailures === 0)\n            return req;\n        if (req.type === 'deleteRange') {\n            return null;\n        }\n        var numBulkOps = req.keys\n            ? req.keys.length\n            : 'values' in req && req.values\n                ? req.values.length\n                : 1;\n        if (res.numFailures === numBulkOps) {\n            return null;\n        }\n        var clone = __assign({}, req);\n        if (isArray(clone.keys)) {\n            clone.keys = clone.keys.filter(function (_, i) { return !(i in res.failures); });\n        }\n        if ('values' in clone && isArray(clone.values)) {\n            clone.values = clone.values.filter(function (_, i) { return !(i in res.failures); });\n        }\n        return clone;\n    }\n\n    function isAboveLower(key, range) {\n        return range.lower === undefined\n            ? true\n            : range.lowerOpen\n                ? cmp(key, range.lower) > 0\n                : cmp(key, range.lower) >= 0;\n    }\n    function isBelowUpper(key, range) {\n        return range.upper === undefined\n            ? true\n            : range.upperOpen\n                ? cmp(key, range.upper) < 0\n                : cmp(key, range.upper) <= 0;\n    }\n    function isWithinRange(key, range) {\n        return isAboveLower(key, range) && isBelowUpper(key, range);\n    }\n\n    function applyOptimisticOps(result, req, ops, table, cacheEntry, immutable) {\n        if (!ops || ops.length === 0)\n            return result;\n        var index = req.query.index;\n        var multiEntry = index.multiEntry;\n        var queryRange = req.query.range;\n        var primaryKey = table.schema.primaryKey;\n        var extractPrimKey = primaryKey.extractKey;\n        var extractIndex = index.extractKey;\n        var extractLowLevelIndex = (index.lowLevelIndex || index).extractKey;\n        var finalResult = ops.reduce(function (result, op) {\n            var modifedResult = result;\n            var includedValues = [];\n            if (op.type === 'add' || op.type === 'put') {\n                var includedPKs = new RangeSet();\n                for (var i = op.values.length - 1; i >= 0; --i) {\n                    var value = op.values[i];\n                    var pk = extractPrimKey(value);\n                    if (includedPKs.hasKey(pk))\n                        continue;\n                    var key = extractIndex(value);\n                    if (multiEntry && isArray(key)\n                        ? key.some(function (k) { return isWithinRange(k, queryRange); })\n                        : isWithinRange(key, queryRange)) {\n                        includedPKs.addKey(pk);\n                        includedValues.push(value);\n                    }\n                }\n            }\n            switch (op.type) {\n                case 'add': {\n                    var existingKeys_1 = new RangeSet().addKeys(req.values ? result.map(function (v) { return extractPrimKey(v); }) : result);\n                    modifedResult = result.concat(req.values\n                        ? includedValues.filter(function (v) {\n                            var key = extractPrimKey(v);\n                            if (existingKeys_1.hasKey(key))\n                                return false;\n                            existingKeys_1.addKey(key);\n                            return true;\n                        })\n                        : includedValues\n                            .map(function (v) { return extractPrimKey(v); })\n                            .filter(function (k) {\n                            if (existingKeys_1.hasKey(k))\n                                return false;\n                            existingKeys_1.addKey(k);\n                            return true;\n                        }));\n                    break;\n                }\n                case 'put': {\n                    var keySet_1 = new RangeSet().addKeys(op.values.map(function (v) { return extractPrimKey(v); }));\n                    modifedResult = result\n                        .filter(\n                    function (item) { return !keySet_1.hasKey(req.values ? extractPrimKey(item) : item); })\n                        .concat(\n                    req.values\n                        ? includedValues\n                        : includedValues.map(function (v) { return extractPrimKey(v); }));\n                    break;\n                }\n                case 'delete':\n                    var keysToDelete_1 = new RangeSet().addKeys(op.keys);\n                    modifedResult = result.filter(function (item) {\n                        return !keysToDelete_1.hasKey(req.values ? extractPrimKey(item) : item);\n                    });\n                    break;\n                case 'deleteRange':\n                    var range_1 = op.range;\n                    modifedResult = result.filter(function (item) { return !isWithinRange(extractPrimKey(item), range_1); });\n                    break;\n            }\n            return modifedResult;\n        }, result);\n        if (finalResult === result)\n            return result;\n        finalResult.sort(function (a, b) {\n            return cmp(extractLowLevelIndex(a), extractLowLevelIndex(b)) ||\n                cmp(extractPrimKey(a), extractPrimKey(b));\n        });\n        if (req.limit && req.limit < Infinity) {\n            if (finalResult.length > req.limit) {\n                finalResult.length = req.limit;\n            }\n            else if (result.length === req.limit && finalResult.length < req.limit) {\n                cacheEntry.dirty = true;\n            }\n        }\n        return immutable ? Object.freeze(finalResult) : finalResult;\n    }\n\n    function areRangesEqual(r1, r2) {\n        return (cmp(r1.lower, r2.lower) === 0 &&\n            cmp(r1.upper, r2.upper) === 0 &&\n            !!r1.lowerOpen === !!r2.lowerOpen &&\n            !!r1.upperOpen === !!r2.upperOpen);\n    }\n\n    function compareLowers(lower1, lower2, lowerOpen1, lowerOpen2) {\n        if (lower1 === undefined)\n            return lower2 !== undefined ? -1 : 0;\n        if (lower2 === undefined)\n            return 1;\n        var c = cmp(lower1, lower2);\n        if (c === 0) {\n            if (lowerOpen1 && lowerOpen2)\n                return 0;\n            if (lowerOpen1)\n                return 1;\n            if (lowerOpen2)\n                return -1;\n        }\n        return c;\n    }\n    function compareUppers(upper1, upper2, upperOpen1, upperOpen2) {\n        if (upper1 === undefined)\n            return upper2 !== undefined ? 1 : 0;\n        if (upper2 === undefined)\n            return -1;\n        var c = cmp(upper1, upper2);\n        if (c === 0) {\n            if (upperOpen1 && upperOpen2)\n                return 0;\n            if (upperOpen1)\n                return -1;\n            if (upperOpen2)\n                return 1;\n        }\n        return c;\n    }\n    function isSuperRange(r1, r2) {\n        return (compareLowers(r1.lower, r2.lower, r1.lowerOpen, r2.lowerOpen) <= 0 &&\n            compareUppers(r1.upper, r2.upper, r1.upperOpen, r2.upperOpen) >= 0);\n    }\n\n    function findCompatibleQuery(dbName, tableName, type, req) {\n        var tblCache = cache[\"idb://\".concat(dbName, \"/\").concat(tableName)];\n        if (!tblCache)\n            return [];\n        var queries = tblCache.queries[type];\n        if (!queries)\n            return [null, false, tblCache, null];\n        var indexName = req.query ? req.query.index.name : null;\n        var entries = queries[indexName || ''];\n        if (!entries)\n            return [null, false, tblCache, null];\n        switch (type) {\n            case 'query':\n                var equalEntry = entries.find(function (entry) {\n                    return entry.req.limit === req.limit &&\n                        entry.req.values === req.values &&\n                        areRangesEqual(entry.req.query.range, req.query.range);\n                });\n                if (equalEntry)\n                    return [\n                        equalEntry,\n                        true,\n                        tblCache,\n                        entries,\n                    ];\n                var superEntry = entries.find(function (entry) {\n                    var limit = 'limit' in entry.req ? entry.req.limit : Infinity;\n                    return (limit >= req.limit &&\n                        (req.values ? entry.req.values : true) &&\n                        isSuperRange(entry.req.query.range, req.query.range));\n                });\n                return [superEntry, false, tblCache, entries];\n            case 'count':\n                var countQuery = entries.find(function (entry) {\n                    return areRangesEqual(entry.req.query.range, req.query.range);\n                });\n                return [countQuery, !!countQuery, tblCache, entries];\n        }\n    }\n\n    function subscribeToCacheEntry(cacheEntry, container, requery, signal) {\n        cacheEntry.subscribers.add(requery);\n        signal.addEventListener(\"abort\", function () {\n            cacheEntry.subscribers.delete(requery);\n            if (cacheEntry.subscribers.size === 0) {\n                enqueForDeletion(cacheEntry, container);\n            }\n        });\n    }\n    function enqueForDeletion(cacheEntry, container) {\n        setTimeout(function () {\n            if (cacheEntry.subscribers.size === 0) {\n                delArrayItem(container, cacheEntry);\n            }\n        }, 3000);\n    }\n\n    var cacheMiddleware = {\n        stack: 'dbcore',\n        level: 0,\n        name: 'Cache',\n        create: function (core) {\n            var dbName = core.schema.name;\n            var coreMW = __assign(__assign({}, core), { transaction: function (stores, mode, options) {\n                    var idbtrans = core.transaction(stores, mode, options);\n                    if (mode === 'readwrite') {\n                        var ac_1 = new AbortController();\n                        var signal = ac_1.signal;\n                        var endTransaction = function (wasCommitted) { return function () {\n                            ac_1.abort();\n                            if (mode === 'readwrite') {\n                                var affectedSubscribers_1 = new Set();\n                                for (var _i = 0, stores_1 = stores; _i < stores_1.length; _i++) {\n                                    var storeName = stores_1[_i];\n                                    var tblCache = cache[\"idb://\".concat(dbName, \"/\").concat(storeName)];\n                                    if (tblCache) {\n                                        var table = core.table(storeName);\n                                        var ops = tblCache.optimisticOps.filter(function (op) { return op.trans === idbtrans; });\n                                        if (idbtrans._explicit && wasCommitted && idbtrans.mutatedParts) {\n                                            for (var _a = 0, _b = Object.values(tblCache.queries.query); _a < _b.length; _a++) {\n                                                var entries = _b[_a];\n                                                for (var _c = 0, _d = entries.slice(); _c < _d.length; _c++) {\n                                                    var entry = _d[_c];\n                                                    if (obsSetsOverlap(entry.obsSet, idbtrans.mutatedParts)) {\n                                                        delArrayItem(entries, entry);\n                                                        entry.subscribers.forEach(function (requery) { return affectedSubscribers_1.add(requery); });\n                                                    }\n                                                }\n                                            }\n                                        }\n                                        else if (ops.length > 0) {\n                                            tblCache.optimisticOps = tblCache.optimisticOps.filter(function (op) { return op.trans !== idbtrans; });\n                                            for (var _e = 0, _f = Object.values(tblCache.queries.query); _e < _f.length; _e++) {\n                                                var entries = _f[_e];\n                                                for (var _g = 0, _h = entries.slice(); _g < _h.length; _g++) {\n                                                    var entry = _h[_g];\n                                                    if (entry.res != null &&\n                                                        idbtrans.mutatedParts\n    ) {\n                                                        if (wasCommitted && !entry.dirty) {\n                                                            var freezeResults = Object.isFrozen(entry.res);\n                                                            var modRes = applyOptimisticOps(entry.res, entry.req, ops, table, entry, freezeResults);\n                                                            if (entry.dirty) {\n                                                                delArrayItem(entries, entry);\n                                                                entry.subscribers.forEach(function (requery) { return affectedSubscribers_1.add(requery); });\n                                                            }\n                                                            else if (modRes !== entry.res) {\n                                                                entry.res = modRes;\n                                                                entry.promise = DexiePromise.resolve({ result: modRes });\n                                                            }\n                                                        }\n                                                        else {\n                                                            if (entry.dirty) {\n                                                                delArrayItem(entries, entry);\n                                                            }\n                                                            entry.subscribers.forEach(function (requery) { return affectedSubscribers_1.add(requery); });\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                                affectedSubscribers_1.forEach(function (requery) { return requery(); });\n                            }\n                        }; };\n                        idbtrans.addEventListener('abort', endTransaction(false), {\n                            signal: signal,\n                        });\n                        idbtrans.addEventListener('error', endTransaction(false), {\n                            signal: signal,\n                        });\n                        idbtrans.addEventListener('complete', endTransaction(true), {\n                            signal: signal,\n                        });\n                    }\n                    return idbtrans;\n                }, table: function (tableName) {\n                    var downTable = core.table(tableName);\n                    var primKey = downTable.schema.primaryKey;\n                    var tableMW = __assign(__assign({}, downTable), { mutate: function (req) {\n                            var trans = PSD.trans;\n                            if (primKey.outbound ||\n                                trans.db._options.cache === 'disabled' ||\n                                trans.explicit ||\n                                trans.idbtrans.mode !== 'readwrite'\n                            ) {\n                                return downTable.mutate(req);\n                            }\n                            var tblCache = cache[\"idb://\".concat(dbName, \"/\").concat(tableName)];\n                            if (!tblCache)\n                                return downTable.mutate(req);\n                            var promise = downTable.mutate(req);\n                            if ((req.type === 'add' || req.type === 'put') && (req.values.length >= 50 || getEffectiveKeys(primKey, req).some(function (key) { return key == null; }))) {\n                                promise.then(function (res) {\n                                    var reqWithResolvedKeys = __assign(__assign({}, req), { values: req.values.map(function (value, i) {\n                                            var _a;\n                                            if (res.failures[i])\n                                                return value;\n                                            var valueWithKey = ((_a = primKey.keyPath) === null || _a === void 0 ? void 0 : _a.includes('.'))\n                                                ? deepClone(value)\n                                                : __assign({}, value);\n                                            setByKeyPath(valueWithKey, primKey.keyPath, res.results[i]);\n                                            return valueWithKey;\n                                        }) });\n                                    var adjustedReq = adjustOptimisticFromFailures(tblCache, reqWithResolvedKeys, res);\n                                    tblCache.optimisticOps.push(adjustedReq);\n                                    queueMicrotask(function () { return req.mutatedParts && signalSubscribersLazily(req.mutatedParts); });\n                                });\n                            }\n                            else {\n                                tblCache.optimisticOps.push(req);\n                                req.mutatedParts && signalSubscribersLazily(req.mutatedParts);\n                                promise.then(function (res) {\n                                    if (res.numFailures > 0) {\n                                        delArrayItem(tblCache.optimisticOps, req);\n                                        var adjustedReq = adjustOptimisticFromFailures(tblCache, req, res);\n                                        if (adjustedReq) {\n                                            tblCache.optimisticOps.push(adjustedReq);\n                                        }\n                                        req.mutatedParts && signalSubscribersLazily(req.mutatedParts);\n                                    }\n                                });\n                                promise.catch(function () {\n                                    delArrayItem(tblCache.optimisticOps, req);\n                                    req.mutatedParts && signalSubscribersLazily(req.mutatedParts);\n                                });\n                            }\n                            return promise;\n                        }, query: function (req) {\n                            var _a;\n                            if (!isCachableContext(PSD, downTable) || !isCachableRequest(\"query\", req))\n                                return downTable.query(req);\n                            var freezeResults = ((_a = PSD.trans) === null || _a === void 0 ? void 0 : _a.db._options.cache) === 'immutable';\n                            var _b = PSD, requery = _b.requery, signal = _b.signal;\n                            var _c = findCompatibleQuery(dbName, tableName, 'query', req), cacheEntry = _c[0], exactMatch = _c[1], tblCache = _c[2], container = _c[3];\n                            if (cacheEntry && exactMatch) {\n                                cacheEntry.obsSet = req.obsSet;\n                            }\n                            else {\n                                var promise = downTable.query(req).then(function (res) {\n                                    var result = res.result;\n                                    if (cacheEntry)\n                                        cacheEntry.res = result;\n                                    if (freezeResults) {\n                                        for (var i = 0, l = result.length; i < l; ++i) {\n                                            Object.freeze(result[i]);\n                                        }\n                                        Object.freeze(result);\n                                    }\n                                    else {\n                                        res.result = deepClone(result);\n                                    }\n                                    return res;\n                                }).catch(function (error) {\n                                    if (container && cacheEntry)\n                                        delArrayItem(container, cacheEntry);\n                                    return Promise.reject(error);\n                                });\n                                cacheEntry = {\n                                    obsSet: req.obsSet,\n                                    promise: promise,\n                                    subscribers: new Set(),\n                                    type: 'query',\n                                    req: req,\n                                    dirty: false,\n                                };\n                                if (container) {\n                                    container.push(cacheEntry);\n                                }\n                                else {\n                                    container = [cacheEntry];\n                                    if (!tblCache) {\n                                        tblCache = cache[\"idb://\".concat(dbName, \"/\").concat(tableName)] = {\n                                            queries: {\n                                                query: {},\n                                                count: {},\n                                            },\n                                            objs: new Map(),\n                                            optimisticOps: [],\n                                            unsignaledParts: {}\n                                        };\n                                    }\n                                    tblCache.queries.query[req.query.index.name || ''] = container;\n                                }\n                            }\n                            subscribeToCacheEntry(cacheEntry, container, requery, signal);\n                            return cacheEntry.promise.then(function (res) {\n                                return {\n                                    result: applyOptimisticOps(res.result, req, tblCache === null || tblCache === void 0 ? void 0 : tblCache.optimisticOps, downTable, cacheEntry, freezeResults),\n                                };\n                            });\n                        } });\n                    return tableMW;\n                } });\n            return coreMW;\n        },\n    };\n\n    function vipify(target, vipDb) {\n        return new Proxy(target, {\n            get: function (target, prop, receiver) {\n                if (prop === 'db')\n                    return vipDb;\n                return Reflect.get(target, prop, receiver);\n            }\n        });\n    }\n\n    var Dexie$1 =  (function () {\n        function Dexie(name, options) {\n            var _this = this;\n            this._middlewares = {};\n            this.verno = 0;\n            var deps = Dexie.dependencies;\n            this._options = options = __assign({\n                addons: Dexie.addons, autoOpen: true,\n                indexedDB: deps.indexedDB, IDBKeyRange: deps.IDBKeyRange, cache: 'cloned' }, options);\n            this._deps = {\n                indexedDB: options.indexedDB,\n                IDBKeyRange: options.IDBKeyRange\n            };\n            var addons = options.addons;\n            this._dbSchema = {};\n            this._versions = [];\n            this._storeNames = [];\n            this._allTables = {};\n            this.idbdb = null;\n            this._novip = this;\n            var state = {\n                dbOpenError: null,\n                isBeingOpened: false,\n                onReadyBeingFired: null,\n                openComplete: false,\n                dbReadyResolve: nop,\n                dbReadyPromise: null,\n                cancelOpen: nop,\n                openCanceller: null,\n                autoSchema: true,\n                PR1398_maxLoop: 3,\n                autoOpen: options.autoOpen,\n            };\n            state.dbReadyPromise = new DexiePromise(function (resolve) {\n                state.dbReadyResolve = resolve;\n            });\n            state.openCanceller = new DexiePromise(function (_, reject) {\n                state.cancelOpen = reject;\n            });\n            this._state = state;\n            this.name = name;\n            this.on = Events(this, \"populate\", \"blocked\", \"versionchange\", \"close\", { ready: [promisableChain, nop] });\n            this.once = function (event, callback) {\n                var fn = function () {\n                    var args = [];\n                    for (var _i = 0; _i < arguments.length; _i++) {\n                        args[_i] = arguments[_i];\n                    }\n                    _this.on(event).unsubscribe(fn);\n                    callback.apply(_this, args);\n                };\n                return _this.on(event, fn);\n            };\n            this.on.ready.subscribe = override(this.on.ready.subscribe, function (subscribe) {\n                return function (subscriber, bSticky) {\n                    Dexie.vip(function () {\n                        var state = _this._state;\n                        if (state.openComplete) {\n                            if (!state.dbOpenError)\n                                DexiePromise.resolve().then(subscriber);\n                            if (bSticky)\n                                subscribe(subscriber);\n                        }\n                        else if (state.onReadyBeingFired) {\n                            state.onReadyBeingFired.push(subscriber);\n                            if (bSticky)\n                                subscribe(subscriber);\n                        }\n                        else {\n                            subscribe(subscriber);\n                            var db_1 = _this;\n                            if (!bSticky)\n                                subscribe(function unsubscribe() {\n                                    db_1.on.ready.unsubscribe(subscriber);\n                                    db_1.on.ready.unsubscribe(unsubscribe);\n                                });\n                        }\n                    });\n                };\n            });\n            this.Collection = createCollectionConstructor(this);\n            this.Table = createTableConstructor(this);\n            this.Transaction = createTransactionConstructor(this);\n            this.Version = createVersionConstructor(this);\n            this.WhereClause = createWhereClauseConstructor(this);\n            this.on(\"versionchange\", function (ev) {\n                if (ev.newVersion > 0)\n                    console.warn(\"Another connection wants to upgrade database '\".concat(_this.name, \"'. Closing db now to resume the upgrade.\"));\n                else\n                    console.warn(\"Another connection wants to delete database '\".concat(_this.name, \"'. Closing db now to resume the delete request.\"));\n                _this.close({ disableAutoOpen: false });\n            });\n            this.on(\"blocked\", function (ev) {\n                if (!ev.newVersion || ev.newVersion < ev.oldVersion)\n                    console.warn(\"Dexie.delete('\".concat(_this.name, \"') was blocked\"));\n                else\n                    console.warn(\"Upgrade '\".concat(_this.name, \"' blocked by other connection holding version \").concat(ev.oldVersion / 10));\n            });\n            this._maxKey = getMaxKey(options.IDBKeyRange);\n            this._createTransaction = function (mode, storeNames, dbschema, parentTransaction) { return new _this.Transaction(mode, storeNames, dbschema, _this._options.chromeTransactionDurability, parentTransaction); };\n            this._fireOnBlocked = function (ev) {\n                _this.on(\"blocked\").fire(ev);\n                connections\n                    .filter(function (c) { return c.name === _this.name && c !== _this && !c._state.vcFired; })\n                    .map(function (c) { return c.on(\"versionchange\").fire(ev); });\n            };\n            this.use(cacheExistingValuesMiddleware);\n            this.use(cacheMiddleware);\n            this.use(observabilityMiddleware);\n            this.use(virtualIndexMiddleware);\n            this.use(hooksMiddleware);\n            var vipDB = new Proxy(this, {\n                get: function (_, prop, receiver) {\n                    if (prop === '_vip')\n                        return true;\n                    if (prop === 'table')\n                        return function (tableName) { return vipify(_this.table(tableName), vipDB); };\n                    var rv = Reflect.get(_, prop, receiver);\n                    if (rv instanceof Table)\n                        return vipify(rv, vipDB);\n                    if (prop === 'tables')\n                        return rv.map(function (t) { return vipify(t, vipDB); });\n                    if (prop === '_createTransaction')\n                        return function () {\n                            var tx = rv.apply(this, arguments);\n                            return vipify(tx, vipDB);\n                        };\n                    return rv;\n                }\n            });\n            this.vip = vipDB;\n            addons.forEach(function (addon) { return addon(_this); });\n        }\n        Dexie.prototype.version = function (versionNumber) {\n            if (isNaN(versionNumber) || versionNumber < 0.1)\n                throw new exceptions.Type(\"Given version is not a positive number\");\n            versionNumber = Math.round(versionNumber * 10) / 10;\n            if (this.idbdb || this._state.isBeingOpened)\n                throw new exceptions.Schema(\"Cannot add version when database is open\");\n            this.verno = Math.max(this.verno, versionNumber);\n            var versions = this._versions;\n            var versionInstance = versions.filter(function (v) { return v._cfg.version === versionNumber; })[0];\n            if (versionInstance)\n                return versionInstance;\n            versionInstance = new this.Version(versionNumber);\n            versions.push(versionInstance);\n            versions.sort(lowerVersionFirst);\n            versionInstance.stores({});\n            this._state.autoSchema = false;\n            return versionInstance;\n        };\n        Dexie.prototype._whenReady = function (fn) {\n            var _this = this;\n            return (this.idbdb && (this._state.openComplete || PSD.letThrough || this._vip)) ? fn() : new DexiePromise(function (resolve, reject) {\n                if (_this._state.openComplete) {\n                    return reject(new exceptions.DatabaseClosed(_this._state.dbOpenError));\n                }\n                if (!_this._state.isBeingOpened) {\n                    if (!_this._state.autoOpen) {\n                        reject(new exceptions.DatabaseClosed());\n                        return;\n                    }\n                    _this.open().catch(nop);\n                }\n                _this._state.dbReadyPromise.then(resolve, reject);\n            }).then(fn);\n        };\n        Dexie.prototype.use = function (_a) {\n            var stack = _a.stack, create = _a.create, level = _a.level, name = _a.name;\n            if (name)\n                this.unuse({ stack: stack, name: name });\n            var middlewares = this._middlewares[stack] || (this._middlewares[stack] = []);\n            middlewares.push({ stack: stack, create: create, level: level == null ? 10 : level, name: name });\n            middlewares.sort(function (a, b) { return a.level - b.level; });\n            return this;\n        };\n        Dexie.prototype.unuse = function (_a) {\n            var stack = _a.stack, name = _a.name, create = _a.create;\n            if (stack && this._middlewares[stack]) {\n                this._middlewares[stack] = this._middlewares[stack].filter(function (mw) {\n                    return create ? mw.create !== create :\n                        name ? mw.name !== name :\n                            false;\n                });\n            }\n            return this;\n        };\n        Dexie.prototype.open = function () {\n            var _this = this;\n            return usePSD(globalPSD,\n            function () { return dexieOpen(_this); });\n        };\n        Dexie.prototype._close = function () {\n            this.on.close.fire(new CustomEvent('close'));\n            var state = this._state;\n            var idx = connections.indexOf(this);\n            if (idx >= 0)\n                connections.splice(idx, 1);\n            if (this.idbdb) {\n                try {\n                    this.idbdb.close();\n                }\n                catch (e) { }\n                this.idbdb = null;\n            }\n            if (!state.isBeingOpened) {\n                state.dbReadyPromise = new DexiePromise(function (resolve) {\n                    state.dbReadyResolve = resolve;\n                });\n                state.openCanceller = new DexiePromise(function (_, reject) {\n                    state.cancelOpen = reject;\n                });\n            }\n        };\n        Dexie.prototype.close = function (_a) {\n            var _b = _a === void 0 ? { disableAutoOpen: true } : _a, disableAutoOpen = _b.disableAutoOpen;\n            var state = this._state;\n            if (disableAutoOpen) {\n                if (state.isBeingOpened) {\n                    state.cancelOpen(new exceptions.DatabaseClosed());\n                }\n                this._close();\n                state.autoOpen = false;\n                state.dbOpenError = new exceptions.DatabaseClosed();\n            }\n            else {\n                this._close();\n                state.autoOpen = this._options.autoOpen ||\n                    state.isBeingOpened;\n                state.openComplete = false;\n                state.dbOpenError = null;\n            }\n        };\n        Dexie.prototype.delete = function (closeOptions) {\n            var _this = this;\n            if (closeOptions === void 0) { closeOptions = { disableAutoOpen: true }; }\n            var hasInvalidArguments = arguments.length > 0 && typeof arguments[0] !== 'object';\n            var state = this._state;\n            return new DexiePromise(function (resolve, reject) {\n                var doDelete = function () {\n                    _this.close(closeOptions);\n                    var req = _this._deps.indexedDB.deleteDatabase(_this.name);\n                    req.onsuccess = wrap(function () {\n                        _onDatabaseDeleted(_this._deps, _this.name);\n                        resolve();\n                    });\n                    req.onerror = eventRejectHandler(reject);\n                    req.onblocked = _this._fireOnBlocked;\n                };\n                if (hasInvalidArguments)\n                    throw new exceptions.InvalidArgument(\"Invalid closeOptions argument to db.delete()\");\n                if (state.isBeingOpened) {\n                    state.dbReadyPromise.then(doDelete);\n                }\n                else {\n                    doDelete();\n                }\n            });\n        };\n        Dexie.prototype.backendDB = function () {\n            return this.idbdb;\n        };\n        Dexie.prototype.isOpen = function () {\n            return this.idbdb !== null;\n        };\n        Dexie.prototype.hasBeenClosed = function () {\n            var dbOpenError = this._state.dbOpenError;\n            return dbOpenError && (dbOpenError.name === 'DatabaseClosed');\n        };\n        Dexie.prototype.hasFailed = function () {\n            return this._state.dbOpenError !== null;\n        };\n        Dexie.prototype.dynamicallyOpened = function () {\n            return this._state.autoSchema;\n        };\n        Object.defineProperty(Dexie.prototype, \"tables\", {\n            get: function () {\n                var _this = this;\n                return keys(this._allTables).map(function (name) { return _this._allTables[name]; });\n            },\n            enumerable: false,\n            configurable: true\n        });\n        Dexie.prototype.transaction = function () {\n            var args = extractTransactionArgs.apply(this, arguments);\n            return this._transaction.apply(this, args);\n        };\n        Dexie.prototype._transaction = function (mode, tables, scopeFunc) {\n            var _this = this;\n            var parentTransaction = PSD.trans;\n            if (!parentTransaction || parentTransaction.db !== this || mode.indexOf('!') !== -1)\n                parentTransaction = null;\n            var onlyIfCompatible = mode.indexOf('?') !== -1;\n            mode = mode.replace('!', '').replace('?', '');\n            var idbMode, storeNames;\n            try {\n                storeNames = tables.map(function (table) {\n                    var storeName = table instanceof _this.Table ? table.name : table;\n                    if (typeof storeName !== 'string')\n                        throw new TypeError(\"Invalid table argument to Dexie.transaction(). Only Table or String are allowed\");\n                    return storeName;\n                });\n                if (mode == \"r\" || mode === READONLY)\n                    idbMode = READONLY;\n                else if (mode == \"rw\" || mode == READWRITE)\n                    idbMode = READWRITE;\n                else\n                    throw new exceptions.InvalidArgument(\"Invalid transaction mode: \" + mode);\n                if (parentTransaction) {\n                    if (parentTransaction.mode === READONLY && idbMode === READWRITE) {\n                        if (onlyIfCompatible) {\n                            parentTransaction = null;\n                        }\n                        else\n                            throw new exceptions.SubTransaction(\"Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY\");\n                    }\n                    if (parentTransaction) {\n                        storeNames.forEach(function (storeName) {\n                            if (parentTransaction && parentTransaction.storeNames.indexOf(storeName) === -1) {\n                                if (onlyIfCompatible) {\n                                    parentTransaction = null;\n                                }\n                                else\n                                    throw new exceptions.SubTransaction(\"Table \" + storeName +\n                                        \" not included in parent transaction.\");\n                            }\n                        });\n                    }\n                    if (onlyIfCompatible && parentTransaction && !parentTransaction.active) {\n                        parentTransaction = null;\n                    }\n                }\n            }\n            catch (e) {\n                return parentTransaction ?\n                    parentTransaction._promise(null, function (_, reject) { reject(e); }) :\n                    rejection(e);\n            }\n            var enterTransaction = enterTransactionScope.bind(null, this, idbMode, storeNames, parentTransaction, scopeFunc);\n            return (parentTransaction ?\n                parentTransaction._promise(idbMode, enterTransaction, \"lock\") :\n                PSD.trans ?\n                    usePSD(PSD.transless, function () { return _this._whenReady(enterTransaction); }) :\n                    this._whenReady(enterTransaction));\n        };\n        Dexie.prototype.table = function (tableName) {\n            if (!hasOwn(this._allTables, tableName)) {\n                throw new exceptions.InvalidTable(\"Table \".concat(tableName, \" does not exist\"));\n            }\n            return this._allTables[tableName];\n        };\n        return Dexie;\n    }());\n\n    var symbolObservable = typeof Symbol !== \"undefined\" && \"observable\" in Symbol\n        ? Symbol.observable\n        : \"@@observable\";\n    var Observable =  (function () {\n        function Observable(subscribe) {\n            this._subscribe = subscribe;\n        }\n        Observable.prototype.subscribe = function (x, error, complete) {\n            return this._subscribe(!x || typeof x === \"function\" ? { next: x, error: error, complete: complete } : x);\n        };\n        Observable.prototype[symbolObservable] = function () {\n            return this;\n        };\n        return Observable;\n    }());\n\n    var domDeps;\n    try {\n        domDeps = {\n            indexedDB: _global.indexedDB || _global.mozIndexedDB || _global.webkitIndexedDB || _global.msIndexedDB,\n            IDBKeyRange: _global.IDBKeyRange || _global.webkitIDBKeyRange\n        };\n    }\n    catch (e) {\n        domDeps = { indexedDB: null, IDBKeyRange: null };\n    }\n\n    function liveQuery(querier) {\n        var hasValue = false;\n        var currentValue;\n        var observable = new Observable(function (observer) {\n            var scopeFuncIsAsync = isAsyncFunction(querier);\n            function execute(ctx) {\n                var wasRootExec = beginMicroTickScope();\n                try {\n                    if (scopeFuncIsAsync) {\n                        incrementExpectedAwaits();\n                    }\n                    var rv = newScope(querier, ctx);\n                    if (scopeFuncIsAsync) {\n                        rv = rv.finally(decrementExpectedAwaits);\n                    }\n                    return rv;\n                }\n                finally {\n                    wasRootExec && endMicroTickScope();\n                }\n            }\n            var closed = false;\n            var abortController;\n            var accumMuts = {};\n            var currentObs = {};\n            var subscription = {\n                get closed() {\n                    return closed;\n                },\n                unsubscribe: function () {\n                    if (closed)\n                        return;\n                    closed = true;\n                    if (abortController)\n                        abortController.abort();\n                    if (startedListening)\n                        globalEvents.storagemutated.unsubscribe(mutationListener);\n                },\n            };\n            observer.start && observer.start(subscription);\n            var startedListening = false;\n            var doQuery = function () { return execInGlobalContext(_doQuery); };\n            function shouldNotify() {\n                return obsSetsOverlap(currentObs, accumMuts);\n            }\n            var mutationListener = function (parts) {\n                extendObservabilitySet(accumMuts, parts);\n                if (shouldNotify()) {\n                    doQuery();\n                }\n            };\n            var _doQuery = function () {\n                if (closed ||\n                    !domDeps.indexedDB)\n                 {\n                    return;\n                }\n                accumMuts = {};\n                var subscr = {};\n                if (abortController)\n                    abortController.abort();\n                abortController = new AbortController();\n                var ctx = {\n                    subscr: subscr,\n                    signal: abortController.signal,\n                    requery: doQuery,\n                    querier: querier,\n                    trans: null\n                };\n                var ret = execute(ctx);\n                Promise.resolve(ret).then(function (result) {\n                    hasValue = true;\n                    currentValue = result;\n                    if (closed || ctx.signal.aborted) {\n                        return;\n                    }\n                    accumMuts = {};\n                    currentObs = subscr;\n                    if (!objectIsEmpty(currentObs) && !startedListening) {\n                        globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, mutationListener);\n                        startedListening = true;\n                    }\n                    execInGlobalContext(function () { return !closed && observer.next && observer.next(result); });\n                }, function (err) {\n                    hasValue = false;\n                    if (!['DatabaseClosedError', 'AbortError'].includes(err === null || err === void 0 ? void 0 : err.name)) {\n                        if (!closed)\n                            execInGlobalContext(function () {\n                                if (closed)\n                                    return;\n                                observer.error && observer.error(err);\n                            });\n                    }\n                });\n            };\n            setTimeout(doQuery, 0);\n            return subscription;\n        });\n        observable.hasValue = function () { return hasValue; };\n        observable.getValue = function () { return currentValue; };\n        return observable;\n    }\n\n    var Dexie = Dexie$1;\n    props(Dexie, __assign(__assign({}, fullNameExceptions), {\n        delete: function (databaseName) {\n            var db = new Dexie(databaseName, { addons: [] });\n            return db.delete();\n        },\n        exists: function (name) {\n            return new Dexie(name, { addons: [] }).open().then(function (db) {\n                db.close();\n                return true;\n            }).catch('NoSuchDatabaseError', function () { return false; });\n        },\n        getDatabaseNames: function (cb) {\n            try {\n                return getDatabaseNames(Dexie.dependencies).then(cb);\n            }\n            catch (_a) {\n                return rejection(new exceptions.MissingAPI());\n            }\n        },\n        defineClass: function () {\n            function Class(content) {\n                extend(this, content);\n            }\n            return Class;\n        }, ignoreTransaction: function (scopeFunc) {\n            return PSD.trans ?\n                usePSD(PSD.transless, scopeFunc) :\n                scopeFunc();\n        }, vip: vip, async: function (generatorFn) {\n            return function () {\n                try {\n                    var rv = awaitIterator(generatorFn.apply(this, arguments));\n                    if (!rv || typeof rv.then !== 'function')\n                        return DexiePromise.resolve(rv);\n                    return rv;\n                }\n                catch (e) {\n                    return rejection(e);\n                }\n            };\n        }, spawn: function (generatorFn, args, thiz) {\n            try {\n                var rv = awaitIterator(generatorFn.apply(thiz, args || []));\n                if (!rv || typeof rv.then !== 'function')\n                    return DexiePromise.resolve(rv);\n                return rv;\n            }\n            catch (e) {\n                return rejection(e);\n            }\n        },\n        currentTransaction: {\n            get: function () { return PSD.trans || null; }\n        }, waitFor: function (promiseOrFunction, optionalTimeout) {\n            var promise = DexiePromise.resolve(typeof promiseOrFunction === 'function' ?\n                Dexie.ignoreTransaction(promiseOrFunction) :\n                promiseOrFunction)\n                .timeout(optionalTimeout || 60000);\n            return PSD.trans ?\n                PSD.trans.waitFor(promise) :\n                promise;\n        },\n        Promise: DexiePromise,\n        debug: {\n            get: function () { return debug; },\n            set: function (value) {\n                setDebug(value);\n            }\n        },\n        derive: derive, extend: extend, props: props, override: override,\n        Events: Events, on: globalEvents, liveQuery: liveQuery, extendObservabilitySet: extendObservabilitySet,\n        getByKeyPath: getByKeyPath, setByKeyPath: setByKeyPath, delByKeyPath: delByKeyPath, shallowClone: shallowClone, deepClone: deepClone, getObjectDiff: getObjectDiff, cmp: cmp, asap: asap$1,\n        minKey: minKey,\n        addons: [],\n        connections: connections,\n        errnames: errnames,\n        dependencies: domDeps, cache: cache,\n        semVer: DEXIE_VERSION, version: DEXIE_VERSION.split('.')\n            .map(function (n) { return parseInt(n); })\n            .reduce(function (p, c, i) { return p + (c / Math.pow(10, i * 2)); }) }));\n    Dexie.maxKey = getMaxKey(Dexie.dependencies.IDBKeyRange);\n\n    if (typeof dispatchEvent !== 'undefined' && typeof addEventListener !== 'undefined') {\n        globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, function (updatedParts) {\n            if (!propagatingLocally) {\n                var event_1;\n                event_1 = new CustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, {\n                    detail: updatedParts\n                });\n                propagatingLocally = true;\n                dispatchEvent(event_1);\n                propagatingLocally = false;\n            }\n        });\n        addEventListener(STORAGE_MUTATED_DOM_EVENT_NAME, function (_a) {\n            var detail = _a.detail;\n            if (!propagatingLocally) {\n                propagateLocally(detail);\n            }\n        });\n    }\n    function propagateLocally(updateParts) {\n        var wasMe = propagatingLocally;\n        try {\n            propagatingLocally = true;\n            globalEvents.storagemutated.fire(updateParts);\n            signalSubscribersNow(updateParts, true);\n        }\n        finally {\n            propagatingLocally = wasMe;\n        }\n    }\n    var propagatingLocally = false;\n\n    var bc;\n    var createBC = function () { };\n    if (typeof BroadcastChannel !== 'undefined') {\n        createBC = function () {\n            bc = new BroadcastChannel(STORAGE_MUTATED_DOM_EVENT_NAME);\n            bc.onmessage = function (ev) { return ev.data && propagateLocally(ev.data); };\n        };\n        createBC();\n        if (typeof bc.unref === 'function') {\n            bc.unref();\n        }\n        globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, function (changedParts) {\n            if (!propagatingLocally) {\n                bc.postMessage(changedParts);\n            }\n        });\n    }\n\n    if (typeof addEventListener !== 'undefined') {\n        addEventListener('pagehide', function (event) {\n            if (!Dexie$1.disableBfCache && event.persisted) {\n                if (debug)\n                    console.debug('Dexie: handling persisted pagehide');\n                bc === null || bc === void 0 ? void 0 : bc.close();\n                for (var _i = 0, connections_1 = connections; _i < connections_1.length; _i++) {\n                    var db = connections_1[_i];\n                    db.close({ disableAutoOpen: false });\n                }\n            }\n        });\n        addEventListener('pageshow', function (event) {\n            if (!Dexie$1.disableBfCache && event.persisted) {\n                if (debug)\n                    console.debug('Dexie: handling persisted pageshow');\n                createBC();\n                propagateLocally({ all: new RangeSet(-Infinity, [[]]) });\n            }\n        });\n    }\n\n    function add(value) {\n        return new PropModification({ add: value });\n    }\n\n    function remove(value) {\n        return new PropModification({ remove: value });\n    }\n\n    function replacePrefix(a, b) {\n        return new PropModification({ replacePrefix: [a, b] });\n    }\n\n    DexiePromise.rejectionMapper = mapError;\n    setDebug(debug);\n\n    var namedExports = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        Dexie: Dexie$1,\n        liveQuery: liveQuery,\n        Entity: Entity,\n        cmp: cmp,\n        PropModification: PropModification,\n        replacePrefix: replacePrefix,\n        add: add,\n        remove: remove,\n        'default': Dexie$1,\n        RangeSet: RangeSet,\n        mergeRanges: mergeRanges,\n        rangesOverlap: rangesOverlap\n    });\n\n    __assign(Dexie$1, namedExports, { default: Dexie$1 });\n\n    return Dexie$1;\n\n}));\n//# sourceMappingURL=dexie.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvZGV4aWUvZGlzdC9kZXhpZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxLQUE0RDtBQUNoRSxJQUFJLENBQ29HO0FBQ3hHLENBQUMsdUJBQXVCOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUN2Riw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELE9BQU87QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRixPQUFPO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxQkFBTTs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDJFQUEyRTtBQUN6RixjQUFjLDZEQUE2RDtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssSUFBSTtBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCwyQkFBMkI7QUFDekY7QUFDQSwrQkFBK0Isd0JBQXdCO0FBQ3ZEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxvQ0FBb0M7QUFDdkU7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxzQ0FBc0MsWUFBWTtBQUNsRDs7QUFFQTtBQUNBLHNDQUFzQyxlQUFlO0FBQ3JEOztBQUVBO0FBQ0Esc0NBQXNDLHVCQUF1QjtBQUM3RDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMLHNDQUFzQyxrQkFBa0I7O0FBRXhEOztBQUVBLENBQUM7QUFDRCIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxuYXRoYVxcT25lRHJpdmVcXERlc2t0b3BcXE1vbmV5UXVlc3RWM1xcbm9kZV9tb2R1bGVzXFxkZXhpZVxcZGlzdFxcZGV4aWUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIERleGllLmpzIC0gYSBtaW5pbWFsaXN0aWMgd3JhcHBlciBmb3IgSW5kZXhlZERCXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICpcbiAqIEJ5IERhdmlkIEZhaGxhbmRlciwgZGF2aWQuZmFobGFuZGVyQGdtYWlsLmNvbVxuICpcbiAqIFZlcnNpb24gNC4yLjAsIFdlZCBBdWcgMTMgMjAyNVxuICpcbiAqIGh0dHBzOi8vZGV4aWUub3JnXG4gKlxuICogQXBhY2hlIExpY2Vuc2UgVmVyc2lvbiAyLjAsIEphbnVhcnkgMjAwNCwgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL1xuICovXG4gXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICAgIChnbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogZ2xvYmFsIHx8IHNlbGYsIGdsb2JhbC5EZXhpZSA9IGZhY3RvcnkoKSk7XG59KSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgICAvKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cbiAgICBQZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcbiAgICBwdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXG4gICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxuICAgIFJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxuICAgIEFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcbiAgICBJTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cbiAgICBMT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxuICAgIE9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcbiAgICBQRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxuICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9XG4gICAgdmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBfX3NwcmVhZEFycmF5KHRvLCBmcm9tLCBwYWNrKSB7XG4gICAgICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcbiAgICAgICAgICAgICAgICBhcltpXSA9IGZyb21baV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XG4gICAgfVxuXG4gICAgdmFyIF9nbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDpcbiAgICAgICAgdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6XG4gICAgICAgICAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6XG4gICAgICAgICAgICAgICAgZ2xvYmFsO1xuXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cztcbiAgICB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG4gICAgaWYgKHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJyAmJiAhX2dsb2JhbC5Qcm9taXNlKSB7XG4gICAgICAgIF9nbG9iYWwuUHJvbWlzZSA9IFByb21pc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGV4dGVuZChvYmosIGV4dGVuc2lvbikge1xuICAgICAgICBpZiAodHlwZW9mIGV4dGVuc2lvbiAhPT0gJ29iamVjdCcpXG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICBrZXlzKGV4dGVuc2lvbikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBvYmpba2V5XSA9IGV4dGVuc2lvbltrZXldO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gICAgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuICAgIHZhciBfaGFzT3duID0ge30uaGFzT3duUHJvcGVydHk7XG4gICAgZnVuY3Rpb24gaGFzT3duKG9iaiwgcHJvcCkge1xuICAgICAgICByZXR1cm4gX2hhc093bi5jYWxsKG9iaiwgcHJvcCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByb3BzKHByb3RvLCBleHRlbnNpb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBleHRlbnNpb24gPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICBleHRlbnNpb24gPSBleHRlbnNpb24oZ2V0UHJvdG8ocHJvdG8pKTtcbiAgICAgICAgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiID8ga2V5cyA6IFJlZmxlY3Qub3duS2V5cykoZXh0ZW5zaW9uKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHNldFByb3AocHJvdG8sIGtleSwgZXh0ZW5zaW9uW2tleV0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdmFyIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuICAgIGZ1bmN0aW9uIHNldFByb3Aob2JqLCBwcm9wLCBmdW5jdGlvbk9yR2V0U2V0LCBvcHRpb25zKSB7XG4gICAgICAgIGRlZmluZVByb3BlcnR5KG9iaiwgcHJvcCwgZXh0ZW5kKGZ1bmN0aW9uT3JHZXRTZXQgJiYgaGFzT3duKGZ1bmN0aW9uT3JHZXRTZXQsIFwiZ2V0XCIpICYmIHR5cGVvZiBmdW5jdGlvbk9yR2V0U2V0LmdldCA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgICAgICB7IGdldDogZnVuY3Rpb25PckdldFNldC5nZXQsIHNldDogZnVuY3Rpb25PckdldFNldC5zZXQsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IDpcbiAgICAgICAgICAgIHsgdmFsdWU6IGZ1bmN0aW9uT3JHZXRTZXQsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSwgb3B0aW9ucykpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXJpdmUoQ2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZyb206IGZ1bmN0aW9uIChQYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBDaGlsZC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFBhcmVudC5wcm90b3R5cGUpO1xuICAgICAgICAgICAgICAgIHNldFByb3AoQ2hpbGQucHJvdG90eXBlLCBcImNvbnN0cnVjdG9yXCIsIENoaWxkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBleHRlbmQ6IHByb3BzLmJpbmQobnVsbCwgQ2hpbGQucHJvdG90eXBlKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIHZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuICAgIGZ1bmN0aW9uIGdldFByb3BlcnR5RGVzY3JpcHRvcihvYmosIHByb3ApIHtcbiAgICAgICAgdmFyIHBkID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgcHJvcCk7XG4gICAgICAgIHZhciBwcm90bztcbiAgICAgICAgcmV0dXJuIHBkIHx8IChwcm90byA9IGdldFByb3RvKG9iaikpICYmIGdldFByb3BlcnR5RGVzY3JpcHRvcihwcm90bywgcHJvcCk7XG4gICAgfVxuICAgIHZhciBfc2xpY2UgPSBbXS5zbGljZTtcbiAgICBmdW5jdGlvbiBzbGljZShhcmdzLCBzdGFydCwgZW5kKSB7XG4gICAgICAgIHJldHVybiBfc2xpY2UuY2FsbChhcmdzLCBzdGFydCwgZW5kKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb3ZlcnJpZGUob3JpZ0Z1bmMsIG92ZXJyaWRlZEZhY3RvcnkpIHtcbiAgICAgICAgcmV0dXJuIG92ZXJyaWRlZEZhY3Rvcnkob3JpZ0Z1bmMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhc3NlcnQoYikge1xuICAgICAgICBpZiAoIWIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBc3NlcnRpb24gRmFpbGVkXCIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhc2FwJDEoZm4pIHtcbiAgICAgICAgaWYgKF9nbG9iYWwuc2V0SW1tZWRpYXRlKVxuICAgICAgICAgICAgc2V0SW1tZWRpYXRlKGZuKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgc2V0VGltZW91dChmbiwgMCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFycmF5VG9PYmplY3QoYXJyYXksIGV4dHJhY3Rvcikge1xuICAgICAgICByZXR1cm4gYXJyYXkucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIGl0ZW0sIGkpIHtcbiAgICAgICAgICAgIHZhciBuYW1lQW5kVmFsdWUgPSBleHRyYWN0b3IoaXRlbSwgaSk7XG4gICAgICAgICAgICBpZiAobmFtZUFuZFZhbHVlKVxuICAgICAgICAgICAgICAgIHJlc3VsdFtuYW1lQW5kVmFsdWVbMF1dID0gbmFtZUFuZFZhbHVlWzFdO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSwge30pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRCeUtleVBhdGgob2JqLCBrZXlQYXRoKSB7XG4gICAgICAgIGlmICh0eXBlb2Yga2V5UGF0aCA9PT0gJ3N0cmluZycgJiYgaGFzT3duKG9iaiwga2V5UGF0aCkpXG4gICAgICAgICAgICByZXR1cm4gb2JqW2tleVBhdGhdO1xuICAgICAgICBpZiAoIWtleVBhdGgpXG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICBpZiAodHlwZW9mIGtleVBhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB2YXIgcnYgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0ga2V5UGF0aC5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsID0gZ2V0QnlLZXlQYXRoKG9iaiwga2V5UGF0aFtpXSk7XG4gICAgICAgICAgICAgICAgcnYucHVzaCh2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJ2O1xuICAgICAgICB9XG4gICAgICAgIHZhciBwZXJpb2QgPSBrZXlQYXRoLmluZGV4T2YoJy4nKTtcbiAgICAgICAgaWYgKHBlcmlvZCAhPT0gLTEpIHtcbiAgICAgICAgICAgIHZhciBpbm5lck9iaiA9IG9ialtrZXlQYXRoLnN1YnN0cigwLCBwZXJpb2QpXTtcbiAgICAgICAgICAgIHJldHVybiBpbm5lck9iaiA9PSBudWxsID8gdW5kZWZpbmVkIDogZ2V0QnlLZXlQYXRoKGlubmVyT2JqLCBrZXlQYXRoLnN1YnN0cihwZXJpb2QgKyAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0QnlLZXlQYXRoKG9iaiwga2V5UGF0aCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKCFvYmogfHwga2V5UGF0aCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoJ2lzRnJvemVuJyBpbiBPYmplY3QgJiYgT2JqZWN0LmlzRnJvemVuKG9iaikpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh0eXBlb2Yga2V5UGF0aCAhPT0gJ3N0cmluZycgJiYgJ2xlbmd0aCcgaW4ga2V5UGF0aCkge1xuICAgICAgICAgICAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycgJiYgJ2xlbmd0aCcgaW4gdmFsdWUpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBrZXlQYXRoLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgICAgIHNldEJ5S2V5UGF0aChvYmosIGtleVBhdGhbaV0sIHZhbHVlW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwZXJpb2QgPSBrZXlQYXRoLmluZGV4T2YoJy4nKTtcbiAgICAgICAgICAgIGlmIChwZXJpb2QgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRLZXlQYXRoID0ga2V5UGF0aC5zdWJzdHIoMCwgcGVyaW9kKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVtYWluaW5nS2V5UGF0aCA9IGtleVBhdGguc3Vic3RyKHBlcmlvZCArIDEpO1xuICAgICAgICAgICAgICAgIGlmIChyZW1haW5pbmdLZXlQYXRoID09PSBcIlwiKVxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQXJyYXkob2JqKSAmJiAhaXNOYU4ocGFyc2VJbnQoY3VycmVudEtleVBhdGgpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmouc3BsaWNlKGN1cnJlbnRLZXlQYXRoLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgb2JqW2N1cnJlbnRLZXlQYXRoXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmpbY3VycmVudEtleVBhdGhdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbm5lck9iaiA9IG9ialtjdXJyZW50S2V5UGF0aF07XG4gICAgICAgICAgICAgICAgICAgIGlmICghaW5uZXJPYmogfHwgIWhhc093bihvYmosIGN1cnJlbnRLZXlQYXRoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlubmVyT2JqID0gKG9ialtjdXJyZW50S2V5UGF0aF0gPSB7fSk7XG4gICAgICAgICAgICAgICAgICAgIHNldEJ5S2V5UGF0aChpbm5lck9iaiwgcmVtYWluaW5nS2V5UGF0aCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KG9iaikgJiYgIWlzTmFOKHBhcnNlSW50KGtleVBhdGgpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iai5zcGxpY2Uoa2V5UGF0aCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvYmpba2V5UGF0aF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgb2JqW2tleVBhdGhdID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZGVsQnlLZXlQYXRoKG9iaiwga2V5UGF0aCkge1xuICAgICAgICBpZiAodHlwZW9mIGtleVBhdGggPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgc2V0QnlLZXlQYXRoKG9iaiwga2V5UGF0aCwgdW5kZWZpbmVkKTtcbiAgICAgICAgZWxzZSBpZiAoJ2xlbmd0aCcgaW4ga2V5UGF0aClcbiAgICAgICAgICAgIFtdLm1hcC5jYWxsKGtleVBhdGgsIGZ1bmN0aW9uIChrcCkge1xuICAgICAgICAgICAgICAgIHNldEJ5S2V5UGF0aChvYmosIGtwLCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNoYWxsb3dDbG9uZShvYmopIHtcbiAgICAgICAgdmFyIHJ2ID0ge307XG4gICAgICAgIGZvciAodmFyIG0gaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duKG9iaiwgbSkpXG4gICAgICAgICAgICAgICAgcnZbbV0gPSBvYmpbbV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJ2O1xuICAgIH1cbiAgICB2YXIgY29uY2F0ID0gW10uY29uY2F0O1xuICAgIGZ1bmN0aW9uIGZsYXR0ZW4oYSkge1xuICAgICAgICByZXR1cm4gY29uY2F0LmFwcGx5KFtdLCBhKTtcbiAgICB9XG4gICAgdmFyIGludHJpbnNpY1R5cGVOYW1lcyA9IFwiQmlnVWludDY0QXJyYXksQmlnSW50NjRBcnJheSxBcnJheSxCb29sZWFuLFN0cmluZyxEYXRlLFJlZ0V4cCxCbG9iLEZpbGUsRmlsZUxpc3QsRmlsZVN5c3RlbUZpbGVIYW5kbGUsRmlsZVN5c3RlbURpcmVjdG9yeUhhbmRsZSxBcnJheUJ1ZmZlcixEYXRhVmlldyxVaW50OENsYW1wZWRBcnJheSxJbWFnZUJpdG1hcCxJbWFnZURhdGEsTWFwLFNldCxDcnlwdG9LZXlcIlxuICAgICAgICAuc3BsaXQoJywnKS5jb25jYXQoZmxhdHRlbihbOCwgMTYsIDMyLCA2NF0ubWFwKGZ1bmN0aW9uIChudW0pIHsgcmV0dXJuIFtcIkludFwiLCBcIlVpbnRcIiwgXCJGbG9hdFwiXS5tYXAoZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQgKyBudW0gKyBcIkFycmF5XCI7IH0pOyB9KSkpLmZpbHRlcihmdW5jdGlvbiAodCkgeyByZXR1cm4gX2dsb2JhbFt0XTsgfSk7XG4gICAgdmFyIGludHJpbnNpY1R5cGVzID0gbmV3IFNldChpbnRyaW5zaWNUeXBlTmFtZXMubWFwKGZ1bmN0aW9uICh0KSB7IHJldHVybiBfZ2xvYmFsW3RdOyB9KSk7XG4gICAgZnVuY3Rpb24gY2xvbmVTaW1wbGVPYmplY3RUcmVlKG8pIHtcbiAgICAgICAgdmFyIHJ2ID0ge307XG4gICAgICAgIGZvciAodmFyIGsgaW4gbylcbiAgICAgICAgICAgIGlmIChoYXNPd24obywgaykpIHtcbiAgICAgICAgICAgICAgICB2YXIgdiA9IG9ba107XG4gICAgICAgICAgICAgICAgcnZba10gPSAhdiB8fCB0eXBlb2YgdiAhPT0gJ29iamVjdCcgfHwgaW50cmluc2ljVHlwZXMuaGFzKHYuY29uc3RydWN0b3IpID8gdiA6IGNsb25lU2ltcGxlT2JqZWN0VHJlZSh2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJ2O1xuICAgIH1cbiAgICBmdW5jdGlvbiBvYmplY3RJc0VtcHR5KG8pIHtcbiAgICAgICAgZm9yICh2YXIgayBpbiBvKVxuICAgICAgICAgICAgaWYgKGhhc093bihvLCBrKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB2YXIgY2lyY3VsYXJSZWZzID0gbnVsbDtcbiAgICBmdW5jdGlvbiBkZWVwQ2xvbmUoYW55KSB7XG4gICAgICAgIGNpcmN1bGFyUmVmcyA9IG5ldyBXZWFrTWFwKCk7XG4gICAgICAgIHZhciBydiA9IGlubmVyRGVlcENsb25lKGFueSk7XG4gICAgICAgIGNpcmN1bGFyUmVmcyA9IG51bGw7XG4gICAgICAgIHJldHVybiBydjtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW5uZXJEZWVwQ2xvbmUoeCkge1xuICAgICAgICBpZiAoIXggfHwgdHlwZW9mIHggIT09ICdvYmplY3QnKVxuICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgIHZhciBydiA9IGNpcmN1bGFyUmVmcy5nZXQoeCk7XG4gICAgICAgIGlmIChydilcbiAgICAgICAgICAgIHJldHVybiBydjtcbiAgICAgICAgaWYgKGlzQXJyYXkoeCkpIHtcbiAgICAgICAgICAgIHJ2ID0gW107XG4gICAgICAgICAgICBjaXJjdWxhclJlZnMuc2V0KHgsIHJ2KTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0geC5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgICAgICBydi5wdXNoKGlubmVyRGVlcENsb25lKHhbaV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbnRyaW5zaWNUeXBlcy5oYXMoeC5jb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgICAgIHJ2ID0geDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwcm90byA9IGdldFByb3RvKHgpO1xuICAgICAgICAgICAgcnYgPSBwcm90byA9PT0gT2JqZWN0LnByb3RvdHlwZSA/IHt9IDogT2JqZWN0LmNyZWF0ZShwcm90byk7XG4gICAgICAgICAgICBjaXJjdWxhclJlZnMuc2V0KHgsIHJ2KTtcbiAgICAgICAgICAgIGZvciAodmFyIHByb3AgaW4geCkge1xuICAgICAgICAgICAgICAgIGlmIChoYXNPd24oeCwgcHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcnZbcHJvcF0gPSBpbm5lckRlZXBDbG9uZSh4W3Byb3BdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJ2O1xuICAgIH1cbiAgICB2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcbiAgICBmdW5jdGlvbiB0b1N0cmluZ1RhZyhvKSB7XG4gICAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgICB9XG4gICAgdmFyIGl0ZXJhdG9yU3ltYm9sID0gdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgP1xuICAgICAgICBTeW1ib2wuaXRlcmF0b3IgOlxuICAgICAgICAnQEBpdGVyYXRvcic7XG4gICAgdmFyIGdldEl0ZXJhdG9yT2YgPSB0eXBlb2YgaXRlcmF0b3JTeW1ib2wgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgcmV0dXJuIHggIT0gbnVsbCAmJiAoaSA9IHhbaXRlcmF0b3JTeW1ib2xdKSAmJiBpLmFwcGx5KHgpO1xuICAgIH0gOiBmdW5jdGlvbiAoKSB7IHJldHVybiBudWxsOyB9O1xuICAgIGZ1bmN0aW9uIGRlbEFycmF5SXRlbShhLCB4KSB7XG4gICAgICAgIHZhciBpID0gYS5pbmRleE9mKHgpO1xuICAgICAgICBpZiAoaSA+PSAwKVxuICAgICAgICAgICAgYS5zcGxpY2UoaSwgMSk7XG4gICAgICAgIHJldHVybiBpID49IDA7XG4gICAgfVxuICAgIHZhciBOT19DSEFSX0FSUkFZID0ge307XG4gICAgZnVuY3Rpb24gZ2V0QXJyYXlPZihhcnJheUxpa2UpIHtcbiAgICAgICAgdmFyIGksIGEsIHgsIGl0O1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgaWYgKGlzQXJyYXkoYXJyYXlMaWtlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXlMaWtlLnNsaWNlKCk7XG4gICAgICAgICAgICBpZiAodGhpcyA9PT0gTk9fQ0hBUl9BUlJBWSAmJiB0eXBlb2YgYXJyYXlMaWtlID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICByZXR1cm4gW2FycmF5TGlrZV07XG4gICAgICAgICAgICBpZiAoKGl0ID0gZ2V0SXRlcmF0b3JPZihhcnJheUxpa2UpKSkge1xuICAgICAgICAgICAgICAgIGEgPSBbXTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoKHggPSBpdC5uZXh0KCkpLCAheC5kb25lKVxuICAgICAgICAgICAgICAgICAgICBhLnB1c2goeC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXJyYXlMaWtlID09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFthcnJheUxpa2VdO1xuICAgICAgICAgICAgaSA9IGFycmF5TGlrZS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGkgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgYSA9IG5ldyBBcnJheShpKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaS0tKVxuICAgICAgICAgICAgICAgICAgICBhW2ldID0gYXJyYXlMaWtlW2ldO1xuICAgICAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFthcnJheUxpa2VdO1xuICAgICAgICB9XG4gICAgICAgIGkgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICBhID0gbmV3IEFycmF5KGkpO1xuICAgICAgICB3aGlsZSAoaS0tKVxuICAgICAgICAgICAgYVtpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfVxuICAgIHZhciBpc0FzeW5jRnVuY3Rpb24gPSB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICA/IGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZm5bU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gJ0FzeW5jRnVuY3Rpb24nOyB9XG4gICAgICAgIDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsc2U7IH07XG5cbiAgICB2YXIgZGV4aWVFcnJvck5hbWVzID0gW1xuICAgICAgICAnTW9kaWZ5JyxcbiAgICAgICAgJ0J1bGsnLFxuICAgICAgICAnT3BlbkZhaWxlZCcsXG4gICAgICAgICdWZXJzaW9uQ2hhbmdlJyxcbiAgICAgICAgJ1NjaGVtYScsXG4gICAgICAgICdVcGdyYWRlJyxcbiAgICAgICAgJ0ludmFsaWRUYWJsZScsXG4gICAgICAgICdNaXNzaW5nQVBJJyxcbiAgICAgICAgJ05vU3VjaERhdGFiYXNlJyxcbiAgICAgICAgJ0ludmFsaWRBcmd1bWVudCcsXG4gICAgICAgICdTdWJUcmFuc2FjdGlvbicsXG4gICAgICAgICdVbnN1cHBvcnRlZCcsXG4gICAgICAgICdJbnRlcm5hbCcsXG4gICAgICAgICdEYXRhYmFzZUNsb3NlZCcsXG4gICAgICAgICdQcmVtYXR1cmVDb21taXQnLFxuICAgICAgICAnRm9yZWlnbkF3YWl0J1xuICAgIF07XG4gICAgdmFyIGlkYkRvbUVycm9yTmFtZXMgPSBbXG4gICAgICAgICdVbmtub3duJyxcbiAgICAgICAgJ0NvbnN0cmFpbnQnLFxuICAgICAgICAnRGF0YScsXG4gICAgICAgICdUcmFuc2FjdGlvbkluYWN0aXZlJyxcbiAgICAgICAgJ1JlYWRPbmx5JyxcbiAgICAgICAgJ1ZlcnNpb24nLFxuICAgICAgICAnTm90Rm91bmQnLFxuICAgICAgICAnSW52YWxpZFN0YXRlJyxcbiAgICAgICAgJ0ludmFsaWRBY2Nlc3MnLFxuICAgICAgICAnQWJvcnQnLFxuICAgICAgICAnVGltZW91dCcsXG4gICAgICAgICdRdW90YUV4Y2VlZGVkJyxcbiAgICAgICAgJ1N5bnRheCcsXG4gICAgICAgICdEYXRhQ2xvbmUnXG4gICAgXTtcbiAgICB2YXIgZXJyb3JMaXN0ID0gZGV4aWVFcnJvck5hbWVzLmNvbmNhdChpZGJEb21FcnJvck5hbWVzKTtcbiAgICB2YXIgZGVmYXVsdFRleHRzID0ge1xuICAgICAgICBWZXJzaW9uQ2hhbmdlZDogXCJEYXRhYmFzZSB2ZXJzaW9uIGNoYW5nZWQgYnkgb3RoZXIgZGF0YWJhc2UgY29ubmVjdGlvblwiLFxuICAgICAgICBEYXRhYmFzZUNsb3NlZDogXCJEYXRhYmFzZSBoYXMgYmVlbiBjbG9zZWRcIixcbiAgICAgICAgQWJvcnQ6IFwiVHJhbnNhY3Rpb24gYWJvcnRlZFwiLFxuICAgICAgICBUcmFuc2FjdGlvbkluYWN0aXZlOiBcIlRyYW5zYWN0aW9uIGhhcyBhbHJlYWR5IGNvbXBsZXRlZCBvciBmYWlsZWRcIixcbiAgICAgICAgTWlzc2luZ0FQSTogXCJJbmRleGVkREIgQVBJIG1pc3NpbmcuIFBsZWFzZSB2aXNpdCBodHRwczovL3Rpbnl1cmwuY29tL3kydXV2c2tiXCJcbiAgICB9O1xuICAgIGZ1bmN0aW9uIERleGllRXJyb3IobmFtZSwgbXNnKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1zZztcbiAgICB9XG4gICAgZGVyaXZlKERleGllRXJyb3IpLmZyb20oRXJyb3IpLmV4dGVuZCh7XG4gICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLm5hbWUgKyBcIjogXCIgKyB0aGlzLm1lc3NhZ2U7IH1cbiAgICB9KTtcbiAgICBmdW5jdGlvbiBnZXRNdWx0aUVycm9yTWVzc2FnZShtc2csIGZhaWx1cmVzKSB7XG4gICAgICAgIHJldHVybiBtc2cgKyBcIi4gRXJyb3JzOiBcIiArIE9iamVjdC5rZXlzKGZhaWx1cmVzKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBmYWlsdXJlc1trZXldLnRvU3RyaW5nKCk7IH0pXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uICh2LCBpLCBzKSB7IHJldHVybiBzLmluZGV4T2YodikgPT09IGk7IH0pXG4gICAgICAgICAgICAuam9pbignXFxuJyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIE1vZGlmeUVycm9yKG1zZywgZmFpbHVyZXMsIHN1Y2Nlc3NDb3VudCwgZmFpbGVkS2V5cykge1xuICAgICAgICB0aGlzLmZhaWx1cmVzID0gZmFpbHVyZXM7XG4gICAgICAgIHRoaXMuZmFpbGVkS2V5cyA9IGZhaWxlZEtleXM7XG4gICAgICAgIHRoaXMuc3VjY2Vzc0NvdW50ID0gc3VjY2Vzc0NvdW50O1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBnZXRNdWx0aUVycm9yTWVzc2FnZShtc2csIGZhaWx1cmVzKTtcbiAgICB9XG4gICAgZGVyaXZlKE1vZGlmeUVycm9yKS5mcm9tKERleGllRXJyb3IpO1xuICAgIGZ1bmN0aW9uIEJ1bGtFcnJvcihtc2csIGZhaWx1cmVzKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiQnVsa0Vycm9yXCI7XG4gICAgICAgIHRoaXMuZmFpbHVyZXMgPSBPYmplY3Qua2V5cyhmYWlsdXJlcykubWFwKGZ1bmN0aW9uIChwb3MpIHsgcmV0dXJuIGZhaWx1cmVzW3Bvc107IH0pO1xuICAgICAgICB0aGlzLmZhaWx1cmVzQnlQb3MgPSBmYWlsdXJlcztcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gZ2V0TXVsdGlFcnJvck1lc3NhZ2UobXNnLCB0aGlzLmZhaWx1cmVzKTtcbiAgICB9XG4gICAgZGVyaXZlKEJ1bGtFcnJvcikuZnJvbShEZXhpZUVycm9yKTtcbiAgICB2YXIgZXJybmFtZXMgPSBlcnJvckxpc3QucmVkdWNlKGZ1bmN0aW9uIChvYmosIG5hbWUpIHsgcmV0dXJuIChvYmpbbmFtZV0gPSBuYW1lICsgXCJFcnJvclwiLCBvYmopOyB9LCB7fSk7XG4gICAgdmFyIEJhc2VFeGNlcHRpb24gPSBEZXhpZUVycm9yO1xuICAgIHZhciBleGNlcHRpb25zID0gZXJyb3JMaXN0LnJlZHVjZShmdW5jdGlvbiAob2JqLCBuYW1lKSB7XG4gICAgICAgIHZhciBmdWxsTmFtZSA9IG5hbWUgKyBcIkVycm9yXCI7XG4gICAgICAgIGZ1bmN0aW9uIERleGllRXJyb3IobXNnT3JJbm5lciwgaW5uZXIpIHtcbiAgICAgICAgICAgIHRoaXMubmFtZSA9IGZ1bGxOYW1lO1xuICAgICAgICAgICAgaWYgKCFtc2dPcklubmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gZGVmYXVsdFRleHRzW25hbWVdIHx8IGZ1bGxOYW1lO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5uZXIgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG1zZ09ySW5uZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gXCJcIi5jb25jYXQobXNnT3JJbm5lcikuY29uY2F0KCFpbm5lciA/ICcnIDogJ1xcbiAnICsgaW5uZXIpO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5uZXIgPSBpbm5lciB8fCBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG1zZ09ySW5uZXIgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gXCJcIi5jb25jYXQobXNnT3JJbm5lci5uYW1lLCBcIiBcIikuY29uY2F0KG1zZ09ySW5uZXIubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5pbm5lciA9IG1zZ09ySW5uZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGVyaXZlKERleGllRXJyb3IpLmZyb20oQmFzZUV4Y2VwdGlvbik7XG4gICAgICAgIG9ialtuYW1lXSA9IERleGllRXJyb3I7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSwge30pO1xuICAgIGV4Y2VwdGlvbnMuU3ludGF4ID0gU3ludGF4RXJyb3I7XG4gICAgZXhjZXB0aW9ucy5UeXBlID0gVHlwZUVycm9yO1xuICAgIGV4Y2VwdGlvbnMuUmFuZ2UgPSBSYW5nZUVycm9yO1xuICAgIHZhciBleGNlcHRpb25NYXAgPSBpZGJEb21FcnJvck5hbWVzLnJlZHVjZShmdW5jdGlvbiAob2JqLCBuYW1lKSB7XG4gICAgICAgIG9ialtuYW1lICsgXCJFcnJvclwiXSA9IGV4Y2VwdGlvbnNbbmFtZV07XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSwge30pO1xuICAgIGZ1bmN0aW9uIG1hcEVycm9yKGRvbUVycm9yLCBtZXNzYWdlKSB7XG4gICAgICAgIGlmICghZG9tRXJyb3IgfHwgZG9tRXJyb3IgaW5zdGFuY2VvZiBEZXhpZUVycm9yIHx8IGRvbUVycm9yIGluc3RhbmNlb2YgVHlwZUVycm9yIHx8IGRvbUVycm9yIGluc3RhbmNlb2YgU3ludGF4RXJyb3IgfHwgIWRvbUVycm9yLm5hbWUgfHwgIWV4Y2VwdGlvbk1hcFtkb21FcnJvci5uYW1lXSlcbiAgICAgICAgICAgIHJldHVybiBkb21FcnJvcjtcbiAgICAgICAgdmFyIHJ2ID0gbmV3IGV4Y2VwdGlvbk1hcFtkb21FcnJvci5uYW1lXShtZXNzYWdlIHx8IGRvbUVycm9yLm1lc3NhZ2UsIGRvbUVycm9yKTtcbiAgICAgICAgaWYgKFwic3RhY2tcIiBpbiBkb21FcnJvcikge1xuICAgICAgICAgICAgc2V0UHJvcChydiwgXCJzdGFja1wiLCB7IGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbm5lci5zdGFjaztcbiAgICAgICAgICAgICAgICB9IH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBydjtcbiAgICB9XG4gICAgdmFyIGZ1bGxOYW1lRXhjZXB0aW9ucyA9IGVycm9yTGlzdC5yZWR1Y2UoZnVuY3Rpb24gKG9iaiwgbmFtZSkge1xuICAgICAgICBpZiAoW1wiU3ludGF4XCIsIFwiVHlwZVwiLCBcIlJhbmdlXCJdLmluZGV4T2YobmFtZSkgPT09IC0xKVxuICAgICAgICAgICAgb2JqW25hbWUgKyBcIkVycm9yXCJdID0gZXhjZXB0aW9uc1tuYW1lXTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LCB7fSk7XG4gICAgZnVsbE5hbWVFeGNlcHRpb25zLk1vZGlmeUVycm9yID0gTW9kaWZ5RXJyb3I7XG4gICAgZnVsbE5hbWVFeGNlcHRpb25zLkRleGllRXJyb3IgPSBEZXhpZUVycm9yO1xuICAgIGZ1bGxOYW1lRXhjZXB0aW9ucy5CdWxrRXJyb3IgPSBCdWxrRXJyb3I7XG5cbiAgICBmdW5jdGlvbiBub3AoKSB7IH1cbiAgICBmdW5jdGlvbiBtaXJyb3IodmFsKSB7IHJldHVybiB2YWw7IH1cbiAgICBmdW5jdGlvbiBwdXJlRnVuY3Rpb25DaGFpbihmMSwgZjIpIHtcbiAgICAgICAgaWYgKGYxID09IG51bGwgfHwgZjEgPT09IG1pcnJvcilcbiAgICAgICAgICAgIHJldHVybiBmMjtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiBmMihmMSh2YWwpKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2FsbEJvdGgob24xLCBvbjIpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIG9uMS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgb24yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhvb2tDcmVhdGluZ0NoYWluKGYxLCBmMikge1xuICAgICAgICBpZiAoZjEgPT09IG5vcClcbiAgICAgICAgICAgIHJldHVybiBmMjtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXMgPSBmMS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgaWYgKHJlcyAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGFyZ3VtZW50c1swXSA9IHJlcztcbiAgICAgICAgICAgIHZhciBvbnN1Y2Nlc3MgPSB0aGlzLm9uc3VjY2VzcyxcbiAgICAgICAgICAgIG9uZXJyb3IgPSB0aGlzLm9uZXJyb3I7XG4gICAgICAgICAgICB0aGlzLm9uc3VjY2VzcyA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLm9uZXJyb3IgPSBudWxsO1xuICAgICAgICAgICAgdmFyIHJlczIgPSBmMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgaWYgKG9uc3VjY2VzcylcbiAgICAgICAgICAgICAgICB0aGlzLm9uc3VjY2VzcyA9IHRoaXMub25zdWNjZXNzID8gY2FsbEJvdGgob25zdWNjZXNzLCB0aGlzLm9uc3VjY2VzcykgOiBvbnN1Y2Nlc3M7XG4gICAgICAgICAgICBpZiAob25lcnJvcilcbiAgICAgICAgICAgICAgICB0aGlzLm9uZXJyb3IgPSB0aGlzLm9uZXJyb3IgPyBjYWxsQm90aChvbmVycm9yLCB0aGlzLm9uZXJyb3IpIDogb25lcnJvcjtcbiAgICAgICAgICAgIHJldHVybiByZXMyICE9PSB1bmRlZmluZWQgPyByZXMyIDogcmVzO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBob29rRGVsZXRpbmdDaGFpbihmMSwgZjIpIHtcbiAgICAgICAgaWYgKGYxID09PSBub3ApXG4gICAgICAgICAgICByZXR1cm4gZjI7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmMS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgdmFyIG9uc3VjY2VzcyA9IHRoaXMub25zdWNjZXNzLFxuICAgICAgICAgICAgb25lcnJvciA9IHRoaXMub25lcnJvcjtcbiAgICAgICAgICAgIHRoaXMub25zdWNjZXNzID0gdGhpcy5vbmVycm9yID0gbnVsbDtcbiAgICAgICAgICAgIGYyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBpZiAob25zdWNjZXNzKVxuICAgICAgICAgICAgICAgIHRoaXMub25zdWNjZXNzID0gdGhpcy5vbnN1Y2Nlc3MgPyBjYWxsQm90aChvbnN1Y2Nlc3MsIHRoaXMub25zdWNjZXNzKSA6IG9uc3VjY2VzcztcbiAgICAgICAgICAgIGlmIChvbmVycm9yKVxuICAgICAgICAgICAgICAgIHRoaXMub25lcnJvciA9IHRoaXMub25lcnJvciA/IGNhbGxCb3RoKG9uZXJyb3IsIHRoaXMub25lcnJvcikgOiBvbmVycm9yO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBob29rVXBkYXRpbmdDaGFpbihmMSwgZjIpIHtcbiAgICAgICAgaWYgKGYxID09PSBub3ApXG4gICAgICAgICAgICByZXR1cm4gZjI7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAobW9kaWZpY2F0aW9ucykge1xuICAgICAgICAgICAgdmFyIHJlcyA9IGYxLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBleHRlbmQobW9kaWZpY2F0aW9ucywgcmVzKTtcbiAgICAgICAgICAgIHZhciBvbnN1Y2Nlc3MgPSB0aGlzLm9uc3VjY2VzcyxcbiAgICAgICAgICAgIG9uZXJyb3IgPSB0aGlzLm9uZXJyb3I7XG4gICAgICAgICAgICB0aGlzLm9uc3VjY2VzcyA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLm9uZXJyb3IgPSBudWxsO1xuICAgICAgICAgICAgdmFyIHJlczIgPSBmMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgaWYgKG9uc3VjY2VzcylcbiAgICAgICAgICAgICAgICB0aGlzLm9uc3VjY2VzcyA9IHRoaXMub25zdWNjZXNzID8gY2FsbEJvdGgob25zdWNjZXNzLCB0aGlzLm9uc3VjY2VzcykgOiBvbnN1Y2Nlc3M7XG4gICAgICAgICAgICBpZiAob25lcnJvcilcbiAgICAgICAgICAgICAgICB0aGlzLm9uZXJyb3IgPSB0aGlzLm9uZXJyb3IgPyBjYWxsQm90aChvbmVycm9yLCB0aGlzLm9uZXJyb3IpIDogb25lcnJvcjtcbiAgICAgICAgICAgIHJldHVybiByZXMgPT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICAgICAgKHJlczIgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHJlczIpIDpcbiAgICAgICAgICAgICAgICAoZXh0ZW5kKHJlcywgcmVzMikpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXZlcnNlU3RvcHBhYmxlRXZlbnRDaGFpbihmMSwgZjIpIHtcbiAgICAgICAgaWYgKGYxID09PSBub3ApXG4gICAgICAgICAgICByZXR1cm4gZjI7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoZjIuYXBwbHkodGhpcywgYXJndW1lbnRzKSA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIGYxLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByb21pc2FibGVDaGFpbihmMSwgZjIpIHtcbiAgICAgICAgaWYgKGYxID09PSBub3ApXG4gICAgICAgICAgICByZXR1cm4gZjI7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVzID0gZjEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIGlmIChyZXMgJiYgdHlwZW9mIHJlcy50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRoaXogPSB0aGlzLCBpID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShpKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaS0tKVxuICAgICAgICAgICAgICAgICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXMudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmMi5hcHBseSh0aGl6LCBhcmdzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBkZWJ1ZyA9IHR5cGVvZiBsb2NhdGlvbiAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgL14oaHR0cHxodHRwcyk6XFwvXFwvKGxvY2FsaG9zdHwxMjdcXC4wXFwuMFxcLjEpLy50ZXN0KGxvY2F0aW9uLmhyZWYpO1xuICAgIGZ1bmN0aW9uIHNldERlYnVnKHZhbHVlLCBmaWx0ZXIpIHtcbiAgICAgICAgZGVidWcgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICB2YXIgSU5URVJOQUwgPSB7fTtcbiAgICB2YXIgWk9ORV9FQ0hPX0xJTUlUID0gMTAwLCBfYSQxID0gdHlwZW9mIFByb21pc2UgPT09ICd1bmRlZmluZWQnID9cbiAgICAgICAgW10gOlxuICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGdsb2JhbFAgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY3J5cHRvID09PSAndW5kZWZpbmVkJyB8fCAhY3J5cHRvLnN1YnRsZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gW2dsb2JhbFAsIGdldFByb3RvKGdsb2JhbFApLCBnbG9iYWxQXTtcbiAgICAgICAgICAgIHZhciBuYXRpdmVQID0gY3J5cHRvLnN1YnRsZS5kaWdlc3QoXCJTSEEtNTEyXCIsIG5ldyBVaW50OEFycmF5KFswXSkpO1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBuYXRpdmVQLFxuICAgICAgICAgICAgICAgIGdldFByb3RvKG5hdGl2ZVApLFxuICAgICAgICAgICAgICAgIGdsb2JhbFBcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0pKCksIHJlc29sdmVkTmF0aXZlUHJvbWlzZSA9IF9hJDFbMF0sIG5hdGl2ZVByb21pc2VQcm90byA9IF9hJDFbMV0sIHJlc29sdmVkR2xvYmFsUHJvbWlzZSA9IF9hJDFbMl0sIG5hdGl2ZVByb21pc2VUaGVuID0gbmF0aXZlUHJvbWlzZVByb3RvICYmIG5hdGl2ZVByb21pc2VQcm90by50aGVuO1xuICAgIHZhciBOYXRpdmVQcm9taXNlID0gcmVzb2x2ZWROYXRpdmVQcm9taXNlICYmIHJlc29sdmVkTmF0aXZlUHJvbWlzZS5jb25zdHJ1Y3RvcjtcbiAgICB2YXIgcGF0Y2hHbG9iYWxQcm9taXNlID0gISFyZXNvbHZlZEdsb2JhbFByb21pc2U7XG4gICAgZnVuY3Rpb24gc2NoZWR1bGVQaHlzaWNhbFRpY2soKSB7XG4gICAgICAgIHF1ZXVlTWljcm90YXNrKHBoeXNpY2FsVGljayk7XG4gICAgfVxuICAgIHZhciBhc2FwID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBhcmdzKSB7XG4gICAgICAgIG1pY3JvdGlja1F1ZXVlLnB1c2goW2NhbGxiYWNrLCBhcmdzXSk7XG4gICAgICAgIGlmIChuZWVkc05ld1BoeXNpY2FsVGljaykge1xuICAgICAgICAgICAgc2NoZWR1bGVQaHlzaWNhbFRpY2soKTtcbiAgICAgICAgICAgIG5lZWRzTmV3UGh5c2ljYWxUaWNrID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBpc091dHNpZGVNaWNyb1RpY2sgPSB0cnVlLFxuICAgIG5lZWRzTmV3UGh5c2ljYWxUaWNrID0gdHJ1ZSxcbiAgICB1bmhhbmRsZWRFcnJvcnMgPSBbXSxcbiAgICByZWplY3RpbmdFcnJvcnMgPSBbXSxcbiAgICByZWplY3Rpb25NYXBwZXIgPSBtaXJyb3I7XG4gICAgdmFyIGdsb2JhbFBTRCA9IHtcbiAgICAgICAgaWQ6ICdnbG9iYWwnLFxuICAgICAgICBnbG9iYWw6IHRydWUsXG4gICAgICAgIHJlZjogMCxcbiAgICAgICAgdW5oYW5kbGVkczogW10sXG4gICAgICAgIG9udW5oYW5kbGVkOiBub3AsXG4gICAgICAgIHBncDogZmFsc2UsXG4gICAgICAgIGVudjoge30sXG4gICAgICAgIGZpbmFsaXplOiBub3BcbiAgICB9O1xuICAgIHZhciBQU0QgPSBnbG9iYWxQU0Q7XG4gICAgdmFyIG1pY3JvdGlja1F1ZXVlID0gW107XG4gICAgdmFyIG51bVNjaGVkdWxlZENhbGxzID0gMDtcbiAgICB2YXIgdGlja0ZpbmFsaXplcnMgPSBbXTtcbiAgICBmdW5jdGlvbiBEZXhpZVByb21pc2UoZm4pIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzICE9PSAnb2JqZWN0JylcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Byb21pc2VzIG11c3QgYmUgY29uc3RydWN0ZWQgdmlhIG5ldycpO1xuICAgICAgICB0aGlzLl9saXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgdGhpcy5fbGliID0gZmFsc2U7XG4gICAgICAgIHZhciBwc2QgPSAodGhpcy5fUFNEID0gUFNEKTtcbiAgICAgICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgaWYgKGZuICE9PSBJTlRFUk5BTClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdOb3QgYSBmdW5jdGlvbicpO1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IGFyZ3VtZW50c1syXTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgaGFuZGxlUmVqZWN0aW9uKHRoaXMsIHRoaXMuX3ZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zdGF0ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gbnVsbDtcbiAgICAgICAgKytwc2QucmVmO1xuICAgICAgICBleGVjdXRlUHJvbWlzZVRhc2sodGhpcywgZm4pO1xuICAgIH1cbiAgICB2YXIgdGhlblByb3AgPSB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHBzZCA9IFBTRCwgbWljcm9UYXNrSWQgPSB0b3RhbEVjaG9lcztcbiAgICAgICAgICAgIGZ1bmN0aW9uIHRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHZhciBwb3NzaWJsZUF3YWl0ID0gIXBzZC5nbG9iYWwgJiYgKHBzZCAhPT0gUFNEIHx8IG1pY3JvVGFza0lkICE9PSB0b3RhbEVjaG9lcyk7XG4gICAgICAgICAgICAgICAgdmFyIGNsZWFudXAgPSBwb3NzaWJsZUF3YWl0ICYmICFkZWNyZW1lbnRFeHBlY3RlZEF3YWl0cygpO1xuICAgICAgICAgICAgICAgIHZhciBydiA9IG5ldyBEZXhpZVByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgICBwcm9wYWdhdGVUb0xpc3RlbmVyKF90aGlzLCBuZXcgTGlzdGVuZXIobmF0aXZlQXdhaXRDb21wYXRpYmxlV3JhcChvbkZ1bGZpbGxlZCwgcHNkLCBwb3NzaWJsZUF3YWl0LCBjbGVhbnVwKSwgbmF0aXZlQXdhaXRDb21wYXRpYmxlV3JhcChvblJlamVjdGVkLCBwc2QsIHBvc3NpYmxlQXdhaXQsIGNsZWFudXApLCByZXNvbHZlLCByZWplY3QsIHBzZCkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jb25zb2xlVGFzaylcbiAgICAgICAgICAgICAgICAgICAgcnYuX2NvbnNvbGVUYXNrID0gdGhpcy5fY29uc29sZVRhc2s7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJ2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhlbi5wcm90b3R5cGUgPSBJTlRFUk5BTDtcbiAgICAgICAgICAgIHJldHVybiB0aGVuO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgc2V0UHJvcCh0aGlzLCAndGhlbicsIHZhbHVlICYmIHZhbHVlLnByb3RvdHlwZSA9PT0gSU5URVJOQUwgP1xuICAgICAgICAgICAgICAgIHRoZW5Qcm9wIDpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBzZXQ6IHRoZW5Qcm9wLnNldFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBwcm9wcyhEZXhpZVByb21pc2UucHJvdG90eXBlLCB7XG4gICAgICAgIHRoZW46IHRoZW5Qcm9wLFxuICAgICAgICBfdGhlbjogZnVuY3Rpb24gKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgICAgICAgICBwcm9wYWdhdGVUb0xpc3RlbmVyKHRoaXMsIG5ldyBMaXN0ZW5lcihudWxsLCBudWxsLCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgUFNEKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNhdGNoOiBmdW5jdGlvbiAob25SZWplY3RlZCkge1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudGhlbihudWxsLCBvblJlamVjdGVkKTtcbiAgICAgICAgICAgIHZhciB0eXBlID0gYXJndW1lbnRzWzBdLCBoYW5kbGVyID0gYXJndW1lbnRzWzFdO1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdGhpcy50aGVuKG51bGwsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyIGluc3RhbmNlb2YgdHlwZSA/IGhhbmRsZXIoZXJyKSA6IFByb21pc2VSZWplY3QoZXJyKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgOiB0aGlzLnRoZW4obnVsbCwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyICYmIGVyci5uYW1lID09PSB0eXBlID8gaGFuZGxlcihlcnIpIDogUHJvbWlzZVJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBmaW5hbGx5OiBmdW5jdGlvbiAob25GaW5hbGx5KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBEZXhpZVByb21pc2UucmVzb2x2ZShvbkZpbmFsbHkoKSkudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiB2YWx1ZTsgfSk7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIERleGllUHJvbWlzZS5yZXNvbHZlKG9uRmluYWxseSgpKS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIFByb21pc2VSZWplY3QoZXJyKTsgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgdGltZW91dDogZnVuY3Rpb24gKG1zLCBtc2cpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gbXMgPCBJbmZpbml0eSA/XG4gICAgICAgICAgICAgICAgbmV3IERleGllUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBoYW5kbGUgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlamVjdChuZXcgZXhjZXB0aW9ucy5UaW1lb3V0KG1zZykpOyB9LCBtcyk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KS5maW5hbGx5KGNsZWFyVGltZW91dC5iaW5kKG51bGwsIGhhbmRsZSkpO1xuICAgICAgICAgICAgICAgIH0pIDogdGhpcztcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpXG4gICAgICAgIHNldFByb3AoRGV4aWVQcm9taXNlLnByb3RvdHlwZSwgU3ltYm9sLnRvU3RyaW5nVGFnLCAnRGV4aWUuUHJvbWlzZScpO1xuICAgIGdsb2JhbFBTRC5lbnYgPSBzbmFwU2hvdCgpO1xuICAgIGZ1bmN0aW9uIExpc3RlbmVyKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCByZXNvbHZlLCByZWplY3QsIHpvbmUpIHtcbiAgICAgICAgdGhpcy5vbkZ1bGZpbGxlZCA9IHR5cGVvZiBvbkZ1bGZpbGxlZCA9PT0gJ2Z1bmN0aW9uJyA/IG9uRnVsZmlsbGVkIDogbnVsbDtcbiAgICAgICAgdGhpcy5vblJlamVjdGVkID0gdHlwZW9mIG9uUmVqZWN0ZWQgPT09ICdmdW5jdGlvbicgPyBvblJlamVjdGVkIDogbnVsbDtcbiAgICAgICAgdGhpcy5yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgdGhpcy5yZWplY3QgPSByZWplY3Q7XG4gICAgICAgIHRoaXMucHNkID0gem9uZTtcbiAgICB9XG4gICAgcHJvcHMoRGV4aWVQcm9taXNlLCB7XG4gICAgICAgIGFsbDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlcyA9IGdldEFycmF5T2YuYXBwbHkobnVsbCwgYXJndW1lbnRzKVxuICAgICAgICAgICAgICAgIC5tYXAob25Qb3NzaWJsZVBhcmFsbGVsbEFzeW5jKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGV4aWVQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShbXSk7XG4gICAgICAgICAgICAgICAgdmFyIHJlbWFpbmluZyA9IHZhbHVlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgdmFsdWVzLmZvckVhY2goZnVuY3Rpb24gKGEsIGkpIHsgcmV0dXJuIERleGllUHJvbWlzZS5yZXNvbHZlKGEpLnRoZW4oZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzW2ldID0geDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEtLXJlbWFpbmluZylcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUodmFsdWVzKTtcbiAgICAgICAgICAgICAgICB9LCByZWplY3QpOyB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICByZXNvbHZlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERleGllUHJvbWlzZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlLnRoZW4gPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEZXhpZVByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgcnYgPSBuZXcgRGV4aWVQcm9taXNlKElOVEVSTkFMLCB0cnVlLCB2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gcnY7XG4gICAgICAgIH0sXG4gICAgICAgIHJlamVjdDogUHJvbWlzZVJlamVjdCxcbiAgICAgICAgcmFjZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlcyA9IGdldEFycmF5T2YuYXBwbHkobnVsbCwgYXJndW1lbnRzKS5tYXAob25Qb3NzaWJsZVBhcmFsbGVsbEFzeW5jKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGV4aWVQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZXMubWFwKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gRGV4aWVQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTsgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgUFNEOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFBTRDsgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBQU0QgPSB2YWx1ZTsgfVxuICAgICAgICB9LFxuICAgICAgICB0b3RhbEVjaG9lczogeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRvdGFsRWNob2VzOyB9IH0sXG4gICAgICAgIG5ld1BTRDogbmV3U2NvcGUsXG4gICAgICAgIHVzZVBTRDogdXNlUFNELFxuICAgICAgICBzY2hlZHVsZXI6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYXNhcDsgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7IGFzYXAgPSB2YWx1ZTsgfVxuICAgICAgICB9LFxuICAgICAgICByZWplY3Rpb25NYXBwZXI6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVqZWN0aW9uTWFwcGVyOyB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHsgcmVqZWN0aW9uTWFwcGVyID0gdmFsdWU7IH1cbiAgICAgICAgfSxcbiAgICAgICAgZm9sbG93OiBmdW5jdGlvbiAoZm4sIHpvbmVQcm9wcykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEZXhpZVByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXdTY29wZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwc2QgPSBQU0Q7XG4gICAgICAgICAgICAgICAgICAgIHBzZC51bmhhbmRsZWRzID0gW107XG4gICAgICAgICAgICAgICAgICAgIHBzZC5vbnVuaGFuZGxlZCA9IHJlamVjdDtcbiAgICAgICAgICAgICAgICAgICAgcHNkLmZpbmFsaXplID0gY2FsbEJvdGgoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bl9hdF9lbmRfb2ZfdGhpc19vcl9uZXh0X3BoeXNpY2FsX3RpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnVuaGFuZGxlZHMubGVuZ3RoID09PSAwID8gcmVzb2x2ZSgpIDogcmVqZWN0KF90aGlzLnVuaGFuZGxlZHNbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0sIHBzZC5maW5hbGl6ZSk7XG4gICAgICAgICAgICAgICAgICAgIGZuKCk7XG4gICAgICAgICAgICAgICAgfSwgem9uZVByb3BzLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoTmF0aXZlUHJvbWlzZSkge1xuICAgICAgICBpZiAoTmF0aXZlUHJvbWlzZS5hbGxTZXR0bGVkKVxuICAgICAgICAgICAgc2V0UHJvcChEZXhpZVByb21pc2UsIFwiYWxsU2V0dGxlZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBvc3NpYmxlUHJvbWlzZXMgPSBnZXRBcnJheU9mLmFwcGx5KG51bGwsIGFyZ3VtZW50cykubWFwKG9uUG9zc2libGVQYXJhbGxlbGxBc3luYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEZXhpZVByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvc3NpYmxlUHJvbWlzZXMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShbXSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZW1haW5pbmcgPSBwb3NzaWJsZVByb21pc2VzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSBuZXcgQXJyYXkocmVtYWluaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgcG9zc2libGVQcm9taXNlcy5mb3JFYWNoKGZ1bmN0aW9uIChwLCBpKSB7IHJldHVybiBEZXhpZVByb21pc2UucmVzb2x2ZShwKS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gcmVzdWx0c1tpXSA9IHsgc3RhdHVzOiBcImZ1bGZpbGxlZFwiLCB2YWx1ZTogdmFsdWUgfTsgfSwgZnVuY3Rpb24gKHJlYXNvbikgeyByZXR1cm4gcmVzdWx0c1tpXSA9IHsgc3RhdHVzOiBcInJlamVjdGVkXCIsIHJlYXNvbjogcmVhc29uIH07IH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiAtLXJlbWFpbmluZyB8fCByZXNvbHZlKHJlc3VsdHMpOyB9KTsgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgaWYgKE5hdGl2ZVByb21pc2UuYW55ICYmIHR5cGVvZiBBZ2dyZWdhdGVFcnJvciAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICBzZXRQcm9wKERleGllUHJvbWlzZSwgXCJhbnlcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBwb3NzaWJsZVByb21pc2VzID0gZ2V0QXJyYXlPZi5hcHBseShudWxsLCBhcmd1bWVudHMpLm1hcChvblBvc3NpYmxlUGFyYWxsZWxsQXN5bmMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGV4aWVQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvc3NpYmxlUHJvbWlzZXMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBBZ2dyZWdhdGVFcnJvcihbXSkpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVtYWluaW5nID0gcG9zc2libGVQcm9taXNlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmYWlsdXJlcyA9IG5ldyBBcnJheShyZW1haW5pbmcpO1xuICAgICAgICAgICAgICAgICAgICBwb3NzaWJsZVByb21pc2VzLmZvckVhY2goZnVuY3Rpb24gKHAsIGkpIHsgcmV0dXJuIERleGllUHJvbWlzZS5yZXNvbHZlKHApLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiByZXNvbHZlKHZhbHVlKTsgfSwgZnVuY3Rpb24gKGZhaWx1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhaWx1cmVzW2ldID0gZmFpbHVyZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghLS1yZW1haW5pbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBBZ2dyZWdhdGVFcnJvcihmYWlsdXJlcykpO1xuICAgICAgICAgICAgICAgICAgICB9KTsgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgaWYgKE5hdGl2ZVByb21pc2Uud2l0aFJlc29sdmVycylcbiAgICAgICAgICAgIERleGllUHJvbWlzZS53aXRoUmVzb2x2ZXJzID0gTmF0aXZlUHJvbWlzZS53aXRoUmVzb2x2ZXJzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBleGVjdXRlUHJvbWlzZVRhc2socHJvbWlzZSwgZm4pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChwcm9taXNlLl9zdGF0ZSAhPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gcHJvbWlzZSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQSBwcm9taXNlIGNhbm5vdCBiZSByZXNvbHZlZCB3aXRoIGl0c2VsZi4nKTtcbiAgICAgICAgICAgICAgICB2YXIgc2hvdWxkRXhlY3V0ZVRpY2sgPSBwcm9taXNlLl9saWIgJiYgYmVnaW5NaWNyb1RpY2tTY29wZSgpO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBleGVjdXRlUHJvbWlzZVRhc2socHJvbWlzZSwgZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBEZXhpZVByb21pc2UgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLl90aGVuKHJlc29sdmUsIHJlamVjdCkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwcm9taXNlLl9zdGF0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHByb21pc2UuX3ZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHByb3BhZ2F0ZUFsbExpc3RlbmVycyhwcm9taXNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZEV4ZWN1dGVUaWNrKVxuICAgICAgICAgICAgICAgICAgICBlbmRNaWNyb1RpY2tTY29wZSgpO1xuICAgICAgICAgICAgfSwgaGFuZGxlUmVqZWN0aW9uLmJpbmQobnVsbCwgcHJvbWlzZSkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChleCkge1xuICAgICAgICAgICAgaGFuZGxlUmVqZWN0aW9uKHByb21pc2UsIGV4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVSZWplY3Rpb24ocHJvbWlzZSwgcmVhc29uKSB7XG4gICAgICAgIHJlamVjdGluZ0Vycm9ycy5wdXNoKHJlYXNvbik7XG4gICAgICAgIGlmIChwcm9taXNlLl9zdGF0ZSAhPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIHNob3VsZEV4ZWN1dGVUaWNrID0gcHJvbWlzZS5fbGliICYmIGJlZ2luTWljcm9UaWNrU2NvcGUoKTtcbiAgICAgICAgcmVhc29uID0gcmVqZWN0aW9uTWFwcGVyKHJlYXNvbik7XG4gICAgICAgIHByb21pc2UuX3N0YXRlID0gZmFsc2U7XG4gICAgICAgIHByb21pc2UuX3ZhbHVlID0gcmVhc29uO1xuICAgICAgICBhZGRQb3NzaWJseVVuaGFuZGxlZEVycm9yKHByb21pc2UpO1xuICAgICAgICBwcm9wYWdhdGVBbGxMaXN0ZW5lcnMocHJvbWlzZSk7XG4gICAgICAgIGlmIChzaG91bGRFeGVjdXRlVGljaylcbiAgICAgICAgICAgIGVuZE1pY3JvVGlja1Njb3BlKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByb3BhZ2F0ZUFsbExpc3RlbmVycyhwcm9taXNlKSB7XG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSBwcm9taXNlLl9saXN0ZW5lcnM7XG4gICAgICAgIHByb21pc2UuX2xpc3RlbmVycyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICBwcm9wYWdhdGVUb0xpc3RlbmVyKHByb21pc2UsIGxpc3RlbmVyc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBzZCA9IHByb21pc2UuX1BTRDtcbiAgICAgICAgLS1wc2QucmVmIHx8IHBzZC5maW5hbGl6ZSgpO1xuICAgICAgICBpZiAobnVtU2NoZWR1bGVkQ2FsbHMgPT09IDApIHtcbiAgICAgICAgICAgICsrbnVtU2NoZWR1bGVkQ2FsbHM7XG4gICAgICAgICAgICBhc2FwKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoLS1udW1TY2hlZHVsZWRDYWxscyA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgZmluYWxpemVQaHlzaWNhbFRpY2soKTtcbiAgICAgICAgICAgIH0sIFtdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBwcm9wYWdhdGVUb0xpc3RlbmVyKHByb21pc2UsIGxpc3RlbmVyKSB7XG4gICAgICAgIGlmIChwcm9taXNlLl9zdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcHJvbWlzZS5fbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjYiA9IHByb21pc2UuX3N0YXRlID8gbGlzdGVuZXIub25GdWxmaWxsZWQgOiBsaXN0ZW5lci5vblJlamVjdGVkO1xuICAgICAgICBpZiAoY2IgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiAocHJvbWlzZS5fc3RhdGUgPyBsaXN0ZW5lci5yZXNvbHZlIDogbGlzdGVuZXIucmVqZWN0KShwcm9taXNlLl92YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgKytsaXN0ZW5lci5wc2QucmVmO1xuICAgICAgICArK251bVNjaGVkdWxlZENhbGxzO1xuICAgICAgICBhc2FwKGNhbGxMaXN0ZW5lciwgW2NiLCBwcm9taXNlLCBsaXN0ZW5lcl0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjYWxsTGlzdGVuZXIoY2IsIHByb21pc2UsIGxpc3RlbmVyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgcmV0LCB2YWx1ZSA9IHByb21pc2UuX3ZhbHVlO1xuICAgICAgICAgICAgaWYgKCFwcm9taXNlLl9zdGF0ZSAmJiByZWplY3RpbmdFcnJvcnMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJlamVjdGluZ0Vycm9ycyA9IFtdO1xuICAgICAgICAgICAgcmV0ID0gZGVidWcgJiYgcHJvbWlzZS5fY29uc29sZVRhc2sgPyBwcm9taXNlLl9jb25zb2xlVGFzay5ydW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gY2IodmFsdWUpOyB9KSA6IGNiKHZhbHVlKTtcbiAgICAgICAgICAgIGlmICghcHJvbWlzZS5fc3RhdGUgJiYgcmVqZWN0aW5nRXJyb3JzLmluZGV4T2YodmFsdWUpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIG1hcmtFcnJvckFzSGFuZGxlZChwcm9taXNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpc3RlbmVyLnJlc29sdmUocmV0KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbGlzdGVuZXIucmVqZWN0KGUpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKC0tbnVtU2NoZWR1bGVkQ2FsbHMgPT09IDApXG4gICAgICAgICAgICAgICAgZmluYWxpemVQaHlzaWNhbFRpY2soKTtcbiAgICAgICAgICAgIC0tbGlzdGVuZXIucHNkLnJlZiB8fCBsaXN0ZW5lci5wc2QuZmluYWxpemUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBwaHlzaWNhbFRpY2soKSB7XG4gICAgICAgIHVzZVBTRChnbG9iYWxQU0QsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGJlZ2luTWljcm9UaWNrU2NvcGUoKSAmJiBlbmRNaWNyb1RpY2tTY29wZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYmVnaW5NaWNyb1RpY2tTY29wZSgpIHtcbiAgICAgICAgdmFyIHdhc1Jvb3RFeGVjID0gaXNPdXRzaWRlTWljcm9UaWNrO1xuICAgICAgICBpc091dHNpZGVNaWNyb1RpY2sgPSBmYWxzZTtcbiAgICAgICAgbmVlZHNOZXdQaHlzaWNhbFRpY2sgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHdhc1Jvb3RFeGVjO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbmRNaWNyb1RpY2tTY29wZSgpIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrcywgaSwgbDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgd2hpbGUgKG1pY3JvdGlja1F1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFja3MgPSBtaWNyb3RpY2tRdWV1ZTtcbiAgICAgICAgICAgICAgICBtaWNyb3RpY2tRdWV1ZSA9IFtdO1xuICAgICAgICAgICAgICAgIGwgPSBjYWxsYmFja3MubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBjYWxsYmFja3NbaV07XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1bMF0uYXBwbHkobnVsbCwgaXRlbVsxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlIChtaWNyb3RpY2tRdWV1ZS5sZW5ndGggPiAwKTtcbiAgICAgICAgaXNPdXRzaWRlTWljcm9UaWNrID0gdHJ1ZTtcbiAgICAgICAgbmVlZHNOZXdQaHlzaWNhbFRpY2sgPSB0cnVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmaW5hbGl6ZVBoeXNpY2FsVGljaygpIHtcbiAgICAgICAgdmFyIHVuaGFuZGxlZEVycnMgPSB1bmhhbmRsZWRFcnJvcnM7XG4gICAgICAgIHVuaGFuZGxlZEVycm9ycyA9IFtdO1xuICAgICAgICB1bmhhbmRsZWRFcnJzLmZvckVhY2goZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICAgIHAuX1BTRC5vbnVuaGFuZGxlZC5jYWxsKG51bGwsIHAuX3ZhbHVlLCBwKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBmaW5hbGl6ZXJzID0gdGlja0ZpbmFsaXplcnMuc2xpY2UoMCk7XG4gICAgICAgIHZhciBpID0gZmluYWxpemVycy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpKVxuICAgICAgICAgICAgZmluYWxpemVyc1stLWldKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJ1bl9hdF9lbmRfb2ZfdGhpc19vcl9uZXh0X3BoeXNpY2FsX3RpY2soZm4pIHtcbiAgICAgICAgZnVuY3Rpb24gZmluYWxpemVyKCkge1xuICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgICAgIHRpY2tGaW5hbGl6ZXJzLnNwbGljZSh0aWNrRmluYWxpemVycy5pbmRleE9mKGZpbmFsaXplciksIDEpO1xuICAgICAgICB9XG4gICAgICAgIHRpY2tGaW5hbGl6ZXJzLnB1c2goZmluYWxpemVyKTtcbiAgICAgICAgKytudW1TY2hlZHVsZWRDYWxscztcbiAgICAgICAgYXNhcChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoLS1udW1TY2hlZHVsZWRDYWxscyA9PT0gMClcbiAgICAgICAgICAgICAgICBmaW5hbGl6ZVBoeXNpY2FsVGljaygpO1xuICAgICAgICB9LCBbXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFkZFBvc3NpYmx5VW5oYW5kbGVkRXJyb3IocHJvbWlzZSkge1xuICAgICAgICBpZiAoIXVuaGFuZGxlZEVycm9ycy5zb21lKGZ1bmN0aW9uIChwKSB7IHJldHVybiBwLl92YWx1ZSA9PT0gcHJvbWlzZS5fdmFsdWU7IH0pKVxuICAgICAgICAgICAgdW5oYW5kbGVkRXJyb3JzLnB1c2gocHJvbWlzZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1hcmtFcnJvckFzSGFuZGxlZChwcm9taXNlKSB7XG4gICAgICAgIHZhciBpID0gdW5oYW5kbGVkRXJyb3JzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGkpXG4gICAgICAgICAgICBpZiAodW5oYW5kbGVkRXJyb3JzWy0taV0uX3ZhbHVlID09PSBwcm9taXNlLl92YWx1ZSkge1xuICAgICAgICAgICAgICAgIHVuaGFuZGxlZEVycm9ycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBQcm9taXNlUmVqZWN0KHJlYXNvbikge1xuICAgICAgICByZXR1cm4gbmV3IERleGllUHJvbWlzZShJTlRFUk5BTCwgZmFsc2UsIHJlYXNvbik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdyYXAoZm4sIGVycm9yQ2F0Y2hlcikge1xuICAgICAgICB2YXIgcHNkID0gUFNEO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHdhc1Jvb3RFeGVjID0gYmVnaW5NaWNyb1RpY2tTY29wZSgpLCBvdXRlclNjb3BlID0gUFNEO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzd2l0Y2hUb1pvbmUocHNkLCB0cnVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JDYXRjaGVyICYmIGVycm9yQ2F0Y2hlcihlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHN3aXRjaFRvWm9uZShvdXRlclNjb3BlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgaWYgKHdhc1Jvb3RFeGVjKVxuICAgICAgICAgICAgICAgICAgICBlbmRNaWNyb1RpY2tTY29wZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICB2YXIgdGFzayA9IHsgYXdhaXRzOiAwLCBlY2hvZXM6IDAsIGlkOiAwIH07XG4gICAgdmFyIHRhc2tDb3VudGVyID0gMDtcbiAgICB2YXIgem9uZVN0YWNrID0gW107XG4gICAgdmFyIHpvbmVFY2hvZXMgPSAwO1xuICAgIHZhciB0b3RhbEVjaG9lcyA9IDA7XG4gICAgdmFyIHpvbmVfaWRfY291bnRlciA9IDA7XG4gICAgZnVuY3Rpb24gbmV3U2NvcGUoZm4sIHByb3BzLCBhMSwgYTIpIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IFBTRCwgcHNkID0gT2JqZWN0LmNyZWF0ZShwYXJlbnQpO1xuICAgICAgICBwc2QucGFyZW50ID0gcGFyZW50O1xuICAgICAgICBwc2QucmVmID0gMDtcbiAgICAgICAgcHNkLmdsb2JhbCA9IGZhbHNlO1xuICAgICAgICBwc2QuaWQgPSArK3pvbmVfaWRfY291bnRlcjtcbiAgICAgICAgZ2xvYmFsUFNELmVudjtcbiAgICAgICAgcHNkLmVudiA9IHBhdGNoR2xvYmFsUHJvbWlzZSA/IHtcbiAgICAgICAgICAgIFByb21pc2U6IERleGllUHJvbWlzZSxcbiAgICAgICAgICAgIFByb21pc2VQcm9wOiB7IHZhbHVlOiBEZXhpZVByb21pc2UsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSxcbiAgICAgICAgICAgIGFsbDogRGV4aWVQcm9taXNlLmFsbCxcbiAgICAgICAgICAgIHJhY2U6IERleGllUHJvbWlzZS5yYWNlLFxuICAgICAgICAgICAgYWxsU2V0dGxlZDogRGV4aWVQcm9taXNlLmFsbFNldHRsZWQsXG4gICAgICAgICAgICBhbnk6IERleGllUHJvbWlzZS5hbnksXG4gICAgICAgICAgICByZXNvbHZlOiBEZXhpZVByb21pc2UucmVzb2x2ZSxcbiAgICAgICAgICAgIHJlamVjdDogRGV4aWVQcm9taXNlLnJlamVjdCxcbiAgICAgICAgfSA6IHt9O1xuICAgICAgICBpZiAocHJvcHMpXG4gICAgICAgICAgICBleHRlbmQocHNkLCBwcm9wcyk7XG4gICAgICAgICsrcGFyZW50LnJlZjtcbiAgICAgICAgcHNkLmZpbmFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLS10aGlzLnBhcmVudC5yZWYgfHwgdGhpcy5wYXJlbnQuZmluYWxpemUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHJ2ID0gdXNlUFNEKHBzZCwgZm4sIGExLCBhMik7XG4gICAgICAgIGlmIChwc2QucmVmID09PSAwKVxuICAgICAgICAgICAgcHNkLmZpbmFsaXplKCk7XG4gICAgICAgIHJldHVybiBydjtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW5jcmVtZW50RXhwZWN0ZWRBd2FpdHMoKSB7XG4gICAgICAgIGlmICghdGFzay5pZClcbiAgICAgICAgICAgIHRhc2suaWQgPSArK3Rhc2tDb3VudGVyO1xuICAgICAgICArK3Rhc2suYXdhaXRzO1xuICAgICAgICB0YXNrLmVjaG9lcyArPSBaT05FX0VDSE9fTElNSVQ7XG4gICAgICAgIHJldHVybiB0YXNrLmlkO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWNyZW1lbnRFeHBlY3RlZEF3YWl0cygpIHtcbiAgICAgICAgaWYgKCF0YXNrLmF3YWl0cylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKC0tdGFzay5hd2FpdHMgPT09IDApXG4gICAgICAgICAgICB0YXNrLmlkID0gMDtcbiAgICAgICAgdGFzay5lY2hvZXMgPSB0YXNrLmF3YWl0cyAqIFpPTkVfRUNIT19MSU1JVDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICgoJycgKyBuYXRpdmVQcm9taXNlVGhlbikuaW5kZXhPZignW25hdGl2ZSBjb2RlXScpID09PSAtMSkge1xuICAgICAgICBpbmNyZW1lbnRFeHBlY3RlZEF3YWl0cyA9IGRlY3JlbWVudEV4cGVjdGVkQXdhaXRzID0gbm9wO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvblBvc3NpYmxlUGFyYWxsZWxsQXN5bmMocG9zc2libGVQcm9taXNlKSB7XG4gICAgICAgIGlmICh0YXNrLmVjaG9lcyAmJiBwb3NzaWJsZVByb21pc2UgJiYgcG9zc2libGVQcm9taXNlLmNvbnN0cnVjdG9yID09PSBOYXRpdmVQcm9taXNlKSB7XG4gICAgICAgICAgICBpbmNyZW1lbnRFeHBlY3RlZEF3YWl0cygpO1xuICAgICAgICAgICAgcmV0dXJuIHBvc3NpYmxlUHJvbWlzZS50aGVuKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgZGVjcmVtZW50RXhwZWN0ZWRBd2FpdHMoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgZGVjcmVtZW50RXhwZWN0ZWRBd2FpdHMoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0aW9uKGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvc3NpYmxlUHJvbWlzZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gem9uZUVudGVyRWNobyh0YXJnZXRab25lKSB7XG4gICAgICAgICsrdG90YWxFY2hvZXM7XG4gICAgICAgIGlmICghdGFzay5lY2hvZXMgfHwgLS10YXNrLmVjaG9lcyA9PT0gMCkge1xuICAgICAgICAgICAgdGFzay5lY2hvZXMgPSB0YXNrLmF3YWl0cyA9IHRhc2suaWQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHpvbmVTdGFjay5wdXNoKFBTRCk7XG4gICAgICAgIHN3aXRjaFRvWm9uZSh0YXJnZXRab25lLCB0cnVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gem9uZUxlYXZlRWNobygpIHtcbiAgICAgICAgdmFyIHpvbmUgPSB6b25lU3RhY2tbem9uZVN0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICB6b25lU3RhY2sucG9wKCk7XG4gICAgICAgIHN3aXRjaFRvWm9uZSh6b25lLCBmYWxzZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN3aXRjaFRvWm9uZSh0YXJnZXRab25lLCBiRW50ZXJpbmdab25lKSB7XG4gICAgICAgIHZhciBjdXJyZW50Wm9uZSA9IFBTRDtcbiAgICAgICAgaWYgKGJFbnRlcmluZ1pvbmUgPyB0YXNrLmVjaG9lcyAmJiAoIXpvbmVFY2hvZXMrKyB8fCB0YXJnZXRab25lICE9PSBQU0QpIDogem9uZUVjaG9lcyAmJiAoIS0tem9uZUVjaG9lcyB8fCB0YXJnZXRab25lICE9PSBQU0QpKSB7XG4gICAgICAgICAgICBxdWV1ZU1pY3JvdGFzayhiRW50ZXJpbmdab25lID8gem9uZUVudGVyRWNoby5iaW5kKG51bGwsIHRhcmdldFpvbmUpIDogem9uZUxlYXZlRWNobyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhcmdldFpvbmUgPT09IFBTRClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgUFNEID0gdGFyZ2V0Wm9uZTtcbiAgICAgICAgaWYgKGN1cnJlbnRab25lID09PSBnbG9iYWxQU0QpXG4gICAgICAgICAgICBnbG9iYWxQU0QuZW52ID0gc25hcFNob3QoKTtcbiAgICAgICAgaWYgKHBhdGNoR2xvYmFsUHJvbWlzZSkge1xuICAgICAgICAgICAgdmFyIEdsb2JhbFByb21pc2UgPSBnbG9iYWxQU0QuZW52LlByb21pc2U7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0RW52ID0gdGFyZ2V0Wm9uZS5lbnY7XG4gICAgICAgICAgICBpZiAoY3VycmVudFpvbmUuZ2xvYmFsIHx8IHRhcmdldFpvbmUuZ2xvYmFsKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9nbG9iYWwsICdQcm9taXNlJywgdGFyZ2V0RW52LlByb21pc2VQcm9wKTtcbiAgICAgICAgICAgICAgICBHbG9iYWxQcm9taXNlLmFsbCA9IHRhcmdldEVudi5hbGw7XG4gICAgICAgICAgICAgICAgR2xvYmFsUHJvbWlzZS5yYWNlID0gdGFyZ2V0RW52LnJhY2U7XG4gICAgICAgICAgICAgICAgR2xvYmFsUHJvbWlzZS5yZXNvbHZlID0gdGFyZ2V0RW52LnJlc29sdmU7XG4gICAgICAgICAgICAgICAgR2xvYmFsUHJvbWlzZS5yZWplY3QgPSB0YXJnZXRFbnYucmVqZWN0O1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXRFbnYuYWxsU2V0dGxlZClcbiAgICAgICAgICAgICAgICAgICAgR2xvYmFsUHJvbWlzZS5hbGxTZXR0bGVkID0gdGFyZ2V0RW52LmFsbFNldHRsZWQ7XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldEVudi5hbnkpXG4gICAgICAgICAgICAgICAgICAgIEdsb2JhbFByb21pc2UuYW55ID0gdGFyZ2V0RW52LmFueTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzbmFwU2hvdCgpIHtcbiAgICAgICAgdmFyIEdsb2JhbFByb21pc2UgPSBfZ2xvYmFsLlByb21pc2U7XG4gICAgICAgIHJldHVybiBwYXRjaEdsb2JhbFByb21pc2UgPyB7XG4gICAgICAgICAgICBQcm9taXNlOiBHbG9iYWxQcm9taXNlLFxuICAgICAgICAgICAgUHJvbWlzZVByb3A6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoX2dsb2JhbCwgXCJQcm9taXNlXCIpLFxuICAgICAgICAgICAgYWxsOiBHbG9iYWxQcm9taXNlLmFsbCxcbiAgICAgICAgICAgIHJhY2U6IEdsb2JhbFByb21pc2UucmFjZSxcbiAgICAgICAgICAgIGFsbFNldHRsZWQ6IEdsb2JhbFByb21pc2UuYWxsU2V0dGxlZCxcbiAgICAgICAgICAgIGFueTogR2xvYmFsUHJvbWlzZS5hbnksXG4gICAgICAgICAgICByZXNvbHZlOiBHbG9iYWxQcm9taXNlLnJlc29sdmUsXG4gICAgICAgICAgICByZWplY3Q6IEdsb2JhbFByb21pc2UucmVqZWN0LFxuICAgICAgICB9IDoge307XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVzZVBTRChwc2QsIGZuLCBhMSwgYTIsIGEzKSB7XG4gICAgICAgIHZhciBvdXRlclNjb3BlID0gUFNEO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc3dpdGNoVG9ab25lKHBzZCwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gZm4oYTEsIGEyLCBhMyk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICBzd2l0Y2hUb1pvbmUob3V0ZXJTY29wZSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5hdGl2ZUF3YWl0Q29tcGF0aWJsZVdyYXAoZm4sIHpvbmUsIHBvc3NpYmxlQXdhaXQsIGNsZWFudXApIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJyA/IGZuIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG91dGVyWm9uZSA9IFBTRDtcbiAgICAgICAgICAgIGlmIChwb3NzaWJsZUF3YWl0KVxuICAgICAgICAgICAgICAgIGluY3JlbWVudEV4cGVjdGVkQXdhaXRzKCk7XG4gICAgICAgICAgICBzd2l0Y2hUb1pvbmUoem9uZSwgdHJ1ZSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoVG9ab25lKG91dGVyWm9uZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGlmIChjbGVhbnVwKVxuICAgICAgICAgICAgICAgICAgICBxdWV1ZU1pY3JvdGFzayhkZWNyZW1lbnRFeHBlY3RlZEF3YWl0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGV4ZWNJbkdsb2JhbENvbnRleHQoY2IpIHtcbiAgICAgICAgaWYgKFByb21pc2UgPT09IE5hdGl2ZVByb21pc2UgJiYgdGFzay5lY2hvZXMgPT09IDApIHtcbiAgICAgICAgICAgIGlmICh6b25lRWNob2VzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVucXVldWVOYXRpdmVNaWNyb1Rhc2soY2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2V0VGltZW91dChjYiwgMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIHJlamVjdGlvbiA9IERleGllUHJvbWlzZS5yZWplY3Q7XG5cbiAgICBmdW5jdGlvbiB0ZW1wVHJhbnNhY3Rpb24oZGIsIG1vZGUsIHN0b3JlTmFtZXMsIGZuKSB7XG4gICAgICAgIGlmICghZGIuaWRiZGIgfHwgKCFkYi5fc3RhdGUub3BlbkNvbXBsZXRlICYmICghUFNELmxldFRocm91Z2ggJiYgIWRiLl92aXApKSkge1xuICAgICAgICAgICAgaWYgKGRiLl9zdGF0ZS5vcGVuQ29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0aW9uKG5ldyBleGNlcHRpb25zLkRhdGFiYXNlQ2xvc2VkKGRiLl9zdGF0ZS5kYk9wZW5FcnJvcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkYi5fc3RhdGUuaXNCZWluZ09wZW5lZCkge1xuICAgICAgICAgICAgICAgIGlmICghZGIuX3N0YXRlLmF1dG9PcGVuKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0aW9uKG5ldyBleGNlcHRpb25zLkRhdGFiYXNlQ2xvc2VkKCkpO1xuICAgICAgICAgICAgICAgIGRiLm9wZW4oKS5jYXRjaChub3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRiLl9zdGF0ZS5kYlJlYWR5UHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRlbXBUcmFuc2FjdGlvbihkYiwgbW9kZSwgc3RvcmVOYW1lcywgZm4pOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0cmFucyA9IGRiLl9jcmVhdGVUcmFuc2FjdGlvbihtb2RlLCBzdG9yZU5hbWVzLCBkYi5fZGJTY2hlbWEpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0cmFucy5jcmVhdGUoKTtcbiAgICAgICAgICAgICAgICBkYi5fc3RhdGUuUFIxMzk4X21heExvb3AgPSAzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4Lm5hbWUgPT09IGVycm5hbWVzLkludmFsaWRTdGF0ZSAmJiBkYi5pc09wZW4oKSAmJiAtLWRiLl9zdGF0ZS5QUjEzOThfbWF4TG9vcCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdEZXhpZTogTmVlZCB0byByZW9wZW4gZGInKTtcbiAgICAgICAgICAgICAgICAgICAgZGIuY2xvc2UoeyBkaXNhYmxlQXV0b09wZW46IGZhbHNlIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGIub3BlbigpLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gdGVtcFRyYW5zYWN0aW9uKGRiLCBtb2RlLCBzdG9yZU5hbWVzLCBmbik7IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0aW9uKGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cmFucy5fcHJvbWlzZShtb2RlLCBmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld1Njb3BlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgUFNELnRyYW5zID0gdHJhbnM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmbihyZXNvbHZlLCByZWplY3QsIHRyYW5zKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGlmIChtb2RlID09PSAncmVhZHdyaXRlJylcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zLmlkYnRyYW5zLmNvbW1pdCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChfYSkgeyB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vZGUgPT09ICdyZWFkb25seScgPyByZXN1bHQgOiB0cmFucy5fY29tcGxldGlvbi50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlc3VsdDsgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBERVhJRV9WRVJTSU9OID0gJzQuMi4wJztcbiAgICB2YXIgbWF4U3RyaW5nID0gU3RyaW5nLmZyb21DaGFyQ29kZSg2NTUzNSk7XG4gICAgdmFyIG1pbktleSA9IC1JbmZpbml0eTtcbiAgICB2YXIgSU5WQUxJRF9LRVlfQVJHVU1FTlQgPSBcIkludmFsaWQga2V5IHByb3ZpZGVkLiBLZXlzIG11c3QgYmUgb2YgdHlwZSBzdHJpbmcsIG51bWJlciwgRGF0ZSBvciBBcnJheTxzdHJpbmcgfCBudW1iZXIgfCBEYXRlPi5cIjtcbiAgICB2YXIgU1RSSU5HX0VYUEVDVEVEID0gXCJTdHJpbmcgZXhwZWN0ZWQuXCI7XG4gICAgdmFyIGNvbm5lY3Rpb25zID0gW107XG4gICAgdmFyIERCTkFNRVNfREIgPSAnX19kYm5hbWVzJztcbiAgICB2YXIgUkVBRE9OTFkgPSAncmVhZG9ubHknO1xuICAgIHZhciBSRUFEV1JJVEUgPSAncmVhZHdyaXRlJztcblxuICAgIGZ1bmN0aW9uIGNvbWJpbmUoZmlsdGVyMSwgZmlsdGVyMikge1xuICAgICAgICByZXR1cm4gZmlsdGVyMSA/XG4gICAgICAgICAgICBmaWx0ZXIyID9cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBmaWx0ZXIxLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgJiYgZmlsdGVyMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IDpcbiAgICAgICAgICAgICAgICBmaWx0ZXIxIDpcbiAgICAgICAgICAgIGZpbHRlcjI7XG4gICAgfVxuXG4gICAgdmFyIEFueVJhbmdlID0ge1xuICAgICAgICB0eXBlOiAzICxcbiAgICAgICAgbG93ZXI6IC1JbmZpbml0eSxcbiAgICAgICAgbG93ZXJPcGVuOiBmYWxzZSxcbiAgICAgICAgdXBwZXI6IFtbXV0sXG4gICAgICAgIHVwcGVyT3BlbjogZmFsc2VcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gd29ya2Fyb3VuZEZvclVuZGVmaW5lZFByaW1LZXkoa2V5UGF0aCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIGtleVBhdGggPT09IFwic3RyaW5nXCIgJiYgIS9cXC4vLnRlc3Qoa2V5UGF0aClcbiAgICAgICAgICAgID8gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgICAgIGlmIChvYmpba2V5UGF0aF0gPT09IHVuZGVmaW5lZCAmJiAoa2V5UGF0aCBpbiBvYmopKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iaiA9IGRlZXBDbG9uZShvYmopO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgb2JqW2tleVBhdGhdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmo7IH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gRW50aXR5KCkge1xuICAgICAgICB0aHJvdyBleGNlcHRpb25zLlR5cGUoXCJFbnRpdHkgaW5zdGFuY2VzIG11c3QgbmV2ZXIgYmUgbmV3OmVkLiBJbnN0YW5jZXMgYXJlIGdlbmVyYXRlZCBieSB0aGUgZnJhbWV3b3JrIGJ5cGFzc2luZyB0aGUgY29uc3RydWN0b3IuXCIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNtcChhLCBiKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgdGEgPSB0eXBlKGEpO1xuICAgICAgICAgICAgdmFyIHRiID0gdHlwZShiKTtcbiAgICAgICAgICAgIGlmICh0YSAhPT0gdGIpIHtcbiAgICAgICAgICAgICAgICBpZiAodGEgPT09ICdBcnJheScpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgICAgIGlmICh0YiA9PT0gJ0FycmF5JylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgIGlmICh0YSA9PT0gJ2JpbmFyeScpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgICAgIGlmICh0YiA9PT0gJ2JpbmFyeScpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgICBpZiAodGEgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICBpZiAodGIgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgaWYgKHRhID09PSAnRGF0ZScpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgICAgIGlmICh0YiAhPT0gJ0RhdGUnKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAodGEpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ0RhdGUnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhID4gYiA/IDEgOiBhIDwgYiA/IC0xIDogMDtcbiAgICAgICAgICAgICAgICBjYXNlICdiaW5hcnknOiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb21wYXJlVWludDhBcnJheXMoZ2V0VWludDhBcnJheShhKSwgZ2V0VWludDhBcnJheShiKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ0FycmF5JzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmVBcnJheXMoYSwgYik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF9hKSB7IH1cbiAgICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tcGFyZUFycmF5cyhhLCBiKSB7XG4gICAgICAgIHZhciBhbCA9IGEubGVuZ3RoO1xuICAgICAgICB2YXIgYmwgPSBiLmxlbmd0aDtcbiAgICAgICAgdmFyIGwgPSBhbCA8IGJsID8gYWwgOiBibDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgIHZhciByZXMgPSBjbXAoYVtpXSwgYltpXSk7XG4gICAgICAgICAgICBpZiAocmVzICE9PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFsID09PSBibCA/IDAgOiBhbCA8IGJsID8gLTEgOiAxO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21wYXJlVWludDhBcnJheXMoYSwgYikge1xuICAgICAgICB2YXIgYWwgPSBhLmxlbmd0aDtcbiAgICAgICAgdmFyIGJsID0gYi5sZW5ndGg7XG4gICAgICAgIHZhciBsID0gYWwgPCBibCA/IGFsIDogYmw7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoYVtpXSAhPT0gYltpXSlcbiAgICAgICAgICAgICAgICByZXR1cm4gYVtpXSA8IGJbaV0gPyAtMSA6IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFsID09PSBibCA/IDAgOiBhbCA8IGJsID8gLTEgOiAxO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0eXBlKHgpIHtcbiAgICAgICAgdmFyIHQgPSB0eXBlb2YgeDtcbiAgICAgICAgaWYgKHQgIT09ICdvYmplY3QnKVxuICAgICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoeCkpXG4gICAgICAgICAgICByZXR1cm4gJ2JpbmFyeSc7XG4gICAgICAgIHZhciB0c1RhZyA9IHRvU3RyaW5nVGFnKHgpO1xuICAgICAgICByZXR1cm4gdHNUYWcgPT09ICdBcnJheUJ1ZmZlcicgPyAnYmluYXJ5JyA6IHRzVGFnO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRVaW50OEFycmF5KGEpIHtcbiAgICAgICAgaWYgKGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KVxuICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoYSkpXG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYS5idWZmZXIsIGEuYnl0ZU9mZnNldCwgYS5ieXRlTGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGEpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJ1aWx0SW5EZWxldGlvblRyaWdnZXIodGFibGUsIGtleXMsIHJlcykge1xuICAgICAgICB2YXIgeVByb3BzID0gdGFibGUuc2NoZW1hLnlQcm9wcztcbiAgICAgICAgaWYgKCF5UHJvcHMpXG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICBpZiAoa2V5cyAmJiByZXMubnVtRmFpbHVyZXMgPiAwKVxuICAgICAgICAgICAga2V5cyA9IGtleXMuZmlsdGVyKGZ1bmN0aW9uIChfLCBpKSB7IHJldHVybiAhcmVzLmZhaWx1cmVzW2ldOyB9KTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHlQcm9wcy5tYXAoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgdXBkYXRlc1RhYmxlID0gX2EudXBkYXRlc1RhYmxlO1xuICAgICAgICAgICAgcmV0dXJuIGtleXNcbiAgICAgICAgICAgICAgICA/IHRhYmxlLmRiLnRhYmxlKHVwZGF0ZXNUYWJsZSkud2hlcmUoJ2snKS5hbnlPZihrZXlzKS5kZWxldGUoKVxuICAgICAgICAgICAgICAgIDogdGFibGUuZGIudGFibGUodXBkYXRlc1RhYmxlKS5jbGVhcigpO1xuICAgICAgICB9KSkudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiByZXM7IH0pO1xuICAgIH1cblxuICAgIHZhciBUYWJsZSA9ICAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBUYWJsZSgpIHtcbiAgICAgICAgfVxuICAgICAgICBUYWJsZS5wcm90b3R5cGUuX3RyYW5zID0gZnVuY3Rpb24gKG1vZGUsIGZuLCB3cml0ZUxvY2tlZCkge1xuICAgICAgICAgICAgdmFyIHRyYW5zID0gdGhpcy5fdHggfHwgUFNELnRyYW5zO1xuICAgICAgICAgICAgdmFyIHRhYmxlTmFtZSA9IHRoaXMubmFtZTtcbiAgICAgICAgICAgIHZhciB0YXNrID0gZGVidWcgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIGNvbnNvbGUuY3JlYXRlVGFzayAmJiBjb25zb2xlLmNyZWF0ZVRhc2soXCJEZXhpZTogXCIuY29uY2F0KG1vZGUgPT09ICdyZWFkb25seScgPyAncmVhZCcgOiAnd3JpdGUnLCBcIiBcIikuY29uY2F0KHRoaXMubmFtZSkpO1xuICAgICAgICAgICAgZnVuY3Rpb24gY2hlY2tUYWJsZUluVHJhbnNhY3Rpb24ocmVzb2x2ZSwgcmVqZWN0LCB0cmFucykge1xuICAgICAgICAgICAgICAgIGlmICghdHJhbnMuc2NoZW1hW3RhYmxlTmFtZV0pXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLk5vdEZvdW5kKFwiVGFibGUgXCIgKyB0YWJsZU5hbWUgKyBcIiBub3QgcGFydCBvZiB0cmFuc2FjdGlvblwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4odHJhbnMuaWRidHJhbnMsIHRyYW5zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB3YXNSb290RXhlYyA9IGJlZ2luTWljcm9UaWNrU2NvcGUoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIHAgPSB0cmFucyAmJiB0cmFucy5kYi5fbm92aXAgPT09IHRoaXMuZGIuX25vdmlwID9cbiAgICAgICAgICAgICAgICAgICAgdHJhbnMgPT09IFBTRC50cmFucyA/XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFucy5fcHJvbWlzZShtb2RlLCBjaGVja1RhYmxlSW5UcmFuc2FjdGlvbiwgd3JpdGVMb2NrZWQpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1Njb3BlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRyYW5zLl9wcm9taXNlKG1vZGUsIGNoZWNrVGFibGVJblRyYW5zYWN0aW9uLCB3cml0ZUxvY2tlZCk7IH0sIHsgdHJhbnM6IHRyYW5zLCB0cmFuc2xlc3M6IFBTRC50cmFuc2xlc3MgfHwgUFNEIH0pIDpcbiAgICAgICAgICAgICAgICAgICAgdGVtcFRyYW5zYWN0aW9uKHRoaXMuZGIsIG1vZGUsIFt0aGlzLm5hbWVdLCBjaGVja1RhYmxlSW5UcmFuc2FjdGlvbik7XG4gICAgICAgICAgICAgICAgaWYgKHRhc2spIHtcbiAgICAgICAgICAgICAgICAgICAgcC5fY29uc29sZVRhc2sgPSB0YXNrO1xuICAgICAgICAgICAgICAgICAgICBwID0gcC5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLnRyYWNlKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0aW9uKGVycik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIGlmICh3YXNSb290RXhlYylcbiAgICAgICAgICAgICAgICAgICAgZW5kTWljcm9UaWNrU2NvcGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgVGFibGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXlPckNyaXQsIGNiKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKGtleU9yQ3JpdCAmJiBrZXlPckNyaXQuY29uc3RydWN0b3IgPT09IE9iamVjdClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy53aGVyZShrZXlPckNyaXQpLmZpcnN0KGNiKTtcbiAgICAgICAgICAgIGlmIChrZXlPckNyaXQgPT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0aW9uKG5ldyBleGNlcHRpb25zLlR5cGUoXCJJbnZhbGlkIGFyZ3VtZW50IHRvIFRhYmxlLmdldCgpXCIpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90cmFucygncmVhZG9ubHknLCBmdW5jdGlvbiAodHJhbnMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuY29yZS5nZXQoeyB0cmFuczogdHJhbnMsIGtleToga2V5T3JDcml0IH0pXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXMpIHsgcmV0dXJuIF90aGlzLmhvb2sucmVhZGluZy5maXJlKHJlcyk7IH0pO1xuICAgICAgICAgICAgfSkudGhlbihjYik7XG4gICAgICAgIH07XG4gICAgICAgIFRhYmxlLnByb3RvdHlwZS53aGVyZSA9IGZ1bmN0aW9uIChpbmRleE9yQ3JpdCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbmRleE9yQ3JpdCA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmRiLldoZXJlQ2xhdXNlKHRoaXMsIGluZGV4T3JDcml0KTtcbiAgICAgICAgICAgIGlmIChpc0FycmF5KGluZGV4T3JDcml0KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHRoaXMuZGIuV2hlcmVDbGF1c2UodGhpcywgXCJbXCIuY29uY2F0KGluZGV4T3JDcml0LmpvaW4oJysnKSwgXCJdXCIpKTtcbiAgICAgICAgICAgIHZhciBrZXlQYXRocyA9IGtleXMoaW5kZXhPckNyaXQpO1xuICAgICAgICAgICAgaWYgKGtleVBhdGhzLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICAgICAgICAgICAgICAud2hlcmUoa2V5UGF0aHNbMF0pXG4gICAgICAgICAgICAgICAgICAgIC5lcXVhbHMoaW5kZXhPckNyaXRba2V5UGF0aHNbMF1dKTtcbiAgICAgICAgICAgIHZhciBjb21wb3VuZEluZGV4ID0gdGhpcy5zY2hlbWEuaW5kZXhlcy5jb25jYXQodGhpcy5zY2hlbWEucHJpbUtleSkuZmlsdGVyKGZ1bmN0aW9uIChpeCkge1xuICAgICAgICAgICAgICAgIGlmIChpeC5jb21wb3VuZCAmJlxuICAgICAgICAgICAgICAgICAgICBrZXlQYXRocy5ldmVyeShmdW5jdGlvbiAoa2V5UGF0aCkgeyByZXR1cm4gaXgua2V5UGF0aC5pbmRleE9mKGtleVBhdGgpID49IDA7IH0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5UGF0aHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXlQYXRocy5pbmRleE9mKGl4LmtleVBhdGhbaV0pID09PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0pLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEua2V5UGF0aC5sZW5ndGggLSBiLmtleVBhdGgubGVuZ3RoOyB9KVswXTtcbiAgICAgICAgICAgIGlmIChjb21wb3VuZEluZGV4ICYmIHRoaXMuZGIuX21heEtleSAhPT0gbWF4U3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleVBhdGhzSW5WYWxpZE9yZGVyID0gY29tcG91bmRJbmRleC5rZXlQYXRoLnNsaWNlKDAsIGtleVBhdGhzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgICAgICAgICAgICAgLndoZXJlKGtleVBhdGhzSW5WYWxpZE9yZGVyKVxuICAgICAgICAgICAgICAgICAgICAuZXF1YWxzKGtleVBhdGhzSW5WYWxpZE9yZGVyLm1hcChmdW5jdGlvbiAoa3ApIHsgcmV0dXJuIGluZGV4T3JDcml0W2twXTsgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjb21wb3VuZEluZGV4ICYmIGRlYnVnKVxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlRoZSBxdWVyeSBcIi5jb25jYXQoSlNPTi5zdHJpbmdpZnkoaW5kZXhPckNyaXQpLCBcIiBvbiBcIikuY29uY2F0KHRoaXMubmFtZSwgXCIgd291bGQgYmVuZWZpdCBmcm9tIGEgXCIpICtcbiAgICAgICAgICAgICAgICAgICAgXCJjb21wb3VuZCBpbmRleCBbXCIuY29uY2F0KGtleVBhdGhzLmpvaW4oJysnKSwgXCJdXCIpKTtcbiAgICAgICAgICAgIHZhciBpZHhCeU5hbWUgPSB0aGlzLnNjaGVtYS5pZHhCeU5hbWU7XG4gICAgICAgICAgICBmdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjbXAoYSwgYikgPT09IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX2EgPSBrZXlQYXRocy5yZWR1Y2UoZnVuY3Rpb24gKF9hLCBrZXlQYXRoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByZXZJbmRleCA9IF9hWzBdLCBwcmV2RmlsdGVyRm4gPSBfYVsxXTtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBpZHhCeU5hbWVba2V5UGF0aF07XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gaW5kZXhPckNyaXRba2V5UGF0aF07XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgcHJldkluZGV4IHx8IGluZGV4LFxuICAgICAgICAgICAgICAgICAgICBwcmV2SW5kZXggfHwgIWluZGV4ID9cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbWJpbmUocHJldkZpbHRlckZuLCBpbmRleCAmJiBpbmRleC5tdWx0aSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb3AgPSBnZXRCeUtleVBhdGgoeCwga2V5UGF0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpc0FycmF5KHByb3ApICYmIHByb3Auc29tZShmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gZXF1YWxzKHZhbHVlLCBpdGVtKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSA6IGZ1bmN0aW9uICh4KSB7IHJldHVybiBlcXVhbHModmFsdWUsIGdldEJ5S2V5UGF0aCh4LCBrZXlQYXRoKSk7IH0pXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHByZXZGaWx0ZXJGblxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9LCBbbnVsbCwgbnVsbF0pLCBpZHggPSBfYVswXSwgZmlsdGVyRnVuY3Rpb24gPSBfYVsxXTtcbiAgICAgICAgICAgIHJldHVybiBpZHggP1xuICAgICAgICAgICAgICAgIHRoaXMud2hlcmUoaWR4Lm5hbWUpLmVxdWFscyhpbmRleE9yQ3JpdFtpZHgua2V5UGF0aF0pXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZmlsdGVyRnVuY3Rpb24pIDpcbiAgICAgICAgICAgICAgICBjb21wb3VuZEluZGV4ID9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maWx0ZXIoZmlsdGVyRnVuY3Rpb24pIDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53aGVyZShrZXlQYXRocykuZXF1YWxzKCcnKTtcbiAgICAgICAgfTtcbiAgICAgICAgVGFibGUucHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uIChmaWx0ZXJGdW5jdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9Db2xsZWN0aW9uKCkuYW5kKGZpbHRlckZ1bmN0aW9uKTtcbiAgICAgICAgfTtcbiAgICAgICAgVGFibGUucHJvdG90eXBlLmNvdW50ID0gZnVuY3Rpb24gKHRoZW5TaG9ydGN1dCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9Db2xsZWN0aW9uKCkuY291bnQodGhlblNob3J0Y3V0KTtcbiAgICAgICAgfTtcbiAgICAgICAgVGFibGUucHJvdG90eXBlLm9mZnNldCA9IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQ29sbGVjdGlvbigpLm9mZnNldChvZmZzZXQpO1xuICAgICAgICB9O1xuICAgICAgICBUYWJsZS5wcm90b3R5cGUubGltaXQgPSBmdW5jdGlvbiAobnVtUm93cykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9Db2xsZWN0aW9uKCkubGltaXQobnVtUm93cyk7XG4gICAgICAgIH07XG4gICAgICAgIFRhYmxlLnByb3RvdHlwZS5lYWNoID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b0NvbGxlY3Rpb24oKS5lYWNoKGNhbGxiYWNrKTtcbiAgICAgICAgfTtcbiAgICAgICAgVGFibGUucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiAodGhlblNob3J0Y3V0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b0NvbGxlY3Rpb24oKS50b0FycmF5KHRoZW5TaG9ydGN1dCk7XG4gICAgICAgIH07XG4gICAgICAgIFRhYmxlLnByb3RvdHlwZS50b0NvbGxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHRoaXMuZGIuQ29sbGVjdGlvbihuZXcgdGhpcy5kYi5XaGVyZUNsYXVzZSh0aGlzKSk7XG4gICAgICAgIH07XG4gICAgICAgIFRhYmxlLnByb3RvdHlwZS5vcmRlckJ5ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHRoaXMuZGIuQ29sbGVjdGlvbihuZXcgdGhpcy5kYi5XaGVyZUNsYXVzZSh0aGlzLCBpc0FycmF5KGluZGV4KSA/XG4gICAgICAgICAgICAgICAgXCJbXCIuY29uY2F0KGluZGV4LmpvaW4oJysnKSwgXCJdXCIpIDpcbiAgICAgICAgICAgICAgICBpbmRleCkpO1xuICAgICAgICB9O1xuICAgICAgICBUYWJsZS5wcm90b3R5cGUucmV2ZXJzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQ29sbGVjdGlvbigpLnJldmVyc2UoKTtcbiAgICAgICAgfTtcbiAgICAgICAgVGFibGUucHJvdG90eXBlLm1hcFRvQ2xhc3MgPSBmdW5jdGlvbiAoY29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IHRoaXMsIGRiID0gX2EuZGIsIHRhYmxlTmFtZSA9IF9hLm5hbWU7XG4gICAgICAgICAgICB0aGlzLnNjaGVtYS5tYXBwZWRDbGFzcyA9IGNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgaWYgKGNvbnN0cnVjdG9yLnByb3RvdHlwZSBpbnN0YW5jZW9mIEVudGl0eSkge1xuICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yID0gIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIF9fZXh0ZW5kcyhjbGFzc18xLCBfc3VwZXIpO1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBjbGFzc18xKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjbGFzc18xLnByb3RvdHlwZSwgXCJkYlwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRiOyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzXzEucHJvdG90eXBlLnRhYmxlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGFibGVOYW1lOyB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2xhc3NfMTtcbiAgICAgICAgICAgICAgICB9KGNvbnN0cnVjdG9yKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaW5oZXJpdGVkUHJvcHMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICBmb3IgKHZhciBwcm90byA9IGNvbnN0cnVjdG9yLnByb3RvdHlwZTsgcHJvdG87IHByb3RvID0gZ2V0UHJvdG8ocHJvdG8pKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvdG8pLmZvckVhY2goZnVuY3Rpb24gKHByb3BOYW1lKSB7IHJldHVybiBpbmhlcml0ZWRQcm9wcy5hZGQocHJvcE5hbWUpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZWFkSG9vayA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgICAgICBpZiAoIW9iailcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICAgICAgICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShjb25zdHJ1Y3Rvci5wcm90b3R5cGUpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIG0gaW4gb2JqKVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWluaGVyaXRlZFByb3BzLmhhcyhtKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzW21dID0gb2JqW21dO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKF8pIHsgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHRoaXMuc2NoZW1hLnJlYWRIb29rKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ob29rLnJlYWRpbmcudW5zdWJzY3JpYmUodGhpcy5zY2hlbWEucmVhZEhvb2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zY2hlbWEucmVhZEhvb2sgPSByZWFkSG9vaztcbiAgICAgICAgICAgIHRoaXMuaG9vayhcInJlYWRpbmdcIiwgcmVhZEhvb2spO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnN0cnVjdG9yO1xuICAgICAgICB9O1xuICAgICAgICBUYWJsZS5wcm90b3R5cGUuZGVmaW5lQ2xhc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBDbGFzcyhjb250ZW50KSB7XG4gICAgICAgICAgICAgICAgZXh0ZW5kKHRoaXMsIGNvbnRlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFwVG9DbGFzcyhDbGFzcyk7XG4gICAgICAgIH07XG4gICAgICAgIFRhYmxlLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAob2JqLCBrZXkpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgX2EgPSB0aGlzLnNjaGVtYS5wcmltS2V5LCBhdXRvID0gX2EuYXV0bywga2V5UGF0aCA9IF9hLmtleVBhdGg7XG4gICAgICAgICAgICB2YXIgb2JqVG9BZGQgPSBvYmo7XG4gICAgICAgICAgICBpZiAoa2V5UGF0aCAmJiBhdXRvKSB7XG4gICAgICAgICAgICAgICAgb2JqVG9BZGQgPSB3b3JrYXJvdW5kRm9yVW5kZWZpbmVkUHJpbUtleShrZXlQYXRoKShvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zKCdyZWFkd3JpdGUnLCBmdW5jdGlvbiAodHJhbnMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuY29yZS5tdXRhdGUoeyB0cmFuczogdHJhbnMsIHR5cGU6ICdhZGQnLCBrZXlzOiBrZXkgIT0gbnVsbCA/IFtrZXldIDogbnVsbCwgdmFsdWVzOiBbb2JqVG9BZGRdIH0pO1xuICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAocmVzKSB7IHJldHVybiByZXMubnVtRmFpbHVyZXMgPyBEZXhpZVByb21pc2UucmVqZWN0KHJlcy5mYWlsdXJlc1swXSkgOiByZXMubGFzdFJlc3VsdDsgfSlcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAobGFzdFJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGlmIChrZXlQYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRCeUtleVBhdGgob2JqLCBrZXlQYXRoLCBsYXN0UmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoXykgeyB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBsYXN0UmVzdWx0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIFRhYmxlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoa2V5T3JPYmplY3QsIG1vZGlmaWNhdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5T3JPYmplY3QgPT09ICdvYmplY3QnICYmICFpc0FycmF5KGtleU9yT2JqZWN0KSkge1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBnZXRCeUtleVBhdGgoa2V5T3JPYmplY3QsIHRoaXMuc2NoZW1hLnByaW1LZXkua2V5UGF0aCk7XG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0aW9uKG5ldyBleGNlcHRpb25zLkludmFsaWRBcmd1bWVudChcIkdpdmVuIG9iamVjdCBkb2VzIG5vdCBjb250YWluIGl0cyBwcmltYXJ5IGtleVwiKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMud2hlcmUoXCI6aWRcIikuZXF1YWxzKGtleSkubW9kaWZ5KG1vZGlmaWNhdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMud2hlcmUoXCI6aWRcIikuZXF1YWxzKGtleU9yT2JqZWN0KS5tb2RpZnkobW9kaWZpY2F0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFRhYmxlLnByb3RvdHlwZS5wdXQgPSBmdW5jdGlvbiAob2JqLCBrZXkpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgX2EgPSB0aGlzLnNjaGVtYS5wcmltS2V5LCBhdXRvID0gX2EuYXV0bywga2V5UGF0aCA9IF9hLmtleVBhdGg7XG4gICAgICAgICAgICB2YXIgb2JqVG9BZGQgPSBvYmo7XG4gICAgICAgICAgICBpZiAoa2V5UGF0aCAmJiBhdXRvKSB7XG4gICAgICAgICAgICAgICAgb2JqVG9BZGQgPSB3b3JrYXJvdW5kRm9yVW5kZWZpbmVkUHJpbUtleShrZXlQYXRoKShvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zKCdyZWFkd3JpdGUnLCBmdW5jdGlvbiAodHJhbnMpIHsgcmV0dXJuIF90aGlzLmNvcmUubXV0YXRlKHsgdHJhbnM6IHRyYW5zLCB0eXBlOiAncHV0JywgdmFsdWVzOiBbb2JqVG9BZGRdLCBrZXlzOiBrZXkgIT0gbnVsbCA/IFtrZXldIDogbnVsbCB9KTsgfSlcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzKSB7IHJldHVybiByZXMubnVtRmFpbHVyZXMgPyBEZXhpZVByb21pc2UucmVqZWN0KHJlcy5mYWlsdXJlc1swXSkgOiByZXMubGFzdFJlc3VsdDsgfSlcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAobGFzdFJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGlmIChrZXlQYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRCeUtleVBhdGgob2JqLCBrZXlQYXRoLCBsYXN0UmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoXykgeyB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBsYXN0UmVzdWx0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIFRhYmxlLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zKCdyZWFkd3JpdGUnLCBmdW5jdGlvbiAodHJhbnMpIHsgcmV0dXJuIF90aGlzLmNvcmUubXV0YXRlKHsgdHJhbnM6IHRyYW5zLCB0eXBlOiAnZGVsZXRlJywga2V5czogW2tleV0gfSlcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzKSB7IHJldHVybiBidWlsdEluRGVsZXRpb25UcmlnZ2VyKF90aGlzLCBba2V5XSwgcmVzKTsgfSlcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzKSB7IHJldHVybiByZXMubnVtRmFpbHVyZXMgPyBEZXhpZVByb21pc2UucmVqZWN0KHJlcy5mYWlsdXJlc1swXSkgOiB1bmRlZmluZWQ7IH0pOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgVGFibGUucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90cmFucygncmVhZHdyaXRlJywgZnVuY3Rpb24gKHRyYW5zKSB7IHJldHVybiBfdGhpcy5jb3JlLm11dGF0ZSh7IHRyYW5zOiB0cmFucywgdHlwZTogJ2RlbGV0ZVJhbmdlJywgcmFuZ2U6IEFueVJhbmdlIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlcykgeyByZXR1cm4gYnVpbHRJbkRlbGV0aW9uVHJpZ2dlcihfdGhpcywgbnVsbCwgcmVzKTsgfSk7IH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlcykgeyByZXR1cm4gcmVzLm51bUZhaWx1cmVzID8gRGV4aWVQcm9taXNlLnJlamVjdChyZXMuZmFpbHVyZXNbMF0pIDogdW5kZWZpbmVkOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgVGFibGUucHJvdG90eXBlLmJ1bGtHZXQgPSBmdW5jdGlvbiAoa2V5cykge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90cmFucygncmVhZG9ubHknLCBmdW5jdGlvbiAodHJhbnMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuY29yZS5nZXRNYW55KHtcbiAgICAgICAgICAgICAgICAgICAga2V5czoga2V5cyxcbiAgICAgICAgICAgICAgICAgICAgdHJhbnM6IHRyYW5zXG4gICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7IHJldHVybiByZXN1bHQubWFwKGZ1bmN0aW9uIChyZXMpIHsgcmV0dXJuIF90aGlzLmhvb2sucmVhZGluZy5maXJlKHJlcyk7IH0pOyB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBUYWJsZS5wcm90b3R5cGUuYnVsa0FkZCA9IGZ1bmN0aW9uIChvYmplY3RzLCBrZXlzT3JPcHRpb25zLCBvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGtleXMgPSBBcnJheS5pc0FycmF5KGtleXNPck9wdGlvbnMpID8ga2V5c09yT3B0aW9ucyA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IChrZXlzID8gdW5kZWZpbmVkIDoga2V5c09yT3B0aW9ucyk7XG4gICAgICAgICAgICB2YXIgd2FudFJlc3VsdHMgPSBvcHRpb25zID8gb3B0aW9ucy5hbGxLZXlzIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zKCdyZWFkd3JpdGUnLCBmdW5jdGlvbiAodHJhbnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5zY2hlbWEucHJpbUtleSwgYXV0byA9IF9hLmF1dG8sIGtleVBhdGggPSBfYS5rZXlQYXRoO1xuICAgICAgICAgICAgICAgIGlmIChrZXlQYXRoICYmIGtleXMpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLkludmFsaWRBcmd1bWVudChcImJ1bGtBZGQoKToga2V5cyBhcmd1bWVudCBpbnZhbGlkIG9uIHRhYmxlcyB3aXRoIGluYm91bmQga2V5c1wiKTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5cyAmJiBrZXlzLmxlbmd0aCAhPT0gb2JqZWN0cy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLkludmFsaWRBcmd1bWVudChcIkFyZ3VtZW50cyBvYmplY3RzIGFuZCBrZXlzIG11c3QgaGF2ZSB0aGUgc2FtZSBsZW5ndGhcIik7XG4gICAgICAgICAgICAgICAgdmFyIG51bU9iamVjdHMgPSBvYmplY3RzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB2YXIgb2JqZWN0c1RvQWRkID0ga2V5UGF0aCAmJiBhdXRvID9cbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0cy5tYXAod29ya2Fyb3VuZEZvclVuZGVmaW5lZFByaW1LZXkoa2V5UGF0aCkpIDpcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0cztcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuY29yZS5tdXRhdGUoeyB0cmFuczogdHJhbnMsIHR5cGU6ICdhZGQnLCBrZXlzOiBrZXlzLCB2YWx1ZXM6IG9iamVjdHNUb0FkZCwgd2FudFJlc3VsdHM6IHdhbnRSZXN1bHRzIH0pXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbnVtRmFpbHVyZXMgPSBfYS5udW1GYWlsdXJlcywgcmVzdWx0cyA9IF9hLnJlc3VsdHMsIGxhc3RSZXN1bHQgPSBfYS5sYXN0UmVzdWx0LCBmYWlsdXJlcyA9IF9hLmZhaWx1cmVzO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gd2FudFJlc3VsdHMgPyByZXN1bHRzIDogbGFzdFJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG51bUZhaWx1cmVzID09PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJ1bGtFcnJvcihcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi5idWxrQWRkKCk6IFwiKS5jb25jYXQobnVtRmFpbHVyZXMsIFwiIG9mIFwiKS5jb25jYXQobnVtT2JqZWN0cywgXCIgb3BlcmF0aW9ucyBmYWlsZWRcIiksIGZhaWx1cmVzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBUYWJsZS5wcm90b3R5cGUuYnVsa1B1dCA9IGZ1bmN0aW9uIChvYmplY3RzLCBrZXlzT3JPcHRpb25zLCBvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGtleXMgPSBBcnJheS5pc0FycmF5KGtleXNPck9wdGlvbnMpID8ga2V5c09yT3B0aW9ucyA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IChrZXlzID8gdW5kZWZpbmVkIDoga2V5c09yT3B0aW9ucyk7XG4gICAgICAgICAgICB2YXIgd2FudFJlc3VsdHMgPSBvcHRpb25zID8gb3B0aW9ucy5hbGxLZXlzIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zKCdyZWFkd3JpdGUnLCBmdW5jdGlvbiAodHJhbnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5zY2hlbWEucHJpbUtleSwgYXV0byA9IF9hLmF1dG8sIGtleVBhdGggPSBfYS5rZXlQYXRoO1xuICAgICAgICAgICAgICAgIGlmIChrZXlQYXRoICYmIGtleXMpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLkludmFsaWRBcmd1bWVudChcImJ1bGtQdXQoKToga2V5cyBhcmd1bWVudCBpbnZhbGlkIG9uIHRhYmxlcyB3aXRoIGluYm91bmQga2V5c1wiKTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5cyAmJiBrZXlzLmxlbmd0aCAhPT0gb2JqZWN0cy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLkludmFsaWRBcmd1bWVudChcIkFyZ3VtZW50cyBvYmplY3RzIGFuZCBrZXlzIG11c3QgaGF2ZSB0aGUgc2FtZSBsZW5ndGhcIik7XG4gICAgICAgICAgICAgICAgdmFyIG51bU9iamVjdHMgPSBvYmplY3RzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB2YXIgb2JqZWN0c1RvUHV0ID0ga2V5UGF0aCAmJiBhdXRvID9cbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0cy5tYXAod29ya2Fyb3VuZEZvclVuZGVmaW5lZFByaW1LZXkoa2V5UGF0aCkpIDpcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0cztcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuY29yZS5tdXRhdGUoeyB0cmFuczogdHJhbnMsIHR5cGU6ICdwdXQnLCBrZXlzOiBrZXlzLCB2YWx1ZXM6IG9iamVjdHNUb1B1dCwgd2FudFJlc3VsdHM6IHdhbnRSZXN1bHRzIH0pXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbnVtRmFpbHVyZXMgPSBfYS5udW1GYWlsdXJlcywgcmVzdWx0cyA9IF9hLnJlc3VsdHMsIGxhc3RSZXN1bHQgPSBfYS5sYXN0UmVzdWx0LCBmYWlsdXJlcyA9IF9hLmZhaWx1cmVzO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gd2FudFJlc3VsdHMgPyByZXN1bHRzIDogbGFzdFJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG51bUZhaWx1cmVzID09PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJ1bGtFcnJvcihcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi5idWxrUHV0KCk6IFwiKS5jb25jYXQobnVtRmFpbHVyZXMsIFwiIG9mIFwiKS5jb25jYXQobnVtT2JqZWN0cywgXCIgb3BlcmF0aW9ucyBmYWlsZWRcIiksIGZhaWx1cmVzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBUYWJsZS5wcm90b3R5cGUuYnVsa1VwZGF0ZSA9IGZ1bmN0aW9uIChrZXlzQW5kQ2hhbmdlcykge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBjb3JlVGFibGUgPSB0aGlzLmNvcmU7XG4gICAgICAgICAgICB2YXIga2V5cyA9IGtleXNBbmRDaGFuZ2VzLm1hcChmdW5jdGlvbiAoZW50cnkpIHsgcmV0dXJuIGVudHJ5LmtleTsgfSk7XG4gICAgICAgICAgICB2YXIgY2hhbmdlU3BlY3MgPSBrZXlzQW5kQ2hhbmdlcy5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7IHJldHVybiBlbnRyeS5jaGFuZ2VzOyB9KTtcbiAgICAgICAgICAgIHZhciBvZmZzZXRNYXAgPSBbXTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90cmFucygncmVhZHdyaXRlJywgZnVuY3Rpb24gKHRyYW5zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvcmVUYWJsZS5nZXRNYW55KHsgdHJhbnM6IHRyYW5zLCBrZXlzOiBrZXlzLCBjYWNoZTogJ2Nsb25lJyB9KS50aGVuKGZ1bmN0aW9uIChvYmpzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHRLZXlzID0gW107XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHRPYmpzID0gW107XG4gICAgICAgICAgICAgICAgICAgIGtleXNBbmRDaGFuZ2VzLmZvckVhY2goZnVuY3Rpb24gKF9hLCBpZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBfYS5rZXksIGNoYW5nZXMgPSBfYS5jaGFuZ2VzO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9iaiA9IG9ianNbaWR4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvYmopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9iID0gT2JqZWN0LmtleXMoY2hhbmdlcyk7IF9pIDwgX2IubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXlQYXRoID0gX2JbX2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBjaGFuZ2VzW2tleVBhdGhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5UGF0aCA9PT0gX3RoaXMuc2NoZW1hLnByaW1LZXkua2V5UGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNtcCh2YWx1ZSwga2V5KSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLkNvbnN0cmFpbnQoXCJDYW5ub3QgdXBkYXRlIHByaW1hcnkga2V5IGluIGJ1bGtVcGRhdGUoKVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEJ5S2V5UGF0aChvYmosIGtleVBhdGgsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXRNYXAucHVzaChpZHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdEtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdE9ianMucHVzaChvYmopO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG51bUVudHJpZXMgPSByZXN1bHRLZXlzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvcmVUYWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgLm11dGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuczogdHJhbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAncHV0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleXM6IHJlc3VsdEtleXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXM6IHJlc3VsdE9ianMsXG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5czoga2V5cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VTcGVjczogY2hhbmdlU3BlY3NcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG51bUZhaWx1cmVzID0gX2EubnVtRmFpbHVyZXMsIGZhaWx1cmVzID0gX2EuZmFpbHVyZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobnVtRmFpbHVyZXMgPT09IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bUVudHJpZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9iID0gT2JqZWN0LmtleXMoZmFpbHVyZXMpOyBfaSA8IF9iLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvZmZzZXQgPSBfYltfaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1hcHBlZE9mZnNldCA9IG9mZnNldE1hcFtOdW1iZXIob2Zmc2V0KV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hcHBlZE9mZnNldCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmYWlsdXJlID0gZmFpbHVyZXNbb2Zmc2V0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGZhaWx1cmVzW29mZnNldF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhaWx1cmVzW21hcHBlZE9mZnNldF0gPSBmYWlsdXJlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBCdWxrRXJyb3IoXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCIuYnVsa1VwZGF0ZSgpOiBcIikuY29uY2F0KG51bUZhaWx1cmVzLCBcIiBvZiBcIikuY29uY2F0KG51bUVudHJpZXMsIFwiIG9wZXJhdGlvbnMgZmFpbGVkXCIpLCBmYWlsdXJlcyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIFRhYmxlLnByb3RvdHlwZS5idWxrRGVsZXRlID0gZnVuY3Rpb24gKGtleXMpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgbnVtS2V5cyA9IGtleXMubGVuZ3RoO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zKCdyZWFkd3JpdGUnLCBmdW5jdGlvbiAodHJhbnMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuY29yZS5tdXRhdGUoeyB0cmFuczogdHJhbnMsIHR5cGU6ICdkZWxldGUnLCBrZXlzOiBrZXlzIH0pXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXMpIHsgcmV0dXJuIGJ1aWx0SW5EZWxldGlvblRyaWdnZXIoX3RoaXMsIGtleXMsIHJlcyk7IH0pO1xuICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICB2YXIgbnVtRmFpbHVyZXMgPSBfYS5udW1GYWlsdXJlcywgbGFzdFJlc3VsdCA9IF9hLmxhc3RSZXN1bHQsIGZhaWx1cmVzID0gX2EuZmFpbHVyZXM7XG4gICAgICAgICAgICAgICAgaWYgKG51bUZhaWx1cmVzID09PSAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGFzdFJlc3VsdDtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQnVsa0Vycm9yKFwiXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiLmJ1bGtEZWxldGUoKTogXCIpLmNvbmNhdChudW1GYWlsdXJlcywgXCIgb2YgXCIpLmNvbmNhdChudW1LZXlzLCBcIiBvcGVyYXRpb25zIGZhaWxlZFwiKSwgZmFpbHVyZXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBUYWJsZTtcbiAgICB9KCkpO1xuXG4gICAgZnVuY3Rpb24gRXZlbnRzKGN0eCkge1xuICAgICAgICB2YXIgZXZzID0ge307XG4gICAgICAgIHZhciBydiA9IGZ1bmN0aW9uIChldmVudE5hbWUsIHN1YnNjcmliZXIpIHtcbiAgICAgICAgICAgIGlmIChzdWJzY3JpYmVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KGkgLSAxKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoLS1pKVxuICAgICAgICAgICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgICAgICBldnNbZXZlbnROYW1lXS5zdWJzY3JpYmUuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN0eDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiAoZXZlbnROYW1lKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXZzW2V2ZW50TmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJ2LmFkZEV2ZW50VHlwZSA9IGFkZDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDEsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICBhZGQoYXJndW1lbnRzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnY7XG4gICAgICAgIGZ1bmN0aW9uIGFkZChldmVudE5hbWUsIGNoYWluRnVuY3Rpb24sIGRlZmF1bHRGdW5jdGlvbikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBldmVudE5hbWUgPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgICAgIHJldHVybiBhZGRDb25maWd1cmVkRXZlbnRzKGV2ZW50TmFtZSk7XG4gICAgICAgICAgICBpZiAoIWNoYWluRnVuY3Rpb24pXG4gICAgICAgICAgICAgICAgY2hhaW5GdW5jdGlvbiA9IHJldmVyc2VTdG9wcGFibGVFdmVudENoYWluO1xuICAgICAgICAgICAgaWYgKCFkZWZhdWx0RnVuY3Rpb24pXG4gICAgICAgICAgICAgICAgZGVmYXVsdEZ1bmN0aW9uID0gbm9wO1xuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlcnM6IFtdLFxuICAgICAgICAgICAgICAgIGZpcmU6IGRlZmF1bHRGdW5jdGlvbixcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmU6IGZ1bmN0aW9uIChjYikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGV4dC5zdWJzY3JpYmVycy5pbmRleE9mKGNiKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuc3Vic2NyaWJlcnMucHVzaChjYik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmZpcmUgPSBjaGFpbkZ1bmN0aW9uKGNvbnRleHQuZmlyZSwgY2IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB1bnN1YnNjcmliZTogZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuc3Vic2NyaWJlcnMgPSBjb250ZXh0LnN1YnNjcmliZXJzLmZpbHRlcihmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIGZuICE9PSBjYjsgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZmlyZSA9IGNvbnRleHQuc3Vic2NyaWJlcnMucmVkdWNlKGNoYWluRnVuY3Rpb24sIGRlZmF1bHRGdW5jdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV2c1tldmVudE5hbWVdID0gcnZbZXZlbnROYW1lXSA9IGNvbnRleHQ7XG4gICAgICAgICAgICByZXR1cm4gY29udGV4dDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhZGRDb25maWd1cmVkRXZlbnRzKGNmZykge1xuICAgICAgICAgICAga2V5cyhjZmcpLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gY2ZnW2V2ZW50TmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKGlzQXJyYXkoYXJncykpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkKGV2ZW50TmFtZSwgY2ZnW2V2ZW50TmFtZV1bMF0sIGNmZ1tldmVudE5hbWVdWzFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYXJncyA9PT0gJ2FzYXAnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250ZXh0ID0gYWRkKGV2ZW50TmFtZSwgbWlycm9yLCBmdW5jdGlvbiBmaXJlKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGktLSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5zdWJzY3JpYmVycy5mb3JFYWNoKGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzYXAkMShmdW5jdGlvbiBmaXJlRXZlbnQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLkludmFsaWRBcmd1bWVudChcIkludmFsaWQgZXZlbnQgY29uZmlnXCIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlQ2xhc3NDb25zdHJ1Y3Rvcihwcm90b3R5cGUsIGNvbnN0cnVjdG9yKSB7XG4gICAgICAgIGRlcml2ZShjb25zdHJ1Y3RvcikuZnJvbSh7IHByb3RvdHlwZTogcHJvdG90eXBlIH0pO1xuICAgICAgICByZXR1cm4gY29uc3RydWN0b3I7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlVGFibGVDb25zdHJ1Y3RvcihkYikge1xuICAgICAgICByZXR1cm4gbWFrZUNsYXNzQ29uc3RydWN0b3IoVGFibGUucHJvdG90eXBlLCBmdW5jdGlvbiBUYWJsZShuYW1lLCB0YWJsZVNjaGVtYSwgdHJhbnMpIHtcbiAgICAgICAgICAgIHRoaXMuZGIgPSBkYjtcbiAgICAgICAgICAgIHRoaXMuX3R4ID0gdHJhbnM7XG4gICAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgdGhpcy5zY2hlbWEgPSB0YWJsZVNjaGVtYTtcbiAgICAgICAgICAgIHRoaXMuaG9vayA9IGRiLl9hbGxUYWJsZXNbbmFtZV0gPyBkYi5fYWxsVGFibGVzW25hbWVdLmhvb2sgOiBFdmVudHMobnVsbCwge1xuICAgICAgICAgICAgICAgIFwiY3JlYXRpbmdcIjogW2hvb2tDcmVhdGluZ0NoYWluLCBub3BdLFxuICAgICAgICAgICAgICAgIFwicmVhZGluZ1wiOiBbcHVyZUZ1bmN0aW9uQ2hhaW4sIG1pcnJvcl0sXG4gICAgICAgICAgICAgICAgXCJ1cGRhdGluZ1wiOiBbaG9va1VwZGF0aW5nQ2hhaW4sIG5vcF0sXG4gICAgICAgICAgICAgICAgXCJkZWxldGluZ1wiOiBbaG9va0RlbGV0aW5nQ2hhaW4sIG5vcF1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1BsYWluS2V5UmFuZ2UoY3R4LCBpZ25vcmVMaW1pdEZpbHRlcikge1xuICAgICAgICByZXR1cm4gIShjdHguZmlsdGVyIHx8IGN0eC5hbGdvcml0aG0gfHwgY3R4Lm9yKSAmJlxuICAgICAgICAgICAgKGlnbm9yZUxpbWl0RmlsdGVyID8gY3R4Lmp1c3RMaW1pdCA6ICFjdHgucmVwbGF5RmlsdGVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWRkRmlsdGVyKGN0eCwgZm4pIHtcbiAgICAgICAgY3R4LmZpbHRlciA9IGNvbWJpbmUoY3R4LmZpbHRlciwgZm4pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhZGRSZXBsYXlGaWx0ZXIoY3R4LCBmYWN0b3J5LCBpc0xpbWl0RmlsdGVyKSB7XG4gICAgICAgIHZhciBjdXJyID0gY3R4LnJlcGxheUZpbHRlcjtcbiAgICAgICAgY3R4LnJlcGxheUZpbHRlciA9IGN1cnIgPyBmdW5jdGlvbiAoKSB7IHJldHVybiBjb21iaW5lKGN1cnIoKSwgZmFjdG9yeSgpKTsgfSA6IGZhY3Rvcnk7XG4gICAgICAgIGN0eC5qdXN0TGltaXQgPSBpc0xpbWl0RmlsdGVyICYmICFjdXJyO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhZGRNYXRjaEZpbHRlcihjdHgsIGZuKSB7XG4gICAgICAgIGN0eC5pc01hdGNoID0gY29tYmluZShjdHguaXNNYXRjaCwgZm4pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRJbmRleE9yU3RvcmUoY3R4LCBjb3JlU2NoZW1hKSB7XG4gICAgICAgIGlmIChjdHguaXNQcmltS2V5KVxuICAgICAgICAgICAgcmV0dXJuIGNvcmVTY2hlbWEucHJpbWFyeUtleTtcbiAgICAgICAgdmFyIGluZGV4ID0gY29yZVNjaGVtYS5nZXRJbmRleEJ5S2V5UGF0aChjdHguaW5kZXgpO1xuICAgICAgICBpZiAoIWluZGV4KVxuICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuU2NoZW1hKFwiS2V5UGF0aCBcIiArIGN0eC5pbmRleCArIFwiIG9uIG9iamVjdCBzdG9yZSBcIiArIGNvcmVTY2hlbWEubmFtZSArIFwiIGlzIG5vdCBpbmRleGVkXCIpO1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9wZW5DdXJzb3IoY3R4LCBjb3JlVGFibGUsIHRyYW5zKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGdldEluZGV4T3JTdG9yZShjdHgsIGNvcmVUYWJsZS5zY2hlbWEpO1xuICAgICAgICByZXR1cm4gY29yZVRhYmxlLm9wZW5DdXJzb3Ioe1xuICAgICAgICAgICAgdHJhbnM6IHRyYW5zLFxuICAgICAgICAgICAgdmFsdWVzOiAhY3R4LmtleXNPbmx5LFxuICAgICAgICAgICAgcmV2ZXJzZTogY3R4LmRpciA9PT0gJ3ByZXYnLFxuICAgICAgICAgICAgdW5pcXVlOiAhIWN0eC51bmlxdWUsXG4gICAgICAgICAgICBxdWVyeToge1xuICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICAgICAgICByYW5nZTogY3R4LnJhbmdlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpdGVyKGN0eCwgZm4sIGNvcmVUcmFucywgY29yZVRhYmxlKSB7XG4gICAgICAgIHZhciBmaWx0ZXIgPSBjdHgucmVwbGF5RmlsdGVyID8gY29tYmluZShjdHguZmlsdGVyLCBjdHgucmVwbGF5RmlsdGVyKCkpIDogY3R4LmZpbHRlcjtcbiAgICAgICAgaWYgKCFjdHgub3IpIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVyYXRlKG9wZW5DdXJzb3IoY3R4LCBjb3JlVGFibGUsIGNvcmVUcmFucyksIGNvbWJpbmUoY3R4LmFsZ29yaXRobSwgZmlsdGVyKSwgZm4sICFjdHgua2V5c09ubHkgJiYgY3R4LnZhbHVlTWFwcGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBzZXRfMSA9IHt9O1xuICAgICAgICAgICAgdmFyIHVuaW9uID0gZnVuY3Rpb24gKGl0ZW0sIGN1cnNvciwgYWR2YW5jZSkge1xuICAgICAgICAgICAgICAgIGlmICghZmlsdGVyIHx8IGZpbHRlcihjdXJzb3IsIGFkdmFuY2UsIGZ1bmN0aW9uIChyZXN1bHQpIHsgcmV0dXJuIGN1cnNvci5zdG9wKHJlc3VsdCk7IH0sIGZ1bmN0aW9uIChlcnIpIHsgcmV0dXJuIGN1cnNvci5mYWlsKGVycik7IH0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcmltYXJ5S2V5ID0gY3Vyc29yLnByaW1hcnlLZXk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSAnJyArIHByaW1hcnlLZXk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScpXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXkgPSAnJyArIG5ldyBVaW50OEFycmF5KHByaW1hcnlLZXkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWhhc093bihzZXRfMSwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0XzFba2V5XSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBmbihpdGVtLCBjdXJzb3IsIGFkdmFuY2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgY3R4Lm9yLl9pdGVyYXRlKHVuaW9uLCBjb3JlVHJhbnMpLFxuICAgICAgICAgICAgICAgIGl0ZXJhdGUob3BlbkN1cnNvcihjdHgsIGNvcmVUYWJsZSwgY29yZVRyYW5zKSwgY3R4LmFsZ29yaXRobSwgdW5pb24sICFjdHgua2V5c09ubHkgJiYgY3R4LnZhbHVlTWFwcGVyKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaXRlcmF0ZShjdXJzb3JQcm9taXNlLCBmaWx0ZXIsIGZuLCB2YWx1ZU1hcHBlcikge1xuICAgICAgICB2YXIgbWFwcGVkRm4gPSB2YWx1ZU1hcHBlciA/IGZ1bmN0aW9uICh4LCBjLCBhKSB7IHJldHVybiBmbih2YWx1ZU1hcHBlcih4KSwgYywgYSk7IH0gOiBmbjtcbiAgICAgICAgdmFyIHdyYXBwZWRGbiA9IHdyYXAobWFwcGVkRm4pO1xuICAgICAgICByZXR1cm4gY3Vyc29yUHJvbWlzZS50aGVuKGZ1bmN0aW9uIChjdXJzb3IpIHtcbiAgICAgICAgICAgIGlmIChjdXJzb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3Vyc29yLnN0YXJ0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjdXJzb3IuY29udGludWUoKTsgfTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmaWx0ZXIgfHwgZmlsdGVyKGN1cnNvciwgZnVuY3Rpb24gKGFkdmFuY2VyKSB7IHJldHVybiBjID0gYWR2YW5jZXI7IH0sIGZ1bmN0aW9uICh2YWwpIHsgY3Vyc29yLnN0b3AodmFsKTsgYyA9IG5vcDsgfSwgZnVuY3Rpb24gKGUpIHsgY3Vyc29yLmZhaWwoZSk7IGMgPSBub3A7IH0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgd3JhcHBlZEZuKGN1cnNvci52YWx1ZSwgY3Vyc29yLCBmdW5jdGlvbiAoYWR2YW5jZXIpIHsgcmV0dXJuIGMgPSBhZHZhbmNlcjsgfSk7XG4gICAgICAgICAgICAgICAgICAgIGMoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIFByb3BNb2RpZmljYXRpb24gPSAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gUHJvcE1vZGlmaWNhdGlvbihzcGVjKSB7XG4gICAgICAgICAgICB0aGlzW1wiQEBwcm9wbW9kXCJdID0gc3BlYztcbiAgICAgICAgfVxuICAgICAgICBQcm9wTW9kaWZpY2F0aW9uLnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICB2YXIgc3BlYyA9IHRoaXNbXCJAQHByb3Btb2RcIl07XG4gICAgICAgICAgICBpZiAoc3BlYy5hZGQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhciB0ZXJtID0gc3BlYy5hZGQ7XG4gICAgICAgICAgICAgICAgaWYgKGlzQXJyYXkodGVybSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgKGlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbXSksIHRydWUpLCB0ZXJtLCB0cnVlKS5zb3J0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGVybSA9PT0gJ251bWJlcicpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoTnVtYmVyKHZhbHVlKSB8fCAwKSArIHRlcm07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0ZXJtID09PSAnYmlnaW50Jykge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJpZ0ludCh2YWx1ZSkgKyB0ZXJtO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChfYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJpZ0ludCgwKSArIHRlcm07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgdGVybSBcIi5jb25jYXQodGVybSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNwZWMucmVtb3ZlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3VidHJhaGVuZF8xID0gc3BlYy5yZW1vdmU7XG4gICAgICAgICAgICAgICAgaWYgKGlzQXJyYXkoc3VidHJhaGVuZF8xKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuICFzdWJ0cmFoZW5kXzEuaW5jbHVkZXMoaXRlbSk7IH0pLnNvcnQoKSA6IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHN1YnRyYWhlbmRfMSA9PT0gJ251bWJlcicpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBOdW1iZXIodmFsdWUpIC0gc3VidHJhaGVuZF8xO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc3VidHJhaGVuZF8xID09PSAnYmlnaW50Jykge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJpZ0ludCh2YWx1ZSkgLSBzdWJ0cmFoZW5kXzE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKF9jKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gQmlnSW50KDApIC0gc3VidHJhaGVuZF8xO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIHN1YnRyYWhlbmQgXCIuY29uY2F0KHN1YnRyYWhlbmRfMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHByZWZpeFRvUmVwbGFjZSA9IChfYSA9IHNwZWMucmVwbGFjZVByZWZpeCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWzBdO1xuICAgICAgICAgICAgaWYgKHByZWZpeFRvUmVwbGFjZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlLnN0YXJ0c1dpdGgocHJlZml4VG9SZXBsYWNlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzcGVjLnJlcGxhY2VQcmVmaXhbMV0gKyB2YWx1ZS5zdWJzdHJpbmcocHJlZml4VG9SZXBsYWNlLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBQcm9wTW9kaWZpY2F0aW9uO1xuICAgIH0oKSk7XG5cbiAgICB2YXIgQ29sbGVjdGlvbiA9ICAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBDb2xsZWN0aW9uKCkge1xuICAgICAgICB9XG4gICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKGZuLCBjYikge1xuICAgICAgICAgICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcbiAgICAgICAgICAgIHJldHVybiBjdHguZXJyb3IgP1xuICAgICAgICAgICAgICAgIGN0eC50YWJsZS5fdHJhbnMobnVsbCwgcmVqZWN0aW9uLmJpbmQobnVsbCwgY3R4LmVycm9yKSkgOlxuICAgICAgICAgICAgICAgIGN0eC50YWJsZS5fdHJhbnMoJ3JlYWRvbmx5JywgZm4pLnRoZW4oY2IpO1xuICAgICAgICB9O1xuICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG4gICAgICAgICAgICByZXR1cm4gY3R4LmVycm9yID9cbiAgICAgICAgICAgICAgICBjdHgudGFibGUuX3RyYW5zKG51bGwsIHJlamVjdGlvbi5iaW5kKG51bGwsIGN0eC5lcnJvcikpIDpcbiAgICAgICAgICAgICAgICBjdHgudGFibGUuX3RyYW5zKCdyZWFkd3JpdGUnLCBmbiwgXCJsb2NrZWRcIik7XG4gICAgICAgIH07XG4gICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLl9hZGRBbGdvcml0aG0gPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG4gICAgICAgICAgICBjdHguYWxnb3JpdGhtID0gY29tYmluZShjdHguYWxnb3JpdGhtLCBmbik7XG4gICAgICAgIH07XG4gICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLl9pdGVyYXRlID0gZnVuY3Rpb24gKGZuLCBjb3JlVHJhbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVyKHRoaXMuX2N0eCwgZm4sIGNvcmVUcmFucywgdGhpcy5fY3R4LnRhYmxlLmNvcmUpO1xuICAgICAgICB9O1xuICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uIChwcm9wcykge1xuICAgICAgICAgICAgdmFyIHJ2ID0gT2JqZWN0LmNyZWF0ZSh0aGlzLmNvbnN0cnVjdG9yLnByb3RvdHlwZSksIGN0eCA9IE9iamVjdC5jcmVhdGUodGhpcy5fY3R4KTtcbiAgICAgICAgICAgIGlmIChwcm9wcylcbiAgICAgICAgICAgICAgICBleHRlbmQoY3R4LCBwcm9wcyk7XG4gICAgICAgICAgICBydi5fY3R4ID0gY3R4O1xuICAgICAgICAgICAgcmV0dXJuIHJ2O1xuICAgICAgICB9O1xuICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5yYXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9jdHgudmFsdWVNYXBwZXIgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLmVhY2ggPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVhZChmdW5jdGlvbiAodHJhbnMpIHsgcmV0dXJuIGl0ZXIoY3R4LCBmbiwgdHJhbnMsIGN0eC50YWJsZS5jb3JlKTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLmNvdW50ID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWQoZnVuY3Rpb24gKHRyYW5zKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN0eCA9IF90aGlzLl9jdHg7XG4gICAgICAgICAgICAgICAgdmFyIGNvcmVUYWJsZSA9IGN0eC50YWJsZS5jb3JlO1xuICAgICAgICAgICAgICAgIGlmIChpc1BsYWluS2V5UmFuZ2UoY3R4LCB0cnVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29yZVRhYmxlLmNvdW50KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zOiB0cmFucyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGdldEluZGV4T3JTdG9yZShjdHgsIGNvcmVUYWJsZS5zY2hlbWEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlOiBjdHgucmFuZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoY291bnQpIHsgcmV0dXJuIE1hdGgubWluKGNvdW50LCBjdHgubGltaXQpOyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVyKGN0eCwgZnVuY3Rpb24gKCkgeyArK2NvdW50OyByZXR1cm4gZmFsc2U7IH0sIHRyYW5zLCBjb3JlVGFibGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiBjb3VudDsgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkudGhlbihjYik7XG4gICAgICAgIH07XG4gICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLnNvcnRCeSA9IGZ1bmN0aW9uIChrZXlQYXRoLCBjYikge1xuICAgICAgICAgICAgdmFyIHBhcnRzID0ga2V5UGF0aC5zcGxpdCgnLicpLnJldmVyc2UoKSwgbGFzdFBhcnQgPSBwYXJ0c1swXSwgbGFzdEluZGV4ID0gcGFydHMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldHZhbChvYmosIGkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldHZhbChvYmpbcGFydHNbaV1dLCBpIC0gMSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9ialtsYXN0UGFydF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgb3JkZXIgPSB0aGlzLl9jdHguZGlyID09PSBcIm5leHRcIiA/IDEgOiAtMTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIHNvcnRlcihhLCBiKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFWYWwgPSBnZXR2YWwoYSwgbGFzdEluZGV4KSwgYlZhbCA9IGdldHZhbChiLCBsYXN0SW5kZXgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjbXAoYVZhbCwgYlZhbCkgKiBvcmRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQXJyYXkoZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYS5zb3J0KHNvcnRlcik7XG4gICAgICAgICAgICB9KS50aGVuKGNiKTtcbiAgICAgICAgfTtcbiAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uIChjYikge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWFkKGZ1bmN0aW9uICh0cmFucykge1xuICAgICAgICAgICAgICAgIHZhciBjdHggPSBfdGhpcy5fY3R4O1xuICAgICAgICAgICAgICAgIGlmIChjdHguZGlyID09PSAnbmV4dCcgJiYgaXNQbGFpbktleVJhbmdlKGN0eCwgdHJ1ZSkgJiYgY3R4LmxpbWl0ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWVNYXBwZXJfMSA9IGN0eC52YWx1ZU1hcHBlcjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gZ2V0SW5kZXhPclN0b3JlKGN0eCwgY3R4LnRhYmxlLmNvcmUuc2NoZW1hKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN0eC50YWJsZS5jb3JlLnF1ZXJ5KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zOiB0cmFucyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbWl0OiBjdHgubGltaXQsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXM6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZTogY3R4LnJhbmdlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gX2EucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlTWFwcGVyXzEgPyByZXN1bHQubWFwKHZhbHVlTWFwcGVyXzEpIDogcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhXzEgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZXIoY3R4LCBmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gYV8xLnB1c2goaXRlbSk7IH0sIHRyYW5zLCBjdHgudGFibGUuY29yZSkudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiBhXzE7IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGNiKTtcbiAgICAgICAgfTtcbiAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUub2Zmc2V0ID0gZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgICAgICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPD0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIGN0eC5vZmZzZXQgKz0gb2Zmc2V0O1xuICAgICAgICAgICAgaWYgKGlzUGxhaW5LZXlSYW5nZShjdHgpKSB7XG4gICAgICAgICAgICAgICAgYWRkUmVwbGF5RmlsdGVyKGN0eCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0TGVmdCA9IG9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjdXJzb3IsIGFkdmFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvZmZzZXRMZWZ0ID09PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9mZnNldExlZnQgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAtLW9mZnNldExlZnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYWR2YW5jZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLmFkdmFuY2Uob2Zmc2V0TGVmdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0TGVmdCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFkZFJlcGxheUZpbHRlcihjdHgsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9mZnNldExlZnQgPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiAoLS1vZmZzZXRMZWZ0IDwgMCk7IH07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUubGltaXQgPSBmdW5jdGlvbiAobnVtUm93cykge1xuICAgICAgICAgICAgdGhpcy5fY3R4LmxpbWl0ID0gTWF0aC5taW4odGhpcy5fY3R4LmxpbWl0LCBudW1Sb3dzKTtcbiAgICAgICAgICAgIGFkZFJlcGxheUZpbHRlcih0aGlzLl9jdHgsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcm93c0xlZnQgPSBudW1Sb3dzO1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoY3Vyc29yLCBhZHZhbmNlLCByZXNvbHZlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgtLXJvd3NMZWZ0IDw9IDApXG4gICAgICAgICAgICAgICAgICAgICAgICBhZHZhbmNlKHJlc29sdmUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcm93c0xlZnQgPj0gMDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUudW50aWwgPSBmdW5jdGlvbiAoZmlsdGVyRnVuY3Rpb24sIGJJbmNsdWRlU3RvcEVudHJ5KSB7XG4gICAgICAgICAgICBhZGRGaWx0ZXIodGhpcy5fY3R4LCBmdW5jdGlvbiAoY3Vyc29yLCBhZHZhbmNlLCByZXNvbHZlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpbHRlckZ1bmN0aW9uKGN1cnNvci52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYWR2YW5jZShyZXNvbHZlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJJbmNsdWRlU3RvcEVudHJ5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUuZmlyc3QgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxpbWl0KDEpLnRvQXJyYXkoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGFbMF07IH0pLnRoZW4oY2IpO1xuICAgICAgICB9O1xuICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5sYXN0ID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXZlcnNlKCkuZmlyc3QoY2IpO1xuICAgICAgICB9O1xuICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5maWx0ZXIgPSBmdW5jdGlvbiAoZmlsdGVyRnVuY3Rpb24pIHtcbiAgICAgICAgICAgIGFkZEZpbHRlcih0aGlzLl9jdHgsIGZ1bmN0aW9uIChjdXJzb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsdGVyRnVuY3Rpb24oY3Vyc29yLnZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYWRkTWF0Y2hGaWx0ZXIodGhpcy5fY3R4LCBmaWx0ZXJGdW5jdGlvbik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUuYW5kID0gZnVuY3Rpb24gKGZpbHRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKGZpbHRlcik7XG4gICAgICAgIH07XG4gICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLm9yID0gZnVuY3Rpb24gKGluZGV4TmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmRiLldoZXJlQ2xhdXNlKHRoaXMuX2N0eC50YWJsZSwgaW5kZXhOYW1lLCB0aGlzKTtcbiAgICAgICAgfTtcbiAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUucmV2ZXJzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2N0eC5kaXIgPSAodGhpcy5fY3R4LmRpciA9PT0gXCJwcmV2XCIgPyBcIm5leHRcIiA6IFwicHJldlwiKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9vbmRpcmVjdGlvbmNoYW5nZSlcbiAgICAgICAgICAgICAgICB0aGlzLl9vbmRpcmVjdGlvbmNoYW5nZSh0aGlzLl9jdHguZGlyKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5kZXNjID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmV2ZXJzZSgpO1xuICAgICAgICB9O1xuICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5lYWNoS2V5ID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICAgICAgICAgICAgY3R4LmtleXNPbmx5ID0gIWN0eC5pc01hdGNoO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAodmFsLCBjdXJzb3IpIHsgY2IoY3Vyc29yLmtleSwgY3Vyc29yKTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLmVhY2hVbmlxdWVLZXkgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgICAgIHRoaXMuX2N0eC51bmlxdWUgPSBcInVuaXF1ZVwiO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaEtleShjYik7XG4gICAgICAgIH07XG4gICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLmVhY2hQcmltYXJ5S2V5ID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICAgICAgICAgICAgY3R4LmtleXNPbmx5ID0gIWN0eC5pc01hdGNoO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAodmFsLCBjdXJzb3IpIHsgY2IoY3Vyc29yLnByaW1hcnlLZXksIGN1cnNvcik7IH0pO1xuICAgICAgICB9O1xuICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5rZXlzID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICAgICAgICAgICAgY3R4LmtleXNPbmx5ID0gIWN0eC5pc01hdGNoO1xuICAgICAgICAgICAgdmFyIGEgPSBbXTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKGl0ZW0sIGN1cnNvcikge1xuICAgICAgICAgICAgICAgIGEucHVzaChjdXJzb3Iua2V5KTtcbiAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICAgICAgfSkudGhlbihjYik7XG4gICAgICAgIH07XG4gICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLnByaW1hcnlLZXlzID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICAgICAgICAgICAgaWYgKGN0eC5kaXIgPT09ICduZXh0JyAmJiBpc1BsYWluS2V5UmFuZ2UoY3R4LCB0cnVlKSAmJiBjdHgubGltaXQgPiAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWQoZnVuY3Rpb24gKHRyYW5zKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGdldEluZGV4T3JTdG9yZShjdHgsIGN0eC50YWJsZS5jb3JlLnNjaGVtYSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjdHgudGFibGUuY29yZS5xdWVyeSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuczogdHJhbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXM6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGltaXQ6IGN0eC5saW1pdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlOiBjdHgucmFuZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IF9hLnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9KS50aGVuKGNiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5rZXlzT25seSA9ICFjdHguaXNNYXRjaDtcbiAgICAgICAgICAgIHZhciBhID0gW107XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uIChpdGVtLCBjdXJzb3IpIHtcbiAgICAgICAgICAgICAgICBhLnB1c2goY3Vyc29yLnByaW1hcnlLZXkpO1xuICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgICAgICB9KS50aGVuKGNiKTtcbiAgICAgICAgfTtcbiAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUudW5pcXVlS2V5cyA9IGZ1bmN0aW9uIChjYikge1xuICAgICAgICAgICAgdGhpcy5fY3R4LnVuaXF1ZSA9IFwidW5pcXVlXCI7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5rZXlzKGNiKTtcbiAgICAgICAgfTtcbiAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUuZmlyc3RLZXkgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxpbWl0KDEpLmtleXMoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGFbMF07IH0pLnRoZW4oY2IpO1xuICAgICAgICB9O1xuICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5sYXN0S2V5ID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXZlcnNlKCkuZmlyc3RLZXkoY2IpO1xuICAgICAgICB9O1xuICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5kaXN0aW5jdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjdHggPSB0aGlzLl9jdHgsIGlkeCA9IGN0eC5pbmRleCAmJiBjdHgudGFibGUuc2NoZW1hLmlkeEJ5TmFtZVtjdHguaW5kZXhdO1xuICAgICAgICAgICAgaWYgKCFpZHggfHwgIWlkeC5tdWx0aSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIHZhciBzZXQgPSB7fTtcbiAgICAgICAgICAgIGFkZEZpbHRlcih0aGlzLl9jdHgsIGZ1bmN0aW9uIChjdXJzb3IpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RyS2V5ID0gY3Vyc29yLnByaW1hcnlLZXkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB2YXIgZm91bmQgPSBoYXNPd24oc2V0LCBzdHJLZXkpO1xuICAgICAgICAgICAgICAgIHNldFtzdHJLZXldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gIWZvdW5kO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUubW9kaWZ5ID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dyaXRlKGZ1bmN0aW9uICh0cmFucykge1xuICAgICAgICAgICAgICAgIHZhciBtb2RpZnllcjtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNoYW5nZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kaWZ5ZXIgPSBjaGFuZ2VzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleVBhdGhzID0ga2V5cyhjaGFuZ2VzKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG51bUtleXMgPSBrZXlQYXRocy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIG1vZGlmeWVyID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhbnl0aGluZ01vZGlmaWVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUtleXM7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXlQYXRoID0ga2V5UGF0aHNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IGNoYW5nZXNba2V5UGF0aF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9yaWdWYWwgPSBnZXRCeUtleVBhdGgoaXRlbSwga2V5UGF0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIFByb3BNb2RpZmljYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0QnlLZXlQYXRoKGl0ZW0sIGtleVBhdGgsIHZhbC5leGVjdXRlKG9yaWdWYWwpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW55dGhpbmdNb2RpZmllZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9yaWdWYWwgIT09IHZhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRCeUtleVBhdGgoaXRlbSwga2V5UGF0aCwgdmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW55dGhpbmdNb2RpZmllZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFueXRoaW5nTW9kaWZpZWQ7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBjb3JlVGFibGUgPSBjdHgudGFibGUuY29yZTtcbiAgICAgICAgICAgICAgICB2YXIgX2EgPSBjb3JlVGFibGUuc2NoZW1hLnByaW1hcnlLZXksIG91dGJvdW5kID0gX2Eub3V0Ym91bmQsIGV4dHJhY3RLZXkgPSBfYS5leHRyYWN0S2V5O1xuICAgICAgICAgICAgICAgIHZhciBsaW1pdCA9IDIwMDtcbiAgICAgICAgICAgICAgICB2YXIgbW9kaWZ5Q2h1bmtTaXplID0gX3RoaXMuZGIuX29wdGlvbnMubW9kaWZ5Q2h1bmtTaXplO1xuICAgICAgICAgICAgICAgIGlmIChtb2RpZnlDaHVua1NpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtb2RpZnlDaHVua1NpemUgPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbWl0ID0gbW9kaWZ5Q2h1bmtTaXplW2NvcmVUYWJsZS5uYW1lXSB8fCBtb2RpZnlDaHVua1NpemVbJyonXSB8fCAyMDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW1pdCA9IG1vZGlmeUNodW5rU2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgdG90YWxGYWlsdXJlcyA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBzdWNjZXNzQ291bnQgPSAwO1xuICAgICAgICAgICAgICAgIHZhciBmYWlsZWRLZXlzID0gW107XG4gICAgICAgICAgICAgICAgdmFyIGFwcGx5TXV0YXRlUmVzdWx0ID0gZnVuY3Rpb24gKGV4cGVjdGVkQ291bnQsIHJlcykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZmFpbHVyZXMgPSByZXMuZmFpbHVyZXMsIG51bUZhaWx1cmVzID0gcmVzLm51bUZhaWx1cmVzO1xuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzQ291bnQgKz0gZXhwZWN0ZWRDb3VudCAtIG51bUZhaWx1cmVzO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0ga2V5cyhmYWlsdXJlcyk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcG9zID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG90YWxGYWlsdXJlcy5wdXNoKGZhaWx1cmVzW3Bvc10pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB2YXIgaXNVbmNvbmRpdGlvbmFsRGVsZXRlID0gY2hhbmdlcyA9PT0gZGVsZXRlQ2FsbGJhY2s7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmNsb25lKCkucHJpbWFyeUtleXMoKS50aGVuKGZ1bmN0aW9uIChrZXlzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjcml0ZXJpYSA9IGlzUGxhaW5LZXlSYW5nZShjdHgpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgubGltaXQgPT09IEluZmluaXR5ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mIGNoYW5nZXMgIT09ICdmdW5jdGlvbicgfHwgaXNVbmNvbmRpdGlvbmFsRGVsZXRlKSAmJiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogY3R4LmluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IGN0eC5yYW5nZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dENodW5rID0gZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvdW50ID0gTWF0aC5taW4obGltaXQsIGtleXMubGVuZ3RoIC0gb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXlzSW5DaHVuayA9IGtleXMuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBjb3VudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGlzVW5jb25kaXRpb25hbERlbGV0ZSA/IFByb21pc2UucmVzb2x2ZShbXSkgOiBjb3JlVGFibGUuZ2V0TWFueSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnM6IHRyYW5zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleXM6IGtleXNJbkNodW5rLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlOiBcImltbXV0YWJsZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSkudGhlbihmdW5jdGlvbiAodmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFkZFZhbHVlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwdXRWYWx1ZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHV0S2V5cyA9IG91dGJvdW5kID8gW10gOiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWxldGVLZXlzID0gaXNVbmNvbmRpdGlvbmFsRGVsZXRlID8ga2V5c0luQ2h1bmsgOiBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzVW5jb25kaXRpb25hbERlbGV0ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3JpZ1ZhbHVlID0gdmFsdWVzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN0eF8xID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBkZWVwQ2xvbmUob3JpZ1ZhbHVlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmltS2V5OiBrZXlzW29mZnNldCArIGldXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGlmeWVyLmNhbGwoY3R4XzEsIGN0eF8xLnZhbHVlLCBjdHhfMSkgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN0eF8xLnZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlS2V5cy5wdXNoKGtleXNbb2Zmc2V0ICsgaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghb3V0Ym91bmQgJiYgY21wKGV4dHJhY3RLZXkob3JpZ1ZhbHVlKSwgZXh0cmFjdEtleShjdHhfMS52YWx1ZSkpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZUtleXMucHVzaChrZXlzW29mZnNldCArIGldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkVmFsdWVzLnB1c2goY3R4XzEudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHV0VmFsdWVzLnB1c2goY3R4XzEudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3V0Ym91bmQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdXRLZXlzLnB1c2goa2V5c1tvZmZzZXQgKyBpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShhZGRWYWx1ZXMubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3JlVGFibGUubXV0YXRlKHsgdHJhbnM6IHRyYW5zLCB0eXBlOiAnYWRkJywgdmFsdWVzOiBhZGRWYWx1ZXMgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHBvcyBpbiByZXMuZmFpbHVyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGVLZXlzLnNwbGljZShwYXJzZUludChwb3MpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwcGx5TXV0YXRlUmVzdWx0KGFkZFZhbHVlcy5sZW5ndGgsIHJlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIChwdXRWYWx1ZXMubGVuZ3RoID4gMCB8fCAoY3JpdGVyaWEgJiYgdHlwZW9mIGNoYW5nZXMgPT09ICdvYmplY3QnKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29yZVRhYmxlLm11dGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuczogdHJhbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAncHV0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleXM6IHB1dEtleXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXM6IHB1dFZhbHVlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNyaXRlcmlhOiBjcml0ZXJpYSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZVNwZWM6IHR5cGVvZiBjaGFuZ2VzICE9PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgY2hhbmdlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzQWRkaXRpb25hbENodW5rOiBvZmZzZXQgPiAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHJlcykgeyByZXR1cm4gYXBwbHlNdXRhdGVSZXN1bHQocHV0VmFsdWVzLmxlbmd0aCwgcmVzKTsgfSk7IH0pLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gKGRlbGV0ZUtleXMubGVuZ3RoID4gMCB8fCAoY3JpdGVyaWEgJiYgaXNVbmNvbmRpdGlvbmFsRGVsZXRlKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29yZVRhYmxlLm11dGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuczogdHJhbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZGVsZXRlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleXM6IGRlbGV0ZUtleXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcml0ZXJpYTogY3JpdGVyaWEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0FkZGl0aW9uYWxDaHVuazogb2Zmc2V0ID4gMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChyZXMpIHsgcmV0dXJuIGJ1aWx0SW5EZWxldGlvblRyaWdnZXIoY3R4LnRhYmxlLCBkZWxldGVLZXlzLCByZXMpOyB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlcykgeyByZXR1cm4gYXBwbHlNdXRhdGVSZXN1bHQoZGVsZXRlS2V5cy5sZW5ndGgsIHJlcyk7IH0pOyB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtleXMubGVuZ3RoID4gb2Zmc2V0ICsgY291bnQgJiYgbmV4dENodW5rKG9mZnNldCArIGxpbWl0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV4dENodW5rKDApLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRvdGFsRmFpbHVyZXMubGVuZ3RoID4gMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTW9kaWZ5RXJyb3IoXCJFcnJvciBtb2RpZnlpbmcgb25lIG9yIG1vcmUgb2JqZWN0c1wiLCB0b3RhbEZhaWx1cmVzLCBzdWNjZXNzQ291bnQsIGZhaWxlZEtleXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtleXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4LCByYW5nZSA9IGN0eC5yYW5nZTtcbiAgICAgICAgICAgIGlmIChpc1BsYWluS2V5UmFuZ2UoY3R4KSAmJlxuICAgICAgICAgICAgICAgICFjdHgudGFibGUuc2NoZW1hLnlQcm9wcyAmJlxuICAgICAgICAgICAgICAgIChjdHguaXNQcmltS2V5IHx8IHJhbmdlLnR5cGUgPT09IDMgKSlcbiAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dyaXRlKGZ1bmN0aW9uICh0cmFucykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJpbWFyeUtleSA9IGN0eC50YWJsZS5jb3JlLnNjaGVtYS5wcmltYXJ5S2V5O1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29yZVJhbmdlID0gcmFuZ2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjdHgudGFibGUuY29yZS5jb3VudCh7IHRyYW5zOiB0cmFucywgcXVlcnk6IHsgaW5kZXg6IHByaW1hcnlLZXksIHJhbmdlOiBjb3JlUmFuZ2UgfSB9KS50aGVuKGZ1bmN0aW9uIChjb3VudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN0eC50YWJsZS5jb3JlLm11dGF0ZSh7IHRyYW5zOiB0cmFucywgdHlwZTogJ2RlbGV0ZVJhbmdlJywgcmFuZ2U6IGNvcmVSYW5nZSB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmYWlsdXJlcyA9IF9hLmZhaWx1cmVzLCBudW1GYWlsdXJlcyA9IF9hLm51bUZhaWx1cmVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChudW1GYWlsdXJlcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE1vZGlmeUVycm9yKFwiQ291bGQgbm90IGRlbGV0ZSBzb21lIHZhbHVlc1wiLCBPYmplY3Qua2V5cyhmYWlsdXJlcykubWFwKGZ1bmN0aW9uIChwb3MpIHsgcmV0dXJuIGZhaWx1cmVzW3Bvc107IH0pLCBjb3VudCAtIG51bUZhaWx1cmVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY291bnQgLSBudW1GYWlsdXJlcztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1vZGlmeShkZWxldGVDYWxsYmFjayk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBDb2xsZWN0aW9uO1xuICAgIH0oKSk7XG4gICAgdmFyIGRlbGV0ZUNhbGxiYWNrID0gZnVuY3Rpb24gKHZhbHVlLCBjdHgpIHsgcmV0dXJuIGN0eC52YWx1ZSA9IG51bGw7IH07XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVDb2xsZWN0aW9uQ29uc3RydWN0b3IoZGIpIHtcbiAgICAgICAgcmV0dXJuIG1ha2VDbGFzc0NvbnN0cnVjdG9yKENvbGxlY3Rpb24ucHJvdG90eXBlLCBmdW5jdGlvbiBDb2xsZWN0aW9uKHdoZXJlQ2xhdXNlLCBrZXlSYW5nZUdlbmVyYXRvcikge1xuICAgICAgICAgICAgdGhpcy5kYiA9IGRiO1xuICAgICAgICAgICAgdmFyIGtleVJhbmdlID0gQW55UmFuZ2UsIGVycm9yID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChrZXlSYW5nZUdlbmVyYXRvcilcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBrZXlSYW5nZSA9IGtleVJhbmdlR2VuZXJhdG9yKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChleCkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvciA9IGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB3aGVyZUN0eCA9IHdoZXJlQ2xhdXNlLl9jdHg7XG4gICAgICAgICAgICB2YXIgdGFibGUgPSB3aGVyZUN0eC50YWJsZTtcbiAgICAgICAgICAgIHZhciByZWFkaW5nSG9vayA9IHRhYmxlLmhvb2sucmVhZGluZy5maXJlO1xuICAgICAgICAgICAgdGhpcy5fY3R4ID0ge1xuICAgICAgICAgICAgICAgIHRhYmxlOiB0YWJsZSxcbiAgICAgICAgICAgICAgICBpbmRleDogd2hlcmVDdHguaW5kZXgsXG4gICAgICAgICAgICAgICAgaXNQcmltS2V5OiAoIXdoZXJlQ3R4LmluZGV4IHx8ICh0YWJsZS5zY2hlbWEucHJpbUtleS5rZXlQYXRoICYmIHdoZXJlQ3R4LmluZGV4ID09PSB0YWJsZS5zY2hlbWEucHJpbUtleS5uYW1lKSksXG4gICAgICAgICAgICAgICAgcmFuZ2U6IGtleVJhbmdlLFxuICAgICAgICAgICAgICAgIGtleXNPbmx5OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBkaXI6IFwibmV4dFwiLFxuICAgICAgICAgICAgICAgIHVuaXF1ZTogXCJcIixcbiAgICAgICAgICAgICAgICBhbGdvcml0aG06IG51bGwsXG4gICAgICAgICAgICAgICAgZmlsdGVyOiBudWxsLFxuICAgICAgICAgICAgICAgIHJlcGxheUZpbHRlcjogbnVsbCxcbiAgICAgICAgICAgICAgICBqdXN0TGltaXQ6IHRydWUsXG4gICAgICAgICAgICAgICAgaXNNYXRjaDogbnVsbCxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IDAsXG4gICAgICAgICAgICAgICAgbGltaXQ6IEluZmluaXR5LFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgICAgICBvcjogd2hlcmVDdHgub3IsXG4gICAgICAgICAgICAgICAgdmFsdWVNYXBwZXI6IHJlYWRpbmdIb29rICE9PSBtaXJyb3IgPyByZWFkaW5nSG9vayA6IG51bGxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNpbXBsZUNvbXBhcmUoYSwgYikge1xuICAgICAgICByZXR1cm4gYSA8IGIgPyAtMSA6IGEgPT09IGIgPyAwIDogMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2ltcGxlQ29tcGFyZVJldmVyc2UoYSwgYikge1xuICAgICAgICByZXR1cm4gYSA+IGIgPyAtMSA6IGEgPT09IGIgPyAwIDogMTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmYWlsKGNvbGxlY3Rpb25PcldoZXJlQ2xhdXNlLCBlcnIsIFQpIHtcbiAgICAgICAgdmFyIGNvbGxlY3Rpb24gPSBjb2xsZWN0aW9uT3JXaGVyZUNsYXVzZSBpbnN0YW5jZW9mIFdoZXJlQ2xhdXNlID9cbiAgICAgICAgICAgIG5ldyBjb2xsZWN0aW9uT3JXaGVyZUNsYXVzZS5Db2xsZWN0aW9uKGNvbGxlY3Rpb25PcldoZXJlQ2xhdXNlKSA6XG4gICAgICAgICAgICBjb2xsZWN0aW9uT3JXaGVyZUNsYXVzZTtcbiAgICAgICAgY29sbGVjdGlvbi5fY3R4LmVycm9yID0gVCA/IG5ldyBUKGVycikgOiBuZXcgVHlwZUVycm9yKGVycik7XG4gICAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbXB0eUNvbGxlY3Rpb24od2hlcmVDbGF1c2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB3aGVyZUNsYXVzZS5Db2xsZWN0aW9uKHdoZXJlQ2xhdXNlLCBmdW5jdGlvbiAoKSB7IHJldHVybiByYW5nZUVxdWFsKFwiXCIpOyB9KS5saW1pdCgwKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBwZXJGYWN0b3J5KGRpcikge1xuICAgICAgICByZXR1cm4gZGlyID09PSBcIm5leHRcIiA/XG4gICAgICAgICAgICBmdW5jdGlvbiAocykgeyByZXR1cm4gcy50b1VwcGVyQ2FzZSgpOyB9IDpcbiAgICAgICAgICAgIGZ1bmN0aW9uIChzKSB7IHJldHVybiBzLnRvTG93ZXJDYXNlKCk7IH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxvd2VyRmFjdG9yeShkaXIpIHtcbiAgICAgICAgcmV0dXJuIGRpciA9PT0gXCJuZXh0XCIgP1xuICAgICAgICAgICAgZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMudG9Mb3dlckNhc2UoKTsgfSA6XG4gICAgICAgICAgICBmdW5jdGlvbiAocykgeyByZXR1cm4gcy50b1VwcGVyQ2FzZSgpOyB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBuZXh0Q2FzaW5nKGtleSwgbG93ZXJLZXksIHVwcGVyTmVlZGxlLCBsb3dlck5lZWRsZSwgY21wLCBkaXIpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IE1hdGgubWluKGtleS5sZW5ndGgsIGxvd2VyTmVlZGxlLmxlbmd0aCk7XG4gICAgICAgIHZhciBsbHAgPSAtMTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIGx3cktleUNoYXIgPSBsb3dlcktleVtpXTtcbiAgICAgICAgICAgIGlmIChsd3JLZXlDaGFyICE9PSBsb3dlck5lZWRsZVtpXSkge1xuICAgICAgICAgICAgICAgIGlmIChjbXAoa2V5W2ldLCB1cHBlck5lZWRsZVtpXSkgPCAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2V5LnN1YnN0cigwLCBpKSArIHVwcGVyTmVlZGxlW2ldICsgdXBwZXJOZWVkbGUuc3Vic3RyKGkgKyAxKTtcbiAgICAgICAgICAgICAgICBpZiAoY21wKGtleVtpXSwgbG93ZXJOZWVkbGVbaV0pIDwgMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtleS5zdWJzdHIoMCwgaSkgKyBsb3dlck5lZWRsZVtpXSArIHVwcGVyTmVlZGxlLnN1YnN0cihpICsgMSk7XG4gICAgICAgICAgICAgICAgaWYgKGxscCA+PSAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2V5LnN1YnN0cigwLCBsbHApICsgbG93ZXJLZXlbbGxwXSArIHVwcGVyTmVlZGxlLnN1YnN0cihsbHAgKyAxKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjbXAoa2V5W2ldLCBsd3JLZXlDaGFyKSA8IDApXG4gICAgICAgICAgICAgICAgbGxwID0gaTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuZ3RoIDwgbG93ZXJOZWVkbGUubGVuZ3RoICYmIGRpciA9PT0gXCJuZXh0XCIpXG4gICAgICAgICAgICByZXR1cm4ga2V5ICsgdXBwZXJOZWVkbGUuc3Vic3RyKGtleS5sZW5ndGgpO1xuICAgICAgICBpZiAobGVuZ3RoIDwga2V5Lmxlbmd0aCAmJiBkaXIgPT09IFwicHJldlwiKVxuICAgICAgICAgICAgcmV0dXJuIGtleS5zdWJzdHIoMCwgdXBwZXJOZWVkbGUubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIChsbHAgPCAwID8gbnVsbCA6IGtleS5zdWJzdHIoMCwgbGxwKSArIGxvd2VyTmVlZGxlW2xscF0gKyB1cHBlck5lZWRsZS5zdWJzdHIobGxwICsgMSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhZGRJZ25vcmVDYXNlQWxnb3JpdGhtKHdoZXJlQ2xhdXNlLCBtYXRjaCwgbmVlZGxlcywgc3VmZml4KSB7XG4gICAgICAgIHZhciB1cHBlciwgbG93ZXIsIGNvbXBhcmUsIHVwcGVyTmVlZGxlcywgbG93ZXJOZWVkbGVzLCBkaXJlY3Rpb24sIG5leHRLZXlTdWZmaXgsIG5lZWRsZXNMZW4gPSBuZWVkbGVzLmxlbmd0aDtcbiAgICAgICAgaWYgKCFuZWVkbGVzLmV2ZXJ5KGZ1bmN0aW9uIChzKSB7IHJldHVybiB0eXBlb2YgcyA9PT0gJ3N0cmluZyc7IH0pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFpbCh3aGVyZUNsYXVzZSwgU1RSSU5HX0VYUEVDVEVEKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpbml0RGlyZWN0aW9uKGRpcikge1xuICAgICAgICAgICAgdXBwZXIgPSB1cHBlckZhY3RvcnkoZGlyKTtcbiAgICAgICAgICAgIGxvd2VyID0gbG93ZXJGYWN0b3J5KGRpcik7XG4gICAgICAgICAgICBjb21wYXJlID0gKGRpciA9PT0gXCJuZXh0XCIgPyBzaW1wbGVDb21wYXJlIDogc2ltcGxlQ29tcGFyZVJldmVyc2UpO1xuICAgICAgICAgICAgdmFyIG5lZWRsZUJvdW5kcyA9IG5lZWRsZXMubWFwKGZ1bmN0aW9uIChuZWVkbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBsb3dlcjogbG93ZXIobmVlZGxlKSwgdXBwZXI6IHVwcGVyKG5lZWRsZSkgfTtcbiAgICAgICAgICAgIH0pLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcGFyZShhLmxvd2VyLCBiLmxvd2VyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdXBwZXJOZWVkbGVzID0gbmVlZGxlQm91bmRzLm1hcChmdW5jdGlvbiAobmIpIHsgcmV0dXJuIG5iLnVwcGVyOyB9KTtcbiAgICAgICAgICAgIGxvd2VyTmVlZGxlcyA9IG5lZWRsZUJvdW5kcy5tYXAoZnVuY3Rpb24gKG5iKSB7IHJldHVybiBuYi5sb3dlcjsgfSk7XG4gICAgICAgICAgICBkaXJlY3Rpb24gPSBkaXI7XG4gICAgICAgICAgICBuZXh0S2V5U3VmZml4ID0gKGRpciA9PT0gXCJuZXh0XCIgPyBcIlwiIDogc3VmZml4KTtcbiAgICAgICAgfVxuICAgICAgICBpbml0RGlyZWN0aW9uKFwibmV4dFwiKTtcbiAgICAgICAgdmFyIGMgPSBuZXcgd2hlcmVDbGF1c2UuQ29sbGVjdGlvbih3aGVyZUNsYXVzZSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gY3JlYXRlUmFuZ2UodXBwZXJOZWVkbGVzWzBdLCBsb3dlck5lZWRsZXNbbmVlZGxlc0xlbiAtIDFdICsgc3VmZml4KTsgfSk7XG4gICAgICAgIGMuX29uZGlyZWN0aW9uY2hhbmdlID0gZnVuY3Rpb24gKGRpcmVjdGlvbikge1xuICAgICAgICAgICAgaW5pdERpcmVjdGlvbihkaXJlY3Rpb24pO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgZmlyc3RQb3NzaWJsZU5lZWRsZSA9IDA7XG4gICAgICAgIGMuX2FkZEFsZ29yaXRobShmdW5jdGlvbiAoY3Vyc29yLCBhZHZhbmNlLCByZXNvbHZlKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gY3Vyc29yLmtleTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB2YXIgbG93ZXJLZXkgPSBsb3dlcihrZXkpO1xuICAgICAgICAgICAgaWYgKG1hdGNoKGxvd2VyS2V5LCBsb3dlck5lZWRsZXMsIGZpcnN0UG9zc2libGVOZWVkbGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgbG93ZXN0UG9zc2libGVDYXNpbmcgPSBudWxsO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBmaXJzdFBvc3NpYmxlTmVlZGxlOyBpIDwgbmVlZGxlc0xlbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjYXNpbmcgPSBuZXh0Q2FzaW5nKGtleSwgbG93ZXJLZXksIHVwcGVyTmVlZGxlc1tpXSwgbG93ZXJOZWVkbGVzW2ldLCBjb21wYXJlLCBkaXJlY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FzaW5nID09PSBudWxsICYmIGxvd2VzdFBvc3NpYmxlQ2FzaW5nID09PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3RQb3NzaWJsZU5lZWRsZSA9IGkgKyAxO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChsb3dlc3RQb3NzaWJsZUNhc2luZyA9PT0gbnVsbCB8fCBjb21wYXJlKGxvd2VzdFBvc3NpYmxlQ2FzaW5nLCBjYXNpbmcpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXN0UG9zc2libGVDYXNpbmcgPSBjYXNpbmc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGxvd2VzdFBvc3NpYmxlQ2FzaW5nICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkdmFuY2UoZnVuY3Rpb24gKCkgeyBjdXJzb3IuY29udGludWUobG93ZXN0UG9zc2libGVDYXNpbmcgKyBuZXh0S2V5U3VmZml4KTsgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhZHZhbmNlKHJlc29sdmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYztcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlUmFuZ2UobG93ZXIsIHVwcGVyLCBsb3dlck9wZW4sIHVwcGVyT3Blbikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogMiAsXG4gICAgICAgICAgICBsb3dlcjogbG93ZXIsXG4gICAgICAgICAgICB1cHBlcjogdXBwZXIsXG4gICAgICAgICAgICBsb3dlck9wZW46IGxvd2VyT3BlbixcbiAgICAgICAgICAgIHVwcGVyT3BlbjogdXBwZXJPcGVuXG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJhbmdlRXF1YWwodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IDEgLFxuICAgICAgICAgICAgbG93ZXI6IHZhbHVlLFxuICAgICAgICAgICAgdXBwZXI6IHZhbHVlXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIFdoZXJlQ2xhdXNlID0gIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFdoZXJlQ2xhdXNlKCkge1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXaGVyZUNsYXVzZS5wcm90b3R5cGUsIFwiQ29sbGVjdGlvblwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY3R4LnRhYmxlLmRiLkNvbGxlY3Rpb247XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIFdoZXJlQ2xhdXNlLnByb3RvdHlwZS5iZXR3ZWVuID0gZnVuY3Rpb24gKGxvd2VyLCB1cHBlciwgaW5jbHVkZUxvd2VyLCBpbmNsdWRlVXBwZXIpIHtcbiAgICAgICAgICAgIGluY2x1ZGVMb3dlciA9IGluY2x1ZGVMb3dlciAhPT0gZmFsc2U7XG4gICAgICAgICAgICBpbmNsdWRlVXBwZXIgPSBpbmNsdWRlVXBwZXIgPT09IHRydWU7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICgodGhpcy5fY21wKGxvd2VyLCB1cHBlcikgPiAwKSB8fFxuICAgICAgICAgICAgICAgICAgICAodGhpcy5fY21wKGxvd2VyLCB1cHBlcikgPT09IDAgJiYgKGluY2x1ZGVMb3dlciB8fCBpbmNsdWRlVXBwZXIpICYmICEoaW5jbHVkZUxvd2VyICYmIGluY2x1ZGVVcHBlcikpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZW1wdHlDb2xsZWN0aW9uKHRoaXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgdGhpcy5Db2xsZWN0aW9uKHRoaXMsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNyZWF0ZVJhbmdlKGxvd2VyLCB1cHBlciwgIWluY2x1ZGVMb3dlciwgIWluY2x1ZGVVcHBlcik7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFpbCh0aGlzLCBJTlZBTElEX0tFWV9BUkdVTUVOVCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFdoZXJlQ2xhdXNlLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWlsKHRoaXMsIElOVkFMSURfS0VZX0FSR1VNRU5UKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgdGhpcy5Db2xsZWN0aW9uKHRoaXMsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJhbmdlRXF1YWwodmFsdWUpOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgV2hlcmVDbGF1c2UucHJvdG90eXBlLmFib3ZlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFpbCh0aGlzLCBJTlZBTElEX0tFWV9BUkdVTUVOVCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHRoaXMuQ29sbGVjdGlvbih0aGlzLCBmdW5jdGlvbiAoKSB7IHJldHVybiBjcmVhdGVSYW5nZSh2YWx1ZSwgdW5kZWZpbmVkLCB0cnVlKTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIFdoZXJlQ2xhdXNlLnByb3RvdHlwZS5hYm92ZU9yRXF1YWwgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWlsKHRoaXMsIElOVkFMSURfS0VZX0FSR1VNRU5UKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgdGhpcy5Db2xsZWN0aW9uKHRoaXMsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNyZWF0ZVJhbmdlKHZhbHVlLCB1bmRlZmluZWQsIGZhbHNlKTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIFdoZXJlQ2xhdXNlLnByb3RvdHlwZS5iZWxvdyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhaWwodGhpcywgSU5WQUxJRF9LRVlfQVJHVU1FTlQpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyB0aGlzLkNvbGxlY3Rpb24odGhpcywgZnVuY3Rpb24gKCkgeyByZXR1cm4gY3JlYXRlUmFuZ2UodW5kZWZpbmVkLCB2YWx1ZSwgZmFsc2UsIHRydWUpOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgV2hlcmVDbGF1c2UucHJvdG90eXBlLmJlbG93T3JFcXVhbCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhaWwodGhpcywgSU5WQUxJRF9LRVlfQVJHVU1FTlQpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyB0aGlzLkNvbGxlY3Rpb24odGhpcywgZnVuY3Rpb24gKCkgeyByZXR1cm4gY3JlYXRlUmFuZ2UodW5kZWZpbmVkLCB2YWx1ZSk7IH0pO1xuICAgICAgICB9O1xuICAgICAgICBXaGVyZUNsYXVzZS5wcm90b3R5cGUuc3RhcnRzV2l0aCA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFpbCh0aGlzLCBTVFJJTkdfRVhQRUNURUQpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmV0d2VlbihzdHIsIHN0ciArIG1heFN0cmluZywgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIFdoZXJlQ2xhdXNlLnByb3RvdHlwZS5zdGFydHNXaXRoSWdub3JlQ2FzZSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgICAgIGlmIChzdHIgPT09IFwiXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRzV2l0aChzdHIpO1xuICAgICAgICAgICAgcmV0dXJuIGFkZElnbm9yZUNhc2VBbGdvcml0aG0odGhpcywgZnVuY3Rpb24gKHgsIGEpIHsgcmV0dXJuIHguaW5kZXhPZihhWzBdKSA9PT0gMDsgfSwgW3N0cl0sIG1heFN0cmluZyk7XG4gICAgICAgIH07XG4gICAgICAgIFdoZXJlQ2xhdXNlLnByb3RvdHlwZS5lcXVhbHNJZ25vcmVDYXNlID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICAgICAgcmV0dXJuIGFkZElnbm9yZUNhc2VBbGdvcml0aG0odGhpcywgZnVuY3Rpb24gKHgsIGEpIHsgcmV0dXJuIHggPT09IGFbMF07IH0sIFtzdHJdLCBcIlwiKTtcbiAgICAgICAgfTtcbiAgICAgICAgV2hlcmVDbGF1c2UucHJvdG90eXBlLmFueU9mSWdub3JlQ2FzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzZXQgPSBnZXRBcnJheU9mLmFwcGx5KE5PX0NIQVJfQVJSQVksIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBpZiAoc2V0Lmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gZW1wdHlDb2xsZWN0aW9uKHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIGFkZElnbm9yZUNhc2VBbGdvcml0aG0odGhpcywgZnVuY3Rpb24gKHgsIGEpIHsgcmV0dXJuIGEuaW5kZXhPZih4KSAhPT0gLTE7IH0sIHNldCwgXCJcIik7XG4gICAgICAgIH07XG4gICAgICAgIFdoZXJlQ2xhdXNlLnByb3RvdHlwZS5zdGFydHNXaXRoQW55T2ZJZ25vcmVDYXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHNldCA9IGdldEFycmF5T2YuYXBwbHkoTk9fQ0hBUl9BUlJBWSwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIGlmIChzZXQubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBlbXB0eUNvbGxlY3Rpb24odGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gYWRkSWdub3JlQ2FzZUFsZ29yaXRobSh0aGlzLCBmdW5jdGlvbiAoeCwgYSkgeyByZXR1cm4gYS5zb21lKGZ1bmN0aW9uIChuKSB7IHJldHVybiB4LmluZGV4T2YobikgPT09IDA7IH0pOyB9LCBzZXQsIG1heFN0cmluZyk7XG4gICAgICAgIH07XG4gICAgICAgIFdoZXJlQ2xhdXNlLnByb3RvdHlwZS5hbnlPZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgc2V0ID0gZ2V0QXJyYXlPZi5hcHBseShOT19DSEFSX0FSUkFZLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgdmFyIGNvbXBhcmUgPSB0aGlzLl9jbXA7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHNldC5zb3J0KGNvbXBhcmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFpbCh0aGlzLCBJTlZBTElEX0tFWV9BUkdVTUVOVCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2V0Lmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gZW1wdHlDb2xsZWN0aW9uKHRoaXMpO1xuICAgICAgICAgICAgdmFyIGMgPSBuZXcgdGhpcy5Db2xsZWN0aW9uKHRoaXMsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNyZWF0ZVJhbmdlKHNldFswXSwgc2V0W3NldC5sZW5ndGggLSAxXSk7IH0pO1xuICAgICAgICAgICAgYy5fb25kaXJlY3Rpb25jaGFuZ2UgPSBmdW5jdGlvbiAoZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgY29tcGFyZSA9IChkaXJlY3Rpb24gPT09IFwibmV4dFwiID9cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2FzY2VuZGluZyA6XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9kZXNjZW5kaW5nKTtcbiAgICAgICAgICAgICAgICBzZXQuc29ydChjb21wYXJlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgICBjLl9hZGRBbGdvcml0aG0oZnVuY3Rpb24gKGN1cnNvciwgYWR2YW5jZSwgcmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBjdXJzb3Iua2V5O1xuICAgICAgICAgICAgICAgIHdoaWxlIChjb21wYXJlKGtleSwgc2V0W2ldKSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgKytpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gc2V0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWR2YW5jZShyZXNvbHZlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY29tcGFyZShrZXksIHNldFtpXSkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhZHZhbmNlKGZ1bmN0aW9uICgpIHsgY3Vyc29yLmNvbnRpbnVlKHNldFtpXSk7IH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gYztcbiAgICAgICAgfTtcbiAgICAgICAgV2hlcmVDbGF1c2UucHJvdG90eXBlLm5vdEVxdWFsID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbkFueVJhbmdlKFtbbWluS2V5LCB2YWx1ZV0sIFt2YWx1ZSwgdGhpcy5kYi5fbWF4S2V5XV0sIHsgaW5jbHVkZUxvd2VyczogZmFsc2UsIGluY2x1ZGVVcHBlcnM6IGZhbHNlIH0pO1xuICAgICAgICB9O1xuICAgICAgICBXaGVyZUNsYXVzZS5wcm90b3R5cGUubm9uZU9mID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHNldCA9IGdldEFycmF5T2YuYXBwbHkoTk9fQ0hBUl9BUlJBWSwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIGlmIChzZXQubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgdGhpcy5Db2xsZWN0aW9uKHRoaXMpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzZXQuc29ydCh0aGlzLl9hc2NlbmRpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFpbCh0aGlzLCBJTlZBTElEX0tFWV9BUkdVTUVOVCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcmFuZ2VzID0gc2V0LnJlZHVjZShmdW5jdGlvbiAocmVzLCB2YWwpIHsgcmV0dXJuIHJlcyA/XG4gICAgICAgICAgICAgICAgcmVzLmNvbmNhdChbW3Jlc1tyZXMubGVuZ3RoIC0gMV1bMV0sIHZhbF1dKSA6XG4gICAgICAgICAgICAgICAgW1ttaW5LZXksIHZhbF1dOyB9LCBudWxsKTtcbiAgICAgICAgICAgIHJhbmdlcy5wdXNoKFtzZXRbc2V0Lmxlbmd0aCAtIDFdLCB0aGlzLmRiLl9tYXhLZXldKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmluQW55UmFuZ2UocmFuZ2VzLCB7IGluY2x1ZGVMb3dlcnM6IGZhbHNlLCBpbmNsdWRlVXBwZXJzOiBmYWxzZSB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgV2hlcmVDbGF1c2UucHJvdG90eXBlLmluQW55UmFuZ2UgPSBmdW5jdGlvbiAocmFuZ2VzLCBvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGNtcCA9IHRoaXMuX2NtcCwgYXNjZW5kaW5nID0gdGhpcy5fYXNjZW5kaW5nLCBkZXNjZW5kaW5nID0gdGhpcy5fZGVzY2VuZGluZywgbWluID0gdGhpcy5fbWluLCBtYXggPSB0aGlzLl9tYXg7XG4gICAgICAgICAgICBpZiAocmFuZ2VzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gZW1wdHlDb2xsZWN0aW9uKHRoaXMpO1xuICAgICAgICAgICAgaWYgKCFyYW5nZXMuZXZlcnkoZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJhbmdlWzBdICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2VbMV0gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICAgICBhc2NlbmRpbmcocmFuZ2VbMF0sIHJhbmdlWzFdKSA8PSAwO1xuICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFpbCh0aGlzLCBcIkZpcnN0IGFyZ3VtZW50IHRvIGluQW55UmFuZ2UoKSBtdXN0IGJlIGFuIEFycmF5IG9mIHR3by12YWx1ZSBBcnJheXMgW2xvd2VyLHVwcGVyXSB3aGVyZSB1cHBlciBtdXN0IG5vdCBiZSBsb3dlciB0aGFuIGxvd2VyXCIsIGV4Y2VwdGlvbnMuSW52YWxpZEFyZ3VtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBpbmNsdWRlTG93ZXJzID0gIW9wdGlvbnMgfHwgb3B0aW9ucy5pbmNsdWRlTG93ZXJzICE9PSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBpbmNsdWRlVXBwZXJzID0gb3B0aW9ucyAmJiBvcHRpb25zLmluY2x1ZGVVcHBlcnMgPT09IHRydWU7XG4gICAgICAgICAgICBmdW5jdGlvbiBhZGRSYW5nZShyYW5nZXMsIG5ld1JhbmdlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSAwLCBsID0gcmFuZ2VzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSByYW5nZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChjbXAobmV3UmFuZ2VbMF0sIHJhbmdlWzFdKSA8IDAgJiYgY21wKG5ld1JhbmdlWzFdLCByYW5nZVswXSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZVswXSA9IG1pbihyYW5nZVswXSwgbmV3UmFuZ2VbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2VbMV0gPSBtYXgocmFuZ2VbMV0sIG5ld1JhbmdlWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpID09PSBsKVxuICAgICAgICAgICAgICAgICAgICByYW5nZXMucHVzaChuZXdSYW5nZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJhbmdlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzb3J0RGlyZWN0aW9uID0gYXNjZW5kaW5nO1xuICAgICAgICAgICAgZnVuY3Rpb24gcmFuZ2VTb3J0ZXIoYSwgYikgeyByZXR1cm4gc29ydERpcmVjdGlvbihhWzBdLCBiWzBdKTsgfVxuICAgICAgICAgICAgdmFyIHNldDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgc2V0ID0gcmFuZ2VzLnJlZHVjZShhZGRSYW5nZSwgW10pO1xuICAgICAgICAgICAgICAgIHNldC5zb3J0KHJhbmdlU29ydGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChleCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWlsKHRoaXMsIElOVkFMSURfS0VZX0FSR1VNRU5UKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByYW5nZVBvcyA9IDA7XG4gICAgICAgICAgICB2YXIga2V5SXNCZXlvbmRDdXJyZW50RW50cnkgPSBpbmNsdWRlVXBwZXJzID9cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBhc2NlbmRpbmcoa2V5LCBzZXRbcmFuZ2VQb3NdWzFdKSA+IDA7IH0gOlxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGFzY2VuZGluZyhrZXksIHNldFtyYW5nZVBvc11bMV0pID49IDA7IH07XG4gICAgICAgICAgICB2YXIga2V5SXNCZWZvcmVDdXJyZW50RW50cnkgPSBpbmNsdWRlTG93ZXJzID9cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBkZXNjZW5kaW5nKGtleSwgc2V0W3JhbmdlUG9zXVswXSkgPiAwOyB9IDpcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBkZXNjZW5kaW5nKGtleSwgc2V0W3JhbmdlUG9zXVswXSkgPj0gMDsgfTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGtleVdpdGhpbkN1cnJlbnRSYW5nZShrZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIWtleUlzQmV5b25kQ3VycmVudEVudHJ5KGtleSkgJiYgIWtleUlzQmVmb3JlQ3VycmVudEVudHJ5KGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY2hlY2tLZXkgPSBrZXlJc0JleW9uZEN1cnJlbnRFbnRyeTtcbiAgICAgICAgICAgIHZhciBjID0gbmV3IHRoaXMuQ29sbGVjdGlvbih0aGlzLCBmdW5jdGlvbiAoKSB7IHJldHVybiBjcmVhdGVSYW5nZShzZXRbMF1bMF0sIHNldFtzZXQubGVuZ3RoIC0gMV1bMV0sICFpbmNsdWRlTG93ZXJzLCAhaW5jbHVkZVVwcGVycyk7IH0pO1xuICAgICAgICAgICAgYy5fb25kaXJlY3Rpb25jaGFuZ2UgPSBmdW5jdGlvbiAoZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tLZXkgPSBrZXlJc0JleW9uZEN1cnJlbnRFbnRyeTtcbiAgICAgICAgICAgICAgICAgICAgc29ydERpcmVjdGlvbiA9IGFzY2VuZGluZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNoZWNrS2V5ID0ga2V5SXNCZWZvcmVDdXJyZW50RW50cnk7XG4gICAgICAgICAgICAgICAgICAgIHNvcnREaXJlY3Rpb24gPSBkZXNjZW5kaW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZXQuc29ydChyYW5nZVNvcnRlcik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYy5fYWRkQWxnb3JpdGhtKGZ1bmN0aW9uIChjdXJzb3IsIGFkdmFuY2UsIHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gY3Vyc29yLmtleTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoY2hlY2tLZXkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICArK3JhbmdlUG9zO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmFuZ2VQb3MgPT09IHNldC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkdmFuY2UocmVzb2x2ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGtleVdpdGhpbkN1cnJlbnRSYW5nZShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChfdGhpcy5fY21wKGtleSwgc2V0W3JhbmdlUG9zXVsxXSkgPT09IDAgfHwgX3RoaXMuX2NtcChrZXksIHNldFtyYW5nZVBvc11bMF0pID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFkdmFuY2UoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNvcnREaXJlY3Rpb24gPT09IGFzY2VuZGluZylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuY29udGludWUoc2V0W3JhbmdlUG9zXVswXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLmNvbnRpbnVlKHNldFtyYW5nZVBvc11bMV0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGM7XG4gICAgICAgIH07XG4gICAgICAgIFdoZXJlQ2xhdXNlLnByb3RvdHlwZS5zdGFydHNXaXRoQW55T2YgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc2V0ID0gZ2V0QXJyYXlPZi5hcHBseShOT19DSEFSX0FSUkFZLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgaWYgKCFzZXQuZXZlcnkoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHR5cGVvZiBzID09PSAnc3RyaW5nJzsgfSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFpbCh0aGlzLCBcInN0YXJ0c1dpdGhBbnlPZigpIG9ubHkgd29ya3Mgd2l0aCBzdHJpbmdzXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNldC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVtcHR5Q29sbGVjdGlvbih0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmluQW55UmFuZ2Uoc2V0Lm1hcChmdW5jdGlvbiAoc3RyKSB7IHJldHVybiBbc3RyLCBzdHIgKyBtYXhTdHJpbmddOyB9KSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBXaGVyZUNsYXVzZTtcbiAgICB9KCkpO1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlV2hlcmVDbGF1c2VDb25zdHJ1Y3RvcihkYikge1xuICAgICAgICByZXR1cm4gbWFrZUNsYXNzQ29uc3RydWN0b3IoV2hlcmVDbGF1c2UucHJvdG90eXBlLCBmdW5jdGlvbiBXaGVyZUNsYXVzZSh0YWJsZSwgaW5kZXgsIG9yQ29sbGVjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5kYiA9IGRiO1xuICAgICAgICAgICAgdGhpcy5fY3R4ID0ge1xuICAgICAgICAgICAgICAgIHRhYmxlOiB0YWJsZSxcbiAgICAgICAgICAgICAgICBpbmRleDogaW5kZXggPT09IFwiOmlkXCIgPyBudWxsIDogaW5kZXgsXG4gICAgICAgICAgICAgICAgb3I6IG9yQ29sbGVjdGlvblxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuX2NtcCA9IHRoaXMuX2FzY2VuZGluZyA9IGNtcDtcbiAgICAgICAgICAgIHRoaXMuX2Rlc2NlbmRpbmcgPSBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gY21wKGIsIGEpOyB9O1xuICAgICAgICAgICAgdGhpcy5fbWF4ID0gZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGNtcChhLCBiKSA+IDAgPyBhIDogYjsgfTtcbiAgICAgICAgICAgIHRoaXMuX21pbiA9IGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBjbXAoYSwgYikgPCAwID8gYSA6IGI7IH07XG4gICAgICAgICAgICB0aGlzLl9JREJLZXlSYW5nZSA9IGRiLl9kZXBzLklEQktleVJhbmdlO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9JREJLZXlSYW5nZSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5NaXNzaW5nQVBJKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV2ZW50UmVqZWN0SGFuZGxlcihyZWplY3QpIHtcbiAgICAgICAgcmV0dXJuIHdyYXAoZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBwcmV2ZW50RGVmYXVsdChldmVudCk7XG4gICAgICAgICAgICByZWplY3QoZXZlbnQudGFyZ2V0LmVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC5zdG9wUHJvcGFnYXRpb24pXG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgaWYgKGV2ZW50LnByZXZlbnREZWZhdWx0KVxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG5cbiAgICB2YXIgREVYSUVfU1RPUkFHRV9NVVRBVEVEX0VWRU5UX05BTUUgPSAnc3RvcmFnZW11dGF0ZWQnO1xuICAgIHZhciBTVE9SQUdFX01VVEFURURfRE9NX0VWRU5UX05BTUUgPSAneC1zdG9yYWdlbXV0YXRlZC0xJztcbiAgICB2YXIgZ2xvYmFsRXZlbnRzID0gRXZlbnRzKG51bGwsIERFWElFX1NUT1JBR0VfTVVUQVRFRF9FVkVOVF9OQU1FKTtcblxuICAgIHZhciBUcmFuc2FjdGlvbiA9ICAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBUcmFuc2FjdGlvbigpIHtcbiAgICAgICAgfVxuICAgICAgICBUcmFuc2FjdGlvbi5wcm90b3R5cGUuX2xvY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBhc3NlcnQoIVBTRC5nbG9iYWwpO1xuICAgICAgICAgICAgKyt0aGlzLl9yZWN1bG9jaztcbiAgICAgICAgICAgIGlmICh0aGlzLl9yZWN1bG9jayA9PT0gMSAmJiAhUFNELmdsb2JhbClcbiAgICAgICAgICAgICAgICBQU0QubG9ja093bmVyRm9yID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICBUcmFuc2FjdGlvbi5wcm90b3R5cGUuX3VubG9jayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGFzc2VydCghUFNELmdsb2JhbCk7XG4gICAgICAgICAgICBpZiAoLS10aGlzLl9yZWN1bG9jayA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGlmICghUFNELmdsb2JhbClcbiAgICAgICAgICAgICAgICAgICAgUFNELmxvY2tPd25lckZvciA9IG51bGw7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHRoaXMuX2Jsb2NrZWRGdW5jcy5sZW5ndGggPiAwICYmICF0aGlzLl9sb2NrZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZm5BbmRQU0QgPSB0aGlzLl9ibG9ja2VkRnVuY3Muc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZVBTRChmbkFuZFBTRFsxXSwgZm5BbmRQU0RbMF0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgVHJhbnNhY3Rpb24ucHJvdG90eXBlLl9sb2NrZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVjdWxvY2sgJiYgUFNELmxvY2tPd25lckZvciAhPT0gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgVHJhbnNhY3Rpb24ucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uIChpZGJ0cmFucykge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIGlmICghdGhpcy5tb2RlKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgdmFyIGlkYmRiID0gdGhpcy5kYi5pZGJkYjtcbiAgICAgICAgICAgIHZhciBkYk9wZW5FcnJvciA9IHRoaXMuZGIuX3N0YXRlLmRiT3BlbkVycm9yO1xuICAgICAgICAgICAgYXNzZXJ0KCF0aGlzLmlkYnRyYW5zKTtcbiAgICAgICAgICAgIGlmICghaWRidHJhbnMgJiYgIWlkYmRiKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChkYk9wZW5FcnJvciAmJiBkYk9wZW5FcnJvci5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJEYXRhYmFzZUNsb3NlZEVycm9yXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5EYXRhYmFzZUNsb3NlZChkYk9wZW5FcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJNaXNzaW5nQVBJRXJyb3JcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLk1pc3NpbmdBUEkoZGJPcGVuRXJyb3IubWVzc2FnZSwgZGJPcGVuRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuT3BlbkZhaWxlZChkYk9wZW5FcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5UcmFuc2FjdGlvbkluYWN0aXZlKCk7XG4gICAgICAgICAgICBhc3NlcnQodGhpcy5fY29tcGxldGlvbi5fc3RhdGUgPT09IG51bGwpO1xuICAgICAgICAgICAgaWRidHJhbnMgPSB0aGlzLmlkYnRyYW5zID0gaWRidHJhbnMgfHxcbiAgICAgICAgICAgICAgICAodGhpcy5kYi5jb3JlXG4gICAgICAgICAgICAgICAgICAgID8gdGhpcy5kYi5jb3JlLnRyYW5zYWN0aW9uKHRoaXMuc3RvcmVOYW1lcywgdGhpcy5tb2RlLCB7IGR1cmFiaWxpdHk6IHRoaXMuY2hyb21lVHJhbnNhY3Rpb25EdXJhYmlsaXR5IH0pXG4gICAgICAgICAgICAgICAgICAgIDogaWRiZGIudHJhbnNhY3Rpb24odGhpcy5zdG9yZU5hbWVzLCB0aGlzLm1vZGUsIHsgZHVyYWJpbGl0eTogdGhpcy5jaHJvbWVUcmFuc2FjdGlvbkR1cmFiaWxpdHkgfSkpO1xuICAgICAgICAgICAgaWRidHJhbnMub25lcnJvciA9IHdyYXAoZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICAgICAgcHJldmVudERlZmF1bHQoZXYpO1xuICAgICAgICAgICAgICAgIF90aGlzLl9yZWplY3QoaWRidHJhbnMuZXJyb3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZGJ0cmFucy5vbmFib3J0ID0gd3JhcChmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdChldik7XG4gICAgICAgICAgICAgICAgX3RoaXMuYWN0aXZlICYmIF90aGlzLl9yZWplY3QobmV3IGV4Y2VwdGlvbnMuQWJvcnQoaWRidHJhbnMuZXJyb3IpKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBfdGhpcy5vbihcImFib3J0XCIpLmZpcmUoZXYpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZGJ0cmFucy5vbmNvbXBsZXRlID0gd3JhcChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3Jlc29sdmUoKTtcbiAgICAgICAgICAgICAgICBpZiAoJ211dGF0ZWRQYXJ0cycgaW4gaWRidHJhbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2xvYmFsRXZlbnRzLnN0b3JhZ2VtdXRhdGVkLmZpcmUoaWRidHJhbnNbXCJtdXRhdGVkUGFydHNcIl0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIFRyYW5zYWN0aW9uLnByb3RvdHlwZS5fcHJvbWlzZSA9IGZ1bmN0aW9uIChtb2RlLCBmbiwgYldyaXRlTG9jaykge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIGlmIChtb2RlID09PSAncmVhZHdyaXRlJyAmJiB0aGlzLm1vZGUgIT09ICdyZWFkd3JpdGUnKVxuICAgICAgICAgICAgICAgIHJldHVybiByZWplY3Rpb24obmV3IGV4Y2VwdGlvbnMuUmVhZE9ubHkoXCJUcmFuc2FjdGlvbiBpcyByZWFkb25seVwiKSk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuYWN0aXZlKVxuICAgICAgICAgICAgICAgIHJldHVybiByZWplY3Rpb24obmV3IGV4Y2VwdGlvbnMuVHJhbnNhY3Rpb25JbmFjdGl2ZSgpKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9sb2NrZWQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGV4aWVQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2Jsb2NrZWRGdW5jcy5wdXNoKFtmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3Byb21pc2UobW9kZSwgZm4sIGJXcml0ZUxvY2spLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIFBTRF0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYldyaXRlTG9jaykge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXdTY29wZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwID0gbmV3IERleGllUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fbG9jaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJ2ID0gZm4ocmVzb2x2ZSwgcmVqZWN0LCBfdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocnYgJiYgcnYudGhlbilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBydi50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBwLmZpbmFsbHkoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX3VubG9jaygpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgcC5fbGliID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgcCA9IG5ldyBEZXhpZVByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcnYgPSBmbihyZXNvbHZlLCByZWplY3QsIF90aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJ2ICYmIHJ2LnRoZW4pXG4gICAgICAgICAgICAgICAgICAgICAgICBydi50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcC5fbGliID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgVHJhbnNhY3Rpb24ucHJvdG90eXBlLl9yb290ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50ID8gdGhpcy5wYXJlbnQuX3Jvb3QoKSA6IHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIFRyYW5zYWN0aW9uLnByb3RvdHlwZS53YWl0Rm9yID0gZnVuY3Rpb24gKHByb21pc2VMaWtlKSB7XG4gICAgICAgICAgICB2YXIgcm9vdCA9IHRoaXMuX3Jvb3QoKTtcbiAgICAgICAgICAgIHZhciBwcm9taXNlID0gRGV4aWVQcm9taXNlLnJlc29sdmUocHJvbWlzZUxpa2UpO1xuICAgICAgICAgICAgaWYgKHJvb3QuX3dhaXRpbmdGb3IpIHtcbiAgICAgICAgICAgICAgICByb290Ll93YWl0aW5nRm9yID0gcm9vdC5fd2FpdGluZ0Zvci50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb21pc2U7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcm9vdC5fd2FpdGluZ0ZvciA9IHByb21pc2U7XG4gICAgICAgICAgICAgICAgcm9vdC5fd2FpdGluZ1F1ZXVlID0gW107XG4gICAgICAgICAgICAgICAgdmFyIHN0b3JlID0gcm9vdC5pZGJ0cmFucy5vYmplY3RTdG9yZShyb290LnN0b3JlTmFtZXNbMF0pO1xuICAgICAgICAgICAgICAgIChmdW5jdGlvbiBzcGluKCkge1xuICAgICAgICAgICAgICAgICAgICArK3Jvb3QuX3NwaW5Db3VudDtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHJvb3QuX3dhaXRpbmdRdWV1ZS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICAocm9vdC5fd2FpdGluZ1F1ZXVlLnNoaWZ0KCkpKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyb290Ll93YWl0aW5nRm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmUuZ2V0KC1JbmZpbml0eSkub25zdWNjZXNzID0gc3BpbjtcbiAgICAgICAgICAgICAgICB9KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGN1cnJlbnRXYWl0UHJvbWlzZSA9IHJvb3QuX3dhaXRpbmdGb3I7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERleGllUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uIChyZXMpIHsgcmV0dXJuIHJvb3QuX3dhaXRpbmdRdWV1ZS5wdXNoKHdyYXAocmVzb2x2ZS5iaW5kKG51bGwsIHJlcykpKTsgfSwgZnVuY3Rpb24gKGVycikgeyByZXR1cm4gcm9vdC5fd2FpdGluZ1F1ZXVlLnB1c2god3JhcChyZWplY3QuYmluZChudWxsLCBlcnIpKSk7IH0pLmZpbmFsbHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocm9vdC5fd2FpdGluZ0ZvciA9PT0gY3VycmVudFdhaXRQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByb290Ll93YWl0aW5nRm9yID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIFRyYW5zYWN0aW9uLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaWRidHJhbnMpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaWRidHJhbnMuYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWplY3QobmV3IGV4Y2VwdGlvbnMuQWJvcnQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFRyYW5zYWN0aW9uLnByb3RvdHlwZS50YWJsZSA9IGZ1bmN0aW9uICh0YWJsZU5hbWUpIHtcbiAgICAgICAgICAgIHZhciBtZW1vaXplZFRhYmxlcyA9ICh0aGlzLl9tZW1vaXplZFRhYmxlcyB8fCAodGhpcy5fbWVtb2l6ZWRUYWJsZXMgPSB7fSkpO1xuICAgICAgICAgICAgaWYgKGhhc093bihtZW1vaXplZFRhYmxlcywgdGFibGVOYW1lKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVtb2l6ZWRUYWJsZXNbdGFibGVOYW1lXTtcbiAgICAgICAgICAgIHZhciB0YWJsZVNjaGVtYSA9IHRoaXMuc2NoZW1hW3RhYmxlTmFtZV07XG4gICAgICAgICAgICBpZiAoIXRhYmxlU2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuTm90Rm91bmQoXCJUYWJsZSBcIiArIHRhYmxlTmFtZSArIFwiIG5vdCBwYXJ0IG9mIHRyYW5zYWN0aW9uXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHRyYW5zYWN0aW9uQm91bmRUYWJsZSA9IG5ldyB0aGlzLmRiLlRhYmxlKHRhYmxlTmFtZSwgdGFibGVTY2hlbWEsIHRoaXMpO1xuICAgICAgICAgICAgdHJhbnNhY3Rpb25Cb3VuZFRhYmxlLmNvcmUgPSB0aGlzLmRiLmNvcmUudGFibGUodGFibGVOYW1lKTtcbiAgICAgICAgICAgIG1lbW9pemVkVGFibGVzW3RhYmxlTmFtZV0gPSB0cmFuc2FjdGlvbkJvdW5kVGFibGU7XG4gICAgICAgICAgICByZXR1cm4gdHJhbnNhY3Rpb25Cb3VuZFRhYmxlO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gVHJhbnNhY3Rpb247XG4gICAgfSgpKTtcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVRyYW5zYWN0aW9uQ29uc3RydWN0b3IoZGIpIHtcbiAgICAgICAgcmV0dXJuIG1ha2VDbGFzc0NvbnN0cnVjdG9yKFRyYW5zYWN0aW9uLnByb3RvdHlwZSwgZnVuY3Rpb24gVHJhbnNhY3Rpb24obW9kZSwgc3RvcmVOYW1lcywgZGJzY2hlbWEsIGNocm9tZVRyYW5zYWN0aW9uRHVyYWJpbGl0eSwgcGFyZW50KSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKG1vZGUgIT09ICdyZWFkb25seScpXG4gICAgICAgICAgICAgICAgc3RvcmVOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChzdG9yZU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICB2YXIgeVByb3BzID0gKF9hID0gZGJzY2hlbWFbc3RvcmVOYW1lXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnlQcm9wcztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHlQcm9wcylcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlTmFtZXMgPSBzdG9yZU5hbWVzLmNvbmNhdCh5UHJvcHMubWFwKGZ1bmN0aW9uIChwKSB7IHJldHVybiBwLnVwZGF0ZXNUYWJsZTsgfSkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5kYiA9IGRiO1xuICAgICAgICAgICAgdGhpcy5tb2RlID0gbW9kZTtcbiAgICAgICAgICAgIHRoaXMuc3RvcmVOYW1lcyA9IHN0b3JlTmFtZXM7XG4gICAgICAgICAgICB0aGlzLnNjaGVtYSA9IGRic2NoZW1hO1xuICAgICAgICAgICAgdGhpcy5jaHJvbWVUcmFuc2FjdGlvbkR1cmFiaWxpdHkgPSBjaHJvbWVUcmFuc2FjdGlvbkR1cmFiaWxpdHk7XG4gICAgICAgICAgICB0aGlzLmlkYnRyYW5zID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMub24gPSBFdmVudHModGhpcywgXCJjb21wbGV0ZVwiLCBcImVycm9yXCIsIFwiYWJvcnRcIik7XG4gICAgICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudCB8fCBudWxsO1xuICAgICAgICAgICAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fcmVjdWxvY2sgPSAwO1xuICAgICAgICAgICAgdGhpcy5fYmxvY2tlZEZ1bmNzID0gW107XG4gICAgICAgICAgICB0aGlzLl9yZXNvbHZlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX3JlamVjdCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl93YWl0aW5nRm9yID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX3dhaXRpbmdRdWV1ZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9zcGluQ291bnQgPSAwO1xuICAgICAgICAgICAgdGhpcy5fY29tcGxldGlvbiA9IG5ldyBEZXhpZVByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgICAgICAgICBfdGhpcy5fcmVqZWN0ID0gcmVqZWN0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLl9jb21wbGV0aW9uLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIF90aGlzLm9uLmNvbXBsZXRlLmZpcmUoKTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHdhc0FjdGl2ZSA9IF90aGlzLmFjdGl2ZTtcbiAgICAgICAgICAgICAgICBfdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBfdGhpcy5vbi5lcnJvci5maXJlKGUpO1xuICAgICAgICAgICAgICAgIF90aGlzLnBhcmVudCA/XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnBhcmVudC5fcmVqZWN0KGUpIDpcbiAgICAgICAgICAgICAgICAgICAgd2FzQWN0aXZlICYmIF90aGlzLmlkYnRyYW5zICYmIF90aGlzLmlkYnRyYW5zLmFib3J0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdGlvbihlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVJbmRleFNwZWMobmFtZSwga2V5UGF0aCwgdW5pcXVlLCBtdWx0aSwgYXV0bywgY29tcG91bmQsIGlzUHJpbUtleSwgdHlwZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgIGtleVBhdGg6IGtleVBhdGgsXG4gICAgICAgICAgICB1bmlxdWU6IHVuaXF1ZSxcbiAgICAgICAgICAgIG11bHRpOiBtdWx0aSxcbiAgICAgICAgICAgIGF1dG86IGF1dG8sXG4gICAgICAgICAgICBjb21wb3VuZDogY29tcG91bmQsXG4gICAgICAgICAgICBzcmM6ICh1bmlxdWUgJiYgIWlzUHJpbUtleSA/ICcmJyA6ICcnKSArIChtdWx0aSA/ICcqJyA6ICcnKSArIChhdXRvID8gXCIrK1wiIDogXCJcIikgKyBuYW1lRnJvbUtleVBhdGgoa2V5UGF0aCksXG4gICAgICAgICAgICB0eXBlOiB0eXBlXG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5hbWVGcm9tS2V5UGF0aChrZXlQYXRoKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2Yga2V5UGF0aCA9PT0gJ3N0cmluZycgP1xuICAgICAgICAgICAga2V5UGF0aCA6XG4gICAgICAgICAgICBrZXlQYXRoID8gKCdbJyArIFtdLmpvaW4uY2FsbChrZXlQYXRoLCAnKycpICsgJ10nKSA6IFwiXCI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlVGFibGVTY2hlbWEobmFtZSwgcHJpbUtleSwgaW5kZXhlcykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgIHByaW1LZXk6IHByaW1LZXksXG4gICAgICAgICAgICBpbmRleGVzOiBpbmRleGVzLFxuICAgICAgICAgICAgbWFwcGVkQ2xhc3M6IG51bGwsXG4gICAgICAgICAgICBpZHhCeU5hbWU6IGFycmF5VG9PYmplY3QoaW5kZXhlcywgZnVuY3Rpb24gKGluZGV4KSB7IHJldHVybiBbaW5kZXgubmFtZSwgaW5kZXhdOyB9KSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzYWZhcmlNdWx0aVN0b3JlRml4KHN0b3JlTmFtZXMpIHtcbiAgICAgICAgcmV0dXJuIHN0b3JlTmFtZXMubGVuZ3RoID09PSAxID8gc3RvcmVOYW1lc1swXSA6IHN0b3JlTmFtZXM7XG4gICAgfVxuICAgIHZhciBnZXRNYXhLZXkgPSBmdW5jdGlvbiAoSWRiS2V5UmFuZ2UpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIElkYktleVJhbmdlLm9ubHkoW1tdXSk7XG4gICAgICAgICAgICBnZXRNYXhLZXkgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbW11dOyB9O1xuICAgICAgICAgICAgcmV0dXJuIFtbXV07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGdldE1heEtleSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1heFN0cmluZzsgfTtcbiAgICAgICAgICAgIHJldHVybiBtYXhTdHJpbmc7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZ2V0S2V5RXh0cmFjdG9yKGtleVBhdGgpIHtcbiAgICAgICAgaWYgKGtleVBhdGggPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2Yga2V5UGF0aCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRTaW5nbGVQYXRoS2V5RXh0cmFjdG9yKGtleVBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIGdldEJ5S2V5UGF0aChvYmosIGtleVBhdGgpOyB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFNpbmdsZVBhdGhLZXlFeHRyYWN0b3Ioa2V5UGF0aCkge1xuICAgICAgICB2YXIgc3BsaXQgPSBrZXlQYXRoLnNwbGl0KCcuJyk7XG4gICAgICAgIGlmIChzcGxpdC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmpba2V5UGF0aF07IH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gZ2V0QnlLZXlQYXRoKG9iaiwga2V5UGF0aCk7IH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcnJheWlmeShhcnJheUxpa2UpIHtcbiAgICAgICAgcmV0dXJuIFtdLnNsaWNlLmNhbGwoYXJyYXlMaWtlKTtcbiAgICB9XG4gICAgdmFyIF9pZF9jb3VudGVyID0gMDtcbiAgICBmdW5jdGlvbiBnZXRLZXlQYXRoQWxpYXMoa2V5UGF0aCkge1xuICAgICAgICByZXR1cm4ga2V5UGF0aCA9PSBudWxsID9cbiAgICAgICAgICAgIFwiOmlkXCIgOlxuICAgICAgICAgICAgdHlwZW9mIGtleVBhdGggPT09ICdzdHJpbmcnID9cbiAgICAgICAgICAgICAgICBrZXlQYXRoIDpcbiAgICAgICAgICAgICAgICBcIltcIi5jb25jYXQoa2V5UGF0aC5qb2luKCcrJyksIFwiXVwiKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlREJDb3JlKGRiLCBJZGJLZXlSYW5nZSwgdG1wVHJhbnMpIHtcbiAgICAgICAgZnVuY3Rpb24gZXh0cmFjdFNjaGVtYShkYiwgdHJhbnMpIHtcbiAgICAgICAgICAgIHZhciB0YWJsZXMgPSBhcnJheWlmeShkYi5vYmplY3RTdG9yZU5hbWVzKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc2NoZW1hOiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGRiLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHRhYmxlczogdGFibGVzLm1hcChmdW5jdGlvbiAodGFibGUpIHsgcmV0dXJuIHRyYW5zLm9iamVjdFN0b3JlKHRhYmxlKTsgfSkubWFwKGZ1bmN0aW9uIChzdG9yZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleVBhdGggPSBzdG9yZS5rZXlQYXRoLCBhdXRvSW5jcmVtZW50ID0gc3RvcmUuYXV0b0luY3JlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb21wb3VuZCA9IGlzQXJyYXkoa2V5UGF0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3V0Ym91bmQgPSBrZXlQYXRoID09IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXhCeUtleVBhdGggPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogc3RvcmUubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmltYXJ5S2V5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzUHJpbWFyeUtleTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0Ym91bmQ6IG91dGJvdW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb3VuZDogY29tcG91bmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleVBhdGg6IGtleVBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dG9JbmNyZW1lbnQ6IGF1dG9JbmNyZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuaXF1ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmFjdEtleTogZ2V0S2V5RXh0cmFjdG9yKGtleVBhdGgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleGVzOiBhcnJheWlmeShzdG9yZS5pbmRleE5hbWVzKS5tYXAoZnVuY3Rpb24gKGluZGV4TmFtZSkgeyByZXR1cm4gc3RvcmUuaW5kZXgoaW5kZXhOYW1lKTsgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBpbmRleC5uYW1lLCB1bmlxdWUgPSBpbmRleC51bmlxdWUsIG11bHRpRW50cnkgPSBpbmRleC5tdWx0aUVudHJ5LCBrZXlQYXRoID0gaW5kZXgua2V5UGF0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbXBvdW5kID0gaXNBcnJheShrZXlQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb3VuZDogY29tcG91bmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlQYXRoOiBrZXlQYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5pcXVlOiB1bmlxdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdWx0aUVudHJ5OiBtdWx0aUVudHJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmFjdEtleTogZ2V0S2V5RXh0cmFjdG9yKGtleVBhdGgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4QnlLZXlQYXRoW2dldEtleVBhdGhBbGlhcyhrZXlQYXRoKV0gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0SW5kZXhCeUtleVBhdGg6IGZ1bmN0aW9uIChrZXlQYXRoKSB7IHJldHVybiBpbmRleEJ5S2V5UGF0aFtnZXRLZXlQYXRoQWxpYXMoa2V5UGF0aCldOyB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXhCeUtleVBhdGhbXCI6aWRcIl0gPSByZXN1bHQucHJpbWFyeUtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXlQYXRoICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleEJ5S2V5UGF0aFtnZXRLZXlQYXRoQWxpYXMoa2V5UGF0aCldID0gcmVzdWx0LnByaW1hcnlLZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaGFzR2V0QWxsOiB0YWJsZXMubGVuZ3RoID4gMCAmJiAoJ2dldEFsbCcgaW4gdHJhbnMub2JqZWN0U3RvcmUodGFibGVzWzBdKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgISh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvU2FmYXJpLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhLyhDaHJvbWVcXC98RWRnZVxcLykvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIFtdLmNvbmNhdChuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9TYWZhcmlcXC8oXFxkKikvKSlbMV0gPCA2MDQpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG1ha2VJREJLZXlSYW5nZShyYW5nZSkge1xuICAgICAgICAgICAgaWYgKHJhbmdlLnR5cGUgPT09IDMgKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgaWYgKHJhbmdlLnR5cGUgPT09IDQgKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjb252ZXJ0IG5ldmVyIHR5cGUgdG8gSURCS2V5UmFuZ2VcIik7XG4gICAgICAgICAgICB2YXIgbG93ZXIgPSByYW5nZS5sb3dlciwgdXBwZXIgPSByYW5nZS51cHBlciwgbG93ZXJPcGVuID0gcmFuZ2UubG93ZXJPcGVuLCB1cHBlck9wZW4gPSByYW5nZS51cHBlck9wZW47XG4gICAgICAgICAgICB2YXIgaWRiUmFuZ2UgPSBsb3dlciA9PT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgICAgICB1cHBlciA9PT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgICAgICAgICAgbnVsbCA6XG4gICAgICAgICAgICAgICAgICAgIElkYktleVJhbmdlLnVwcGVyQm91bmQodXBwZXIsICEhdXBwZXJPcGVuKSA6XG4gICAgICAgICAgICAgICAgdXBwZXIgPT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICAgICAgICAgIElkYktleVJhbmdlLmxvd2VyQm91bmQobG93ZXIsICEhbG93ZXJPcGVuKSA6XG4gICAgICAgICAgICAgICAgICAgIElkYktleVJhbmdlLmJvdW5kKGxvd2VyLCB1cHBlciwgISFsb3dlck9wZW4sICEhdXBwZXJPcGVuKTtcbiAgICAgICAgICAgIHJldHVybiBpZGJSYW5nZTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjcmVhdGVEYkNvcmVUYWJsZSh0YWJsZVNjaGVtYSkge1xuICAgICAgICAgICAgdmFyIHRhYmxlTmFtZSA9IHRhYmxlU2NoZW1hLm5hbWU7XG4gICAgICAgICAgICBmdW5jdGlvbiBtdXRhdGUoX2EpIHtcbiAgICAgICAgICAgICAgICB2YXIgdHJhbnMgPSBfYS50cmFucywgdHlwZSA9IF9hLnR5cGUsIGtleXMgPSBfYS5rZXlzLCB2YWx1ZXMgPSBfYS52YWx1ZXMsIHJhbmdlID0gX2EucmFuZ2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSA9IHdyYXAocmVzb2x2ZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdG9yZSA9IHRyYW5zLm9iamVjdFN0b3JlKHRhYmxlTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvdXRib3VuZCA9IHN0b3JlLmtleVBhdGggPT0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlzQWRkT3JQdXQgPSB0eXBlID09PSBcInB1dFwiIHx8IHR5cGUgPT09IFwiYWRkXCI7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNBZGRPclB1dCAmJiB0eXBlICE9PSAnZGVsZXRlJyAmJiB0eXBlICE9PSAnZGVsZXRlUmFuZ2UnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBvcGVyYXRpb24gdHlwZTogXCIgKyB0eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxlbmd0aCA9IChrZXlzIHx8IHZhbHVlcyB8fCB7IGxlbmd0aDogMSB9KS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXlzICYmIHZhbHVlcyAmJiBrZXlzLmxlbmd0aCAhPT0gdmFsdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2l2ZW4ga2V5cyBhcnJheSBtdXN0IGhhdmUgc2FtZSBsZW5ndGggYXMgZ2l2ZW4gdmFsdWVzIGFycmF5LlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoeyBudW1GYWlsdXJlczogMCwgZmFpbHVyZXM6IHt9LCByZXN1bHRzOiBbXSwgbGFzdFJlc3VsdDogdW5kZWZpbmVkIH0pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVxO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVxcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZmFpbHVyZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG51bUZhaWx1cmVzID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9ySGFuZGxlciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgKytudW1GYWlsdXJlcztcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0KGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdkZWxldGVSYW5nZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyYW5nZS50eXBlID09PSA0IClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh7IG51bUZhaWx1cmVzOiBudW1GYWlsdXJlcywgZmFpbHVyZXM6IGZhaWx1cmVzLCByZXN1bHRzOiBbXSwgbGFzdFJlc3VsdDogdW5kZWZpbmVkIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlLnR5cGUgPT09IDMgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXMucHVzaChyZXEgPSBzdG9yZS5jbGVhcigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXFzLnB1c2gocmVxID0gc3RvcmUuZGVsZXRlKG1ha2VJREJLZXlSYW5nZShyYW5nZSkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYSA9IGlzQWRkT3JQdXQgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dGJvdW5kID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3ZhbHVlcywga2V5c10gOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbdmFsdWVzLCBudWxsXSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW2tleXMsIG51bGxdLCBhcmdzMSA9IF9hWzBdLCBhcmdzMiA9IF9hWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQWRkT3JQdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXMucHVzaChyZXEgPSAoYXJnczIgJiYgYXJnczJbaV0gIT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9yZVt0eXBlXShhcmdzMVtpXSwgYXJnczJbaV0pIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlW3R5cGVdKGFyZ3MxW2ldKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEub25lcnJvciA9IGVycm9ySGFuZGxlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXMucHVzaChyZXEgPSBzdG9yZVt0eXBlXShhcmdzMVtpXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEub25lcnJvciA9IGVycm9ySGFuZGxlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGRvbmUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsYXN0UmVzdWx0ID0gZXZlbnQudGFyZ2V0LnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXMuZm9yRWFjaChmdW5jdGlvbiAocmVxLCBpKSB7IHJldHVybiByZXEuZXJyb3IgIT0gbnVsbCAmJiAoZmFpbHVyZXNbaV0gPSByZXEuZXJyb3IpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bUZhaWx1cmVzOiBudW1GYWlsdXJlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWlsdXJlczogZmFpbHVyZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0czogdHlwZSA9PT0gXCJkZWxldGVcIiA/IGtleXMgOiByZXFzLm1hcChmdW5jdGlvbiAocmVxKSB7IHJldHVybiByZXEucmVzdWx0OyB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0UmVzdWx0OiBsYXN0UmVzdWx0XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ySGFuZGxlcihldmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb25lKGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IGRvbmU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBvcGVuQ3Vyc29yKF9hKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRyYW5zID0gX2EudHJhbnMsIHZhbHVlcyA9IF9hLnZhbHVlcywgcXVlcnkgPSBfYS5xdWVyeSwgcmV2ZXJzZSA9IF9hLnJldmVyc2UsIHVuaXF1ZSA9IF9hLnVuaXF1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlID0gd3JhcChyZXNvbHZlKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gcXVlcnkuaW5kZXgsIHJhbmdlID0gcXVlcnkucmFuZ2U7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdG9yZSA9IHRyYW5zLm9iamVjdFN0b3JlKHRhYmxlTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzb3VyY2UgPSBpbmRleC5pc1ByaW1hcnlLZXkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmUgOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmUuaW5kZXgoaW5kZXgubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkaXJlY3Rpb24gPSByZXZlcnNlID9cbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaXF1ZSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJwcmV2dW5pcXVlXCIgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwicHJldlwiIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaXF1ZSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJuZXh0dW5pcXVlXCIgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibmV4dFwiO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVxID0gdmFsdWVzIHx8ICEoJ29wZW5LZXlDdXJzb3InIGluIHNvdXJjZSkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlLm9wZW5DdXJzb3IobWFrZUlEQktleVJhbmdlKHJhbmdlKSwgZGlyZWN0aW9uKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2Uub3BlbktleUN1cnNvcihtYWtlSURCS2V5UmFuZ2UocmFuZ2UpLCBkaXJlY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICByZXEub25lcnJvciA9IGV2ZW50UmVqZWN0SGFuZGxlcihyZWplY3QpO1xuICAgICAgICAgICAgICAgICAgICByZXEub25zdWNjZXNzID0gd3JhcChmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJzb3IgPSByZXEucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjdXJzb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5fX19pZCA9ICsrX2lkX2NvdW50ZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9jdXJzb3JDb250aW51ZSA9IGN1cnNvci5jb250aW51ZS5iaW5kKGN1cnNvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2N1cnNvckNvbnRpbnVlUHJpbWFyeUtleSA9IGN1cnNvci5jb250aW51ZVByaW1hcnlLZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2N1cnNvckNvbnRpbnVlUHJpbWFyeUtleSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY3Vyc29yQ29udGludWVQcmltYXJ5S2V5ID0gX2N1cnNvckNvbnRpbnVlUHJpbWFyeUtleS5iaW5kKGN1cnNvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2N1cnNvckFkdmFuY2UgPSBjdXJzb3IuYWR2YW5jZS5iaW5kKGN1cnNvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZG9UaHJvd0N1cnNvcklzTm90U3RhcnRlZCA9IGZ1bmN0aW9uICgpIHsgdGhyb3cgbmV3IEVycm9yKFwiQ3Vyc29yIG5vdCBzdGFydGVkXCIpOyB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRvVGhyb3dDdXJzb3JJc1N0b3BwZWQgPSBmdW5jdGlvbiAoKSB7IHRocm93IG5ldyBFcnJvcihcIkN1cnNvciBub3Qgc3RvcHBlZFwiKTsgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci50cmFucyA9IHRyYW5zO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLnN0b3AgPSBjdXJzb3IuY29udGludWUgPSBjdXJzb3IuY29udGludWVQcmltYXJ5S2V5ID0gY3Vyc29yLmFkdmFuY2UgPSBkb1Rocm93Q3Vyc29ySXNOb3RTdGFydGVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLmZhaWwgPSB3cmFwKHJlamVjdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBnb3RPbmUgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXJ0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdvdE9uZS0tID8gX3RoaXMuY29udGludWUoKSA6IF90aGlzLnN0b3AoKTsgfSkudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpczsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLnN0YXJ0ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZXJhdGlvblByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZUl0ZXJhdGlvbiwgcmVqZWN0SXRlcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVJdGVyYXRpb24gPSB3cmFwKHJlc29sdmVJdGVyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEub25lcnJvciA9IGV2ZW50UmVqZWN0SGFuZGxlcihyZWplY3RJdGVyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuZmFpbCA9IHJlamVjdEl0ZXJhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLnN0b3AgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5zdG9wID0gY3Vyc29yLmNvbnRpbnVlID0gY3Vyc29yLmNvbnRpbnVlUHJpbWFyeUtleSA9IGN1cnNvci5hZHZhbmNlID0gZG9UaHJvd0N1cnNvcklzU3RvcHBlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVJdGVyYXRpb24odmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBndWFyZGVkQ2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXEucmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLmZhaWwoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5kb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5zdGFydCA9IGZ1bmN0aW9uICgpIHsgdGhyb3cgbmV3IEVycm9yKFwiQ3Vyc29yIGJlaGluZCBsYXN0IGVudHJ5XCIpOyB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IHdyYXAoZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSBndWFyZGVkQ2FsbGJhY2s7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGd1YXJkZWRDYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5jb250aW51ZSA9IF9jdXJzb3JDb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuY29udGludWVQcmltYXJ5S2V5ID0gX2N1cnNvckNvbnRpbnVlUHJpbWFyeUtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuYWR2YW5jZSA9IF9jdXJzb3JBZHZhbmNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGd1YXJkZWRDYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVyYXRpb25Qcm9taXNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoY3Vyc29yKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHF1ZXJ5KGhhc0dldEFsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAocmVxdWVzdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSA9IHdyYXAocmVzb2x2ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHJhbnMgPSByZXF1ZXN0LnRyYW5zLCB2YWx1ZXMgPSByZXF1ZXN0LnZhbHVlcywgbGltaXQgPSByZXF1ZXN0LmxpbWl0LCBxdWVyeSA9IHJlcXVlc3QucXVlcnk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm9uSW5maW5pdExpbWl0ID0gbGltaXQgPT09IEluZmluaXR5ID8gdW5kZWZpbmVkIDogbGltaXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBxdWVyeS5pbmRleCwgcmFuZ2UgPSBxdWVyeS5yYW5nZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdG9yZSA9IHRyYW5zLm9iamVjdFN0b3JlKHRhYmxlTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlID0gaW5kZXguaXNQcmltYXJ5S2V5ID8gc3RvcmUgOiBzdG9yZS5pbmRleChpbmRleC5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpZGJLZXlSYW5nZSA9IG1ha2VJREJLZXlSYW5nZShyYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGltaXQgPT09IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoeyByZXN1bHQ6IFtdIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc0dldEFsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXEgPSB2YWx1ZXMgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2UuZ2V0QWxsKGlkYktleVJhbmdlLCBub25JbmZpbml0TGltaXQpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlLmdldEFsbEtleXMoaWRiS2V5UmFuZ2UsIG5vbkluZmluaXRMaW1pdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IGZ1bmN0aW9uIChldmVudCkgeyByZXR1cm4gcmVzb2x2ZSh7IHJlc3VsdDogZXZlbnQudGFyZ2V0LnJlc3VsdCB9KTsgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEub25lcnJvciA9IGV2ZW50UmVqZWN0SGFuZGxlcihyZWplY3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvdW50XzEgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXFfMSA9IHZhbHVlcyB8fCAhKCdvcGVuS2V5Q3Vyc29yJyBpbiBzb3VyY2UpID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlLm9wZW5DdXJzb3IoaWRiS2V5UmFuZ2UpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlLm9wZW5LZXlDdXJzb3IoaWRiS2V5UmFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHRfMSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcV8xLm9uc3VjY2VzcyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3Vyc29yID0gcmVxXzEucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWN1cnNvcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHsgcmVzdWx0OiByZXN1bHRfMSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0XzEucHVzaCh2YWx1ZXMgPyBjdXJzb3IudmFsdWUgOiBjdXJzb3IucHJpbWFyeUtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgrK2NvdW50XzEgPT09IGxpbWl0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoeyByZXN1bHQ6IHJlc3VsdF8xIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuY29udGludWUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcV8xLm9uZXJyb3IgPSBldmVudFJlamVjdEhhbmRsZXIocmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbmFtZTogdGFibGVOYW1lLFxuICAgICAgICAgICAgICAgIHNjaGVtYTogdGFibGVTY2hlbWEsXG4gICAgICAgICAgICAgICAgbXV0YXRlOiBtdXRhdGUsXG4gICAgICAgICAgICAgICAgZ2V0TWFueTogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0cmFucyA9IF9hLnRyYW5zLCBrZXlzID0gX2Eua2V5cztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUgPSB3cmFwKHJlc29sdmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0b3JlID0gdHJhbnMub2JqZWN0U3RvcmUodGFibGVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXlDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2FsbGJhY2tDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVxO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN1Y2Nlc3NIYW5kbGVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlcSA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHJlc3VsdFtyZXEuX3Bvc10gPSByZXEucmVzdWx0KSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCsrY2FsbGJhY2tDb3VudCA9PT0ga2V5Q291bnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3JIYW5kbGVyID0gZXZlbnRSZWplY3RIYW5kbGVyKHJlamVjdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcSA9IHN0b3JlLmdldChrZXlzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLl9wb3MgPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEub25zdWNjZXNzID0gc3VjY2Vzc0hhbmRsZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5vbmVycm9yID0gZXJyb3JIYW5kbGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArK2tleUNvdW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXlDb3VudCA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRyYW5zID0gX2EudHJhbnMsIGtleSA9IF9hLmtleTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUgPSB3cmFwKHJlc29sdmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0b3JlID0gdHJhbnMub2JqZWN0U3RvcmUodGFibGVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXEgPSBzdG9yZS5nZXQoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoZXZlbnQpIHsgcmV0dXJuIHJlc29sdmUoZXZlbnQudGFyZ2V0LnJlc3VsdCk7IH07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXEub25lcnJvciA9IGV2ZW50UmVqZWN0SGFuZGxlcihyZWplY3QpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeShoYXNHZXRBbGwpLFxuICAgICAgICAgICAgICAgIG9wZW5DdXJzb3I6IG9wZW5DdXJzb3IsXG4gICAgICAgICAgICAgICAgY291bnQ6IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcXVlcnkgPSBfYS5xdWVyeSwgdHJhbnMgPSBfYS50cmFucztcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gcXVlcnkuaW5kZXgsIHJhbmdlID0gcXVlcnkucmFuZ2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RvcmUgPSB0cmFucy5vYmplY3RTdG9yZSh0YWJsZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGluZGV4LmlzUHJpbWFyeUtleSA/IHN0b3JlIDogc3RvcmUuaW5kZXgoaW5kZXgubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaWRiS2V5UmFuZ2UgPSBtYWtlSURCS2V5UmFuZ2UocmFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlcSA9IGlkYktleVJhbmdlID8gc291cmNlLmNvdW50KGlkYktleVJhbmdlKSA6IHNvdXJjZS5jb3VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IHdyYXAoZnVuY3Rpb24gKGV2KSB7IHJldHVybiByZXNvbHZlKGV2LnRhcmdldC5yZXN1bHQpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5vbmVycm9yID0gZXZlbnRSZWplY3RIYW5kbGVyKHJlamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9hID0gZXh0cmFjdFNjaGVtYShkYiwgdG1wVHJhbnMpLCBzY2hlbWEgPSBfYS5zY2hlbWEsIGhhc0dldEFsbCA9IF9hLmhhc0dldEFsbDtcbiAgICAgICAgdmFyIHRhYmxlcyA9IHNjaGVtYS50YWJsZXMubWFwKGZ1bmN0aW9uICh0YWJsZVNjaGVtYSkgeyByZXR1cm4gY3JlYXRlRGJDb3JlVGFibGUodGFibGVTY2hlbWEpOyB9KTtcbiAgICAgICAgdmFyIHRhYmxlTWFwID0ge307XG4gICAgICAgIHRhYmxlcy5mb3JFYWNoKGZ1bmN0aW9uICh0YWJsZSkgeyByZXR1cm4gdGFibGVNYXBbdGFibGUubmFtZV0gPSB0YWJsZTsgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGFjazogXCJkYmNvcmVcIixcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uOiBkYi50cmFuc2FjdGlvbi5iaW5kKGRiKSxcbiAgICAgICAgICAgIHRhYmxlOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB0YWJsZU1hcFtuYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGFibGUgJ1wiLmNvbmNhdChuYW1lLCBcIicgbm90IGZvdW5kXCIpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFibGVNYXBbbmFtZV07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgTUlOX0tFWTogLUluZmluaXR5LFxuICAgICAgICAgICAgTUFYX0tFWTogZ2V0TWF4S2V5KElkYktleVJhbmdlKSxcbiAgICAgICAgICAgIHNjaGVtYTogc2NoZW1hXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlTWlkZGxld2FyZVN0YWNrKHN0YWNrSW1wbCwgbWlkZGxld2FyZXMpIHtcbiAgICAgICAgcmV0dXJuIG1pZGRsZXdhcmVzLnJlZHVjZShmdW5jdGlvbiAoZG93biwgX2EpIHtcbiAgICAgICAgICAgIHZhciBjcmVhdGUgPSBfYS5jcmVhdGU7XG4gICAgICAgICAgICByZXR1cm4gKF9fYXNzaWduKF9fYXNzaWduKHt9LCBkb3duKSwgY3JlYXRlKGRvd24pKSk7XG4gICAgICAgIH0sIHN0YWNrSW1wbCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZU1pZGRsZXdhcmVTdGFja3MobWlkZGxld2FyZXMsIGlkYmRiLCBfYSwgdG1wVHJhbnMpIHtcbiAgICAgICAgdmFyIElEQktleVJhbmdlID0gX2EuSURCS2V5UmFuZ2U7IF9hLmluZGV4ZWREQjtcbiAgICAgICAgdmFyIGRiY29yZSA9IGNyZWF0ZU1pZGRsZXdhcmVTdGFjayhjcmVhdGVEQkNvcmUoaWRiZGIsIElEQktleVJhbmdlLCB0bXBUcmFucyksIG1pZGRsZXdhcmVzLmRiY29yZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYmNvcmU6IGRiY29yZVxuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZU1pZGRsZXdhcmVTdGFja3MoZGIsIHRtcFRyYW5zKSB7XG4gICAgICAgIHZhciBpZGJkYiA9IHRtcFRyYW5zLmRiO1xuICAgICAgICB2YXIgc3RhY2tzID0gY3JlYXRlTWlkZGxld2FyZVN0YWNrcyhkYi5fbWlkZGxld2FyZXMsIGlkYmRiLCBkYi5fZGVwcywgdG1wVHJhbnMpO1xuICAgICAgICBkYi5jb3JlID0gc3RhY2tzLmRiY29yZTtcbiAgICAgICAgZGIudGFibGVzLmZvckVhY2goZnVuY3Rpb24gKHRhYmxlKSB7XG4gICAgICAgICAgICB2YXIgdGFibGVOYW1lID0gdGFibGUubmFtZTtcbiAgICAgICAgICAgIGlmIChkYi5jb3JlLnNjaGVtYS50YWJsZXMuc29tZShmdW5jdGlvbiAodGJsKSB7IHJldHVybiB0YmwubmFtZSA9PT0gdGFibGVOYW1lOyB9KSkge1xuICAgICAgICAgICAgICAgIHRhYmxlLmNvcmUgPSBkYi5jb3JlLnRhYmxlKHRhYmxlTmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKGRiW3RhYmxlTmFtZV0gaW5zdGFuY2VvZiBkYi5UYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICBkYlt0YWJsZU5hbWVdLmNvcmUgPSB0YWJsZS5jb3JlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0QXBpT25QbGFjZShkYiwgb2JqcywgdGFibGVOYW1lcywgZGJzY2hlbWEpIHtcbiAgICAgICAgdGFibGVOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uICh0YWJsZU5hbWUpIHtcbiAgICAgICAgICAgIHZhciBzY2hlbWEgPSBkYnNjaGVtYVt0YWJsZU5hbWVdO1xuICAgICAgICAgICAgb2Jqcy5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvcERlc2MgPSBnZXRQcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCB0YWJsZU5hbWUpO1xuICAgICAgICAgICAgICAgIGlmICghcHJvcERlc2MgfHwgKFwidmFsdWVcIiBpbiBwcm9wRGVzYyAmJiBwcm9wRGVzYy52YWx1ZSA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob2JqID09PSBkYi5UcmFuc2FjdGlvbi5wcm90b3R5cGUgfHwgb2JqIGluc3RhbmNlb2YgZGIuVHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFByb3Aob2JqLCB0YWJsZU5hbWUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudGFibGUodGFibGVOYW1lKTsgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZpbmVQcm9wZXJ0eSh0aGlzLCB0YWJsZU5hbWUsIHsgdmFsdWU6IHZhbHVlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqW3RhYmxlTmFtZV0gPSBuZXcgZGIuVGFibGUodGFibGVOYW1lLCBzY2hlbWEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZW1vdmVUYWJsZXNBcGkoZGIsIG9ianMpIHtcbiAgICAgICAgb2Jqcy5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICBpZiAob2JqW2tleV0gaW5zdGFuY2VvZiBkYi5UYWJsZSlcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG9ialtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbG93ZXJWZXJzaW9uRmlyc3QoYSwgYikge1xuICAgICAgICByZXR1cm4gYS5fY2ZnLnZlcnNpb24gLSBiLl9jZmcudmVyc2lvbjtcbiAgICB9XG4gICAgZnVuY3Rpb24gcnVuVXBncmFkZXJzKGRiLCBvbGRWZXJzaW9uLCBpZGJVcGdyYWRlVHJhbnMsIHJlamVjdCkge1xuICAgICAgICB2YXIgZ2xvYmFsU2NoZW1hID0gZGIuX2RiU2NoZW1hO1xuICAgICAgICBpZiAoaWRiVXBncmFkZVRyYW5zLm9iamVjdFN0b3JlTmFtZXMuY29udGFpbnMoJyRtZXRhJykgJiYgIWdsb2JhbFNjaGVtYS4kbWV0YSkge1xuICAgICAgICAgICAgZ2xvYmFsU2NoZW1hLiRtZXRhID0gY3JlYXRlVGFibGVTY2hlbWEoXCIkbWV0YVwiLCBwYXJzZUluZGV4U3ludGF4KFwiXCIpWzBdLCBbXSk7XG4gICAgICAgICAgICBkYi5fc3RvcmVOYW1lcy5wdXNoKCckbWV0YScpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0cmFucyA9IGRiLl9jcmVhdGVUcmFuc2FjdGlvbigncmVhZHdyaXRlJywgZGIuX3N0b3JlTmFtZXMsIGdsb2JhbFNjaGVtYSk7XG4gICAgICAgIHRyYW5zLmNyZWF0ZShpZGJVcGdyYWRlVHJhbnMpO1xuICAgICAgICB0cmFucy5fY29tcGxldGlvbi5jYXRjaChyZWplY3QpO1xuICAgICAgICB2YXIgcmVqZWN0VHJhbnNhY3Rpb24gPSB0cmFucy5fcmVqZWN0LmJpbmQodHJhbnMpO1xuICAgICAgICB2YXIgdHJhbnNsZXNzID0gUFNELnRyYW5zbGVzcyB8fCBQU0Q7XG4gICAgICAgIG5ld1Njb3BlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIFBTRC50cmFucyA9IHRyYW5zO1xuICAgICAgICAgICAgUFNELnRyYW5zbGVzcyA9IHRyYW5zbGVzcztcbiAgICAgICAgICAgIGlmIChvbGRWZXJzaW9uID09PSAwKSB7XG4gICAgICAgICAgICAgICAga2V5cyhnbG9iYWxTY2hlbWEpLmZvckVhY2goZnVuY3Rpb24gKHRhYmxlTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBjcmVhdGVUYWJsZShpZGJVcGdyYWRlVHJhbnMsIHRhYmxlTmFtZSwgZ2xvYmFsU2NoZW1hW3RhYmxlTmFtZV0ucHJpbUtleSwgZ2xvYmFsU2NoZW1hW3RhYmxlTmFtZV0uaW5kZXhlcyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZ2VuZXJhdGVNaWRkbGV3YXJlU3RhY2tzKGRiLCBpZGJVcGdyYWRlVHJhbnMpO1xuICAgICAgICAgICAgICAgIERleGllUHJvbWlzZS5mb2xsb3coZnVuY3Rpb24gKCkgeyByZXR1cm4gZGIub24ucG9wdWxhdGUuZmlyZSh0cmFucyk7IH0pLmNhdGNoKHJlamVjdFRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGdlbmVyYXRlTWlkZGxld2FyZVN0YWNrcyhkYiwgaWRiVXBncmFkZVRyYW5zKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0RXhpc3RpbmdWZXJzaW9uKGRiLCB0cmFucywgb2xkVmVyc2lvbilcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKG9sZFZlcnNpb24pIHsgcmV0dXJuIHVwZGF0ZVRhYmxlc0FuZEluZGV4ZXMoZGIsIG9sZFZlcnNpb24sIHRyYW5zLCBpZGJVcGdyYWRlVHJhbnMpOyB9KVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2gocmVqZWN0VHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGF0Y2hDdXJyZW50VmVyc2lvbihkYiwgaWRiVXBncmFkZVRyYW5zKSB7XG4gICAgICAgIGNyZWF0ZU1pc3NpbmdUYWJsZXMoZGIuX2RiU2NoZW1hLCBpZGJVcGdyYWRlVHJhbnMpO1xuICAgICAgICBpZiAoaWRiVXBncmFkZVRyYW5zLmRiLnZlcnNpb24gJSAxMCA9PT0gMCAmJiAhaWRiVXBncmFkZVRyYW5zLm9iamVjdFN0b3JlTmFtZXMuY29udGFpbnMoJyRtZXRhJykpIHtcbiAgICAgICAgICAgIGlkYlVwZ3JhZGVUcmFucy5kYi5jcmVhdGVPYmplY3RTdG9yZSgnJG1ldGEnKS5hZGQoTWF0aC5jZWlsKChpZGJVcGdyYWRlVHJhbnMuZGIudmVyc2lvbiAvIDEwKSAtIDEpLCAndmVyc2lvbicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBnbG9iYWxTY2hlbWEgPSBidWlsZEdsb2JhbFNjaGVtYShkYiwgZGIuaWRiZGIsIGlkYlVwZ3JhZGVUcmFucyk7XG4gICAgICAgIGFkanVzdFRvRXhpc3RpbmdJbmRleE5hbWVzKGRiLCBkYi5fZGJTY2hlbWEsIGlkYlVwZ3JhZGVUcmFucyk7XG4gICAgICAgIHZhciBkaWZmID0gZ2V0U2NoZW1hRGlmZihnbG9iYWxTY2hlbWEsIGRiLl9kYlNjaGVtYSk7XG4gICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKHRhYmxlQ2hhbmdlKSB7XG4gICAgICAgICAgICBpZiAodGFibGVDaGFuZ2UuY2hhbmdlLmxlbmd0aCB8fCB0YWJsZUNoYW5nZS5yZWNyZWF0ZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlVuYWJsZSB0byBwYXRjaCBpbmRleGVzIG9mIHRhYmxlIFwiLmNvbmNhdCh0YWJsZUNoYW5nZS5uYW1lLCBcIiBiZWNhdXNlIGl0IGhhcyBjaGFuZ2VzIG9uIHRoZSB0eXBlIG9mIGluZGV4IG9yIHByaW1hcnkga2V5LlwiKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHZvaWQgMCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHN0b3JlID0gaWRiVXBncmFkZVRyYW5zLm9iamVjdFN0b3JlKHRhYmxlQ2hhbmdlLm5hbWUpO1xuICAgICAgICAgICAgdGFibGVDaGFuZ2UuYWRkLmZvckVhY2goZnVuY3Rpb24gKGlkeCkge1xuICAgICAgICAgICAgICAgIGlmIChkZWJ1ZylcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1ZyhcIkRleGllIHVwZ3JhZGUgcGF0Y2g6IENyZWF0aW5nIG1pc3NpbmcgaW5kZXggXCIuY29uY2F0KHRhYmxlQ2hhbmdlLm5hbWUsIFwiLlwiKS5jb25jYXQoaWR4LnNyYykpO1xuICAgICAgICAgICAgICAgIGFkZEluZGV4KHN0b3JlLCBpZHgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBkaWZmLmNoYW5nZTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciB0YWJsZUNoYW5nZSA9IF9hW19pXTtcbiAgICAgICAgICAgIHZhciBzdGF0ZV8xID0gX2xvb3BfMSh0YWJsZUNoYW5nZSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHN0YXRlXzEgPT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlXzEudmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0RXhpc3RpbmdWZXJzaW9uKGRiLCB0cmFucywgb2xkVmVyc2lvbikge1xuICAgICAgICBpZiAodHJhbnMuc3RvcmVOYW1lcy5pbmNsdWRlcygnJG1ldGEnKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRyYW5zLnRhYmxlKCckbWV0YScpLmdldCgndmVyc2lvbicpLnRoZW4oZnVuY3Rpb24gKG1ldGFWZXJzaW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ldGFWZXJzaW9uICE9IG51bGwgPyBtZXRhVmVyc2lvbiA6IG9sZFZlcnNpb247XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBEZXhpZVByb21pc2UucmVzb2x2ZShvbGRWZXJzaW9uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVUYWJsZXNBbmRJbmRleGVzKGRiLCBvbGRWZXJzaW9uLCB0cmFucywgaWRiVXBncmFkZVRyYW5zKSB7XG4gICAgICAgIHZhciBxdWV1ZSA9IFtdO1xuICAgICAgICB2YXIgdmVyc2lvbnMgPSBkYi5fdmVyc2lvbnM7XG4gICAgICAgIHZhciBnbG9iYWxTY2hlbWEgPSBkYi5fZGJTY2hlbWEgPSBidWlsZEdsb2JhbFNjaGVtYShkYiwgZGIuaWRiZGIsIGlkYlVwZ3JhZGVUcmFucyk7XG4gICAgICAgIHZhciB2ZXJzVG9SdW4gPSB2ZXJzaW9ucy5maWx0ZXIoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHYuX2NmZy52ZXJzaW9uID49IG9sZFZlcnNpb247IH0pO1xuICAgICAgICBpZiAodmVyc1RvUnVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIERleGllUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmVyc1RvUnVuLmZvckVhY2goZnVuY3Rpb24gKHZlcnNpb24pIHtcbiAgICAgICAgICAgIHF1ZXVlLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBvbGRTY2hlbWEgPSBnbG9iYWxTY2hlbWE7XG4gICAgICAgICAgICAgICAgdmFyIG5ld1NjaGVtYSA9IHZlcnNpb24uX2NmZy5kYnNjaGVtYTtcbiAgICAgICAgICAgICAgICBhZGp1c3RUb0V4aXN0aW5nSW5kZXhOYW1lcyhkYiwgb2xkU2NoZW1hLCBpZGJVcGdyYWRlVHJhbnMpO1xuICAgICAgICAgICAgICAgIGFkanVzdFRvRXhpc3RpbmdJbmRleE5hbWVzKGRiLCBuZXdTY2hlbWEsIGlkYlVwZ3JhZGVUcmFucyk7XG4gICAgICAgICAgICAgICAgZ2xvYmFsU2NoZW1hID0gZGIuX2RiU2NoZW1hID0gbmV3U2NoZW1hO1xuICAgICAgICAgICAgICAgIHZhciBkaWZmID0gZ2V0U2NoZW1hRGlmZihvbGRTY2hlbWEsIG5ld1NjaGVtYSk7XG4gICAgICAgICAgICAgICAgZGlmZi5hZGQuZm9yRWFjaChmdW5jdGlvbiAodHVwbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlVGFibGUoaWRiVXBncmFkZVRyYW5zLCB0dXBsZVswXSwgdHVwbGVbMV0ucHJpbUtleSwgdHVwbGVbMV0uaW5kZXhlcyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZGlmZi5jaGFuZ2UuZm9yRWFjaChmdW5jdGlvbiAoY2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFuZ2UucmVjcmVhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLlVwZ3JhZGUoXCJOb3QgeWV0IHN1cHBvcnQgZm9yIGNoYW5naW5nIHByaW1hcnkga2V5XCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0b3JlXzEgPSBpZGJVcGdyYWRlVHJhbnMub2JqZWN0U3RvcmUoY2hhbmdlLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlLmFkZC5mb3JFYWNoKGZ1bmN0aW9uIChpZHgpIHsgcmV0dXJuIGFkZEluZGV4KHN0b3JlXzEsIGlkeCk7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlLmNoYW5nZS5mb3JFYWNoKGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9yZV8xLmRlbGV0ZUluZGV4KGlkeC5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRJbmRleChzdG9yZV8xLCBpZHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2UuZGVsLmZvckVhY2goZnVuY3Rpb24gKGlkeE5hbWUpIHsgcmV0dXJuIHN0b3JlXzEuZGVsZXRlSW5kZXgoaWR4TmFtZSk7IH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRlbnRVcGdyYWRlID0gdmVyc2lvbi5fY2ZnLmNvbnRlbnRVcGdyYWRlO1xuICAgICAgICAgICAgICAgIGlmIChjb250ZW50VXBncmFkZSAmJiB2ZXJzaW9uLl9jZmcudmVyc2lvbiA+IG9sZFZlcnNpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVNaWRkbGV3YXJlU3RhY2tzKGRiLCBpZGJVcGdyYWRlVHJhbnMpO1xuICAgICAgICAgICAgICAgICAgICB0cmFucy5fbWVtb2l6ZWRUYWJsZXMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVwZ3JhZGVTY2hlbWFfMSA9IHNoYWxsb3dDbG9uZShuZXdTY2hlbWEpO1xuICAgICAgICAgICAgICAgICAgICBkaWZmLmRlbC5mb3JFYWNoKGZ1bmN0aW9uICh0YWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBncmFkZVNjaGVtYV8xW3RhYmxlXSA9IG9sZFNjaGVtYVt0YWJsZV07XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVUYWJsZXNBcGkoZGIsIFtkYi5UcmFuc2FjdGlvbi5wcm90b3R5cGVdKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0QXBpT25QbGFjZShkYiwgW2RiLlRyYW5zYWN0aW9uLnByb3RvdHlwZV0sIGtleXModXBncmFkZVNjaGVtYV8xKSwgdXBncmFkZVNjaGVtYV8xKTtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnMuc2NoZW1hID0gdXBncmFkZVNjaGVtYV8xO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGVudFVwZ3JhZGVJc0FzeW5jXzEgPSBpc0FzeW5jRnVuY3Rpb24oY29udGVudFVwZ3JhZGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGVudFVwZ3JhZGVJc0FzeW5jXzEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY3JlbWVudEV4cGVjdGVkQXdhaXRzKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIHJldHVyblZhbHVlXzE7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9taXNlRm9sbG93ZWQgPSBEZXhpZVByb21pc2UuZm9sbG93KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblZhbHVlXzEgPSBjb250ZW50VXBncmFkZSh0cmFucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmV0dXJuVmFsdWVfMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250ZW50VXBncmFkZUlzQXN5bmNfMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVjcmVtZW50b3IgPSBkZWNyZW1lbnRFeHBlY3RlZEF3YWl0cy5iaW5kKG51bGwsIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZV8xLnRoZW4oZGVjcmVtZW50b3IsIGRlY3JlbWVudG9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHJldHVyblZhbHVlXzEgJiYgdHlwZW9mIHJldHVyblZhbHVlXzEudGhlbiA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgICAgICAgICAgICAgICAgICBEZXhpZVByb21pc2UucmVzb2x2ZShyZXR1cm5WYWx1ZV8xKSA6IHByb21pc2VGb2xsb3dlZC50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJldHVyblZhbHVlXzE7IH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHF1ZXVlLnB1c2goZnVuY3Rpb24gKGlkYnRyYW5zKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld1NjaGVtYSA9IHZlcnNpb24uX2NmZy5kYnNjaGVtYTtcbiAgICAgICAgICAgICAgICBkZWxldGVSZW1vdmVkVGFibGVzKG5ld1NjaGVtYSwgaWRidHJhbnMpO1xuICAgICAgICAgICAgICAgIHJlbW92ZVRhYmxlc0FwaShkYiwgW2RiLlRyYW5zYWN0aW9uLnByb3RvdHlwZV0pO1xuICAgICAgICAgICAgICAgIHNldEFwaU9uUGxhY2UoZGIsIFtkYi5UcmFuc2FjdGlvbi5wcm90b3R5cGVdLCBkYi5fc3RvcmVOYW1lcywgZGIuX2RiU2NoZW1hKTtcbiAgICAgICAgICAgICAgICB0cmFucy5zY2hlbWEgPSBkYi5fZGJTY2hlbWE7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHF1ZXVlLnB1c2goZnVuY3Rpb24gKGlkYnRyYW5zKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRiLmlkYmRiLm9iamVjdFN0b3JlTmFtZXMuY29udGFpbnMoJyRtZXRhJykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGguY2VpbChkYi5pZGJkYi52ZXJzaW9uIC8gMTApID09PSB2ZXJzaW9uLl9jZmcudmVyc2lvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGIuaWRiZGIuZGVsZXRlT2JqZWN0U3RvcmUoJyRtZXRhJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgZGIuX2RiU2NoZW1hLiRtZXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGIuX3N0b3JlTmFtZXMgPSBkYi5fc3RvcmVOYW1lcy5maWx0ZXIoZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIG5hbWUgIT09ICckbWV0YSc7IH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWRidHJhbnMub2JqZWN0U3RvcmUoJyRtZXRhJykucHV0KHZlcnNpb24uX2NmZy52ZXJzaW9uLCAndmVyc2lvbicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBmdW5jdGlvbiBydW5RdWV1ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBxdWV1ZS5sZW5ndGggPyBEZXhpZVByb21pc2UucmVzb2x2ZShxdWV1ZS5zaGlmdCgpKHRyYW5zLmlkYnRyYW5zKSkudGhlbihydW5RdWV1ZSkgOlxuICAgICAgICAgICAgICAgIERleGllUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJ1blF1ZXVlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjcmVhdGVNaXNzaW5nVGFibGVzKGdsb2JhbFNjaGVtYSwgaWRiVXBncmFkZVRyYW5zKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFNjaGVtYURpZmYob2xkU2NoZW1hLCBuZXdTY2hlbWEpIHtcbiAgICAgICAgdmFyIGRpZmYgPSB7XG4gICAgICAgICAgICBkZWw6IFtdLFxuICAgICAgICAgICAgYWRkOiBbXSxcbiAgICAgICAgICAgIGNoYW5nZTogW11cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHRhYmxlO1xuICAgICAgICBmb3IgKHRhYmxlIGluIG9sZFNjaGVtYSkge1xuICAgICAgICAgICAgaWYgKCFuZXdTY2hlbWFbdGFibGVdKVxuICAgICAgICAgICAgICAgIGRpZmYuZGVsLnB1c2godGFibGUpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodGFibGUgaW4gbmV3U2NoZW1hKSB7XG4gICAgICAgICAgICB2YXIgb2xkRGVmID0gb2xkU2NoZW1hW3RhYmxlXSwgbmV3RGVmID0gbmV3U2NoZW1hW3RhYmxlXTtcbiAgICAgICAgICAgIGlmICghb2xkRGVmKSB7XG4gICAgICAgICAgICAgICAgZGlmZi5hZGQucHVzaChbdGFibGUsIG5ld0RlZl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoYW5nZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogdGFibGUsXG4gICAgICAgICAgICAgICAgICAgIGRlZjogbmV3RGVmLFxuICAgICAgICAgICAgICAgICAgICByZWNyZWF0ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGRlbDogW10sXG4gICAgICAgICAgICAgICAgICAgIGFkZDogW10sXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZTogW11cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmICgoXG4gICAgICAgICAgICAgICAgJycgKyAob2xkRGVmLnByaW1LZXkua2V5UGF0aCB8fCAnJykpICE9PSAoJycgKyAobmV3RGVmLnByaW1LZXkua2V5UGF0aCB8fCAnJykpIHx8XG4gICAgICAgICAgICAgICAgICAgIChvbGREZWYucHJpbUtleS5hdXRvICE9PSBuZXdEZWYucHJpbUtleS5hdXRvKSkge1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2UucmVjcmVhdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBkaWZmLmNoYW5nZS5wdXNoKGNoYW5nZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb2xkSW5kZXhlcyA9IG9sZERlZi5pZHhCeU5hbWU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdJbmRleGVzID0gbmV3RGVmLmlkeEJ5TmFtZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlkeE5hbWUgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaWR4TmFtZSBpbiBvbGRJbmRleGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW5ld0luZGV4ZXNbaWR4TmFtZV0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlLmRlbC5wdXNoKGlkeE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaWR4TmFtZSBpbiBuZXdJbmRleGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2xkSWR4ID0gb2xkSW5kZXhlc1tpZHhOYW1lXSwgbmV3SWR4ID0gbmV3SW5kZXhlc1tpZHhOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb2xkSWR4KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZS5hZGQucHVzaChuZXdJZHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAob2xkSWR4LnNyYyAhPT0gbmV3SWR4LnNyYylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2UuY2hhbmdlLnB1c2gobmV3SWR4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhbmdlLmRlbC5sZW5ndGggPiAwIHx8IGNoYW5nZS5hZGQubGVuZ3RoID4gMCB8fCBjaGFuZ2UuY2hhbmdlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpZmYuY2hhbmdlLnB1c2goY2hhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGlmZjtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlVGFibGUoaWRidHJhbnMsIHRhYmxlTmFtZSwgcHJpbUtleSwgaW5kZXhlcykge1xuICAgICAgICB2YXIgc3RvcmUgPSBpZGJ0cmFucy5kYi5jcmVhdGVPYmplY3RTdG9yZSh0YWJsZU5hbWUsIHByaW1LZXkua2V5UGF0aCA/XG4gICAgICAgICAgICB7IGtleVBhdGg6IHByaW1LZXkua2V5UGF0aCwgYXV0b0luY3JlbWVudDogcHJpbUtleS5hdXRvIH0gOlxuICAgICAgICAgICAgeyBhdXRvSW5jcmVtZW50OiBwcmltS2V5LmF1dG8gfSk7XG4gICAgICAgIGluZGV4ZXMuZm9yRWFjaChmdW5jdGlvbiAoaWR4KSB7IHJldHVybiBhZGRJbmRleChzdG9yZSwgaWR4KTsgfSk7XG4gICAgICAgIHJldHVybiBzdG9yZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlTWlzc2luZ1RhYmxlcyhuZXdTY2hlbWEsIGlkYnRyYW5zKSB7XG4gICAgICAgIGtleXMobmV3U2NoZW1hKS5mb3JFYWNoKGZ1bmN0aW9uICh0YWJsZU5hbWUpIHtcbiAgICAgICAgICAgIGlmICghaWRidHJhbnMuZGIub2JqZWN0U3RvcmVOYW1lcy5jb250YWlucyh0YWJsZU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRlYnVnKVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmRlYnVnKCdEZXhpZTogQ3JlYXRpbmcgbWlzc2luZyB0YWJsZScsIHRhYmxlTmFtZSk7XG4gICAgICAgICAgICAgICAgY3JlYXRlVGFibGUoaWRidHJhbnMsIHRhYmxlTmFtZSwgbmV3U2NoZW1hW3RhYmxlTmFtZV0ucHJpbUtleSwgbmV3U2NoZW1hW3RhYmxlTmFtZV0uaW5kZXhlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWxldGVSZW1vdmVkVGFibGVzKG5ld1NjaGVtYSwgaWRidHJhbnMpIHtcbiAgICAgICAgW10uc2xpY2UuY2FsbChpZGJ0cmFucy5kYi5vYmplY3RTdG9yZU5hbWVzKS5mb3JFYWNoKGZ1bmN0aW9uIChzdG9yZU5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXdTY2hlbWFbc3RvcmVOYW1lXSA9PSBudWxsICYmIGlkYnRyYW5zLmRiLmRlbGV0ZU9iamVjdFN0b3JlKHN0b3JlTmFtZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhZGRJbmRleChzdG9yZSwgaWR4KSB7XG4gICAgICAgIHN0b3JlLmNyZWF0ZUluZGV4KGlkeC5uYW1lLCBpZHgua2V5UGF0aCwgeyB1bmlxdWU6IGlkeC51bmlxdWUsIG11bHRpRW50cnk6IGlkeC5tdWx0aSB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYnVpbGRHbG9iYWxTY2hlbWEoZGIsIGlkYmRiLCB0bXBUcmFucykge1xuICAgICAgICB2YXIgZ2xvYmFsU2NoZW1hID0ge307XG4gICAgICAgIHZhciBkYlN0b3JlTmFtZXMgPSBzbGljZShpZGJkYi5vYmplY3RTdG9yZU5hbWVzLCAwKTtcbiAgICAgICAgZGJTdG9yZU5hbWVzLmZvckVhY2goZnVuY3Rpb24gKHN0b3JlTmFtZSkge1xuICAgICAgICAgICAgdmFyIHN0b3JlID0gdG1wVHJhbnMub2JqZWN0U3RvcmUoc3RvcmVOYW1lKTtcbiAgICAgICAgICAgIHZhciBrZXlQYXRoID0gc3RvcmUua2V5UGF0aDtcbiAgICAgICAgICAgIHZhciBwcmltS2V5ID0gY3JlYXRlSW5kZXhTcGVjKG5hbWVGcm9tS2V5UGF0aChrZXlQYXRoKSwga2V5UGF0aCB8fCBcIlwiLCB0cnVlLCBmYWxzZSwgISFzdG9yZS5hdXRvSW5jcmVtZW50LCBrZXlQYXRoICYmIHR5cGVvZiBrZXlQYXRoICE9PSBcInN0cmluZ1wiLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciBpbmRleGVzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHN0b3JlLmluZGV4TmFtZXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICB2YXIgaWRiaW5kZXggPSBzdG9yZS5pbmRleChzdG9yZS5pbmRleE5hbWVzW2pdKTtcbiAgICAgICAgICAgICAgICBrZXlQYXRoID0gaWRiaW5kZXgua2V5UGF0aDtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBjcmVhdGVJbmRleFNwZWMoaWRiaW5kZXgubmFtZSwga2V5UGF0aCwgISFpZGJpbmRleC51bmlxdWUsICEhaWRiaW5kZXgubXVsdGlFbnRyeSwgZmFsc2UsIGtleVBhdGggJiYgdHlwZW9mIGtleVBhdGggIT09IFwic3RyaW5nXCIsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBpbmRleGVzLnB1c2goaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2xvYmFsU2NoZW1hW3N0b3JlTmFtZV0gPSBjcmVhdGVUYWJsZVNjaGVtYShzdG9yZU5hbWUsIHByaW1LZXksIGluZGV4ZXMpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGdsb2JhbFNjaGVtYTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVhZEdsb2JhbFNjaGVtYShkYiwgaWRiZGIsIHRtcFRyYW5zKSB7XG4gICAgICAgIGRiLnZlcm5vID0gaWRiZGIudmVyc2lvbiAvIDEwO1xuICAgICAgICB2YXIgZ2xvYmFsU2NoZW1hID0gZGIuX2RiU2NoZW1hID0gYnVpbGRHbG9iYWxTY2hlbWEoZGIsIGlkYmRiLCB0bXBUcmFucyk7XG4gICAgICAgIGRiLl9zdG9yZU5hbWVzID0gc2xpY2UoaWRiZGIub2JqZWN0U3RvcmVOYW1lcywgMCk7XG4gICAgICAgIHNldEFwaU9uUGxhY2UoZGIsIFtkYi5fYWxsVGFibGVzXSwga2V5cyhnbG9iYWxTY2hlbWEpLCBnbG9iYWxTY2hlbWEpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2ZXJpZnlJbnN0YWxsZWRTY2hlbWEoZGIsIHRtcFRyYW5zKSB7XG4gICAgICAgIHZhciBpbnN0YWxsZWRTY2hlbWEgPSBidWlsZEdsb2JhbFNjaGVtYShkYiwgZGIuaWRiZGIsIHRtcFRyYW5zKTtcbiAgICAgICAgdmFyIGRpZmYgPSBnZXRTY2hlbWFEaWZmKGluc3RhbGxlZFNjaGVtYSwgZGIuX2RiU2NoZW1hKTtcbiAgICAgICAgcmV0dXJuICEoZGlmZi5hZGQubGVuZ3RoIHx8IGRpZmYuY2hhbmdlLnNvbWUoZnVuY3Rpb24gKGNoKSB7IHJldHVybiBjaC5hZGQubGVuZ3RoIHx8IGNoLmNoYW5nZS5sZW5ndGg7IH0pKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWRqdXN0VG9FeGlzdGluZ0luZGV4TmFtZXMoZGIsIHNjaGVtYSwgaWRidHJhbnMpIHtcbiAgICAgICAgdmFyIHN0b3JlTmFtZXMgPSBpZGJ0cmFucy5kYi5vYmplY3RTdG9yZU5hbWVzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0b3JlTmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBzdG9yZU5hbWUgPSBzdG9yZU5hbWVzW2ldO1xuICAgICAgICAgICAgdmFyIHN0b3JlID0gaWRidHJhbnMub2JqZWN0U3RvcmUoc3RvcmVOYW1lKTtcbiAgICAgICAgICAgIGRiLl9oYXNHZXRBbGwgPSAnZ2V0QWxsJyBpbiBzdG9yZTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc3RvcmUuaW5kZXhOYW1lcy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgIHZhciBpbmRleE5hbWUgPSBzdG9yZS5pbmRleE5hbWVzW2pdO1xuICAgICAgICAgICAgICAgIHZhciBrZXlQYXRoID0gc3RvcmUuaW5kZXgoaW5kZXhOYW1lKS5rZXlQYXRoO1xuICAgICAgICAgICAgICAgIHZhciBkZXhpZU5hbWUgPSB0eXBlb2Yga2V5UGF0aCA9PT0gJ3N0cmluZycgPyBrZXlQYXRoIDogXCJbXCIgKyBzbGljZShrZXlQYXRoKS5qb2luKCcrJykgKyBcIl1cIjtcbiAgICAgICAgICAgICAgICBpZiAoc2NoZW1hW3N0b3JlTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4U3BlYyA9IHNjaGVtYVtzdG9yZU5hbWVdLmlkeEJ5TmFtZVtkZXhpZU5hbWVdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXhTcGVjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleFNwZWMubmFtZSA9IGluZGV4TmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzY2hlbWFbc3RvcmVOYW1lXS5pZHhCeU5hbWVbZGV4aWVOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjaGVtYVtzdG9yZU5hbWVdLmlkeEJ5TmFtZVtpbmRleE5hbWVdID0gaW5kZXhTcGVjO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvU2FmYXJpLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmXG4gICAgICAgICAgICAhLyhDaHJvbWVcXC98RWRnZVxcLykvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiZcbiAgICAgICAgICAgIF9nbG9iYWwuV29ya2VyR2xvYmFsU2NvcGUgJiYgX2dsb2JhbCBpbnN0YW5jZW9mIF9nbG9iYWwuV29ya2VyR2xvYmFsU2NvcGUgJiZcbiAgICAgICAgICAgIFtdLmNvbmNhdChuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9TYWZhcmlcXC8oXFxkKikvKSlbMV0gPCA2MDQpIHtcbiAgICAgICAgICAgIGRiLl9oYXNHZXRBbGwgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZUluZGV4U3ludGF4KHByaW1LZXlBbmRJbmRleGVzKSB7XG4gICAgICAgIHJldHVybiBwcmltS2V5QW5kSW5kZXhlcy5zcGxpdCgnLCcpLm1hcChmdW5jdGlvbiAoaW5kZXgsIGluZGV4TnVtKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICB2YXIgdHlwZVNwbGl0ID0gaW5kZXguc3BsaXQoJzonKTtcbiAgICAgICAgICAgIHZhciB0eXBlID0gKF9hID0gdHlwZVNwbGl0WzFdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudHJpbSgpO1xuICAgICAgICAgICAgaW5kZXggPSB0eXBlU3BsaXRbMF0udHJpbSgpO1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBpbmRleC5yZXBsYWNlKC8oWyYqXXxcXCtcXCspL2csIFwiXCIpO1xuICAgICAgICAgICAgdmFyIGtleVBhdGggPSAvXlxcWy8udGVzdChuYW1lKSA/IG5hbWUubWF0Y2goL15cXFsoLiopXFxdJC8pWzFdLnNwbGl0KCcrJykgOiBuYW1lO1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUluZGV4U3BlYyhuYW1lLCBrZXlQYXRoIHx8IG51bGwsIC9cXCYvLnRlc3QoaW5kZXgpLCAvXFwqLy50ZXN0KGluZGV4KSwgL1xcK1xcKy8udGVzdChpbmRleCksIGlzQXJyYXkoa2V5UGF0aCksIGluZGV4TnVtID09PSAwLCB0eXBlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIFZlcnNpb24gPSAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gVmVyc2lvbigpIHtcbiAgICAgICAgfVxuICAgICAgICBWZXJzaW9uLnByb3RvdHlwZS5fY3JlYXRlVGFibGVTY2hlbWEgPSBmdW5jdGlvbiAobmFtZSwgcHJpbUtleSwgaW5kZXhlcykge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVRhYmxlU2NoZW1hKG5hbWUsIHByaW1LZXksIGluZGV4ZXMpO1xuICAgICAgICB9O1xuICAgICAgICBWZXJzaW9uLnByb3RvdHlwZS5fcGFyc2VJbmRleFN5bnRheCA9IGZ1bmN0aW9uIChwcmltS2V5QW5kSW5kZXhlcykge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW5kZXhTeW50YXgocHJpbUtleUFuZEluZGV4ZXMpO1xuICAgICAgICB9O1xuICAgICAgICBWZXJzaW9uLnByb3RvdHlwZS5fcGFyc2VTdG9yZXNTcGVjID0gZnVuY3Rpb24gKHN0b3Jlcywgb3V0U2NoZW1hKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAga2V5cyhzdG9yZXMpLmZvckVhY2goZnVuY3Rpb24gKHRhYmxlTmFtZSkge1xuICAgICAgICAgICAgICAgIGlmIChzdG9yZXNbdGFibGVOYW1lXSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXhlcyA9IF90aGlzLl9wYXJzZUluZGV4U3ludGF4KHN0b3Jlc1t0YWJsZU5hbWVdKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByaW1LZXkgPSBpbmRleGVzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcHJpbUtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuU2NoZW1hKCdJbnZhbGlkIHNjaGVtYSBmb3IgdGFibGUgJyArIHRhYmxlTmFtZSArICc6ICcgKyBzdG9yZXNbdGFibGVOYW1lXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcHJpbUtleS51bmlxdWUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJpbUtleS5tdWx0aSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLlNjaGVtYSgnUHJpbWFyeSBrZXkgY2Fubm90IGJlIG11bHRpRW50cnkqJyk7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ZXMuZm9yRWFjaChmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWR4LmF1dG8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuU2NoZW1hKCdPbmx5IHByaW1hcnkga2V5IGNhbiBiZSBtYXJrZWQgYXMgYXV0b0luY3JlbWVudCAoKyspJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlkeC5rZXlQYXRoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLlNjaGVtYSgnSW5kZXggbXVzdCBoYXZlIGEgbmFtZSBhbmQgY2Fubm90IGJlIGFuIGVtcHR5IHN0cmluZycpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRibFNjaGVtYSA9IF90aGlzLl9jcmVhdGVUYWJsZVNjaGVtYSh0YWJsZU5hbWUsIHByaW1LZXksIGluZGV4ZXMpO1xuICAgICAgICAgICAgICAgICAgICBvdXRTY2hlbWFbdGFibGVOYW1lXSA9IHRibFNjaGVtYTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgVmVyc2lvbi5wcm90b3R5cGUuc3RvcmVzID0gZnVuY3Rpb24gKHN0b3Jlcykge1xuICAgICAgICAgICAgdmFyIGRiID0gdGhpcy5kYjtcbiAgICAgICAgICAgIHRoaXMuX2NmZy5zdG9yZXNTb3VyY2UgPSB0aGlzLl9jZmcuc3RvcmVzU291cmNlXG4gICAgICAgICAgICAgICAgPyBleHRlbmQodGhpcy5fY2ZnLnN0b3Jlc1NvdXJjZSwgc3RvcmVzKVxuICAgICAgICAgICAgICAgIDogc3RvcmVzO1xuICAgICAgICAgICAgdmFyIHZlcnNpb25zID0gZGIuX3ZlcnNpb25zO1xuICAgICAgICAgICAgdmFyIHN0b3Jlc1NwZWMgPSB7fTtcbiAgICAgICAgICAgIHZhciBkYnNjaGVtYSA9IHt9O1xuICAgICAgICAgICAgdmVyc2lvbnMuZm9yRWFjaChmdW5jdGlvbiAodmVyc2lvbikge1xuICAgICAgICAgICAgICAgIGV4dGVuZChzdG9yZXNTcGVjLCB2ZXJzaW9uLl9jZmcuc3RvcmVzU291cmNlKTtcbiAgICAgICAgICAgICAgICBkYnNjaGVtYSA9IHZlcnNpb24uX2NmZy5kYnNjaGVtYSA9IHt9O1xuICAgICAgICAgICAgICAgIHZlcnNpb24uX3BhcnNlU3RvcmVzU3BlYyhzdG9yZXNTcGVjLCBkYnNjaGVtYSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRiLl9kYlNjaGVtYSA9IGRic2NoZW1hO1xuICAgICAgICAgICAgcmVtb3ZlVGFibGVzQXBpKGRiLCBbZGIuX2FsbFRhYmxlcywgZGIsIGRiLlRyYW5zYWN0aW9uLnByb3RvdHlwZV0pO1xuICAgICAgICAgICAgc2V0QXBpT25QbGFjZShkYiwgW2RiLl9hbGxUYWJsZXMsIGRiLCBkYi5UcmFuc2FjdGlvbi5wcm90b3R5cGUsIHRoaXMuX2NmZy50YWJsZXNdLCBrZXlzKGRic2NoZW1hKSwgZGJzY2hlbWEpO1xuICAgICAgICAgICAgZGIuX3N0b3JlTmFtZXMgPSBrZXlzKGRic2NoZW1hKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICBWZXJzaW9uLnByb3RvdHlwZS51cGdyYWRlID0gZnVuY3Rpb24gKHVwZ3JhZGVGdW5jdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fY2ZnLmNvbnRlbnRVcGdyYWRlID0gcHJvbWlzYWJsZUNoYWluKHRoaXMuX2NmZy5jb250ZW50VXBncmFkZSB8fCBub3AsIHVwZ3JhZGVGdW5jdGlvbik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFZlcnNpb247XG4gICAgfSgpKTtcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVZlcnNpb25Db25zdHJ1Y3RvcihkYikge1xuICAgICAgICByZXR1cm4gbWFrZUNsYXNzQ29uc3RydWN0b3IoVmVyc2lvbi5wcm90b3R5cGUsIGZ1bmN0aW9uIFZlcnNpb24odmVyc2lvbk51bWJlcikge1xuICAgICAgICAgICAgdGhpcy5kYiA9IGRiO1xuICAgICAgICAgICAgdGhpcy5fY2ZnID0ge1xuICAgICAgICAgICAgICAgIHZlcnNpb246IHZlcnNpb25OdW1iZXIsXG4gICAgICAgICAgICAgICAgc3RvcmVzU291cmNlOiBudWxsLFxuICAgICAgICAgICAgICAgIGRic2NoZW1hOiB7fSxcbiAgICAgICAgICAgICAgICB0YWJsZXM6IHt9LFxuICAgICAgICAgICAgICAgIGNvbnRlbnRVcGdyYWRlOiBudWxsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXREYk5hbWVzVGFibGUoaW5kZXhlZERCLCBJREJLZXlSYW5nZSkge1xuICAgICAgICB2YXIgZGJOYW1lc0RCID0gaW5kZXhlZERCW1wiX2RiTmFtZXNEQlwiXTtcbiAgICAgICAgaWYgKCFkYk5hbWVzREIpIHtcbiAgICAgICAgICAgIGRiTmFtZXNEQiA9IGluZGV4ZWREQltcIl9kYk5hbWVzREJcIl0gPSBuZXcgRGV4aWUkMShEQk5BTUVTX0RCLCB7XG4gICAgICAgICAgICAgICAgYWRkb25zOiBbXSxcbiAgICAgICAgICAgICAgICBpbmRleGVkREI6IGluZGV4ZWREQixcbiAgICAgICAgICAgICAgICBJREJLZXlSYW5nZTogSURCS2V5UmFuZ2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRiTmFtZXNEQi52ZXJzaW9uKDEpLnN0b3Jlcyh7IGRibmFtZXM6IFwibmFtZVwiIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYk5hbWVzREIudGFibGUoXCJkYm5hbWVzXCIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYXNEYXRhYmFzZXNOYXRpdmUoaW5kZXhlZERCKSB7XG4gICAgICAgIHJldHVybiBpbmRleGVkREIgJiYgdHlwZW9mIGluZGV4ZWREQi5kYXRhYmFzZXMgPT09IFwiZnVuY3Rpb25cIjtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0RGF0YWJhc2VOYW1lcyhfYSkge1xuICAgICAgICB2YXIgaW5kZXhlZERCID0gX2EuaW5kZXhlZERCLCBJREJLZXlSYW5nZSA9IF9hLklEQktleVJhbmdlO1xuICAgICAgICByZXR1cm4gaGFzRGF0YWJhc2VzTmF0aXZlKGluZGV4ZWREQilcbiAgICAgICAgICAgID8gUHJvbWlzZS5yZXNvbHZlKGluZGV4ZWREQi5kYXRhYmFzZXMoKSkudGhlbihmdW5jdGlvbiAoaW5mb3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5mb3NcbiAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoaW5mbykgeyByZXR1cm4gaW5mby5uYW1lOyB9KVxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBuYW1lICE9PSBEQk5BTUVTX0RCOyB9KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICA6IGdldERiTmFtZXNUYWJsZShpbmRleGVkREIsIElEQktleVJhbmdlKS50b0NvbGxlY3Rpb24oKS5wcmltYXJ5S2V5cygpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfb25EYXRhYmFzZUNyZWF0ZWQoX2EsIG5hbWUpIHtcbiAgICAgICAgdmFyIGluZGV4ZWREQiA9IF9hLmluZGV4ZWREQiwgSURCS2V5UmFuZ2UgPSBfYS5JREJLZXlSYW5nZTtcbiAgICAgICAgIWhhc0RhdGFiYXNlc05hdGl2ZShpbmRleGVkREIpICYmXG4gICAgICAgICAgICBuYW1lICE9PSBEQk5BTUVTX0RCICYmXG4gICAgICAgICAgICBnZXREYk5hbWVzVGFibGUoaW5kZXhlZERCLCBJREJLZXlSYW5nZSkucHV0KHsgbmFtZTogbmFtZSB9KS5jYXRjaChub3ApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfb25EYXRhYmFzZURlbGV0ZWQoX2EsIG5hbWUpIHtcbiAgICAgICAgdmFyIGluZGV4ZWREQiA9IF9hLmluZGV4ZWREQiwgSURCS2V5UmFuZ2UgPSBfYS5JREJLZXlSYW5nZTtcbiAgICAgICAgIWhhc0RhdGFiYXNlc05hdGl2ZShpbmRleGVkREIpICYmXG4gICAgICAgICAgICBuYW1lICE9PSBEQk5BTUVTX0RCICYmXG4gICAgICAgICAgICBnZXREYk5hbWVzVGFibGUoaW5kZXhlZERCLCBJREJLZXlSYW5nZSkuZGVsZXRlKG5hbWUpLmNhdGNoKG5vcCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmlwKGZuKSB7XG4gICAgICAgIHJldHVybiBuZXdTY29wZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBQU0QubGV0VGhyb3VnaCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gZm4oKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaWRiUmVhZHkoKSB7XG4gICAgICAgIHZhciBpc1NhZmFyaSA9ICFuYXZpZ2F0b3IudXNlckFnZW50RGF0YSAmJlxuICAgICAgICAgICAgL1NhZmFyaVxcLy8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJlxuICAgICAgICAgICAgIS9DaHJvbShlfGl1bSlcXC8vLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgICAgIGlmICghaXNTYWZhcmkgfHwgIWluZGV4ZWREQi5kYXRhYmFzZXMpXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIHZhciBpbnRlcnZhbElkO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgIHZhciB0cnlJZGIgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleGVkREIuZGF0YWJhc2VzKCkuZmluYWxseShyZXNvbHZlKTsgfTtcbiAgICAgICAgICAgIGludGVydmFsSWQgPSBzZXRJbnRlcnZhbCh0cnlJZGIsIDEwMCk7XG4gICAgICAgICAgICB0cnlJZGIoKTtcbiAgICAgICAgfSkuZmluYWxseShmdW5jdGlvbiAoKSB7IHJldHVybiBjbGVhckludGVydmFsKGludGVydmFsSWQpOyB9KTtcbiAgICB9XG5cbiAgICB2YXIgX2E7XG4gICAgZnVuY3Rpb24gaXNFbXB0eVJhbmdlKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuICEoXCJmcm9tXCIgaW4gbm9kZSk7XG4gICAgfVxuICAgIHZhciBSYW5nZVNldCA9IGZ1bmN0aW9uIChmcm9tT3JUcmVlLCB0bykge1xuICAgICAgICBpZiAodGhpcykge1xuICAgICAgICAgICAgZXh0ZW5kKHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPyB7IGQ6IDEsIGZyb206IGZyb21PclRyZWUsIHRvOiBhcmd1bWVudHMubGVuZ3RoID4gMSA/IHRvIDogZnJvbU9yVHJlZSB9IDogeyBkOiAwIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHJ2ID0gbmV3IFJhbmdlU2V0KCk7XG4gICAgICAgICAgICBpZiAoZnJvbU9yVHJlZSAmJiAoXCJkXCIgaW4gZnJvbU9yVHJlZSkpIHtcbiAgICAgICAgICAgICAgICBleHRlbmQocnYsIGZyb21PclRyZWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJ2O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBwcm9wcyhSYW5nZVNldC5wcm90b3R5cGUsIChfYSA9IHtcbiAgICAgICAgICAgIGFkZDogZnVuY3Rpb24gKHJhbmdlU2V0KSB7XG4gICAgICAgICAgICAgICAgbWVyZ2VSYW5nZXModGhpcywgcmFuZ2VTZXQpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFkZEtleTogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIGFkZFJhbmdlKHRoaXMsIGtleSwga2V5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhZGRLZXlzOiBmdW5jdGlvbiAoa2V5cykge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAgICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGFkZFJhbmdlKF90aGlzLCBrZXksIGtleSk7IH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhhc0tleTogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHZhciBub2RlID0gZ2V0UmFuZ2VTZXRJdGVyYXRvcih0aGlzKS5uZXh0KGtleSkudmFsdWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUgJiYgY21wKG5vZGUuZnJvbSwga2V5KSA8PSAwICYmIGNtcChub2RlLnRvLCBrZXkpID49IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIF9hW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRSYW5nZVNldEl0ZXJhdG9yKHRoaXMpO1xuICAgICAgICB9LFxuICAgICAgICBfYSkpO1xuICAgIGZ1bmN0aW9uIGFkZFJhbmdlKHRhcmdldCwgZnJvbSwgdG8pIHtcbiAgICAgICAgdmFyIGRpZmYgPSBjbXAoZnJvbSwgdG8pO1xuICAgICAgICBpZiAoaXNOYU4oZGlmZikpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChkaWZmID4gMClcbiAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoKTtcbiAgICAgICAgaWYgKGlzRW1wdHlSYW5nZSh0YXJnZXQpKVxuICAgICAgICAgICAgcmV0dXJuIGV4dGVuZCh0YXJnZXQsIHsgZnJvbTogZnJvbSwgdG86IHRvLCBkOiAxIH0pO1xuICAgICAgICB2YXIgbGVmdCA9IHRhcmdldC5sO1xuICAgICAgICB2YXIgcmlnaHQgPSB0YXJnZXQucjtcbiAgICAgICAgaWYgKGNtcCh0bywgdGFyZ2V0LmZyb20pIDwgMCkge1xuICAgICAgICAgICAgbGVmdFxuICAgICAgICAgICAgICAgID8gYWRkUmFuZ2UobGVmdCwgZnJvbSwgdG8pXG4gICAgICAgICAgICAgICAgOiAodGFyZ2V0LmwgPSB7IGZyb206IGZyb20sIHRvOiB0bywgZDogMSwgbDogbnVsbCwgcjogbnVsbCB9KTtcbiAgICAgICAgICAgIHJldHVybiByZWJhbGFuY2UodGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY21wKGZyb20sIHRhcmdldC50bykgPiAwKSB7XG4gICAgICAgICAgICByaWdodFxuICAgICAgICAgICAgICAgID8gYWRkUmFuZ2UocmlnaHQsIGZyb20sIHRvKVxuICAgICAgICAgICAgICAgIDogKHRhcmdldC5yID0geyBmcm9tOiBmcm9tLCB0bzogdG8sIGQ6IDEsIGw6IG51bGwsIHI6IG51bGwgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmViYWxhbmNlKHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNtcChmcm9tLCB0YXJnZXQuZnJvbSkgPCAwKSB7XG4gICAgICAgICAgICB0YXJnZXQuZnJvbSA9IGZyb207XG4gICAgICAgICAgICB0YXJnZXQubCA9IG51bGw7XG4gICAgICAgICAgICB0YXJnZXQuZCA9IHJpZ2h0ID8gcmlnaHQuZCArIDEgOiAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjbXAodG8sIHRhcmdldC50bykgPiAwKSB7XG4gICAgICAgICAgICB0YXJnZXQudG8gPSB0bztcbiAgICAgICAgICAgIHRhcmdldC5yID0gbnVsbDtcbiAgICAgICAgICAgIHRhcmdldC5kID0gdGFyZ2V0LmwgPyB0YXJnZXQubC5kICsgMSA6IDE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJpZ2h0V2FzQ3V0T2ZmID0gIXRhcmdldC5yO1xuICAgICAgICBpZiAobGVmdCAmJiAhdGFyZ2V0LmwpIHtcbiAgICAgICAgICAgIG1lcmdlUmFuZ2VzKHRhcmdldCwgbGVmdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJpZ2h0ICYmIHJpZ2h0V2FzQ3V0T2ZmKSB7XG4gICAgICAgICAgICBtZXJnZVJhbmdlcyh0YXJnZXQsIHJpZ2h0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBtZXJnZVJhbmdlcyh0YXJnZXQsIG5ld1NldCkge1xuICAgICAgICBmdW5jdGlvbiBfYWRkUmFuZ2VTZXQodGFyZ2V0LCBfYSkge1xuICAgICAgICAgICAgdmFyIGZyb20gPSBfYS5mcm9tLCB0byA9IF9hLnRvLCBsID0gX2EubCwgciA9IF9hLnI7XG4gICAgICAgICAgICBhZGRSYW5nZSh0YXJnZXQsIGZyb20sIHRvKTtcbiAgICAgICAgICAgIGlmIChsKVxuICAgICAgICAgICAgICAgIF9hZGRSYW5nZVNldCh0YXJnZXQsIGwpO1xuICAgICAgICAgICAgaWYgKHIpXG4gICAgICAgICAgICAgICAgX2FkZFJhbmdlU2V0KHRhcmdldCwgcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0VtcHR5UmFuZ2UobmV3U2V0KSlcbiAgICAgICAgICAgIF9hZGRSYW5nZVNldCh0YXJnZXQsIG5ld1NldCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJhbmdlc092ZXJsYXAocmFuZ2VTZXQxLCByYW5nZVNldDIpIHtcbiAgICAgICAgdmFyIGkxID0gZ2V0UmFuZ2VTZXRJdGVyYXRvcihyYW5nZVNldDIpO1xuICAgICAgICB2YXIgbmV4dFJlc3VsdDEgPSBpMS5uZXh0KCk7XG4gICAgICAgIGlmIChuZXh0UmVzdWx0MS5kb25lKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgYSA9IG5leHRSZXN1bHQxLnZhbHVlO1xuICAgICAgICB2YXIgaTIgPSBnZXRSYW5nZVNldEl0ZXJhdG9yKHJhbmdlU2V0MSk7XG4gICAgICAgIHZhciBuZXh0UmVzdWx0MiA9IGkyLm5leHQoYS5mcm9tKTtcbiAgICAgICAgdmFyIGIgPSBuZXh0UmVzdWx0Mi52YWx1ZTtcbiAgICAgICAgd2hpbGUgKCFuZXh0UmVzdWx0MS5kb25lICYmICFuZXh0UmVzdWx0Mi5kb25lKSB7XG4gICAgICAgICAgICBpZiAoY21wKGIuZnJvbSwgYS50bykgPD0gMCAmJiBjbXAoYi50bywgYS5mcm9tKSA+PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgY21wKGEuZnJvbSwgYi5mcm9tKSA8IDBcbiAgICAgICAgICAgICAgICA/IChhID0gKG5leHRSZXN1bHQxID0gaTEubmV4dChiLmZyb20pKS52YWx1ZSlcbiAgICAgICAgICAgICAgICA6IChiID0gKG5leHRSZXN1bHQyID0gaTIubmV4dChhLmZyb20pKS52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRSYW5nZVNldEl0ZXJhdG9yKG5vZGUpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gaXNFbXB0eVJhbmdlKG5vZGUpID8gbnVsbCA6IHsgczogMCwgbjogbm9kZSB9O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHZhciBrZXlQcm92aWRlZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwO1xuICAgICAgICAgICAgICAgIHdoaWxlIChzdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHN0YXRlLnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5zID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5UHJvdmlkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0YXRlLm4ubCAmJiBjbXAoa2V5LCBzdGF0ZS5uLmZyb20pIDwgMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0geyB1cDogc3RhdGUsIG46IHN0YXRlLm4ubCwgczogMSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0YXRlLm4ubClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0geyB1cDogc3RhdGUsIG46IHN0YXRlLm4ubCwgczogMSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5zID0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWtleVByb3ZpZGVkIHx8IGNtcChrZXksIHN0YXRlLm4udG8pIDw9IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBzdGF0ZS5uLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5uLnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUucyA9IDM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0geyB1cDogc3RhdGUsIG46IHN0YXRlLm4uciwgczogMCB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBzdGF0ZS51cDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWJhbGFuY2UodGFyZ2V0KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHZhciBkaWZmID0gKCgoX2EgPSB0YXJnZXQucikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmQpIHx8IDApIC0gKCgoX2IgPSB0YXJnZXQubCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmQpIHx8IDApO1xuICAgICAgICB2YXIgciA9IGRpZmYgPiAxID8gXCJyXCIgOiBkaWZmIDwgLTEgPyBcImxcIiA6IFwiXCI7XG4gICAgICAgIGlmIChyKSB7XG4gICAgICAgICAgICB2YXIgbCA9IHIgPT09IFwiclwiID8gXCJsXCIgOiBcInJcIjtcbiAgICAgICAgICAgIHZhciByb290Q2xvbmUgPSBfX2Fzc2lnbih7fSwgdGFyZ2V0KTtcbiAgICAgICAgICAgIHZhciBvbGRSb290UmlnaHQgPSB0YXJnZXRbcl07XG4gICAgICAgICAgICB0YXJnZXQuZnJvbSA9IG9sZFJvb3RSaWdodC5mcm9tO1xuICAgICAgICAgICAgdGFyZ2V0LnRvID0gb2xkUm9vdFJpZ2h0LnRvO1xuICAgICAgICAgICAgdGFyZ2V0W3JdID0gb2xkUm9vdFJpZ2h0W3JdO1xuICAgICAgICAgICAgcm9vdENsb25lW3JdID0gb2xkUm9vdFJpZ2h0W2xdO1xuICAgICAgICAgICAgdGFyZ2V0W2xdID0gcm9vdENsb25lO1xuICAgICAgICAgICAgcm9vdENsb25lLmQgPSBjb21wdXRlRGVwdGgocm9vdENsb25lKTtcbiAgICAgICAgfVxuICAgICAgICB0YXJnZXQuZCA9IGNvbXB1dGVEZXB0aCh0YXJnZXQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21wdXRlRGVwdGgoX2EpIHtcbiAgICAgICAgdmFyIHIgPSBfYS5yLCBsID0gX2EubDtcbiAgICAgICAgcmV0dXJuIChyID8gKGwgPyBNYXRoLm1heChyLmQsIGwuZCkgOiByLmQpIDogbCA/IGwuZCA6IDApICsgMTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHRlbmRPYnNlcnZhYmlsaXR5U2V0KHRhcmdldCwgbmV3U2V0KSB7XG4gICAgICAgIGtleXMobmV3U2V0KS5mb3JFYWNoKGZ1bmN0aW9uIChwYXJ0KSB7XG4gICAgICAgICAgICBpZiAodGFyZ2V0W3BhcnRdKVxuICAgICAgICAgICAgICAgIG1lcmdlUmFuZ2VzKHRhcmdldFtwYXJ0XSwgbmV3U2V0W3BhcnRdKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0YXJnZXRbcGFydF0gPSBjbG9uZVNpbXBsZU9iamVjdFRyZWUobmV3U2V0W3BhcnRdKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb2JzU2V0c092ZXJsYXAob3MxLCBvczIpIHtcbiAgICAgICAgcmV0dXJuIG9zMS5hbGwgfHwgb3MyLmFsbCB8fCBPYmplY3Qua2V5cyhvczEpLnNvbWUoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gb3MyW2tleV0gJiYgcmFuZ2VzT3ZlcmxhcChvczJba2V5XSwgb3MxW2tleV0pOyB9KTtcbiAgICB9XG5cbiAgICB2YXIgY2FjaGUgPSB7fTtcblxuICAgIHZhciB1bnNpZ25hbGVkUGFydHMgPSB7fTtcbiAgICB2YXIgaXNUYXNrRW5xdWV1ZWQgPSBmYWxzZTtcbiAgICBmdW5jdGlvbiBzaWduYWxTdWJzY3JpYmVyc0xhemlseShwYXJ0LCBvcHRpbWlzdGljKSB7XG4gICAgICAgIGV4dGVuZE9ic2VydmFiaWxpdHlTZXQodW5zaWduYWxlZFBhcnRzLCBwYXJ0KTtcbiAgICAgICAgaWYgKCFpc1Rhc2tFbnF1ZXVlZCkge1xuICAgICAgICAgICAgaXNUYXNrRW5xdWV1ZWQgPSB0cnVlO1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaXNUYXNrRW5xdWV1ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB2YXIgcGFydHMgPSB1bnNpZ25hbGVkUGFydHM7XG4gICAgICAgICAgICAgICAgdW5zaWduYWxlZFBhcnRzID0ge307XG4gICAgICAgICAgICAgICAgc2lnbmFsU3Vic2NyaWJlcnNOb3cocGFydHMsIGZhbHNlKTtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNpZ25hbFN1YnNjcmliZXJzTm93KHVwZGF0ZWRQYXJ0cywgZGVsZXRlQWZmZWN0ZWRDYWNoZUVudHJpZXMpIHtcbiAgICAgICAgaWYgKGRlbGV0ZUFmZmVjdGVkQ2FjaGVFbnRyaWVzID09PSB2b2lkIDApIHsgZGVsZXRlQWZmZWN0ZWRDYWNoZUVudHJpZXMgPSBmYWxzZTsgfVxuICAgICAgICB2YXIgcXVlcmllc1RvU2lnbmFsID0gbmV3IFNldCgpO1xuICAgICAgICBpZiAodXBkYXRlZFBhcnRzLmFsbCkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IE9iamVjdC52YWx1ZXMoY2FjaGUpOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciB0YmxDYWNoZSA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICBjb2xsZWN0VGFibGVTdWJzY3JpYmVycyh0YmxDYWNoZSwgdXBkYXRlZFBhcnRzLCBxdWVyaWVzVG9TaWduYWwsIGRlbGV0ZUFmZmVjdGVkQ2FjaGVFbnRyaWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiB1cGRhdGVkUGFydHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFydHMgPSAvXmlkYlxcOlxcL1xcLyguKilcXC8oLiopXFwvLy5leGVjKGtleSk7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkYk5hbWUgPSBwYXJ0c1sxXSwgdGFibGVOYW1lID0gcGFydHNbMl07XG4gICAgICAgICAgICAgICAgICAgIHZhciB0YmxDYWNoZSA9IGNhY2hlW1wiaWRiOi8vXCIuY29uY2F0KGRiTmFtZSwgXCIvXCIpLmNvbmNhdCh0YWJsZU5hbWUpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRibENhY2hlKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdFRhYmxlU3Vic2NyaWJlcnModGJsQ2FjaGUsIHVwZGF0ZWRQYXJ0cywgcXVlcmllc1RvU2lnbmFsLCBkZWxldGVBZmZlY3RlZENhY2hlRW50cmllcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXJpZXNUb1NpZ25hbC5mb3JFYWNoKGZ1bmN0aW9uIChyZXF1ZXJ5KSB7IHJldHVybiByZXF1ZXJ5KCk7IH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb2xsZWN0VGFibGVTdWJzY3JpYmVycyh0YmxDYWNoZSwgdXBkYXRlZFBhcnRzLCBvdXRRdWVyaWVzVG9TaWduYWwsIGRlbGV0ZUFmZmVjdGVkQ2FjaGVFbnRyaWVzKSB7XG4gICAgICAgIHZhciB1cGRhdGVkRW50cnlMaXN0cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gT2JqZWN0LmVudHJpZXModGJsQ2FjaGUucXVlcmllcy5xdWVyeSk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgX2IgPSBfYVtfaV0sIGluZGV4TmFtZSA9IF9iWzBdLCBlbnRyaWVzID0gX2JbMV07XG4gICAgICAgICAgICB2YXIgZmlsdGVyZWRFbnRyaWVzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfYyA9IDAsIGVudHJpZXNfMSA9IGVudHJpZXM7IF9jIDwgZW50cmllc18xLmxlbmd0aDsgX2MrKykge1xuICAgICAgICAgICAgICAgIHZhciBlbnRyeSA9IGVudHJpZXNfMVtfY107XG4gICAgICAgICAgICAgICAgaWYgKG9ic1NldHNPdmVybGFwKHVwZGF0ZWRQYXJ0cywgZW50cnkub2JzU2V0KSkge1xuICAgICAgICAgICAgICAgICAgICBlbnRyeS5zdWJzY3JpYmVycy5mb3JFYWNoKGZ1bmN0aW9uIChyZXF1ZXJ5KSB7IHJldHVybiBvdXRRdWVyaWVzVG9TaWduYWwuYWRkKHJlcXVlcnkpOyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZGVsZXRlQWZmZWN0ZWRDYWNoZUVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyZWRFbnRyaWVzLnB1c2goZW50cnkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkZWxldGVBZmZlY3RlZENhY2hlRW50cmllcylcbiAgICAgICAgICAgICAgICB1cGRhdGVkRW50cnlMaXN0cy5wdXNoKFtpbmRleE5hbWUsIGZpbHRlcmVkRW50cmllc10pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWxldGVBZmZlY3RlZENhY2hlRW50cmllcykge1xuICAgICAgICAgICAgZm9yICh2YXIgX2QgPSAwLCB1cGRhdGVkRW50cnlMaXN0c18xID0gdXBkYXRlZEVudHJ5TGlzdHM7IF9kIDwgdXBkYXRlZEVudHJ5TGlzdHNfMS5sZW5ndGg7IF9kKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgX2UgPSB1cGRhdGVkRW50cnlMaXN0c18xW19kXSwgaW5kZXhOYW1lID0gX2VbMF0sIGZpbHRlcmVkRW50cmllcyA9IF9lWzFdO1xuICAgICAgICAgICAgICAgIHRibENhY2hlLnF1ZXJpZXMucXVlcnlbaW5kZXhOYW1lXSA9IGZpbHRlcmVkRW50cmllcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRleGllT3BlbihkYikge1xuICAgICAgICB2YXIgc3RhdGUgPSBkYi5fc3RhdGU7XG4gICAgICAgIHZhciBpbmRleGVkREIgPSBkYi5fZGVwcy5pbmRleGVkREI7XG4gICAgICAgIGlmIChzdGF0ZS5pc0JlaW5nT3BlbmVkIHx8IGRiLmlkYmRiKVxuICAgICAgICAgICAgcmV0dXJuIHN0YXRlLmRiUmVhZHlQcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gc3RhdGUuZGJPcGVuRXJyb3IgP1xuICAgICAgICAgICAgICAgIHJlamVjdGlvbihzdGF0ZS5kYk9wZW5FcnJvcikgOlxuICAgICAgICAgICAgICAgIGRiOyB9KTtcbiAgICAgICAgc3RhdGUuaXNCZWluZ09wZW5lZCA9IHRydWU7XG4gICAgICAgIHN0YXRlLmRiT3BlbkVycm9yID0gbnVsbDtcbiAgICAgICAgc3RhdGUub3BlbkNvbXBsZXRlID0gZmFsc2U7XG4gICAgICAgIHZhciBvcGVuQ2FuY2VsbGVyID0gc3RhdGUub3BlbkNhbmNlbGxlcjtcbiAgICAgICAgdmFyIG5hdGl2ZVZlclRvT3BlbiA9IE1hdGgucm91bmQoZGIudmVybm8gKiAxMCk7XG4gICAgICAgIHZhciBzY2hlbWFQYXRjaE1vZGUgPSBmYWxzZTtcbiAgICAgICAgZnVuY3Rpb24gdGhyb3dJZkNhbmNlbGxlZCgpIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5vcGVuQ2FuY2VsbGVyICE9PSBvcGVuQ2FuY2VsbGVyKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLkRhdGFiYXNlQ2xvc2VkKCdkYi5vcGVuKCkgd2FzIGNhbmNlbGxlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXNvbHZlRGJSZWFkeSA9IHN0YXRlLmRiUmVhZHlSZXNvbHZlLFxuICAgICAgICB1cGdyYWRlVHJhbnNhY3Rpb24gPSBudWxsLCB3YXNDcmVhdGVkID0gZmFsc2U7XG4gICAgICAgIHZhciB0cnlPcGVuREIgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgRGV4aWVQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHRocm93SWZDYW5jZWxsZWQoKTtcbiAgICAgICAgICAgIGlmICghaW5kZXhlZERCKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLk1pc3NpbmdBUEkoKTtcbiAgICAgICAgICAgIHZhciBkYk5hbWUgPSBkYi5uYW1lO1xuICAgICAgICAgICAgdmFyIHJlcSA9IHN0YXRlLmF1dG9TY2hlbWEgfHwgIW5hdGl2ZVZlclRvT3BlbiA/XG4gICAgICAgICAgICAgICAgaW5kZXhlZERCLm9wZW4oZGJOYW1lKSA6XG4gICAgICAgICAgICAgICAgaW5kZXhlZERCLm9wZW4oZGJOYW1lLCBuYXRpdmVWZXJUb09wZW4pO1xuICAgICAgICAgICAgaWYgKCFyZXEpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuTWlzc2luZ0FQSSgpO1xuICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBldmVudFJlamVjdEhhbmRsZXIocmVqZWN0KTtcbiAgICAgICAgICAgIHJlcS5vbmJsb2NrZWQgPSB3cmFwKGRiLl9maXJlT25CbG9ja2VkKTtcbiAgICAgICAgICAgIHJlcS5vbnVwZ3JhZGVuZWVkZWQgPSB3cmFwKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgdXBncmFkZVRyYW5zYWN0aW9uID0gcmVxLnRyYW5zYWN0aW9uO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5hdXRvU2NoZW1hICYmICFkYi5fb3B0aW9ucy5hbGxvd0VtcHR5REIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBwcmV2ZW50RGVmYXVsdDtcbiAgICAgICAgICAgICAgICAgICAgdXBncmFkZVRyYW5zYWN0aW9uLmFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIHJlcS5yZXN1bHQuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlbHJlcSA9IGluZGV4ZWREQi5kZWxldGVEYXRhYmFzZShkYk5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBkZWxyZXEub25zdWNjZXNzID0gZGVscmVxLm9uZXJyb3IgPSB3cmFwKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgZXhjZXB0aW9ucy5Ob1N1Y2hEYXRhYmFzZShcIkRhdGFiYXNlIFwiLmNvbmNhdChkYk5hbWUsIFwiIGRvZXNudCBleGlzdFwiKSkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHVwZ3JhZGVUcmFuc2FjdGlvbi5vbmVycm9yID0gZXZlbnRSZWplY3RIYW5kbGVyKHJlamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvbGRWZXIgPSBlLm9sZFZlcnNpb24gPiBNYXRoLnBvdygyLCA2MikgPyAwIDogZS5vbGRWZXJzaW9uO1xuICAgICAgICAgICAgICAgICAgICB3YXNDcmVhdGVkID0gb2xkVmVyIDwgMTtcbiAgICAgICAgICAgICAgICAgICAgZGIuaWRiZGIgPSByZXEucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2NoZW1hUGF0Y2hNb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRjaEN1cnJlbnRWZXJzaW9uKGRiLCB1cGdyYWRlVHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJ1blVwZ3JhZGVycyhkYiwgb2xkVmVyIC8gMTAsIHVwZ3JhZGVUcmFuc2FjdGlvbiwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCByZWplY3QpO1xuICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IHdyYXAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHVwZ3JhZGVUcmFuc2FjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgdmFyIGlkYmRiID0gZGIuaWRiZGIgPSByZXEucmVzdWx0O1xuICAgICAgICAgICAgICAgIHZhciBvYmplY3RTdG9yZU5hbWVzID0gc2xpY2UoaWRiZGIub2JqZWN0U3RvcmVOYW1lcyk7XG4gICAgICAgICAgICAgICAgaWYgKG9iamVjdFN0b3JlTmFtZXMubGVuZ3RoID4gMClcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0bXBUcmFucyA9IGlkYmRiLnRyYW5zYWN0aW9uKHNhZmFyaU11bHRpU3RvcmVGaXgob2JqZWN0U3RvcmVOYW1lcyksICdyZWFkb25seScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLmF1dG9TY2hlbWEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZEdsb2JhbFNjaGVtYShkYiwgaWRiZGIsIHRtcFRyYW5zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkanVzdFRvRXhpc3RpbmdJbmRleE5hbWVzKGRiLCBkYi5fZGJTY2hlbWEsIHRtcFRyYW5zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXZlcmlmeUluc3RhbGxlZFNjaGVtYShkYiwgdG1wVHJhbnMpICYmICFzY2hlbWFQYXRjaE1vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiRGV4aWUgU2NoZW1hRGlmZjogU2NoZW1hIHdhcyBleHRlbmRlZCB3aXRob3V0IGluY3JlYXNpbmcgdGhlIG51bWJlciBwYXNzZWQgdG8gZGIudmVyc2lvbigpLiBEZXhpZSB3aWxsIGFkZCBtaXNzaW5nIHBhcnRzIGFuZCBpbmNyZW1lbnQgbmF0aXZlIHZlcnNpb24gbnVtYmVyIHRvIHdvcmthcm91bmQgdGhpcy5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkYmRiLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdGl2ZVZlclRvT3BlbiA9IGlkYmRiLnZlcnNpb24gKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2hlbWFQYXRjaE1vZGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh0cnlPcGVuREIoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVNaWRkbGV3YXJlU3RhY2tzKGRiLCB0bXBUcmFucyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25zLnB1c2goZGIpO1xuICAgICAgICAgICAgICAgIGlkYmRiLm9udmVyc2lvbmNoYW5nZSA9IHdyYXAoZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLnZjRmlyZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBkYi5vbihcInZlcnNpb25jaGFuZ2VcIikuZmlyZShldik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWRiZGIub25jbG9zZSA9IHdyYXAoZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICAgICAgICAgIGRiLm9uKFwiY2xvc2VcIikuZmlyZShldik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHdhc0NyZWF0ZWQpXG4gICAgICAgICAgICAgICAgICAgIF9vbkRhdGFiYXNlQ3JlYXRlZChkYi5fZGVwcywgZGJOYW1lKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9LCByZWplY3QpO1xuICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGVyciA9PT0gbnVsbCB8fCBlcnIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVyci5uYW1lKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcIlVua25vd25FcnJvclwiOlxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUuUFIxMzk4X21heExvb3AgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5QUjEzOThfbWF4TG9vcC0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdEZXhpZTogV29ya2Fyb3VuZCBmb3IgQ2hyb21lIFVua25vd25FcnJvciBvbiBvcGVuKCknKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnlPcGVuREIoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiVmVyc2lvbkVycm9yXCI6XG4gICAgICAgICAgICAgICAgICAgIGlmIChuYXRpdmVWZXJUb09wZW4gPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYXRpdmVWZXJUb09wZW4gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRyeU9wZW5EQigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIERleGllUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICAgICAgfSk7IH07XG4gICAgICAgIHJldHVybiBEZXhpZVByb21pc2UucmFjZShbXG4gICAgICAgICAgICBvcGVuQ2FuY2VsbGVyLFxuICAgICAgICAgICAgKHR5cGVvZiBuYXZpZ2F0b3IgPT09ICd1bmRlZmluZWQnID8gRGV4aWVQcm9taXNlLnJlc29sdmUoKSA6IGlkYlJlYWR5KCkpLnRoZW4odHJ5T3BlbkRCKVxuICAgICAgICBdKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93SWZDYW5jZWxsZWQoKTtcbiAgICAgICAgICAgIHN0YXRlLm9uUmVhZHlCZWluZ0ZpcmVkID0gW107XG4gICAgICAgICAgICByZXR1cm4gRGV4aWVQcm9taXNlLnJlc29sdmUodmlwKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRiLm9uLnJlYWR5LmZpcmUoZGIudmlwKTsgfSkpLnRoZW4oZnVuY3Rpb24gZmlyZVJlbWFpbmRlcnMoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLm9uUmVhZHlCZWluZ0ZpcmVkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlbWFpbmRlcnNfMSA9IHN0YXRlLm9uUmVhZHlCZWluZ0ZpcmVkLnJlZHVjZShwcm9taXNhYmxlQ2hhaW4sIG5vcCk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLm9uUmVhZHlCZWluZ0ZpcmVkID0gW107XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBEZXhpZVByb21pc2UucmVzb2x2ZSh2aXAoZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVtYWluZGVyc18xKGRiLnZpcCk7IH0pKS50aGVuKGZpcmVSZW1haW5kZXJzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkuZmluYWxseShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUub3BlbkNhbmNlbGxlciA9PT0gb3BlbkNhbmNlbGxlcikge1xuICAgICAgICAgICAgICAgIHN0YXRlLm9uUmVhZHlCZWluZ0ZpcmVkID0gbnVsbDtcbiAgICAgICAgICAgICAgICBzdGF0ZS5pc0JlaW5nT3BlbmVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIHN0YXRlLmRiT3BlbkVycm9yID0gZXJyO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB1cGdyYWRlVHJhbnNhY3Rpb24gJiYgdXBncmFkZVRyYW5zYWN0aW9uLmFib3J0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoX2EpIHsgfVxuICAgICAgICAgICAgaWYgKG9wZW5DYW5jZWxsZXIgPT09IHN0YXRlLm9wZW5DYW5jZWxsZXIpIHtcbiAgICAgICAgICAgICAgICBkYi5fY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZWplY3Rpb24oZXJyKTtcbiAgICAgICAgfSkuZmluYWxseShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzdGF0ZS5vcGVuQ29tcGxldGUgPSB0cnVlO1xuICAgICAgICAgICAgcmVzb2x2ZURiUmVhZHkoKTtcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAod2FzQ3JlYXRlZCkge1xuICAgICAgICAgICAgICAgIHZhciBldmVyeXRoaW5nXzEgPSB7fTtcbiAgICAgICAgICAgICAgICBkYi50YWJsZXMuZm9yRWFjaChmdW5jdGlvbiAodGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFibGUuc2NoZW1hLmluZGV4ZXMuZm9yRWFjaChmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWR4Lm5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlcnl0aGluZ18xW1wiaWRiOi8vXCIuY29uY2F0KGRiLm5hbWUsIFwiL1wiKS5jb25jYXQodGFibGUubmFtZSwgXCIvXCIpLmNvbmNhdChpZHgubmFtZSldID0gbmV3IFJhbmdlU2V0KC1JbmZpbml0eSwgW1tbXV1dKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGV2ZXJ5dGhpbmdfMVtcImlkYjovL1wiLmNvbmNhdChkYi5uYW1lLCBcIi9cIikuY29uY2F0KHRhYmxlLm5hbWUsIFwiL1wiKV0gPSBldmVyeXRoaW5nXzFbXCJpZGI6Ly9cIi5jb25jYXQoZGIubmFtZSwgXCIvXCIpLmNvbmNhdCh0YWJsZS5uYW1lLCBcIi86ZGVsc1wiKV0gPSBuZXcgUmFuZ2VTZXQoLUluZmluaXR5LCBbW1tdXV0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGdsb2JhbEV2ZW50cyhERVhJRV9TVE9SQUdFX01VVEFURURfRVZFTlRfTkFNRSkuZmlyZShldmVyeXRoaW5nXzEpO1xuICAgICAgICAgICAgICAgIHNpZ25hbFN1YnNjcmliZXJzTm93KGV2ZXJ5dGhpbmdfMSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGI7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGF3YWl0SXRlcmF0b3IoaXRlcmF0b3IpIHtcbiAgICAgICAgdmFyIGNhbGxOZXh0ID0gZnVuY3Rpb24gKHJlc3VsdCkgeyByZXR1cm4gaXRlcmF0b3IubmV4dChyZXN1bHQpOyB9LCBkb1Rocm93ID0gZnVuY3Rpb24gKGVycm9yKSB7IHJldHVybiBpdGVyYXRvci50aHJvdyhlcnJvcik7IH0sIG9uU3VjY2VzcyA9IHN0ZXAoY2FsbE5leHQpLCBvbkVycm9yID0gc3RlcChkb1Rocm93KTtcbiAgICAgICAgZnVuY3Rpb24gc3RlcChnZXROZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgICAgIHZhciBuZXh0ID0gZ2V0TmV4dCh2YWwpLCB2YWx1ZSA9IG5leHQudmFsdWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5leHQuZG9uZSA/IHZhbHVlIDpcbiAgICAgICAgICAgICAgICAgICAgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUudGhlbiAhPT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0FycmF5KHZhbHVlKSA/IFByb21pc2UuYWxsKHZhbHVlKS50aGVuKG9uU3VjY2Vzcywgb25FcnJvcikgOiBvblN1Y2Nlc3ModmFsdWUpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLnRoZW4ob25TdWNjZXNzLCBvbkVycm9yKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGVwKGNhbGxOZXh0KSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4dHJhY3RUcmFuc2FjdGlvbkFyZ3MobW9kZSwgX3RhYmxlQXJnc18sIHNjb3BlRnVuYykge1xuICAgICAgICB2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIGlmIChpIDwgMilcbiAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLkludmFsaWRBcmd1bWVudChcIlRvbyBmZXcgYXJndW1lbnRzXCIpO1xuICAgICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShpIC0gMSk7XG4gICAgICAgIHdoaWxlICgtLWkpXG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgc2NvcGVGdW5jID0gYXJncy5wb3AoKTtcbiAgICAgICAgdmFyIHRhYmxlcyA9IGZsYXR0ZW4oYXJncyk7XG4gICAgICAgIHJldHVybiBbbW9kZSwgdGFibGVzLCBzY29wZUZ1bmNdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbnRlclRyYW5zYWN0aW9uU2NvcGUoZGIsIG1vZGUsIHN0b3JlTmFtZXMsIHBhcmVudFRyYW5zYWN0aW9uLCBzY29wZUZ1bmMpIHtcbiAgICAgICAgcmV0dXJuIERleGllUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdHJhbnNsZXNzID0gUFNELnRyYW5zbGVzcyB8fCBQU0Q7XG4gICAgICAgICAgICB2YXIgdHJhbnMgPSBkYi5fY3JlYXRlVHJhbnNhY3Rpb24obW9kZSwgc3RvcmVOYW1lcywgZGIuX2RiU2NoZW1hLCBwYXJlbnRUcmFuc2FjdGlvbik7XG4gICAgICAgICAgICB0cmFucy5leHBsaWNpdCA9IHRydWU7XG4gICAgICAgICAgICB2YXIgem9uZVByb3BzID0ge1xuICAgICAgICAgICAgICAgIHRyYW5zOiB0cmFucyxcbiAgICAgICAgICAgICAgICB0cmFuc2xlc3M6IHRyYW5zbGVzc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChwYXJlbnRUcmFuc2FjdGlvbikge1xuICAgICAgICAgICAgICAgIHRyYW5zLmlkYnRyYW5zID0gcGFyZW50VHJhbnNhY3Rpb24uaWRidHJhbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0cmFucy5jcmVhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnMuaWRidHJhbnMuX2V4cGxpY2l0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZGIuX3N0YXRlLlBSMTM5OF9tYXhMb29wID0gMztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleC5uYW1lID09PSBlcnJuYW1lcy5JbnZhbGlkU3RhdGUgJiYgZGIuaXNPcGVuKCkgJiYgLS1kYi5fc3RhdGUuUFIxMzk4X21heExvb3AgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0RleGllOiBOZWVkIHRvIHJlb3BlbiBkYicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGIuY2xvc2UoeyBkaXNhYmxlQXV0b09wZW46IGZhbHNlIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRiLm9wZW4oKS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVudGVyVHJhbnNhY3Rpb25TY29wZShkYiwgbW9kZSwgc3RvcmVOYW1lcywgbnVsbCwgc2NvcGVGdW5jKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdGlvbihleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHNjb3BlRnVuY0lzQXN5bmMgPSBpc0FzeW5jRnVuY3Rpb24oc2NvcGVGdW5jKTtcbiAgICAgICAgICAgIGlmIChzY29wZUZ1bmNJc0FzeW5jKSB7XG4gICAgICAgICAgICAgICAgaW5jcmVtZW50RXhwZWN0ZWRBd2FpdHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZXR1cm5WYWx1ZTtcbiAgICAgICAgICAgIHZhciBwcm9taXNlRm9sbG93ZWQgPSBEZXhpZVByb21pc2UuZm9sbG93KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZSA9IHNjb3BlRnVuYy5jYWxsKHRyYW5zLCB0cmFucyk7XG4gICAgICAgICAgICAgICAgaWYgKHJldHVyblZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzY29wZUZ1bmNJc0FzeW5jKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVjcmVtZW50b3IgPSBkZWNyZW1lbnRFeHBlY3RlZEF3YWl0cy5iaW5kKG51bGwsIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuVmFsdWUudGhlbihkZWNyZW1lbnRvciwgZGVjcmVtZW50b3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiByZXR1cm5WYWx1ZS5uZXh0ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiByZXR1cm5WYWx1ZS50aHJvdyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSBhd2FpdEl0ZXJhdG9yKHJldHVyblZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHpvbmVQcm9wcyk7XG4gICAgICAgICAgICByZXR1cm4gKHJldHVyblZhbHVlICYmIHR5cGVvZiByZXR1cm5WYWx1ZS50aGVuID09PSAnZnVuY3Rpb24nID9cbiAgICAgICAgICAgICAgICBEZXhpZVByb21pc2UucmVzb2x2ZShyZXR1cm5WYWx1ZSkudGhlbihmdW5jdGlvbiAoeCkgeyByZXR1cm4gdHJhbnMuYWN0aXZlID9cbiAgICAgICAgICAgICAgICAgICAgeFxuICAgICAgICAgICAgICAgICAgICA6IHJlamVjdGlvbihuZXcgZXhjZXB0aW9ucy5QcmVtYXR1cmVDb21taXQoXCJUcmFuc2FjdGlvbiBjb21taXR0ZWQgdG9vIGVhcmx5LiBTZWUgaHR0cDovL2JpdC5seS8ya2Rja01uXCIpKTsgfSlcbiAgICAgICAgICAgICAgICA6IHByb21pc2VGb2xsb3dlZC50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJldHVyblZhbHVlOyB9KSkudGhlbihmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnRUcmFuc2FjdGlvbilcbiAgICAgICAgICAgICAgICAgICAgdHJhbnMuX3Jlc29sdmUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJhbnMuX2NvbXBsZXRpb24udGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiB4OyB9KTtcbiAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgdHJhbnMuX3JlamVjdChlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0aW9uKGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhZChhLCB2YWx1ZSwgY291bnQpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGlzQXJyYXkoYSkgPyBhLnNsaWNlKCkgOiBbYV07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7ICsraSlcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlVmlydHVhbEluZGV4TWlkZGxld2FyZShkb3duKSB7XG4gICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZG93biksIHsgdGFibGU6IGZ1bmN0aW9uICh0YWJsZU5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFibGUgPSBkb3duLnRhYmxlKHRhYmxlTmFtZSk7XG4gICAgICAgICAgICAgICAgdmFyIHNjaGVtYSA9IHRhYmxlLnNjaGVtYTtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXhMb29rdXAgPSB7fTtcbiAgICAgICAgICAgICAgICB2YXIgYWxsVmlydHVhbEluZGV4ZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBhZGRWaXJ0dWFsSW5kZXhlcyhrZXlQYXRoLCBrZXlUYWlsLCBsb3dMZXZlbEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXlQYXRoQWxpYXMgPSBnZXRLZXlQYXRoQWxpYXMoa2V5UGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleExpc3QgPSAoaW5kZXhMb29rdXBba2V5UGF0aEFsaWFzXSA9IGluZGV4TG9va3VwW2tleVBhdGhBbGlhc10gfHwgW10pO1xuICAgICAgICAgICAgICAgICAgICB2YXIga2V5TGVuZ3RoID0ga2V5UGF0aCA9PSBudWxsID8gMCA6IHR5cGVvZiBrZXlQYXRoID09PSAnc3RyaW5nJyA/IDEgOiBrZXlQYXRoLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlzVmlydHVhbCA9IGtleVRhaWwgPiAwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmlydHVhbEluZGV4ID0gX19hc3NpZ24oX19hc3NpZ24oe30sIGxvd0xldmVsSW5kZXgpLCB7IG5hbWU6IGlzVmlydHVhbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gXCJcIi5jb25jYXQoa2V5UGF0aEFsaWFzLCBcIih2aXJ0dWFsLWZyb206XCIpLmNvbmNhdChsb3dMZXZlbEluZGV4Lm5hbWUsIFwiKVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogbG93TGV2ZWxJbmRleC5uYW1lLCBsb3dMZXZlbEluZGV4OiBsb3dMZXZlbEluZGV4LCBpc1ZpcnR1YWw6IGlzVmlydHVhbCwga2V5VGFpbDoga2V5VGFpbCwga2V5TGVuZ3RoOiBrZXlMZW5ndGgsIGV4dHJhY3RLZXk6IGdldEtleUV4dHJhY3RvcihrZXlQYXRoKSwgdW5pcXVlOiAhaXNWaXJ0dWFsICYmIGxvd0xldmVsSW5kZXgudW5pcXVlIH0pO1xuICAgICAgICAgICAgICAgICAgICBpbmRleExpc3QucHVzaCh2aXJ0dWFsSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXZpcnR1YWxJbmRleC5pc1ByaW1hcnlLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbFZpcnR1YWxJbmRleGVzLnB1c2godmlydHVhbEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5TGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZpcnR1YWxLZXlQYXRoID0ga2V5TGVuZ3RoID09PSAyID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlQYXRoWzBdIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlQYXRoLnNsaWNlKDAsIGtleUxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkVmlydHVhbEluZGV4ZXModmlydHVhbEtleVBhdGgsIGtleVRhaWwgKyAxLCBsb3dMZXZlbEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpbmRleExpc3Quc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5rZXlUYWlsIC0gYi5rZXlUYWlsOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZpcnR1YWxJbmRleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHByaW1hcnlLZXkgPSBhZGRWaXJ0dWFsSW5kZXhlcyhzY2hlbWEucHJpbWFyeUtleS5rZXlQYXRoLCAwLCBzY2hlbWEucHJpbWFyeUtleSk7XG4gICAgICAgICAgICAgICAgaW5kZXhMb29rdXBbXCI6aWRcIl0gPSBbcHJpbWFyeUtleV07XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHNjaGVtYS5pbmRleGVzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgICAgIGFkZFZpcnR1YWxJbmRleGVzKGluZGV4LmtleVBhdGgsIDAsIGluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZmluZEJlc3RJbmRleChrZXlQYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBpbmRleExvb2t1cFtnZXRLZXlQYXRoQWxpYXMoa2V5UGF0aCldO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0ICYmIHJlc3VsdFswXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gdHJhbnNsYXRlUmFuZ2UocmFuZ2UsIGtleVRhaWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHJhbmdlLnR5cGUgPT09IDEgID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAyICA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2UudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvd2VyOiBwYWQocmFuZ2UubG93ZXIsIHJhbmdlLmxvd2VyT3BlbiA/IGRvd24uTUFYX0tFWSA6IGRvd24uTUlOX0tFWSwga2V5VGFpbCksXG4gICAgICAgICAgICAgICAgICAgICAgICBsb3dlck9wZW46IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB1cHBlcjogcGFkKHJhbmdlLnVwcGVyLCByYW5nZS51cHBlck9wZW4gPyBkb3duLk1JTl9LRVkgOiBkb3duLk1BWF9LRVksIGtleVRhaWwpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXBwZXJPcGVuOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHRyYW5zbGF0ZVJlcXVlc3QocmVxKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHJlcS5xdWVyeS5pbmRleDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4LmlzVmlydHVhbCA/IF9fYXNzaWduKF9fYXNzaWduKHt9LCByZXEpLCB7IHF1ZXJ5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4Lmxvd0xldmVsSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IHRyYW5zbGF0ZVJhbmdlKHJlcS5xdWVyeS5yYW5nZSwgaW5kZXgua2V5VGFpbClcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gfSkgOiByZXE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgdGFibGUpLCB7IHNjaGVtYTogX19hc3NpZ24oX19hc3NpZ24oe30sIHNjaGVtYSksIHsgcHJpbWFyeUtleTogcHJpbWFyeUtleSwgaW5kZXhlczogYWxsVmlydHVhbEluZGV4ZXMsIGdldEluZGV4QnlLZXlQYXRoOiBmaW5kQmVzdEluZGV4IH0pLCBjb3VudDogZnVuY3Rpb24gKHJlcSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhYmxlLmNvdW50KHRyYW5zbGF0ZVJlcXVlc3QocmVxKSk7XG4gICAgICAgICAgICAgICAgICAgIH0sIHF1ZXJ5OiBmdW5jdGlvbiAocmVxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFibGUucXVlcnkodHJhbnNsYXRlUmVxdWVzdChyZXEpKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgb3BlbkN1cnNvcjogZnVuY3Rpb24gKHJlcSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hID0gcmVxLnF1ZXJ5LmluZGV4LCBrZXlUYWlsID0gX2Eua2V5VGFpbCwgaXNWaXJ0dWFsID0gX2EuaXNWaXJ0dWFsLCBrZXlMZW5ndGggPSBfYS5rZXlMZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzVmlydHVhbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFibGUub3BlbkN1cnNvcihyZXEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gY3JlYXRlVmlydHVhbEN1cnNvcihjdXJzb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBfY29udGludWUoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleSAhPSBudWxsID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5jb250aW51ZShwYWQoa2V5LCByZXEucmV2ZXJzZSA/IGRvd24uTUFYX0tFWSA6IGRvd24uTUlOX0tFWSwga2V5VGFpbCkpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS51bmlxdWUgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5jb250aW51ZShjdXJzb3Iua2V5LnNsaWNlKDAsIGtleUxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChyZXEucmV2ZXJzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGRvd24uTUlOX0tFWVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGRvd24uTUFYX0tFWSwga2V5VGFpbCkpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuY29udGludWUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZpcnR1YWxDdXJzb3IgPSBPYmplY3QuY3JlYXRlKGN1cnNvciwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTogeyB2YWx1ZTogX2NvbnRpbnVlIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlUHJpbWFyeUtleToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIChrZXksIHByaW1hcnlLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuY29udGludWVQcmltYXJ5S2V5KHBhZChrZXksIGRvd24uTUFYX0tFWSwga2V5VGFpbCksIHByaW1hcnlLZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmltYXJ5S2V5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3Vyc29yLnByaW1hcnlLZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IGN1cnNvci5rZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtleUxlbmd0aCA9PT0gMSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleVswXSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleS5zbGljZSgwLCBrZXlMZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1cnNvci52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2aXJ0dWFsQ3Vyc29yO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhYmxlLm9wZW5DdXJzb3IodHJhbnNsYXRlUmVxdWVzdChyZXEpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChjdXJzb3IpIHsgcmV0dXJuIGN1cnNvciAmJiBjcmVhdGVWaXJ0dWFsQ3Vyc29yKGN1cnNvcik7IH0pO1xuICAgICAgICAgICAgICAgICAgICB9IH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9IH0pO1xuICAgIH1cbiAgICB2YXIgdmlydHVhbEluZGV4TWlkZGxld2FyZSA9IHtcbiAgICAgICAgc3RhY2s6IFwiZGJjb3JlXCIsXG4gICAgICAgIG5hbWU6IFwiVmlydHVhbEluZGV4TWlkZGxld2FyZVwiLFxuICAgICAgICBsZXZlbDogMSxcbiAgICAgICAgY3JlYXRlOiBjcmVhdGVWaXJ0dWFsSW5kZXhNaWRkbGV3YXJlXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGdldE9iamVjdERpZmYoYSwgYiwgcnYsIHByZngpIHtcbiAgICAgICAgcnYgPSBydiB8fCB7fTtcbiAgICAgICAgcHJmeCA9IHByZnggfHwgJyc7XG4gICAgICAgIGtleXMoYSkuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd24oYiwgcHJvcCkpIHtcbiAgICAgICAgICAgICAgICBydltwcmZ4ICsgcHJvcF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgYXAgPSBhW3Byb3BdLCBicCA9IGJbcHJvcF07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhcCA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGJwID09PSAnb2JqZWN0JyAmJiBhcCAmJiBicCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXBUeXBlTmFtZSA9IHRvU3RyaW5nVGFnKGFwKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJwVHlwZU5hbWUgPSB0b1N0cmluZ1RhZyhicCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhcFR5cGVOYW1lICE9PSBicFR5cGVOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBydltwcmZ4ICsgcHJvcF0gPSBiW3Byb3BdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFwVHlwZU5hbWUgPT09ICdPYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRPYmplY3REaWZmKGFwLCBicCwgcnYsIHByZnggKyBwcm9wICsgJy4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChhcCAhPT0gYnApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ2W3ByZnggKyBwcm9wXSA9IGJbcHJvcF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYXAgIT09IGJwKVxuICAgICAgICAgICAgICAgICAgICBydltwcmZ4ICsgcHJvcF0gPSBiW3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAga2V5cyhiKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICBpZiAoIWhhc093bihhLCBwcm9wKSkge1xuICAgICAgICAgICAgICAgIHJ2W3ByZnggKyBwcm9wXSA9IGJbcHJvcF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcnY7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RWZmZWN0aXZlS2V5cyhwcmltYXJ5S2V5LCByZXEpIHtcbiAgICAgICAgaWYgKHJlcS50eXBlID09PSAnZGVsZXRlJylcbiAgICAgICAgICAgIHJldHVybiByZXEua2V5cztcbiAgICAgICAgcmV0dXJuIHJlcS5rZXlzIHx8IHJlcS52YWx1ZXMubWFwKHByaW1hcnlLZXkuZXh0cmFjdEtleSk7XG4gICAgfVxuXG4gICAgdmFyIGhvb2tzTWlkZGxld2FyZSA9IHtcbiAgICAgICAgc3RhY2s6IFwiZGJjb3JlXCIsXG4gICAgICAgIG5hbWU6IFwiSG9va3NNaWRkbGV3YXJlXCIsXG4gICAgICAgIGxldmVsOiAyLFxuICAgICAgICBjcmVhdGU6IGZ1bmN0aW9uIChkb3duQ29yZSkgeyByZXR1cm4gKF9fYXNzaWduKF9fYXNzaWduKHt9LCBkb3duQ29yZSksIHsgdGFibGU6IGZ1bmN0aW9uICh0YWJsZU5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZG93blRhYmxlID0gZG93bkNvcmUudGFibGUodGFibGVOYW1lKTtcbiAgICAgICAgICAgICAgICB2YXIgcHJpbWFyeUtleSA9IGRvd25UYWJsZS5zY2hlbWEucHJpbWFyeUtleTtcbiAgICAgICAgICAgICAgICB2YXIgdGFibGVNaWRkbGV3YXJlID0gX19hc3NpZ24oX19hc3NpZ24oe30sIGRvd25UYWJsZSksIHsgbXV0YXRlOiBmdW5jdGlvbiAocmVxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHhUcmFucyA9IFBTRC50cmFucztcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYSA9IGR4VHJhbnMudGFibGUodGFibGVOYW1lKS5ob29rLCBkZWxldGluZyA9IF9hLmRlbGV0aW5nLCBjcmVhdGluZyA9IF9hLmNyZWF0aW5nLCB1cGRhdGluZyA9IF9hLnVwZGF0aW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChyZXEudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2FkZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjcmVhdGluZy5maXJlID09PSBub3ApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGR4VHJhbnMuX3Byb21pc2UoJ3JlYWR3cml0ZScsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFkZFB1dE9yRGVsZXRlKHJlcSk7IH0sIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3B1dCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjcmVhdGluZy5maXJlID09PSBub3AgJiYgdXBkYXRpbmcuZmlyZSA9PT0gbm9wKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkeFRyYW5zLl9wcm9taXNlKCdyZWFkd3JpdGUnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBhZGRQdXRPckRlbGV0ZShyZXEpOyB9LCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdkZWxldGUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVsZXRpbmcuZmlyZSA9PT0gbm9wKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkeFRyYW5zLl9wcm9taXNlKCdyZWFkd3JpdGUnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBhZGRQdXRPckRlbGV0ZShyZXEpOyB9LCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdkZWxldGVSYW5nZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWxldGluZy5maXJlID09PSBub3ApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGR4VHJhbnMuX3Byb21pc2UoJ3JlYWR3cml0ZScsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRlbGV0ZVJhbmdlKHJlcSk7IH0sIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRvd25UYWJsZS5tdXRhdGUocmVxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGFkZFB1dE9yRGVsZXRlKHJlcSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkeFRyYW5zID0gUFNELnRyYW5zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXlzID0gcmVxLmtleXMgfHwgZ2V0RWZmZWN0aXZlS2V5cyhwcmltYXJ5S2V5LCByZXEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgha2V5cylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiS2V5cyBtaXNzaW5nXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcSA9IHJlcS50eXBlID09PSAnYWRkJyB8fCByZXEudHlwZSA9PT0gJ3B1dCcgPyBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcmVxKSwgeyBrZXlzOiBrZXlzIH0pIDogX19hc3NpZ24oe30sIHJlcSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcS50eXBlICE9PSAnZGVsZXRlJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLnZhbHVlcyA9IF9fc3ByZWFkQXJyYXkoW10sIHJlcS52YWx1ZXMsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXEua2V5cylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLmtleXMgPSBfX3NwcmVhZEFycmF5KFtdLCByZXEua2V5cywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldEV4aXN0aW5nVmFsdWVzKGRvd25UYWJsZSwgcmVxLCBrZXlzKS50aGVuKGZ1bmN0aW9uIChleGlzdGluZ1ZhbHVlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29udGV4dHMgPSBrZXlzLm1hcChmdW5jdGlvbiAoa2V5LCBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXhpc3RpbmdWYWx1ZSA9IGV4aXN0aW5nVmFsdWVzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN0eCA9IHsgb25lcnJvcjogbnVsbCwgb25zdWNjZXNzOiBudWxsIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVxLnR5cGUgPT09ICdkZWxldGUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRpbmcuZmlyZS5jYWxsKGN0eCwga2V5LCBleGlzdGluZ1ZhbHVlLCBkeFRyYW5zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlcS50eXBlID09PSAnYWRkJyB8fCBleGlzdGluZ1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZ2VuZXJhdGVkUHJpbWFyeUtleSA9IGNyZWF0aW5nLmZpcmUuY2FsbChjdHgsIGtleSwgcmVxLnZhbHVlc1tpXSwgZHhUcmFucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleSA9PSBudWxsICYmIGdlbmVyYXRlZFByaW1hcnlLZXkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXkgPSBnZW5lcmF0ZWRQcmltYXJ5S2V5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEua2V5c1tpXSA9IGtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwcmltYXJ5S2V5Lm91dGJvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRCeUtleVBhdGgocmVxLnZhbHVlc1tpXSwgcHJpbWFyeUtleS5rZXlQYXRoLCBrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9iamVjdERpZmYgPSBnZXRPYmplY3REaWZmKGV4aXN0aW5nVmFsdWUsIHJlcS52YWx1ZXNbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhZGRpdGlvbmFsQ2hhbmdlc18xID0gdXBkYXRpbmcuZmlyZS5jYWxsKGN0eCwgb2JqZWN0RGlmZiwga2V5LCBleGlzdGluZ1ZhbHVlLCBkeFRyYW5zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWRkaXRpb25hbENoYW5nZXNfMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVxdWVzdGVkVmFsdWVfMSA9IHJlcS52YWx1ZXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGFkZGl0aW9uYWxDaGFuZ2VzXzEpLmZvckVhY2goZnVuY3Rpb24gKGtleVBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNPd24ocmVxdWVzdGVkVmFsdWVfMSwga2V5UGF0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0ZWRWYWx1ZV8xW2tleVBhdGhdID0gYWRkaXRpb25hbENoYW5nZXNfMVtrZXlQYXRoXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEJ5S2V5UGF0aChyZXF1ZXN0ZWRWYWx1ZV8xLCBrZXlQYXRoLCBhZGRpdGlvbmFsQ2hhbmdlc18xW2tleVBhdGhdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN0eDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkb3duVGFibGUubXV0YXRlKHJlcSkudGhlbihmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmYWlsdXJlcyA9IF9hLmZhaWx1cmVzLCByZXN1bHRzID0gX2EucmVzdWx0cywgbnVtRmFpbHVyZXMgPSBfYS5udW1GYWlsdXJlcywgbGFzdFJlc3VsdCA9IF9hLmxhc3RSZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJpbUtleSA9IHJlc3VsdHMgPyByZXN1bHRzW2ldIDoga2V5c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3R4ID0gY29udGV4dHNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByaW1LZXkgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHgub25lcnJvciAmJiBjdHgub25lcnJvcihmYWlsdXJlc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHgub25zdWNjZXNzICYmIGN0eC5vbnN1Y2Nlc3MocmVxLnR5cGUgPT09ICdwdXQnICYmIGV4aXN0aW5nVmFsdWVzW2ldID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS52YWx1ZXNbaV0gOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpbUtleVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGZhaWx1cmVzOiBmYWlsdXJlcywgcmVzdWx0czogcmVzdWx0cywgbnVtRmFpbHVyZXM6IG51bUZhaWx1cmVzLCBsYXN0UmVzdWx0OiBsYXN0UmVzdWx0IH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dHMuZm9yRWFjaChmdW5jdGlvbiAoY3R4KSB7IHJldHVybiBjdHgub25lcnJvciAmJiBjdHgub25lcnJvcihlcnJvcik7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBkZWxldGVSYW5nZShyZXEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVsZXRlTmV4dENodW5rKHJlcS50cmFucywgcmVxLnJhbmdlLCAxMDAwMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBkZWxldGVOZXh0Q2h1bmsodHJhbnMsIHJhbmdlLCBsaW1pdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkb3duVGFibGUucXVlcnkoeyB0cmFuczogdHJhbnMsIHZhbHVlczogZmFsc2UsIHF1ZXJ5OiB7IGluZGV4OiBwcmltYXJ5S2V5LCByYW5nZTogcmFuZ2UgfSwgbGltaXQ6IGxpbWl0IH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gX2EucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWRkUHV0T3JEZWxldGUoeyB0eXBlOiAnZGVsZXRlJywga2V5czogcmVzdWx0LCB0cmFuczogdHJhbnMgfSkudGhlbihmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzLm51bUZhaWx1cmVzID4gMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QocmVzLmZhaWx1cmVzWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoIDwgbGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBmYWlsdXJlczogW10sIG51bUZhaWx1cmVzOiAwLCBsYXN0UmVzdWx0OiB1bmRlZmluZWQgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWxldGVOZXh0Q2h1bmsodHJhbnMsIF9fYXNzaWduKF9fYXNzaWduKHt9LCByYW5nZSksIHsgbG93ZXI6IHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0sIGxvd2VyT3BlbjogdHJ1ZSB9KSwgbGltaXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFibGVNaWRkbGV3YXJlO1xuICAgICAgICAgICAgfSB9KSk7IH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIGdldEV4aXN0aW5nVmFsdWVzKHRhYmxlLCByZXEsIGVmZmVjdGl2ZUtleXMpIHtcbiAgICAgICAgcmV0dXJuIHJlcS50eXBlID09PSBcImFkZFwiXG4gICAgICAgICAgICA/IFByb21pc2UucmVzb2x2ZShbXSlcbiAgICAgICAgICAgIDogdGFibGUuZ2V0TWFueSh7IHRyYW5zOiByZXEudHJhbnMsIGtleXM6IGVmZmVjdGl2ZUtleXMsIGNhY2hlOiBcImltbXV0YWJsZVwiIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEZyb21UcmFuc2FjdGlvbkNhY2hlKGtleXMsIGNhY2hlLCBjbG9uZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCFjYWNoZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGlmIChjYWNoZS5rZXlzLmxlbmd0aCA8IGtleXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSAwOyBpIDwgY2FjaGUua2V5cy5sZW5ndGggJiYgaiA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAoY21wKGNhY2hlLmtleXNbaV0sIGtleXNbal0pICE9PSAwKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjbG9uZSA/IGRlZXBDbG9uZShjYWNoZS52YWx1ZXNbaV0pIDogY2FjaGUudmFsdWVzW2ldKTtcbiAgICAgICAgICAgICAgICArK2o7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0Lmxlbmd0aCA9PT0ga2V5cy5sZW5ndGggPyByZXN1bHQgOiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfYSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIGNhY2hlRXhpc3RpbmdWYWx1ZXNNaWRkbGV3YXJlID0ge1xuICAgICAgICBzdGFjazogXCJkYmNvcmVcIixcbiAgICAgICAgbGV2ZWw6IC0xLFxuICAgICAgICBjcmVhdGU6IGZ1bmN0aW9uIChjb3JlKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRhYmxlOiBmdW5jdGlvbiAodGFibGVOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0YWJsZSA9IGNvcmUudGFibGUodGFibGVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCB0YWJsZSksIHsgZ2V0TWFueTogZnVuY3Rpb24gKHJlcSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmVxLmNhY2hlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YWJsZS5nZXRNYW55KHJlcSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjYWNoZWRSZXN1bHQgPSBnZXRGcm9tVHJhbnNhY3Rpb25DYWNoZShyZXEua2V5cywgcmVxLnRyYW5zW1wiX2NhY2hlXCJdLCByZXEuY2FjaGUgPT09IFwiY2xvbmVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhY2hlZFJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gRGV4aWVQcm9taXNlLnJlc29sdmUoY2FjaGVkUmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhYmxlLmdldE1hbnkocmVxKS50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLnRyYW5zW1wiX2NhY2hlXCJdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5czogcmVxLmtleXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXM6IHJlcS5jYWNoZSA9PT0gXCJjbG9uZVwiID8gZGVlcENsb25lKHJlcykgOiByZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBtdXRhdGU6IGZ1bmN0aW9uIChyZXEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVxLnR5cGUgIT09IFwiYWRkXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS50cmFuc1tcIl9jYWNoZVwiXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhYmxlLm11dGF0ZShyZXEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSB9KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gaXNDYWNoYWJsZUNvbnRleHQoY3R4LCB0YWJsZSkge1xuICAgICAgICByZXR1cm4gKGN0eC50cmFucy5tb2RlID09PSAncmVhZG9ubHknICYmXG4gICAgICAgICAgICAhIWN0eC5zdWJzY3IgJiZcbiAgICAgICAgICAgICFjdHgudHJhbnMuZXhwbGljaXQgJiZcbiAgICAgICAgICAgIGN0eC50cmFucy5kYi5fb3B0aW9ucy5jYWNoZSAhPT0gJ2Rpc2FibGVkJyAmJlxuICAgICAgICAgICAgIXRhYmxlLnNjaGVtYS5wcmltYXJ5S2V5Lm91dGJvdW5kKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0NhY2hhYmxlUmVxdWVzdCh0eXBlLCByZXEpIHtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdxdWVyeSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcS52YWx1ZXMgJiYgIXJlcS51bmlxdWU7XG4gICAgICAgICAgICBjYXNlICdnZXQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGNhc2UgJ2dldE1hbnknOlxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGNhc2UgJ2NvdW50JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBjYXNlICdvcGVuQ3Vyc29yJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgb2JzZXJ2YWJpbGl0eU1pZGRsZXdhcmUgPSB7XG4gICAgICAgIHN0YWNrOiBcImRiY29yZVwiLFxuICAgICAgICBsZXZlbDogMCxcbiAgICAgICAgbmFtZTogXCJPYnNlcnZhYmlsaXR5XCIsXG4gICAgICAgIGNyZWF0ZTogZnVuY3Rpb24gKGNvcmUpIHtcbiAgICAgICAgICAgIHZhciBkYk5hbWUgPSBjb3JlLnNjaGVtYS5uYW1lO1xuICAgICAgICAgICAgdmFyIEZVTExfUkFOR0UgPSBuZXcgUmFuZ2VTZXQoY29yZS5NSU5fS0VZLCBjb3JlLk1BWF9LRVkpO1xuICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBjb3JlKSwgeyB0cmFuc2FjdGlvbjogZnVuY3Rpb24gKHN0b3JlcywgbW9kZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoUFNELnN1YnNjciAmJiBtb2RlICE9PSAncmVhZG9ubHknKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5SZWFkT25seShcIlJlYWR3cml0ZSB0cmFuc2FjdGlvbiBpbiBsaXZlUXVlcnkgY29udGV4dC4gUXVlcmllciBzb3VyY2U6IFwiLmNvbmNhdChQU0QucXVlcmllcikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb3JlLnRyYW5zYWN0aW9uKHN0b3JlcywgbW9kZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfSwgdGFibGU6IGZ1bmN0aW9uICh0YWJsZU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhYmxlID0gY29yZS50YWJsZSh0YWJsZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2NoZW1hID0gdGFibGUuc2NoZW1hO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJpbWFyeUtleSA9IHNjaGVtYS5wcmltYXJ5S2V5LCBpbmRleGVzID0gc2NoZW1hLmluZGV4ZXM7XG4gICAgICAgICAgICAgICAgICAgIHZhciBleHRyYWN0S2V5ID0gcHJpbWFyeUtleS5leHRyYWN0S2V5LCBvdXRib3VuZCA9IHByaW1hcnlLZXkub3V0Ym91bmQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleGVzV2l0aEF1dG9JbmNQSyA9IHByaW1hcnlLZXkuYXV0b0luY3JlbWVudCAmJiBpbmRleGVzLmZpbHRlcihmdW5jdGlvbiAoaW5kZXgpIHsgcmV0dXJuIGluZGV4LmNvbXBvdW5kICYmIGluZGV4LmtleVBhdGguaW5jbHVkZXMocHJpbWFyeUtleS5rZXlQYXRoKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0YWJsZUNsb25lID0gX19hc3NpZ24oX19hc3NpZ24oe30sIHRhYmxlKSwgeyBtdXRhdGU6IGZ1bmN0aW9uIChyZXEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0cmFucyA9IHJlcS50cmFucztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbXV0YXRlZFBhcnRzID0gcmVxLm11dGF0ZWRQYXJ0cyB8fCAocmVxLm11dGF0ZWRQYXJ0cyA9IHt9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZ2V0UmFuZ2VTZXQgPSBmdW5jdGlvbiAoaW5kZXhOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJ0ID0gXCJpZGI6Ly9cIi5jb25jYXQoZGJOYW1lLCBcIi9cIikuY29uY2F0KHRhYmxlTmFtZSwgXCIvXCIpLmNvbmNhdChpbmRleE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKG11dGF0ZWRQYXJ0c1twYXJ0XSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG11dGF0ZWRQYXJ0c1twYXJ0XSA9IG5ldyBSYW5nZVNldCgpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGtSYW5nZVNldCA9IGdldFJhbmdlU2V0KFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWxzUmFuZ2VTZXQgPSBnZXRSYW5nZVNldChcIjpkZWxzXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0eXBlID0gcmVxLnR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9jID0gcmVxLnR5cGUgPT09IFwiZGVsZXRlUmFuZ2VcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IFtyZXEucmFuZ2VdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogcmVxLnR5cGUgPT09IFwiZGVsZXRlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gW3JlcS5rZXlzXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiByZXEudmFsdWVzLmxlbmd0aCA8IDUwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBbZ2V0RWZmZWN0aXZlS2V5cyhwcmltYXJ5S2V5LCByZXEpLmZpbHRlcihmdW5jdGlvbiAoaWQpIHsgcmV0dXJuIGlkOyB9KSwgcmVxLnZhbHVlc11cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFtdLCBrZXlzID0gX2NbMF0sIG5ld09ianMgPSBfY1sxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2xkQ2FjaGUgPSByZXEudHJhbnNbXCJfY2FjaGVcIl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQXJyYXkoa2V5cykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGtSYW5nZVNldC5hZGRLZXlzKGtleXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2xkT2JqcyA9IHR5cGUgPT09ICdkZWxldGUnIHx8IGtleXMubGVuZ3RoID09PSBuZXdPYmpzLmxlbmd0aCA/IGdldEZyb21UcmFuc2FjdGlvbkNhY2hlKGtleXMsIG9sZENhY2hlKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb2xkT2Jqcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsc1JhbmdlU2V0LmFkZEtleXMoa2V5cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9sZE9ianMgfHwgbmV3T2Jqcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2tBZmZlY3RlZEluZGV4ZXMoZ2V0UmFuZ2VTZXQsIHNjaGVtYSwgb2xkT2JqcywgbmV3T2Jqcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoa2V5cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tOiAoX2EgPSBrZXlzLmxvd2VyKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjb3JlLk1JTl9LRVksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bzogKF9iID0ga2V5cy51cHBlcikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogY29yZS5NQVhfS0VZXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbHNSYW5nZVNldC5hZGQocmFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwa1JhbmdlU2V0LmFkZChyYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwa1JhbmdlU2V0LmFkZChGVUxMX1JBTkdFKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsc1JhbmdlU2V0LmFkZChGVUxMX1JBTkdFKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NoZW1hLmluZGV4ZXMuZm9yRWFjaChmdW5jdGlvbiAoaWR4KSB7IHJldHVybiBnZXRSYW5nZVNldChpZHgubmFtZSkuYWRkKEZVTExfUkFOR0UpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhYmxlLm11dGF0ZShyZXEpLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5cyAmJiAocmVxLnR5cGUgPT09ICdhZGQnIHx8IHJlcS50eXBlID09PSAncHV0JykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBrUmFuZ2VTZXQuYWRkS2V5cyhyZXMucmVzdWx0cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXhlc1dpdGhBdXRvSW5jUEspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleGVzV2l0aEF1dG9JbmNQSy5mb3JFYWNoKGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlkeFZhbHMgPSByZXEudmFsdWVzLm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gaWR4LmV4dHJhY3RLZXkodik7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGtQb3MgPSBpZHgua2V5UGF0aC5maW5kSW5kZXgoZnVuY3Rpb24gKHByb3ApIHsgcmV0dXJuIHByb3AgPT09IHByaW1hcnlLZXkua2V5UGF0aDsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSByZXMucmVzdWx0cy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWR4VmFsc1tpXVtwa1Bvc10gPSByZXMucmVzdWx0c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRSYW5nZVNldChpZHgubmFtZSkuYWRkS2V5cyhpZHhWYWxzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFucy5tdXRhdGVkUGFydHMgPSBleHRlbmRPYnNlcnZhYmlsaXR5U2V0KHRyYW5zLm11dGF0ZWRQYXJ0cyB8fCB7fSwgbXV0YXRlZFBhcnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gfSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBnZXRSYW5nZSA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9iLCBfYztcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfZCA9IF9hLnF1ZXJ5LCBpbmRleCA9IF9kLmluZGV4LCByYW5nZSA9IF9kLnJhbmdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgUmFuZ2VTZXQoKF9iID0gcmFuZ2UubG93ZXIpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGNvcmUuTUlOX0tFWSwgKF9jID0gcmFuZ2UudXBwZXIpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IGNvcmUuTUFYX0tFWSksXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVhZFN1YnNjcmliZXJzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAocmVxKSB7IHJldHVybiBbcHJpbWFyeUtleSwgbmV3IFJhbmdlU2V0KHJlcS5rZXkpXTsgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldE1hbnk6IGZ1bmN0aW9uIChyZXEpIHsgcmV0dXJuIFtwcmltYXJ5S2V5LCBuZXcgUmFuZ2VTZXQoKS5hZGRLZXlzKHJlcS5rZXlzKV07IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudDogZ2V0UmFuZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeTogZ2V0UmFuZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVuQ3Vyc29yOiBnZXRSYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAga2V5cyhyZWFkU3Vic2NyaWJlcnMpLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFibGVDbG9uZVttZXRob2RdID0gZnVuY3Rpb24gKHJlcSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdWJzY3IgPSBQU0Quc3Vic2NyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpc0xpdmVRdWVyeSA9ICEhc3Vic2NyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjYWNoYWJsZSA9IGlzQ2FjaGFibGVDb250ZXh0KFBTRCwgdGFibGUpICYmIGlzQ2FjaGFibGVSZXF1ZXN0KG1ldGhvZCwgcmVxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2JzU2V0ID0gY2FjaGFibGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyByZXEub2JzU2V0ID0ge31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBzdWJzY3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzTGl2ZVF1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBnZXRSYW5nZVNldCA9IGZ1bmN0aW9uIChpbmRleE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJ0ID0gXCJpZGI6Ly9cIi5jb25jYXQoZGJOYW1lLCBcIi9cIikuY29uY2F0KHRhYmxlTmFtZSwgXCIvXCIpLmNvbmNhdChpbmRleE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChvYnNTZXRbcGFydF0gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAob2JzU2V0W3BhcnRdID0gbmV3IFJhbmdlU2V0KCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBrUmFuZ2VTZXRfMSA9IGdldFJhbmdlU2V0KFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVsc1JhbmdlU2V0XzEgPSBnZXRSYW5nZVNldChcIjpkZWxzXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2EgPSByZWFkU3Vic2NyaWJlcnNbbWV0aG9kXShyZXEpLCBxdWVyaWVkSW5kZXggPSBfYVswXSwgcXVlcmllZFJhbmdlcyA9IF9hWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWV0aG9kID09PSAncXVlcnknICYmIHF1ZXJpZWRJbmRleC5pc1ByaW1hcnlLZXkgJiYgIXJlcS52YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbHNSYW5nZVNldF8xLmFkZChxdWVyaWVkUmFuZ2VzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFJhbmdlU2V0KHF1ZXJpZWRJbmRleC5uYW1lIHx8IFwiXCIpLmFkZChxdWVyaWVkUmFuZ2VzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXF1ZXJpZWRJbmRleC5pc1ByaW1hcnlLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXRob2QgPT09IFwiY291bnRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbHNSYW5nZVNldF8xLmFkZChGVUxMX1JBTkdFKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXlzUHJvbWlzZV8xID0gbWV0aG9kID09PSBcInF1ZXJ5XCIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0Ym91bmQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLnZhbHVlcyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWJsZS5xdWVyeShfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcmVxKSwgeyB2YWx1ZXM6IGZhbHNlIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFibGVbbWV0aG9kXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWV0aG9kID09PSBcInF1ZXJ5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdXRib3VuZCAmJiByZXEudmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtleXNQcm9taXNlXzEudGhlbihmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdGluZ0tleXMgPSBfYS5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBrUmFuZ2VTZXRfMS5hZGRLZXlzKHJlc3VsdGluZ0tleXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBLZXlzID0gcmVxLnZhbHVlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gcmVzLnJlc3VsdC5tYXAoZXh0cmFjdEtleSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHJlcy5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVxLnZhbHVlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBrUmFuZ2VTZXRfMS5hZGRLZXlzKHBLZXlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbHNSYW5nZVNldF8xLmFkZEtleXMocEtleXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1ldGhvZCA9PT0gXCJvcGVuQ3Vyc29yXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJzb3JfMSA9IHJlcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3YW50VmFsdWVzXzEgPSByZXEudmFsdWVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChjdXJzb3JfMSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5jcmVhdGUoY3Vyc29yXzEsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxzUmFuZ2VTZXRfMS5hZGRLZXkoY3Vyc29yXzEucHJpbWFyeUtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1cnNvcl8xLmtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaW1hcnlLZXk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwa2V5ID0gY3Vyc29yXzEucHJpbWFyeUtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxzUmFuZ2VTZXRfMS5hZGRLZXkocGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBrZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FudFZhbHVlc18xICYmIHBrUmFuZ2VTZXRfMS5hZGRLZXkoY3Vyc29yXzEucHJpbWFyeUtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1cnNvcl8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFibGVbbWV0aG9kXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0YWJsZUNsb25lO1xuICAgICAgICAgICAgICAgIH0gfSk7XG4gICAgICAgIH0sXG4gICAgfTtcbiAgICBmdW5jdGlvbiB0cmFja0FmZmVjdGVkSW5kZXhlcyhnZXRSYW5nZVNldCwgc2NoZW1hLCBvbGRPYmpzLCBuZXdPYmpzKSB7XG4gICAgICAgIGZ1bmN0aW9uIGFkZEFmZmVjdGVkSW5kZXgoaXgpIHtcbiAgICAgICAgICAgIHZhciByYW5nZVNldCA9IGdldFJhbmdlU2V0KGl4Lm5hbWUgfHwgXCJcIik7XG4gICAgICAgICAgICBmdW5jdGlvbiBleHRyYWN0S2V5KG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmogIT0gbnVsbCA/IGl4LmV4dHJhY3RLZXkob2JqKSA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYWRkS2V5T3JLZXlzID0gZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gaXgubXVsdGlFbnRyeSAmJiBpc0FycmF5KGtleSlcbiAgICAgICAgICAgICAgICA/IGtleS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIHJhbmdlU2V0LmFkZEtleShrZXkpOyB9KVxuICAgICAgICAgICAgICAgIDogcmFuZ2VTZXQuYWRkS2V5KGtleSk7IH07XG4gICAgICAgICAgICAob2xkT2JqcyB8fCBuZXdPYmpzKS5mb3JFYWNoKGZ1bmN0aW9uIChfLCBpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9sZEtleSA9IG9sZE9ianMgJiYgZXh0cmFjdEtleShvbGRPYmpzW2ldKTtcbiAgICAgICAgICAgICAgICB2YXIgbmV3S2V5ID0gbmV3T2JqcyAmJiBleHRyYWN0S2V5KG5ld09ianNbaV0pO1xuICAgICAgICAgICAgICAgIGlmIChjbXAob2xkS2V5LCBuZXdLZXkpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvbGRLZXkgIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZEtleU9yS2V5cyhvbGRLZXkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV3S2V5ICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRLZXlPcktleXMobmV3S2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzY2hlbWEuaW5kZXhlcy5mb3JFYWNoKGFkZEFmZmVjdGVkSW5kZXgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkanVzdE9wdGltaXN0aWNGcm9tRmFpbHVyZXModGJsQ2FjaGUsIHJlcSwgcmVzKSB7XG4gICAgICAgIGlmIChyZXMubnVtRmFpbHVyZXMgPT09IDApXG4gICAgICAgICAgICByZXR1cm4gcmVxO1xuICAgICAgICBpZiAocmVxLnR5cGUgPT09ICdkZWxldGVSYW5nZScpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBudW1CdWxrT3BzID0gcmVxLmtleXNcbiAgICAgICAgICAgID8gcmVxLmtleXMubGVuZ3RoXG4gICAgICAgICAgICA6ICd2YWx1ZXMnIGluIHJlcSAmJiByZXEudmFsdWVzXG4gICAgICAgICAgICAgICAgPyByZXEudmFsdWVzLmxlbmd0aFxuICAgICAgICAgICAgICAgIDogMTtcbiAgICAgICAgaWYgKHJlcy5udW1GYWlsdXJlcyA9PT0gbnVtQnVsa09wcykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNsb25lID0gX19hc3NpZ24oe30sIHJlcSk7XG4gICAgICAgIGlmIChpc0FycmF5KGNsb25lLmtleXMpKSB7XG4gICAgICAgICAgICBjbG9uZS5rZXlzID0gY2xvbmUua2V5cy5maWx0ZXIoZnVuY3Rpb24gKF8sIGkpIHsgcmV0dXJuICEoaSBpbiByZXMuZmFpbHVyZXMpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJ3ZhbHVlcycgaW4gY2xvbmUgJiYgaXNBcnJheShjbG9uZS52YWx1ZXMpKSB7XG4gICAgICAgICAgICBjbG9uZS52YWx1ZXMgPSBjbG9uZS52YWx1ZXMuZmlsdGVyKGZ1bmN0aW9uIChfLCBpKSB7IHJldHVybiAhKGkgaW4gcmVzLmZhaWx1cmVzKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNsb25lO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQWJvdmVMb3dlcihrZXksIHJhbmdlKSB7XG4gICAgICAgIHJldHVybiByYW5nZS5sb3dlciA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IHRydWVcbiAgICAgICAgICAgIDogcmFuZ2UubG93ZXJPcGVuXG4gICAgICAgICAgICAgICAgPyBjbXAoa2V5LCByYW5nZS5sb3dlcikgPiAwXG4gICAgICAgICAgICAgICAgOiBjbXAoa2V5LCByYW5nZS5sb3dlcikgPj0gMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNCZWxvd1VwcGVyKGtleSwgcmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIHJhbmdlLnVwcGVyID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gdHJ1ZVxuICAgICAgICAgICAgOiByYW5nZS51cHBlck9wZW5cbiAgICAgICAgICAgICAgICA/IGNtcChrZXksIHJhbmdlLnVwcGVyKSA8IDBcbiAgICAgICAgICAgICAgICA6IGNtcChrZXksIHJhbmdlLnVwcGVyKSA8PSAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc1dpdGhpblJhbmdlKGtleSwgcmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIGlzQWJvdmVMb3dlcihrZXksIHJhbmdlKSAmJiBpc0JlbG93VXBwZXIoa2V5LCByYW5nZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXBwbHlPcHRpbWlzdGljT3BzKHJlc3VsdCwgcmVxLCBvcHMsIHRhYmxlLCBjYWNoZUVudHJ5LCBpbW11dGFibGUpIHtcbiAgICAgICAgaWYgKCFvcHMgfHwgb3BzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIHZhciBpbmRleCA9IHJlcS5xdWVyeS5pbmRleDtcbiAgICAgICAgdmFyIG11bHRpRW50cnkgPSBpbmRleC5tdWx0aUVudHJ5O1xuICAgICAgICB2YXIgcXVlcnlSYW5nZSA9IHJlcS5xdWVyeS5yYW5nZTtcbiAgICAgICAgdmFyIHByaW1hcnlLZXkgPSB0YWJsZS5zY2hlbWEucHJpbWFyeUtleTtcbiAgICAgICAgdmFyIGV4dHJhY3RQcmltS2V5ID0gcHJpbWFyeUtleS5leHRyYWN0S2V5O1xuICAgICAgICB2YXIgZXh0cmFjdEluZGV4ID0gaW5kZXguZXh0cmFjdEtleTtcbiAgICAgICAgdmFyIGV4dHJhY3RMb3dMZXZlbEluZGV4ID0gKGluZGV4Lmxvd0xldmVsSW5kZXggfHwgaW5kZXgpLmV4dHJhY3RLZXk7XG4gICAgICAgIHZhciBmaW5hbFJlc3VsdCA9IG9wcy5yZWR1Y2UoZnVuY3Rpb24gKHJlc3VsdCwgb3ApIHtcbiAgICAgICAgICAgIHZhciBtb2RpZmVkUmVzdWx0ID0gcmVzdWx0O1xuICAgICAgICAgICAgdmFyIGluY2x1ZGVkVmFsdWVzID0gW107XG4gICAgICAgICAgICBpZiAob3AudHlwZSA9PT0gJ2FkZCcgfHwgb3AudHlwZSA9PT0gJ3B1dCcpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5jbHVkZWRQS3MgPSBuZXcgUmFuZ2VTZXQoKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gb3AudmFsdWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IG9wLnZhbHVlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBrID0gZXh0cmFjdFByaW1LZXkodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5jbHVkZWRQS3MuaGFzS2V5KHBrKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gZXh0cmFjdEluZGV4KHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG11bHRpRW50cnkgJiYgaXNBcnJheShrZXkpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGtleS5zb21lKGZ1bmN0aW9uIChrKSB7IHJldHVybiBpc1dpdGhpblJhbmdlKGssIHF1ZXJ5UmFuZ2UpOyB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBpc1dpdGhpblJhbmdlKGtleSwgcXVlcnlSYW5nZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1ZGVkUEtzLmFkZEtleShwayk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNsdWRlZFZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAob3AudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2FkZCc6IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGV4aXN0aW5nS2V5c18xID0gbmV3IFJhbmdlU2V0KCkuYWRkS2V5cyhyZXEudmFsdWVzID8gcmVzdWx0Lm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gZXh0cmFjdFByaW1LZXkodik7IH0pIDogcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgbW9kaWZlZFJlc3VsdCA9IHJlc3VsdC5jb25jYXQocmVxLnZhbHVlc1xuICAgICAgICAgICAgICAgICAgICAgICAgPyBpbmNsdWRlZFZhbHVlcy5maWx0ZXIoZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gZXh0cmFjdFByaW1LZXkodik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nS2V5c18xLmhhc0tleShrZXkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmdLZXlzXzEuYWRkS2V5KGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBpbmNsdWRlZFZhbHVlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIGV4dHJhY3RQcmltS2V5KHYpOyB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdLZXlzXzEuaGFzS2V5KGspKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmdLZXlzXzEuYWRkS2V5KGspO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAncHV0Jzoge1xuICAgICAgICAgICAgICAgICAgICB2YXIga2V5U2V0XzEgPSBuZXcgUmFuZ2VTZXQoKS5hZGRLZXlzKG9wLnZhbHVlcy5tYXAoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIGV4dHJhY3RQcmltS2V5KHYpOyB9KSk7XG4gICAgICAgICAgICAgICAgICAgIG1vZGlmZWRSZXN1bHQgPSByZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiAha2V5U2V0XzEuaGFzS2V5KHJlcS52YWx1ZXMgPyBleHRyYWN0UHJpbUtleShpdGVtKSA6IGl0ZW0pOyB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChcbiAgICAgICAgICAgICAgICAgICAgcmVxLnZhbHVlc1xuICAgICAgICAgICAgICAgICAgICAgICAgPyBpbmNsdWRlZFZhbHVlc1xuICAgICAgICAgICAgICAgICAgICAgICAgOiBpbmNsdWRlZFZhbHVlcy5tYXAoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIGV4dHJhY3RQcmltS2V5KHYpOyB9KSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdkZWxldGUnOlxuICAgICAgICAgICAgICAgICAgICB2YXIga2V5c1RvRGVsZXRlXzEgPSBuZXcgUmFuZ2VTZXQoKS5hZGRLZXlzKG9wLmtleXMpO1xuICAgICAgICAgICAgICAgICAgICBtb2RpZmVkUmVzdWx0ID0gcmVzdWx0LmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFrZXlzVG9EZWxldGVfMS5oYXNLZXkocmVxLnZhbHVlcyA/IGV4dHJhY3RQcmltS2V5KGl0ZW0pIDogaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdkZWxldGVSYW5nZSc6XG4gICAgICAgICAgICAgICAgICAgIHZhciByYW5nZV8xID0gb3AucmFuZ2U7XG4gICAgICAgICAgICAgICAgICAgIG1vZGlmZWRSZXN1bHQgPSByZXN1bHQuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiAhaXNXaXRoaW5SYW5nZShleHRyYWN0UHJpbUtleShpdGVtKSwgcmFuZ2VfMSk7IH0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtb2RpZmVkUmVzdWx0O1xuICAgICAgICB9LCByZXN1bHQpO1xuICAgICAgICBpZiAoZmluYWxSZXN1bHQgPT09IHJlc3VsdClcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIGZpbmFsUmVzdWx0LnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBjbXAoZXh0cmFjdExvd0xldmVsSW5kZXgoYSksIGV4dHJhY3RMb3dMZXZlbEluZGV4KGIpKSB8fFxuICAgICAgICAgICAgICAgIGNtcChleHRyYWN0UHJpbUtleShhKSwgZXh0cmFjdFByaW1LZXkoYikpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHJlcS5saW1pdCAmJiByZXEubGltaXQgPCBJbmZpbml0eSkge1xuICAgICAgICAgICAgaWYgKGZpbmFsUmVzdWx0Lmxlbmd0aCA+IHJlcS5saW1pdCkge1xuICAgICAgICAgICAgICAgIGZpbmFsUmVzdWx0Lmxlbmd0aCA9IHJlcS5saW1pdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJlc3VsdC5sZW5ndGggPT09IHJlcS5saW1pdCAmJiBmaW5hbFJlc3VsdC5sZW5ndGggPCByZXEubGltaXQpIHtcbiAgICAgICAgICAgICAgICBjYWNoZUVudHJ5LmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW1tdXRhYmxlID8gT2JqZWN0LmZyZWV6ZShmaW5hbFJlc3VsdCkgOiBmaW5hbFJlc3VsdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcmVSYW5nZXNFcXVhbChyMSwgcjIpIHtcbiAgICAgICAgcmV0dXJuIChjbXAocjEubG93ZXIsIHIyLmxvd2VyKSA9PT0gMCAmJlxuICAgICAgICAgICAgY21wKHIxLnVwcGVyLCByMi51cHBlcikgPT09IDAgJiZcbiAgICAgICAgICAgICEhcjEubG93ZXJPcGVuID09PSAhIXIyLmxvd2VyT3BlbiAmJlxuICAgICAgICAgICAgISFyMS51cHBlck9wZW4gPT09ICEhcjIudXBwZXJPcGVuKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wYXJlTG93ZXJzKGxvd2VyMSwgbG93ZXIyLCBsb3dlck9wZW4xLCBsb3dlck9wZW4yKSB7XG4gICAgICAgIGlmIChsb3dlcjEgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiBsb3dlcjIgIT09IHVuZGVmaW5lZCA/IC0xIDogMDtcbiAgICAgICAgaWYgKGxvd2VyMiA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIHZhciBjID0gY21wKGxvd2VyMSwgbG93ZXIyKTtcbiAgICAgICAgaWYgKGMgPT09IDApIHtcbiAgICAgICAgICAgIGlmIChsb3dlck9wZW4xICYmIGxvd2VyT3BlbjIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICBpZiAobG93ZXJPcGVuMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIGlmIChsb3dlck9wZW4yKVxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYztcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tcGFyZVVwcGVycyh1cHBlcjEsIHVwcGVyMiwgdXBwZXJPcGVuMSwgdXBwZXJPcGVuMikge1xuICAgICAgICBpZiAodXBwZXIxID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gdXBwZXIyICE9PSB1bmRlZmluZWQgPyAxIDogMDtcbiAgICAgICAgaWYgKHVwcGVyMiA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB2YXIgYyA9IGNtcCh1cHBlcjEsIHVwcGVyMik7XG4gICAgICAgIGlmIChjID09PSAwKSB7XG4gICAgICAgICAgICBpZiAodXBwZXJPcGVuMSAmJiB1cHBlck9wZW4yKVxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgaWYgKHVwcGVyT3BlbjEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgaWYgKHVwcGVyT3BlbjIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzU3VwZXJSYW5nZShyMSwgcjIpIHtcbiAgICAgICAgcmV0dXJuIChjb21wYXJlTG93ZXJzKHIxLmxvd2VyLCByMi5sb3dlciwgcjEubG93ZXJPcGVuLCByMi5sb3dlck9wZW4pIDw9IDAgJiZcbiAgICAgICAgICAgIGNvbXBhcmVVcHBlcnMocjEudXBwZXIsIHIyLnVwcGVyLCByMS51cHBlck9wZW4sIHIyLnVwcGVyT3BlbikgPj0gMCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmluZENvbXBhdGlibGVRdWVyeShkYk5hbWUsIHRhYmxlTmFtZSwgdHlwZSwgcmVxKSB7XG4gICAgICAgIHZhciB0YmxDYWNoZSA9IGNhY2hlW1wiaWRiOi8vXCIuY29uY2F0KGRiTmFtZSwgXCIvXCIpLmNvbmNhdCh0YWJsZU5hbWUpXTtcbiAgICAgICAgaWYgKCF0YmxDYWNoZSlcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgdmFyIHF1ZXJpZXMgPSB0YmxDYWNoZS5xdWVyaWVzW3R5cGVdO1xuICAgICAgICBpZiAoIXF1ZXJpZXMpXG4gICAgICAgICAgICByZXR1cm4gW251bGwsIGZhbHNlLCB0YmxDYWNoZSwgbnVsbF07XG4gICAgICAgIHZhciBpbmRleE5hbWUgPSByZXEucXVlcnkgPyByZXEucXVlcnkuaW5kZXgubmFtZSA6IG51bGw7XG4gICAgICAgIHZhciBlbnRyaWVzID0gcXVlcmllc1tpbmRleE5hbWUgfHwgJyddO1xuICAgICAgICBpZiAoIWVudHJpZXMpXG4gICAgICAgICAgICByZXR1cm4gW251bGwsIGZhbHNlLCB0YmxDYWNoZSwgbnVsbF07XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSAncXVlcnknOlxuICAgICAgICAgICAgICAgIHZhciBlcXVhbEVudHJ5ID0gZW50cmllcy5maW5kKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZW50cnkucmVxLmxpbWl0ID09PSByZXEubGltaXQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5LnJlcS52YWx1ZXMgPT09IHJlcS52YWx1ZXMgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZVJhbmdlc0VxdWFsKGVudHJ5LnJlcS5xdWVyeS5yYW5nZSwgcmVxLnF1ZXJ5LnJhbmdlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoZXF1YWxFbnRyeSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVxdWFsRW50cnksXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGJsQ2FjaGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbnRyaWVzLFxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIHZhciBzdXBlckVudHJ5ID0gZW50cmllcy5maW5kKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGltaXQgPSAnbGltaXQnIGluIGVudHJ5LnJlcSA/IGVudHJ5LnJlcS5saW1pdCA6IEluZmluaXR5O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGxpbWl0ID49IHJlcS5saW1pdCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKHJlcS52YWx1ZXMgPyBlbnRyeS5yZXEudmFsdWVzIDogdHJ1ZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzU3VwZXJSYW5nZShlbnRyeS5yZXEucXVlcnkucmFuZ2UsIHJlcS5xdWVyeS5yYW5nZSkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBbc3VwZXJFbnRyeSwgZmFsc2UsIHRibENhY2hlLCBlbnRyaWVzXTtcbiAgICAgICAgICAgIGNhc2UgJ2NvdW50JzpcbiAgICAgICAgICAgICAgICB2YXIgY291bnRRdWVyeSA9IGVudHJpZXMuZmluZChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFyZVJhbmdlc0VxdWFsKGVudHJ5LnJlcS5xdWVyeS5yYW5nZSwgcmVxLnF1ZXJ5LnJhbmdlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2NvdW50UXVlcnksICEhY291bnRRdWVyeSwgdGJsQ2FjaGUsIGVudHJpZXNdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3Vic2NyaWJlVG9DYWNoZUVudHJ5KGNhY2hlRW50cnksIGNvbnRhaW5lciwgcmVxdWVyeSwgc2lnbmFsKSB7XG4gICAgICAgIGNhY2hlRW50cnkuc3Vic2NyaWJlcnMuYWRkKHJlcXVlcnkpO1xuICAgICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNhY2hlRW50cnkuc3Vic2NyaWJlcnMuZGVsZXRlKHJlcXVlcnkpO1xuICAgICAgICAgICAgaWYgKGNhY2hlRW50cnkuc3Vic2NyaWJlcnMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGVucXVlRm9yRGVsZXRpb24oY2FjaGVFbnRyeSwgY29udGFpbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVucXVlRm9yRGVsZXRpb24oY2FjaGVFbnRyeSwgY29udGFpbmVyKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGNhY2hlRW50cnkuc3Vic2NyaWJlcnMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGRlbEFycmF5SXRlbShjb250YWluZXIsIGNhY2hlRW50cnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCAzMDAwKTtcbiAgICB9XG5cbiAgICB2YXIgY2FjaGVNaWRkbGV3YXJlID0ge1xuICAgICAgICBzdGFjazogJ2RiY29yZScsXG4gICAgICAgIGxldmVsOiAwLFxuICAgICAgICBuYW1lOiAnQ2FjaGUnLFxuICAgICAgICBjcmVhdGU6IGZ1bmN0aW9uIChjb3JlKSB7XG4gICAgICAgICAgICB2YXIgZGJOYW1lID0gY29yZS5zY2hlbWEubmFtZTtcbiAgICAgICAgICAgIHZhciBjb3JlTVcgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgY29yZSksIHsgdHJhbnNhY3Rpb246IGZ1bmN0aW9uIChzdG9yZXMsIG1vZGUsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlkYnRyYW5zID0gY29yZS50cmFuc2FjdGlvbihzdG9yZXMsIG1vZGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobW9kZSA9PT0gJ3JlYWR3cml0ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhY18xID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNpZ25hbCA9IGFjXzEuc2lnbmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVuZFRyYW5zYWN0aW9uID0gZnVuY3Rpb24gKHdhc0NvbW1pdHRlZCkgeyByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjXzEuYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobW9kZSA9PT0gJ3JlYWR3cml0ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFmZmVjdGVkU3Vic2NyaWJlcnNfMSA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBzdG9yZXNfMSA9IHN0b3JlczsgX2kgPCBzdG9yZXNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdG9yZU5hbWUgPSBzdG9yZXNfMVtfaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGJsQ2FjaGUgPSBjYWNoZVtcImlkYjovL1wiLmNvbmNhdChkYk5hbWUsIFwiL1wiKS5jb25jYXQoc3RvcmVOYW1lKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGJsQ2FjaGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGFibGUgPSBjb3JlLnRhYmxlKHN0b3JlTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9wcyA9IHRibENhY2hlLm9wdGltaXN0aWNPcHMuZmlsdGVyKGZ1bmN0aW9uIChvcCkgeyByZXR1cm4gb3AudHJhbnMgPT09IGlkYnRyYW5zOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWRidHJhbnMuX2V4cGxpY2l0ICYmIHdhc0NvbW1pdHRlZCAmJiBpZGJ0cmFucy5tdXRhdGVkUGFydHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2EgPSAwLCBfYiA9IE9iamVjdC52YWx1ZXModGJsQ2FjaGUucXVlcmllcy5xdWVyeSk7IF9hIDwgX2IubGVuZ3RoOyBfYSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW50cmllcyA9IF9iW19hXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9jID0gMCwgX2QgPSBlbnRyaWVzLnNsaWNlKCk7IF9jIDwgX2QubGVuZ3RoOyBfYysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gX2RbX2NdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvYnNTZXRzT3ZlcmxhcChlbnRyeS5vYnNTZXQsIGlkYnRyYW5zLm11dGF0ZWRQYXJ0cykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsQXJyYXlJdGVtKGVudHJpZXMsIGVudHJ5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50cnkuc3Vic2NyaWJlcnMuZm9yRWFjaChmdW5jdGlvbiAocmVxdWVyeSkgeyByZXR1cm4gYWZmZWN0ZWRTdWJzY3JpYmVyc18xLmFkZChyZXF1ZXJ5KTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9wcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRibENhY2hlLm9wdGltaXN0aWNPcHMgPSB0YmxDYWNoZS5vcHRpbWlzdGljT3BzLmZpbHRlcihmdW5jdGlvbiAob3ApIHsgcmV0dXJuIG9wLnRyYW5zICE9PSBpZGJ0cmFuczsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9lID0gMCwgX2YgPSBPYmplY3QudmFsdWVzKHRibENhY2hlLnF1ZXJpZXMucXVlcnkpOyBfZSA8IF9mLmxlbmd0aDsgX2UrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVudHJpZXMgPSBfZltfZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfZyA9IDAsIF9oID0gZW50cmllcy5zbGljZSgpOyBfZyA8IF9oLmxlbmd0aDsgX2crKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbnRyeSA9IF9oW19nXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW50cnkucmVzICE9IG51bGwgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWRidHJhbnMubXV0YXRlZFBhcnRzXG4gICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3YXNDb21taXR0ZWQgJiYgIWVudHJ5LmRpcnR5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZnJlZXplUmVzdWx0cyA9IE9iamVjdC5pc0Zyb3plbihlbnRyeS5yZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1vZFJlcyA9IGFwcGx5T3B0aW1pc3RpY09wcyhlbnRyeS5yZXMsIGVudHJ5LnJlcSwgb3BzLCB0YWJsZSwgZW50cnksIGZyZWV6ZVJlc3VsdHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVudHJ5LmRpcnR5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsQXJyYXlJdGVtKGVudHJpZXMsIGVudHJ5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnRyeS5zdWJzY3JpYmVycy5mb3JFYWNoKGZ1bmN0aW9uIChyZXF1ZXJ5KSB7IHJldHVybiBhZmZlY3RlZFN1YnNjcmliZXJzXzEuYWRkKHJlcXVlcnkpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1vZFJlcyAhPT0gZW50cnkucmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50cnkucmVzID0gbW9kUmVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5LnByb21pc2UgPSBEZXhpZVByb21pc2UucmVzb2x2ZSh7IHJlc3VsdDogbW9kUmVzIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVudHJ5LmRpcnR5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsQXJyYXlJdGVtKGVudHJpZXMsIGVudHJ5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5LnN1YnNjcmliZXJzLmZvckVhY2goZnVuY3Rpb24gKHJlcXVlcnkpIHsgcmV0dXJuIGFmZmVjdGVkU3Vic2NyaWJlcnNfMS5hZGQocmVxdWVyeSk7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFmZmVjdGVkU3Vic2NyaWJlcnNfMS5mb3JFYWNoKGZ1bmN0aW9uIChyZXF1ZXJ5KSB7IHJldHVybiByZXF1ZXJ5KCk7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH07IH07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZGJ0cmFucy5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIGVuZFRyYW5zYWN0aW9uKGZhbHNlKSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hbDogc2lnbmFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZGJ0cmFucy5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGVuZFRyYW5zYWN0aW9uKGZhbHNlKSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hbDogc2lnbmFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZGJ0cmFucy5hZGRFdmVudExpc3RlbmVyKCdjb21wbGV0ZScsIGVuZFRyYW5zYWN0aW9uKHRydWUpLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmFsOiBzaWduYWwsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWRidHJhbnM7XG4gICAgICAgICAgICAgICAgfSwgdGFibGU6IGZ1bmN0aW9uICh0YWJsZU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRvd25UYWJsZSA9IGNvcmUudGFibGUodGFibGVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByaW1LZXkgPSBkb3duVGFibGUuc2NoZW1hLnByaW1hcnlLZXk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0YWJsZU1XID0gX19hc3NpZ24oX19hc3NpZ24oe30sIGRvd25UYWJsZSksIHsgbXV0YXRlOiBmdW5jdGlvbiAocmVxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRyYW5zID0gUFNELnRyYW5zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmltS2V5Lm91dGJvdW5kIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zLmRiLl9vcHRpb25zLmNhY2hlID09PSAnZGlzYWJsZWQnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zLmV4cGxpY2l0IHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zLmlkYnRyYW5zLm1vZGUgIT09ICdyZWFkd3JpdGUnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkb3duVGFibGUubXV0YXRlKHJlcSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0YmxDYWNoZSA9IGNhY2hlW1wiaWRiOi8vXCIuY29uY2F0KGRiTmFtZSwgXCIvXCIpLmNvbmNhdCh0YWJsZU5hbWUpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRibENhY2hlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG93blRhYmxlLm11dGF0ZShyZXEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm9taXNlID0gZG93blRhYmxlLm11dGF0ZShyZXEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgocmVxLnR5cGUgPT09ICdhZGQnIHx8IHJlcS50eXBlID09PSAncHV0JykgJiYgKHJlcS52YWx1ZXMubGVuZ3RoID49IDUwIHx8IGdldEVmZmVjdGl2ZUtleXMocHJpbUtleSwgcmVxKS5zb21lKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGtleSA9PSBudWxsOyB9KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXFXaXRoUmVzb2x2ZWRLZXlzID0gX19hc3NpZ24oX19hc3NpZ24oe30sIHJlcSksIHsgdmFsdWVzOiByZXEudmFsdWVzLm1hcChmdW5jdGlvbiAodmFsdWUsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzLmZhaWx1cmVzW2ldKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWVXaXRoS2V5ID0gKChfYSA9IHByaW1LZXkua2V5UGF0aCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmluY2x1ZGVzKCcuJykpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGRlZXBDbG9uZSh2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogX19hc3NpZ24oe30sIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0QnlLZXlQYXRoKHZhbHVlV2l0aEtleSwgcHJpbUtleS5rZXlQYXRoLCByZXMucmVzdWx0c1tpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZVdpdGhLZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWRqdXN0ZWRSZXEgPSBhZGp1c3RPcHRpbWlzdGljRnJvbUZhaWx1cmVzKHRibENhY2hlLCByZXFXaXRoUmVzb2x2ZWRLZXlzLCByZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGJsQ2FjaGUub3B0aW1pc3RpY09wcy5wdXNoKGFkanVzdGVkUmVxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXVlTWljcm90YXNrKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlcS5tdXRhdGVkUGFydHMgJiYgc2lnbmFsU3Vic2NyaWJlcnNMYXppbHkocmVxLm11dGF0ZWRQYXJ0cyk7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRibENhY2hlLm9wdGltaXN0aWNPcHMucHVzaChyZXEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEubXV0YXRlZFBhcnRzICYmIHNpZ25hbFN1YnNjcmliZXJzTGF6aWx5KHJlcS5tdXRhdGVkUGFydHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcy5udW1GYWlsdXJlcyA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxBcnJheUl0ZW0odGJsQ2FjaGUub3B0aW1pc3RpY09wcywgcmVxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWRqdXN0ZWRSZXEgPSBhZGp1c3RPcHRpbWlzdGljRnJvbUZhaWx1cmVzKHRibENhY2hlLCByZXEsIHJlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFkanVzdGVkUmVxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRibENhY2hlLm9wdGltaXN0aWNPcHMucHVzaChhZGp1c3RlZFJlcSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5tdXRhdGVkUGFydHMgJiYgc2lnbmFsU3Vic2NyaWJlcnNMYXppbHkocmVxLm11dGF0ZWRQYXJ0cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlLmNhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbEFycmF5SXRlbSh0YmxDYWNoZS5vcHRpbWlzdGljT3BzLCByZXEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLm11dGF0ZWRQYXJ0cyAmJiBzaWduYWxTdWJzY3JpYmVyc0xhemlseShyZXEubXV0YXRlZFBhcnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgcXVlcnk6IGZ1bmN0aW9uIChyZXEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0NhY2hhYmxlQ29udGV4dChQU0QsIGRvd25UYWJsZSkgfHwgIWlzQ2FjaGFibGVSZXF1ZXN0KFwicXVlcnlcIiwgcmVxKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRvd25UYWJsZS5xdWVyeShyZXEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmcmVlemVSZXN1bHRzID0gKChfYSA9IFBTRC50cmFucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRiLl9vcHRpb25zLmNhY2hlKSA9PT0gJ2ltbXV0YWJsZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9iID0gUFNELCByZXF1ZXJ5ID0gX2IucmVxdWVyeSwgc2lnbmFsID0gX2Iuc2lnbmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYyA9IGZpbmRDb21wYXRpYmxlUXVlcnkoZGJOYW1lLCB0YWJsZU5hbWUsICdxdWVyeScsIHJlcSksIGNhY2hlRW50cnkgPSBfY1swXSwgZXhhY3RNYXRjaCA9IF9jWzFdLCB0YmxDYWNoZSA9IF9jWzJdLCBjb250YWluZXIgPSBfY1szXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FjaGVFbnRyeSAmJiBleGFjdE1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlRW50cnkub2JzU2V0ID0gcmVxLm9ic1NldDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm9taXNlID0gZG93blRhYmxlLnF1ZXJ5KHJlcSkudGhlbihmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gcmVzLnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYWNoZUVudHJ5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlRW50cnkucmVzID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZyZWV6ZVJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHJlc3VsdC5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZShyZXN1bHRbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMucmVzdWx0ID0gZGVlcENsb25lKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250YWluZXIgJiYgY2FjaGVFbnRyeSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxBcnJheUl0ZW0oY29udGFpbmVyLCBjYWNoZUVudHJ5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZUVudHJ5ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JzU2V0OiByZXEub2JzU2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZTogcHJvbWlzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXJzOiBuZXcgU2V0KCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAncXVlcnknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxOiByZXEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXJ0eTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci5wdXNoKGNhY2hlRW50cnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyID0gW2NhY2hlRW50cnldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0YmxDYWNoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRibENhY2hlID0gY2FjaGVbXCJpZGI6Ly9cIi5jb25jYXQoZGJOYW1lLCBcIi9cIikuY29uY2F0KHRhYmxlTmFtZSldID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyaWVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeToge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ianM6IG5ldyBNYXAoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW1pc3RpY09wczogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuc2lnbmFsZWRQYXJ0czoge31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGJsQ2FjaGUucXVlcmllcy5xdWVyeVtyZXEucXVlcnkuaW5kZXgubmFtZSB8fCAnJ10gPSBjb250YWluZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlVG9DYWNoZUVudHJ5KGNhY2hlRW50cnksIGNvbnRhaW5lciwgcmVxdWVyeSwgc2lnbmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVFbnRyeS5wcm9taXNlLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiBhcHBseU9wdGltaXN0aWNPcHMocmVzLnJlc3VsdCwgcmVxLCB0YmxDYWNoZSA9PT0gbnVsbCB8fCB0YmxDYWNoZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGJsQ2FjaGUub3B0aW1pc3RpY09wcywgZG93blRhYmxlLCBjYWNoZUVudHJ5LCBmcmVlemVSZXN1bHRzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0YWJsZU1XO1xuICAgICAgICAgICAgICAgIH0gfSk7XG4gICAgICAgICAgICByZXR1cm4gY29yZU1XO1xuICAgICAgICB9LFxuICAgIH07XG5cbiAgICBmdW5jdGlvbiB2aXBpZnkodGFyZ2V0LCB2aXBEYikge1xuICAgICAgICByZXR1cm4gbmV3IFByb3h5KHRhcmdldCwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wID09PSAnZGInKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmlwRGI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgRGV4aWUkMSA9ICAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBEZXhpZShuYW1lLCBvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5fbWlkZGxld2FyZXMgPSB7fTtcbiAgICAgICAgICAgIHRoaXMudmVybm8gPSAwO1xuICAgICAgICAgICAgdmFyIGRlcHMgPSBEZXhpZS5kZXBlbmRlbmNpZXM7XG4gICAgICAgICAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucyA9IF9fYXNzaWduKHtcbiAgICAgICAgICAgICAgICBhZGRvbnM6IERleGllLmFkZG9ucywgYXV0b09wZW46IHRydWUsXG4gICAgICAgICAgICAgICAgaW5kZXhlZERCOiBkZXBzLmluZGV4ZWREQiwgSURCS2V5UmFuZ2U6IGRlcHMuSURCS2V5UmFuZ2UsIGNhY2hlOiAnY2xvbmVkJyB9LCBvcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMuX2RlcHMgPSB7XG4gICAgICAgICAgICAgICAgaW5kZXhlZERCOiBvcHRpb25zLmluZGV4ZWREQixcbiAgICAgICAgICAgICAgICBJREJLZXlSYW5nZTogb3B0aW9ucy5JREJLZXlSYW5nZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBhZGRvbnMgPSBvcHRpb25zLmFkZG9ucztcbiAgICAgICAgICAgIHRoaXMuX2RiU2NoZW1hID0ge307XG4gICAgICAgICAgICB0aGlzLl92ZXJzaW9ucyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fc3RvcmVOYW1lcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fYWxsVGFibGVzID0ge307XG4gICAgICAgICAgICB0aGlzLmlkYmRiID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX25vdmlwID0gdGhpcztcbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgICAgICAgICAgICBkYk9wZW5FcnJvcjogbnVsbCxcbiAgICAgICAgICAgICAgICBpc0JlaW5nT3BlbmVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBvblJlYWR5QmVpbmdGaXJlZDogbnVsbCxcbiAgICAgICAgICAgICAgICBvcGVuQ29tcGxldGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGRiUmVhZHlSZXNvbHZlOiBub3AsXG4gICAgICAgICAgICAgICAgZGJSZWFkeVByb21pc2U6IG51bGwsXG4gICAgICAgICAgICAgICAgY2FuY2VsT3Blbjogbm9wLFxuICAgICAgICAgICAgICAgIG9wZW5DYW5jZWxsZXI6IG51bGwsXG4gICAgICAgICAgICAgICAgYXV0b1NjaGVtYTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBQUjEzOThfbWF4TG9vcDogMyxcbiAgICAgICAgICAgICAgICBhdXRvT3Blbjogb3B0aW9ucy5hdXRvT3BlbixcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBzdGF0ZS5kYlJlYWR5UHJvbWlzZSA9IG5ldyBEZXhpZVByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5kYlJlYWR5UmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHN0YXRlLm9wZW5DYW5jZWxsZXIgPSBuZXcgRGV4aWVQcm9taXNlKGZ1bmN0aW9uIChfLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5jYW5jZWxPcGVuID0gcmVqZWN0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IHN0YXRlO1xuICAgICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgICAgIHRoaXMub24gPSBFdmVudHModGhpcywgXCJwb3B1bGF0ZVwiLCBcImJsb2NrZWRcIiwgXCJ2ZXJzaW9uY2hhbmdlXCIsIFwiY2xvc2VcIiwgeyByZWFkeTogW3Byb21pc2FibGVDaGFpbiwgbm9wXSB9KTtcbiAgICAgICAgICAgIHRoaXMub25jZSA9IGZ1bmN0aW9uIChldmVudCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB2YXIgZm4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub24oZXZlbnQpLnVuc3Vic2NyaWJlKGZuKTtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkoX3RoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLm9uKGV2ZW50LCBmbik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5vbi5yZWFkeS5zdWJzY3JpYmUgPSBvdmVycmlkZSh0aGlzLm9uLnJlYWR5LnN1YnNjcmliZSwgZnVuY3Rpb24gKHN1YnNjcmliZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoc3Vic2NyaWJlciwgYlN0aWNreSkge1xuICAgICAgICAgICAgICAgICAgICBEZXhpZS52aXAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXRlID0gX3RoaXMuX3N0YXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLm9wZW5Db21wbGV0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc3RhdGUuZGJPcGVuRXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERleGllUHJvbWlzZS5yZXNvbHZlKCkudGhlbihzdWJzY3JpYmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYlN0aWNreSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc3RhdGUub25SZWFkeUJlaW5nRmlyZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5vblJlYWR5QmVpbmdGaXJlZC5wdXNoKHN1YnNjcmliZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiU3RpY2t5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmUoc3Vic2NyaWJlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmUoc3Vic2NyaWJlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRiXzEgPSBfdGhpcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWJTdGlja3kpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZShmdW5jdGlvbiB1bnN1YnNjcmliZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRiXzEub24ucmVhZHkudW5zdWJzY3JpYmUoc3Vic2NyaWJlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYl8xLm9uLnJlYWR5LnVuc3Vic2NyaWJlKHVuc3Vic2NyaWJlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuQ29sbGVjdGlvbiA9IGNyZWF0ZUNvbGxlY3Rpb25Db25zdHJ1Y3Rvcih0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuVGFibGUgPSBjcmVhdGVUYWJsZUNvbnN0cnVjdG9yKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5UcmFuc2FjdGlvbiA9IGNyZWF0ZVRyYW5zYWN0aW9uQ29uc3RydWN0b3IodGhpcyk7XG4gICAgICAgICAgICB0aGlzLlZlcnNpb24gPSBjcmVhdGVWZXJzaW9uQ29uc3RydWN0b3IodGhpcyk7XG4gICAgICAgICAgICB0aGlzLldoZXJlQ2xhdXNlID0gY3JlYXRlV2hlcmVDbGF1c2VDb25zdHJ1Y3Rvcih0aGlzKTtcbiAgICAgICAgICAgIHRoaXMub24oXCJ2ZXJzaW9uY2hhbmdlXCIsIGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgICAgIGlmIChldi5uZXdWZXJzaW9uID4gMClcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiQW5vdGhlciBjb25uZWN0aW9uIHdhbnRzIHRvIHVwZ3JhZGUgZGF0YWJhc2UgJ1wiLmNvbmNhdChfdGhpcy5uYW1lLCBcIicuIENsb3NpbmcgZGIgbm93IHRvIHJlc3VtZSB0aGUgdXBncmFkZS5cIikpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiQW5vdGhlciBjb25uZWN0aW9uIHdhbnRzIHRvIGRlbGV0ZSBkYXRhYmFzZSAnXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiJy4gQ2xvc2luZyBkYiBub3cgdG8gcmVzdW1lIHRoZSBkZWxldGUgcmVxdWVzdC5cIikpO1xuICAgICAgICAgICAgICAgIF90aGlzLmNsb3NlKHsgZGlzYWJsZUF1dG9PcGVuOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5vbihcImJsb2NrZWRcIiwgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFldi5uZXdWZXJzaW9uIHx8IGV2Lm5ld1ZlcnNpb24gPCBldi5vbGRWZXJzaW9uKVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJEZXhpZS5kZWxldGUoJ1wiLmNvbmNhdChfdGhpcy5uYW1lLCBcIicpIHdhcyBibG9ja2VkXCIpKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlVwZ3JhZGUgJ1wiLmNvbmNhdChfdGhpcy5uYW1lLCBcIicgYmxvY2tlZCBieSBvdGhlciBjb25uZWN0aW9uIGhvbGRpbmcgdmVyc2lvbiBcIikuY29uY2F0KGV2Lm9sZFZlcnNpb24gLyAxMCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLl9tYXhLZXkgPSBnZXRNYXhLZXkob3B0aW9ucy5JREJLZXlSYW5nZSk7XG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVUcmFuc2FjdGlvbiA9IGZ1bmN0aW9uIChtb2RlLCBzdG9yZU5hbWVzLCBkYnNjaGVtYSwgcGFyZW50VHJhbnNhY3Rpb24pIHsgcmV0dXJuIG5ldyBfdGhpcy5UcmFuc2FjdGlvbihtb2RlLCBzdG9yZU5hbWVzLCBkYnNjaGVtYSwgX3RoaXMuX29wdGlvbnMuY2hyb21lVHJhbnNhY3Rpb25EdXJhYmlsaXR5LCBwYXJlbnRUcmFuc2FjdGlvbik7IH07XG4gICAgICAgICAgICB0aGlzLl9maXJlT25CbG9ja2VkID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMub24oXCJibG9ja2VkXCIpLmZpcmUoZXYpO1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25zXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMubmFtZSA9PT0gX3RoaXMubmFtZSAmJiBjICE9PSBfdGhpcyAmJiAhYy5fc3RhdGUudmNGaXJlZDsgfSlcbiAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gYy5vbihcInZlcnNpb25jaGFuZ2VcIikuZmlyZShldik7IH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMudXNlKGNhY2hlRXhpc3RpbmdWYWx1ZXNNaWRkbGV3YXJlKTtcbiAgICAgICAgICAgIHRoaXMudXNlKGNhY2hlTWlkZGxld2FyZSk7XG4gICAgICAgICAgICB0aGlzLnVzZShvYnNlcnZhYmlsaXR5TWlkZGxld2FyZSk7XG4gICAgICAgICAgICB0aGlzLnVzZSh2aXJ0dWFsSW5kZXhNaWRkbGV3YXJlKTtcbiAgICAgICAgICAgIHRoaXMudXNlKGhvb2tzTWlkZGxld2FyZSk7XG4gICAgICAgICAgICB2YXIgdmlwREIgPSBuZXcgUHJveHkodGhpcywge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKF8sIHByb3AsIHJlY2VpdmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wID09PSAnX3ZpcCcpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3AgPT09ICd0YWJsZScpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHRhYmxlTmFtZSkgeyByZXR1cm4gdmlwaWZ5KF90aGlzLnRhYmxlKHRhYmxlTmFtZSksIHZpcERCKTsgfTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJ2ID0gUmVmbGVjdC5nZXQoXywgcHJvcCwgcmVjZWl2ZXIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocnYgaW5zdGFuY2VvZiBUYWJsZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2aXBpZnkocnYsIHZpcERCKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3AgPT09ICd0YWJsZXMnKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJ2Lm1hcChmdW5jdGlvbiAodCkgeyByZXR1cm4gdmlwaWZ5KHQsIHZpcERCKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wID09PSAnX2NyZWF0ZVRyYW5zYWN0aW9uJylcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHR4ID0gcnYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmlwaWZ5KHR4LCB2aXBEQik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcnY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnZpcCA9IHZpcERCO1xuICAgICAgICAgICAgYWRkb25zLmZvckVhY2goZnVuY3Rpb24gKGFkZG9uKSB7IHJldHVybiBhZGRvbihfdGhpcyk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIERleGllLnByb3RvdHlwZS52ZXJzaW9uID0gZnVuY3Rpb24gKHZlcnNpb25OdW1iZXIpIHtcbiAgICAgICAgICAgIGlmIChpc05hTih2ZXJzaW9uTnVtYmVyKSB8fCB2ZXJzaW9uTnVtYmVyIDwgMC4xKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLlR5cGUoXCJHaXZlbiB2ZXJzaW9uIGlzIG5vdCBhIHBvc2l0aXZlIG51bWJlclwiKTtcbiAgICAgICAgICAgIHZlcnNpb25OdW1iZXIgPSBNYXRoLnJvdW5kKHZlcnNpb25OdW1iZXIgKiAxMCkgLyAxMDtcbiAgICAgICAgICAgIGlmICh0aGlzLmlkYmRiIHx8IHRoaXMuX3N0YXRlLmlzQmVpbmdPcGVuZWQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuU2NoZW1hKFwiQ2Fubm90IGFkZCB2ZXJzaW9uIHdoZW4gZGF0YWJhc2UgaXMgb3BlblwiKTtcbiAgICAgICAgICAgIHRoaXMudmVybm8gPSBNYXRoLm1heCh0aGlzLnZlcm5vLCB2ZXJzaW9uTnVtYmVyKTtcbiAgICAgICAgICAgIHZhciB2ZXJzaW9ucyA9IHRoaXMuX3ZlcnNpb25zO1xuICAgICAgICAgICAgdmFyIHZlcnNpb25JbnN0YW5jZSA9IHZlcnNpb25zLmZpbHRlcihmdW5jdGlvbiAodikgeyByZXR1cm4gdi5fY2ZnLnZlcnNpb24gPT09IHZlcnNpb25OdW1iZXI7IH0pWzBdO1xuICAgICAgICAgICAgaWYgKHZlcnNpb25JbnN0YW5jZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdmVyc2lvbkluc3RhbmNlO1xuICAgICAgICAgICAgdmVyc2lvbkluc3RhbmNlID0gbmV3IHRoaXMuVmVyc2lvbih2ZXJzaW9uTnVtYmVyKTtcbiAgICAgICAgICAgIHZlcnNpb25zLnB1c2godmVyc2lvbkluc3RhbmNlKTtcbiAgICAgICAgICAgIHZlcnNpb25zLnNvcnQobG93ZXJWZXJzaW9uRmlyc3QpO1xuICAgICAgICAgICAgdmVyc2lvbkluc3RhbmNlLnN0b3Jlcyh7fSk7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZS5hdXRvU2NoZW1hID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gdmVyc2lvbkluc3RhbmNlO1xuICAgICAgICB9O1xuICAgICAgICBEZXhpZS5wcm90b3R5cGUuX3doZW5SZWFkeSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5pZGJkYiAmJiAodGhpcy5fc3RhdGUub3BlbkNvbXBsZXRlIHx8IFBTRC5sZXRUaHJvdWdoIHx8IHRoaXMuX3ZpcCkpID8gZm4oKSA6IG5ldyBEZXhpZVByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fc3RhdGUub3BlbkNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IGV4Y2VwdGlvbnMuRGF0YWJhc2VDbG9zZWQoX3RoaXMuX3N0YXRlLmRiT3BlbkVycm9yKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghX3RoaXMuX3N0YXRlLmlzQmVpbmdPcGVuZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5fc3RhdGUuYXV0b09wZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgZXhjZXB0aW9ucy5EYXRhYmFzZUNsb3NlZCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vcGVuKCkuY2F0Y2gobm9wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMuX3N0YXRlLmRiUmVhZHlQcm9taXNlLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgIH0pLnRoZW4oZm4pO1xuICAgICAgICB9O1xuICAgICAgICBEZXhpZS5wcm90b3R5cGUudXNlID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgc3RhY2sgPSBfYS5zdGFjaywgY3JlYXRlID0gX2EuY3JlYXRlLCBsZXZlbCA9IF9hLmxldmVsLCBuYW1lID0gX2EubmFtZTtcbiAgICAgICAgICAgIGlmIChuYW1lKVxuICAgICAgICAgICAgICAgIHRoaXMudW51c2UoeyBzdGFjazogc3RhY2ssIG5hbWU6IG5hbWUgfSk7XG4gICAgICAgICAgICB2YXIgbWlkZGxld2FyZXMgPSB0aGlzLl9taWRkbGV3YXJlc1tzdGFja10gfHwgKHRoaXMuX21pZGRsZXdhcmVzW3N0YWNrXSA9IFtdKTtcbiAgICAgICAgICAgIG1pZGRsZXdhcmVzLnB1c2goeyBzdGFjazogc3RhY2ssIGNyZWF0ZTogY3JlYXRlLCBsZXZlbDogbGV2ZWwgPT0gbnVsbCA/IDEwIDogbGV2ZWwsIG5hbWU6IG5hbWUgfSk7XG4gICAgICAgICAgICBtaWRkbGV3YXJlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLmxldmVsIC0gYi5sZXZlbDsgfSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgRGV4aWUucHJvdG90eXBlLnVudXNlID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgc3RhY2sgPSBfYS5zdGFjaywgbmFtZSA9IF9hLm5hbWUsIGNyZWF0ZSA9IF9hLmNyZWF0ZTtcbiAgICAgICAgICAgIGlmIChzdGFjayAmJiB0aGlzLl9taWRkbGV3YXJlc1tzdGFja10pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9taWRkbGV3YXJlc1tzdGFja10gPSB0aGlzLl9taWRkbGV3YXJlc1tzdGFja10uZmlsdGVyKGZ1bmN0aW9uIChtdykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlID8gbXcuY3JlYXRlICE9PSBjcmVhdGUgOlxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA/IG13Lm5hbWUgIT09IG5hbWUgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIERleGllLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiB1c2VQU0QoZ2xvYmFsUFNELFxuICAgICAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gZGV4aWVPcGVuKF90aGlzKTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIERleGllLnByb3RvdHlwZS5fY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLm9uLmNsb3NlLmZpcmUobmV3IEN1c3RvbUV2ZW50KCdjbG9zZScpKTtcbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuX3N0YXRlO1xuICAgICAgICAgICAgdmFyIGlkeCA9IGNvbm5lY3Rpb25zLmluZGV4T2YodGhpcyk7XG4gICAgICAgICAgICBpZiAoaWR4ID49IDApXG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbnMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgICAgICBpZiAodGhpcy5pZGJkYikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaWRiZGIuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgICAgICAgICAgICAgIHRoaXMuaWRiZGIgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzdGF0ZS5pc0JlaW5nT3BlbmVkKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUuZGJSZWFkeVByb21pc2UgPSBuZXcgRGV4aWVQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmRiUmVhZHlSZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5vcGVuQ2FuY2VsbGVyID0gbmV3IERleGllUHJvbWlzZShmdW5jdGlvbiAoXywgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmNhbmNlbE9wZW4gPSByZWplY3Q7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIERleGllLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHsgZGlzYWJsZUF1dG9PcGVuOiB0cnVlIH0gOiBfYSwgZGlzYWJsZUF1dG9PcGVuID0gX2IuZGlzYWJsZUF1dG9PcGVuO1xuICAgICAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5fc3RhdGU7XG4gICAgICAgICAgICBpZiAoZGlzYWJsZUF1dG9PcGVuKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLmlzQmVpbmdPcGVuZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuY2FuY2VsT3BlbihuZXcgZXhjZXB0aW9ucy5EYXRhYmFzZUNsb3NlZCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fY2xvc2UoKTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5hdXRvT3BlbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHN0YXRlLmRiT3BlbkVycm9yID0gbmV3IGV4Y2VwdGlvbnMuRGF0YWJhc2VDbG9zZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Nsb3NlKCk7XG4gICAgICAgICAgICAgICAgc3RhdGUuYXV0b09wZW4gPSB0aGlzLl9vcHRpb25zLmF1dG9PcGVuIHx8XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmlzQmVpbmdPcGVuZWQ7XG4gICAgICAgICAgICAgICAgc3RhdGUub3BlbkNvbXBsZXRlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgc3RhdGUuZGJPcGVuRXJyb3IgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBEZXhpZS5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24gKGNsb3NlT3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIGlmIChjbG9zZU9wdGlvbnMgPT09IHZvaWQgMCkgeyBjbG9zZU9wdGlvbnMgPSB7IGRpc2FibGVBdXRvT3BlbjogdHJ1ZSB9OyB9XG4gICAgICAgICAgICB2YXIgaGFzSW52YWxpZEFyZ3VtZW50cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIHR5cGVvZiBhcmd1bWVudHNbMF0gIT09ICdvYmplY3QnO1xuICAgICAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5fc3RhdGU7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERleGllUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGRvRGVsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jbG9zZShjbG9zZU9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVxID0gX3RoaXMuX2RlcHMuaW5kZXhlZERCLmRlbGV0ZURhdGFiYXNlKF90aGlzLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICByZXEub25zdWNjZXNzID0gd3JhcChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfb25EYXRhYmFzZURlbGV0ZWQoX3RoaXMuX2RlcHMsIF90aGlzLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBldmVudFJlamVjdEhhbmRsZXIocmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgcmVxLm9uYmxvY2tlZCA9IF90aGlzLl9maXJlT25CbG9ja2VkO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKGhhc0ludmFsaWRBcmd1bWVudHMpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLkludmFsaWRBcmd1bWVudChcIkludmFsaWQgY2xvc2VPcHRpb25zIGFyZ3VtZW50IHRvIGRiLmRlbGV0ZSgpXCIpO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5pc0JlaW5nT3BlbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmRiUmVhZHlQcm9taXNlLnRoZW4oZG9EZWxldGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZG9EZWxldGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgRGV4aWUucHJvdG90eXBlLmJhY2tlbmREQiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlkYmRiO1xuICAgICAgICB9O1xuICAgICAgICBEZXhpZS5wcm90b3R5cGUuaXNPcGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaWRiZGIgIT09IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIERleGllLnByb3RvdHlwZS5oYXNCZWVuQ2xvc2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGRiT3BlbkVycm9yID0gdGhpcy5fc3RhdGUuZGJPcGVuRXJyb3I7XG4gICAgICAgICAgICByZXR1cm4gZGJPcGVuRXJyb3IgJiYgKGRiT3BlbkVycm9yLm5hbWUgPT09ICdEYXRhYmFzZUNsb3NlZCcpO1xuICAgICAgICB9O1xuICAgICAgICBEZXhpZS5wcm90b3R5cGUuaGFzRmFpbGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlLmRiT3BlbkVycm9yICE9PSBudWxsO1xuICAgICAgICB9O1xuICAgICAgICBEZXhpZS5wcm90b3R5cGUuZHluYW1pY2FsbHlPcGVuZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGUuYXV0b1NjaGVtYTtcbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERleGllLnByb3RvdHlwZSwgXCJ0YWJsZXNcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5cyh0aGlzLl9hbGxUYWJsZXMpLm1hcChmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gX3RoaXMuX2FsbFRhYmxlc1tuYW1lXTsgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIERleGllLnByb3RvdHlwZS50cmFuc2FjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gZXh0cmFjdFRyYW5zYWN0aW9uQXJncy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zYWN0aW9uLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9O1xuICAgICAgICBEZXhpZS5wcm90b3R5cGUuX3RyYW5zYWN0aW9uID0gZnVuY3Rpb24gKG1vZGUsIHRhYmxlcywgc2NvcGVGdW5jKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIHBhcmVudFRyYW5zYWN0aW9uID0gUFNELnRyYW5zO1xuICAgICAgICAgICAgaWYgKCFwYXJlbnRUcmFuc2FjdGlvbiB8fCBwYXJlbnRUcmFuc2FjdGlvbi5kYiAhPT0gdGhpcyB8fCBtb2RlLmluZGV4T2YoJyEnKSAhPT0gLTEpXG4gICAgICAgICAgICAgICAgcGFyZW50VHJhbnNhY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgdmFyIG9ubHlJZkNvbXBhdGlibGUgPSBtb2RlLmluZGV4T2YoJz8nKSAhPT0gLTE7XG4gICAgICAgICAgICBtb2RlID0gbW9kZS5yZXBsYWNlKCchJywgJycpLnJlcGxhY2UoJz8nLCAnJyk7XG4gICAgICAgICAgICB2YXIgaWRiTW9kZSwgc3RvcmVOYW1lcztcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgc3RvcmVOYW1lcyA9IHRhYmxlcy5tYXAoZnVuY3Rpb24gKHRhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdG9yZU5hbWUgPSB0YWJsZSBpbnN0YW5jZW9mIF90aGlzLlRhYmxlID8gdGFibGUubmFtZSA6IHRhYmxlO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHN0b3JlTmFtZSAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCB0YWJsZSBhcmd1bWVudCB0byBEZXhpZS50cmFuc2FjdGlvbigpLiBPbmx5IFRhYmxlIG9yIFN0cmluZyBhcmUgYWxsb3dlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0b3JlTmFtZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAobW9kZSA9PSBcInJcIiB8fCBtb2RlID09PSBSRUFET05MWSlcbiAgICAgICAgICAgICAgICAgICAgaWRiTW9kZSA9IFJFQURPTkxZO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1vZGUgPT0gXCJyd1wiIHx8IG1vZGUgPT0gUkVBRFdSSVRFKVxuICAgICAgICAgICAgICAgICAgICBpZGJNb2RlID0gUkVBRFdSSVRFO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuSW52YWxpZEFyZ3VtZW50KFwiSW52YWxpZCB0cmFuc2FjdGlvbiBtb2RlOiBcIiArIG1vZGUpO1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnRUcmFuc2FjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50VHJhbnNhY3Rpb24ubW9kZSA9PT0gUkVBRE9OTFkgJiYgaWRiTW9kZSA9PT0gUkVBRFdSSVRFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob25seUlmQ29tcGF0aWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFRyYW5zYWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5TdWJUcmFuc2FjdGlvbihcIkNhbm5vdCBlbnRlciBhIHN1Yi10cmFuc2FjdGlvbiB3aXRoIFJFQURXUklURSBtb2RlIHdoZW4gcGFyZW50IHRyYW5zYWN0aW9uIGlzIFJFQURPTkxZXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnRUcmFuc2FjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmVOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChzdG9yZU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50VHJhbnNhY3Rpb24gJiYgcGFyZW50VHJhbnNhY3Rpb24uc3RvcmVOYW1lcy5pbmRleE9mKHN0b3JlTmFtZSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvbmx5SWZDb21wYXRpYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRUcmFuc2FjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuU3ViVHJhbnNhY3Rpb24oXCJUYWJsZSBcIiArIHN0b3JlTmFtZSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgbm90IGluY2x1ZGVkIGluIHBhcmVudCB0cmFuc2FjdGlvbi5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9ubHlJZkNvbXBhdGlibGUgJiYgcGFyZW50VHJhbnNhY3Rpb24gJiYgIXBhcmVudFRyYW5zYWN0aW9uLmFjdGl2ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50VHJhbnNhY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyZW50VHJhbnNhY3Rpb24gP1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnRUcmFuc2FjdGlvbi5fcHJvbWlzZShudWxsLCBmdW5jdGlvbiAoXywgcmVqZWN0KSB7IHJlamVjdChlKTsgfSkgOlxuICAgICAgICAgICAgICAgICAgICByZWplY3Rpb24oZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZW50ZXJUcmFuc2FjdGlvbiA9IGVudGVyVHJhbnNhY3Rpb25TY29wZS5iaW5kKG51bGwsIHRoaXMsIGlkYk1vZGUsIHN0b3JlTmFtZXMsIHBhcmVudFRyYW5zYWN0aW9uLCBzY29wZUZ1bmMpO1xuICAgICAgICAgICAgcmV0dXJuIChwYXJlbnRUcmFuc2FjdGlvbiA/XG4gICAgICAgICAgICAgICAgcGFyZW50VHJhbnNhY3Rpb24uX3Byb21pc2UoaWRiTW9kZSwgZW50ZXJUcmFuc2FjdGlvbiwgXCJsb2NrXCIpIDpcbiAgICAgICAgICAgICAgICBQU0QudHJhbnMgP1xuICAgICAgICAgICAgICAgICAgICB1c2VQU0QoUFNELnRyYW5zbGVzcywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX3doZW5SZWFkeShlbnRlclRyYW5zYWN0aW9uKTsgfSkgOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl93aGVuUmVhZHkoZW50ZXJUcmFuc2FjdGlvbikpO1xuICAgICAgICB9O1xuICAgICAgICBEZXhpZS5wcm90b3R5cGUudGFibGUgPSBmdW5jdGlvbiAodGFibGVOYW1lKSB7XG4gICAgICAgICAgICBpZiAoIWhhc093bih0aGlzLl9hbGxUYWJsZXMsIHRhYmxlTmFtZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5JbnZhbGlkVGFibGUoXCJUYWJsZSBcIi5jb25jYXQodGFibGVOYW1lLCBcIiBkb2VzIG5vdCBleGlzdFwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYWxsVGFibGVzW3RhYmxlTmFtZV07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBEZXhpZTtcbiAgICB9KCkpO1xuXG4gICAgdmFyIHN5bWJvbE9ic2VydmFibGUgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIFwib2JzZXJ2YWJsZVwiIGluIFN5bWJvbFxuICAgICAgICA/IFN5bWJvbC5vYnNlcnZhYmxlXG4gICAgICAgIDogXCJAQG9ic2VydmFibGVcIjtcbiAgICB2YXIgT2JzZXJ2YWJsZSA9ICAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBPYnNlcnZhYmxlKHN1YnNjcmliZSkge1xuICAgICAgICAgICAgdGhpcy5fc3Vic2NyaWJlID0gc3Vic2NyaWJlO1xuICAgICAgICB9XG4gICAgICAgIE9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uICh4LCBlcnJvciwgY29tcGxldGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdWJzY3JpYmUoIXggfHwgdHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIiA/IHsgbmV4dDogeCwgZXJyb3I6IGVycm9yLCBjb21wbGV0ZTogY29tcGxldGUgfSA6IHgpO1xuICAgICAgICB9O1xuICAgICAgICBPYnNlcnZhYmxlLnByb3RvdHlwZVtzeW1ib2xPYnNlcnZhYmxlXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gT2JzZXJ2YWJsZTtcbiAgICB9KCkpO1xuXG4gICAgdmFyIGRvbURlcHM7XG4gICAgdHJ5IHtcbiAgICAgICAgZG9tRGVwcyA9IHtcbiAgICAgICAgICAgIGluZGV4ZWREQjogX2dsb2JhbC5pbmRleGVkREIgfHwgX2dsb2JhbC5tb3pJbmRleGVkREIgfHwgX2dsb2JhbC53ZWJraXRJbmRleGVkREIgfHwgX2dsb2JhbC5tc0luZGV4ZWREQixcbiAgICAgICAgICAgIElEQktleVJhbmdlOiBfZ2xvYmFsLklEQktleVJhbmdlIHx8IF9nbG9iYWwud2Via2l0SURCS2V5UmFuZ2VcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgZG9tRGVwcyA9IHsgaW5kZXhlZERCOiBudWxsLCBJREJLZXlSYW5nZTogbnVsbCB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpdmVRdWVyeShxdWVyaWVyKSB7XG4gICAgICAgIHZhciBoYXNWYWx1ZSA9IGZhbHNlO1xuICAgICAgICB2YXIgY3VycmVudFZhbHVlO1xuICAgICAgICB2YXIgb2JzZXJ2YWJsZSA9IG5ldyBPYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICAgICAgdmFyIHNjb3BlRnVuY0lzQXN5bmMgPSBpc0FzeW5jRnVuY3Rpb24ocXVlcmllcik7XG4gICAgICAgICAgICBmdW5jdGlvbiBleGVjdXRlKGN0eCkge1xuICAgICAgICAgICAgICAgIHZhciB3YXNSb290RXhlYyA9IGJlZ2luTWljcm9UaWNrU2NvcGUoKTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2NvcGVGdW5jSXNBc3luYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5jcmVtZW50RXhwZWN0ZWRBd2FpdHMoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgcnYgPSBuZXdTY29wZShxdWVyaWVyLCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2NvcGVGdW5jSXNBc3luYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcnYgPSBydi5maW5hbGx5KGRlY3JlbWVudEV4cGVjdGVkQXdhaXRzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcnY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICB3YXNSb290RXhlYyAmJiBlbmRNaWNyb1RpY2tTY29wZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjbG9zZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBhYm9ydENvbnRyb2xsZXI7XG4gICAgICAgICAgICB2YXIgYWNjdW1NdXRzID0ge307XG4gICAgICAgICAgICB2YXIgY3VycmVudE9icyA9IHt9O1xuICAgICAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IHtcbiAgICAgICAgICAgICAgICBnZXQgY2xvc2VkKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2xvc2VkO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdW5zdWJzY3JpYmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNsb3NlZClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFib3J0Q29udHJvbGxlcilcbiAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnRlZExpc3RlbmluZylcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsb2JhbEV2ZW50cy5zdG9yYWdlbXV0YXRlZC51bnN1YnNjcmliZShtdXRhdGlvbkxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG9ic2VydmVyLnN0YXJ0ICYmIG9ic2VydmVyLnN0YXJ0KHN1YnNjcmlwdGlvbik7XG4gICAgICAgICAgICB2YXIgc3RhcnRlZExpc3RlbmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGRvUXVlcnkgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBleGVjSW5HbG9iYWxDb250ZXh0KF9kb1F1ZXJ5KTsgfTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIHNob3VsZE5vdGlmeSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JzU2V0c092ZXJsYXAoY3VycmVudE9icywgYWNjdW1NdXRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBtdXRhdGlvbkxpc3RlbmVyID0gZnVuY3Rpb24gKHBhcnRzKSB7XG4gICAgICAgICAgICAgICAgZXh0ZW5kT2JzZXJ2YWJpbGl0eVNldChhY2N1bU11dHMsIHBhcnRzKTtcbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkTm90aWZ5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9RdWVyeSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgX2RvUXVlcnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNsb3NlZCB8fFxuICAgICAgICAgICAgICAgICAgICAhZG9tRGVwcy5pbmRleGVkREIpXG4gICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhY2N1bU11dHMgPSB7fTtcbiAgICAgICAgICAgICAgICB2YXIgc3Vic2NyID0ge307XG4gICAgICAgICAgICAgICAgaWYgKGFib3J0Q29udHJvbGxlcilcbiAgICAgICAgICAgICAgICAgICAgYWJvcnRDb250cm9sbGVyLmFib3J0KCk7XG4gICAgICAgICAgICAgICAgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICAgICAgICAgIHZhciBjdHggPSB7XG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcjogc3Vic2NyLFxuICAgICAgICAgICAgICAgICAgICBzaWduYWw6IGFib3J0Q29udHJvbGxlci5zaWduYWwsXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlcnk6IGRvUXVlcnksXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJpZXI6IHF1ZXJpZXIsXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zOiBudWxsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB2YXIgcmV0ID0gZXhlY3V0ZShjdHgpO1xuICAgICAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZShyZXQpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBoYXNWYWx1ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRWYWx1ZSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNsb3NlZCB8fCBjdHguc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhY2N1bU11dHMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudE9icyA9IHN1YnNjcjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFvYmplY3RJc0VtcHR5KGN1cnJlbnRPYnMpICYmICFzdGFydGVkTGlzdGVuaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnbG9iYWxFdmVudHMoREVYSUVfU1RPUkFHRV9NVVRBVEVEX0VWRU5UX05BTUUsIG11dGF0aW9uTGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRlZExpc3RlbmluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZXhlY0luR2xvYmFsQ29udGV4dChmdW5jdGlvbiAoKSB7IHJldHVybiAhY2xvc2VkICYmIG9ic2VydmVyLm5leHQgJiYgb2JzZXJ2ZXIubmV4dChyZXN1bHQpOyB9KTtcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhc1ZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGlmICghWydEYXRhYmFzZUNsb3NlZEVycm9yJywgJ0Fib3J0RXJyb3InXS5pbmNsdWRlcyhlcnIgPT09IG51bGwgfHwgZXJyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlcnIubmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY2xvc2VkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWNJbkdsb2JhbENvbnRleHQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2xvc2VkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5lcnJvciAmJiBvYnNlcnZlci5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgc2V0VGltZW91dChkb1F1ZXJ5LCAwKTtcbiAgICAgICAgICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gICAgICAgIH0pO1xuICAgICAgICBvYnNlcnZhYmxlLmhhc1ZhbHVlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gaGFzVmFsdWU7IH07XG4gICAgICAgIG9ic2VydmFibGUuZ2V0VmFsdWUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjdXJyZW50VmFsdWU7IH07XG4gICAgICAgIHJldHVybiBvYnNlcnZhYmxlO1xuICAgIH1cblxuICAgIHZhciBEZXhpZSA9IERleGllJDE7XG4gICAgcHJvcHMoRGV4aWUsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBmdWxsTmFtZUV4Y2VwdGlvbnMpLCB7XG4gICAgICAgIGRlbGV0ZTogZnVuY3Rpb24gKGRhdGFiYXNlTmFtZSkge1xuICAgICAgICAgICAgdmFyIGRiID0gbmV3IERleGllKGRhdGFiYXNlTmFtZSwgeyBhZGRvbnM6IFtdIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGRiLmRlbGV0ZSgpO1xuICAgICAgICB9LFxuICAgICAgICBleGlzdHM6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERleGllKG5hbWUsIHsgYWRkb25zOiBbXSB9KS5vcGVuKCkudGhlbihmdW5jdGlvbiAoZGIpIHtcbiAgICAgICAgICAgICAgICBkYi5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSkuY2F0Y2goJ05vU3VjaERhdGFiYXNlRXJyb3InLCBmdW5jdGlvbiAoKSB7IHJldHVybiBmYWxzZTsgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldERhdGFiYXNlTmFtZXM6IGZ1bmN0aW9uIChjYikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0RGF0YWJhc2VOYW1lcyhEZXhpZS5kZXBlbmRlbmNpZXMpLnRoZW4oY2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdGlvbihuZXcgZXhjZXB0aW9ucy5NaXNzaW5nQVBJKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBkZWZpbmVDbGFzczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gQ2xhc3MoY29udGVudCkge1xuICAgICAgICAgICAgICAgIGV4dGVuZCh0aGlzLCBjb250ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBDbGFzcztcbiAgICAgICAgfSwgaWdub3JlVHJhbnNhY3Rpb246IGZ1bmN0aW9uIChzY29wZUZ1bmMpIHtcbiAgICAgICAgICAgIHJldHVybiBQU0QudHJhbnMgP1xuICAgICAgICAgICAgICAgIHVzZVBTRChQU0QudHJhbnNsZXNzLCBzY29wZUZ1bmMpIDpcbiAgICAgICAgICAgICAgICBzY29wZUZ1bmMoKTtcbiAgICAgICAgfSwgdmlwOiB2aXAsIGFzeW5jOiBmdW5jdGlvbiAoZ2VuZXJhdG9yRm4pIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJ2ID0gYXdhaXRJdGVyYXRvcihnZW5lcmF0b3JGbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFydiB8fCB0eXBlb2YgcnYudGhlbiAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBEZXhpZVByb21pc2UucmVzb2x2ZShydik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBydjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdGlvbihlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LCBzcGF3bjogZnVuY3Rpb24gKGdlbmVyYXRvckZuLCBhcmdzLCB0aGl6KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciBydiA9IGF3YWl0SXRlcmF0b3IoZ2VuZXJhdG9yRm4uYXBwbHkodGhpeiwgYXJncyB8fCBbXSkpO1xuICAgICAgICAgICAgICAgIGlmICghcnYgfHwgdHlwZW9mIHJ2LnRoZW4gIT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBEZXhpZVByb21pc2UucmVzb2x2ZShydik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJ2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0aW9uKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjdXJyZW50VHJhbnNhY3Rpb246IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gUFNELnRyYW5zIHx8IG51bGw7IH1cbiAgICAgICAgfSwgd2FpdEZvcjogZnVuY3Rpb24gKHByb21pc2VPckZ1bmN0aW9uLCBvcHRpb25hbFRpbWVvdXQpIHtcbiAgICAgICAgICAgIHZhciBwcm9taXNlID0gRGV4aWVQcm9taXNlLnJlc29sdmUodHlwZW9mIHByb21pc2VPckZ1bmN0aW9uID09PSAnZnVuY3Rpb24nID9cbiAgICAgICAgICAgICAgICBEZXhpZS5pZ25vcmVUcmFuc2FjdGlvbihwcm9taXNlT3JGdW5jdGlvbikgOlxuICAgICAgICAgICAgICAgIHByb21pc2VPckZ1bmN0aW9uKVxuICAgICAgICAgICAgICAgIC50aW1lb3V0KG9wdGlvbmFsVGltZW91dCB8fCA2MDAwMCk7XG4gICAgICAgICAgICByZXR1cm4gUFNELnRyYW5zID9cbiAgICAgICAgICAgICAgICBQU0QudHJhbnMud2FpdEZvcihwcm9taXNlKSA6XG4gICAgICAgICAgICAgICAgcHJvbWlzZTtcbiAgICAgICAgfSxcbiAgICAgICAgUHJvbWlzZTogRGV4aWVQcm9taXNlLFxuICAgICAgICBkZWJ1Zzoge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkZWJ1ZzsgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgc2V0RGVidWcodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBkZXJpdmU6IGRlcml2ZSwgZXh0ZW5kOiBleHRlbmQsIHByb3BzOiBwcm9wcywgb3ZlcnJpZGU6IG92ZXJyaWRlLFxuICAgICAgICBFdmVudHM6IEV2ZW50cywgb246IGdsb2JhbEV2ZW50cywgbGl2ZVF1ZXJ5OiBsaXZlUXVlcnksIGV4dGVuZE9ic2VydmFiaWxpdHlTZXQ6IGV4dGVuZE9ic2VydmFiaWxpdHlTZXQsXG4gICAgICAgIGdldEJ5S2V5UGF0aDogZ2V0QnlLZXlQYXRoLCBzZXRCeUtleVBhdGg6IHNldEJ5S2V5UGF0aCwgZGVsQnlLZXlQYXRoOiBkZWxCeUtleVBhdGgsIHNoYWxsb3dDbG9uZTogc2hhbGxvd0Nsb25lLCBkZWVwQ2xvbmU6IGRlZXBDbG9uZSwgZ2V0T2JqZWN0RGlmZjogZ2V0T2JqZWN0RGlmZiwgY21wOiBjbXAsIGFzYXA6IGFzYXAkMSxcbiAgICAgICAgbWluS2V5OiBtaW5LZXksXG4gICAgICAgIGFkZG9uczogW10sXG4gICAgICAgIGNvbm5lY3Rpb25zOiBjb25uZWN0aW9ucyxcbiAgICAgICAgZXJybmFtZXM6IGVycm5hbWVzLFxuICAgICAgICBkZXBlbmRlbmNpZXM6IGRvbURlcHMsIGNhY2hlOiBjYWNoZSxcbiAgICAgICAgc2VtVmVyOiBERVhJRV9WRVJTSU9OLCB2ZXJzaW9uOiBERVhJRV9WRVJTSU9OLnNwbGl0KCcuJylcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKG4pIHsgcmV0dXJuIHBhcnNlSW50KG4pOyB9KVxuICAgICAgICAgICAgLnJlZHVjZShmdW5jdGlvbiAocCwgYywgaSkgeyByZXR1cm4gcCArIChjIC8gTWF0aC5wb3coMTAsIGkgKiAyKSk7IH0pIH0pKTtcbiAgICBEZXhpZS5tYXhLZXkgPSBnZXRNYXhLZXkoRGV4aWUuZGVwZW5kZW5jaWVzLklEQktleVJhbmdlKTtcblxuICAgIGlmICh0eXBlb2YgZGlzcGF0Y2hFdmVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGFkZEV2ZW50TGlzdGVuZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGdsb2JhbEV2ZW50cyhERVhJRV9TVE9SQUdFX01VVEFURURfRVZFTlRfTkFNRSwgZnVuY3Rpb24gKHVwZGF0ZWRQYXJ0cykge1xuICAgICAgICAgICAgaWYgKCFwcm9wYWdhdGluZ0xvY2FsbHkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnRfMTtcbiAgICAgICAgICAgICAgICBldmVudF8xID0gbmV3IEN1c3RvbUV2ZW50KFNUT1JBR0VfTVVUQVRFRF9ET01fRVZFTlRfTkFNRSwge1xuICAgICAgICAgICAgICAgICAgICBkZXRhaWw6IHVwZGF0ZWRQYXJ0c1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHByb3BhZ2F0aW5nTG9jYWxseSA9IHRydWU7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2hFdmVudChldmVudF8xKTtcbiAgICAgICAgICAgICAgICBwcm9wYWdhdGluZ0xvY2FsbHkgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoU1RPUkFHRV9NVVRBVEVEX0RPTV9FVkVOVF9OQU1FLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBkZXRhaWwgPSBfYS5kZXRhaWw7XG4gICAgICAgICAgICBpZiAoIXByb3BhZ2F0aW5nTG9jYWxseSkge1xuICAgICAgICAgICAgICAgIHByb3BhZ2F0ZUxvY2FsbHkoZGV0YWlsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByb3BhZ2F0ZUxvY2FsbHkodXBkYXRlUGFydHMpIHtcbiAgICAgICAgdmFyIHdhc01lID0gcHJvcGFnYXRpbmdMb2NhbGx5O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcHJvcGFnYXRpbmdMb2NhbGx5ID0gdHJ1ZTtcbiAgICAgICAgICAgIGdsb2JhbEV2ZW50cy5zdG9yYWdlbXV0YXRlZC5maXJlKHVwZGF0ZVBhcnRzKTtcbiAgICAgICAgICAgIHNpZ25hbFN1YnNjcmliZXJzTm93KHVwZGF0ZVBhcnRzLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHByb3BhZ2F0aW5nTG9jYWxseSA9IHdhc01lO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBwcm9wYWdhdGluZ0xvY2FsbHkgPSBmYWxzZTtcblxuICAgIHZhciBiYztcbiAgICB2YXIgY3JlYXRlQkMgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgaWYgKHR5cGVvZiBCcm9hZGNhc3RDaGFubmVsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjcmVhdGVCQyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGJjID0gbmV3IEJyb2FkY2FzdENoYW5uZWwoU1RPUkFHRV9NVVRBVEVEX0RPTV9FVkVOVF9OQU1FKTtcbiAgICAgICAgICAgIGJjLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChldikgeyByZXR1cm4gZXYuZGF0YSAmJiBwcm9wYWdhdGVMb2NhbGx5KGV2LmRhdGEpOyB9O1xuICAgICAgICB9O1xuICAgICAgICBjcmVhdGVCQygpO1xuICAgICAgICBpZiAodHlwZW9mIGJjLnVucmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBiYy51bnJlZigpO1xuICAgICAgICB9XG4gICAgICAgIGdsb2JhbEV2ZW50cyhERVhJRV9TVE9SQUdFX01VVEFURURfRVZFTlRfTkFNRSwgZnVuY3Rpb24gKGNoYW5nZWRQYXJ0cykge1xuICAgICAgICAgICAgaWYgKCFwcm9wYWdhdGluZ0xvY2FsbHkpIHtcbiAgICAgICAgICAgICAgICBiYy5wb3N0TWVzc2FnZShjaGFuZ2VkUGFydHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGFkZEV2ZW50TGlzdGVuZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoJ3BhZ2VoaWRlJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoIURleGllJDEuZGlzYWJsZUJmQ2FjaGUgJiYgZXZlbnQucGVyc2lzdGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRlYnVnKVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmRlYnVnKCdEZXhpZTogaGFuZGxpbmcgcGVyc2lzdGVkIHBhZ2VoaWRlJyk7XG4gICAgICAgICAgICAgICAgYmMgPT09IG51bGwgfHwgYmMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJjLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBjb25uZWN0aW9uc18xID0gY29ubmVjdGlvbnM7IF9pIDwgY29ubmVjdGlvbnNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRiID0gY29ubmVjdGlvbnNfMVtfaV07XG4gICAgICAgICAgICAgICAgICAgIGRiLmNsb3NlKHsgZGlzYWJsZUF1dG9PcGVuOiBmYWxzZSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBhZGRFdmVudExpc3RlbmVyKCdwYWdlc2hvdycsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgaWYgKCFEZXhpZSQxLmRpc2FibGVCZkNhY2hlICYmIGV2ZW50LnBlcnNpc3RlZCkge1xuICAgICAgICAgICAgICAgIGlmIChkZWJ1ZylcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1ZygnRGV4aWU6IGhhbmRsaW5nIHBlcnNpc3RlZCBwYWdlc2hvdycpO1xuICAgICAgICAgICAgICAgIGNyZWF0ZUJDKCk7XG4gICAgICAgICAgICAgICAgcHJvcGFnYXRlTG9jYWxseSh7IGFsbDogbmV3IFJhbmdlU2V0KC1JbmZpbml0eSwgW1tdXSkgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BNb2RpZmljYXRpb24oeyBhZGQ6IHZhbHVlIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BNb2RpZmljYXRpb24oeyByZW1vdmU6IHZhbHVlIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlcGxhY2VQcmVmaXgoYSwgYikge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BNb2RpZmljYXRpb24oeyByZXBsYWNlUHJlZml4OiBbYSwgYl0gfSk7XG4gICAgfVxuXG4gICAgRGV4aWVQcm9taXNlLnJlamVjdGlvbk1hcHBlciA9IG1hcEVycm9yO1xuICAgIHNldERlYnVnKGRlYnVnKTtcblxuICAgIHZhciBuYW1lZEV4cG9ydHMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICAgICAgRGV4aWU6IERleGllJDEsXG4gICAgICAgIGxpdmVRdWVyeTogbGl2ZVF1ZXJ5LFxuICAgICAgICBFbnRpdHk6IEVudGl0eSxcbiAgICAgICAgY21wOiBjbXAsXG4gICAgICAgIFByb3BNb2RpZmljYXRpb246IFByb3BNb2RpZmljYXRpb24sXG4gICAgICAgIHJlcGxhY2VQcmVmaXg6IHJlcGxhY2VQcmVmaXgsXG4gICAgICAgIGFkZDogYWRkLFxuICAgICAgICByZW1vdmU6IHJlbW92ZSxcbiAgICAgICAgJ2RlZmF1bHQnOiBEZXhpZSQxLFxuICAgICAgICBSYW5nZVNldDogUmFuZ2VTZXQsXG4gICAgICAgIG1lcmdlUmFuZ2VzOiBtZXJnZVJhbmdlcyxcbiAgICAgICAgcmFuZ2VzT3ZlcmxhcDogcmFuZ2VzT3ZlcmxhcFxuICAgIH0pO1xuXG4gICAgX19hc3NpZ24oRGV4aWUkMSwgbmFtZWRFeHBvcnRzLCB7IGRlZmF1bHQ6IERleGllJDEgfSk7XG5cbiAgICByZXR1cm4gRGV4aWUkMTtcblxufSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGV4aWUuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/dexie/dist/dexie.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/dexie/import-wrapper.mjs":
/*!***************************************************!*\
  !*** ../../node_modules/dexie/import-wrapper.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Dexie: () => (/* binding */ Dexie),\n/* harmony export */   DexieYProvider: () => (/* binding */ DexieYProvider),\n/* harmony export */   Entity: () => (/* binding */ Entity),\n/* harmony export */   PropModification: () => (/* binding */ PropModification),\n/* harmony export */   RangeSet: () => (/* binding */ RangeSet),\n/* harmony export */   add: () => (/* binding */ add),\n/* harmony export */   cmp: () => (/* binding */ cmp),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   liveQuery: () => (/* binding */ liveQuery),\n/* harmony export */   mergeRanges: () => (/* binding */ mergeRanges),\n/* harmony export */   rangesOverlap: () => (/* binding */ rangesOverlap),\n/* harmony export */   remove: () => (/* binding */ remove),\n/* harmony export */   replacePrefix: () => (/* binding */ replacePrefix)\n/* harmony export */ });\n/* harmony import */ var _dist_dexie_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dist/dexie.js */ \"(app-pages-browser)/../../node_modules/dexie/dist/dexie.js\");\n// Making the module version consumable via require - to prohibit\n// multiple occurrancies of the same module in the same app\n// (dual package hazard, https://nodejs.org/api/packages.html#dual-package-hazard)\n\nconst DexieSymbol = Symbol.for(\"Dexie\");\nconst Dexie = globalThis[DexieSymbol] || (globalThis[DexieSymbol] = _dist_dexie_js__WEBPACK_IMPORTED_MODULE_0__);\nif (_dist_dexie_js__WEBPACK_IMPORTED_MODULE_0__.semVer !== Dexie.semVer) {\n    throw new Error(`Two different versions of Dexie loaded in the same app: ${_dist_dexie_js__WEBPACK_IMPORTED_MODULE_0__.semVer} and ${Dexie.semVer}`);\n}\nconst { liveQuery, mergeRanges, rangesOverlap, RangeSet, cmp, Entity,\n    PropModification, replacePrefix, add, remove,\n    DexieYProvider } = Dexie;\n\n    \n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Dexie);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvZGV4aWUvaW1wb3J0LXdyYXBwZXIubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ3FDO0FBQ3JDO0FBQ0Esb0VBQW9FLDJDQUFNO0FBQzFFLElBQUksa0RBQWE7QUFDakIsK0VBQStFLGtEQUFhLEVBQUUsTUFBTSxhQUFhO0FBQ2pIO0FBQ0EsUUFBUTtBQUNSO0FBQ0EscUJBQXFCO0FBR0Q7QUFDcEI7QUFDQSxpRUFBZSxLQUFLLEVBQUMiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbmF0aGFcXE9uZURyaXZlXFxEZXNrdG9wXFxNb25leVF1ZXN0VjNcXG5vZGVfbW9kdWxlc1xcZGV4aWVcXGltcG9ydC13cmFwcGVyLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBNYWtpbmcgdGhlIG1vZHVsZSB2ZXJzaW9uIGNvbnN1bWFibGUgdmlhIHJlcXVpcmUgLSB0byBwcm9oaWJpdFxuLy8gbXVsdGlwbGUgb2NjdXJyYW5jaWVzIG9mIHRoZSBzYW1lIG1vZHVsZSBpbiB0aGUgc2FtZSBhcHBcbi8vIChkdWFsIHBhY2thZ2UgaGF6YXJkLCBodHRwczovL25vZGVqcy5vcmcvYXBpL3BhY2thZ2VzLmh0bWwjZHVhbC1wYWNrYWdlLWhhemFyZClcbmltcG9ydCBfRGV4aWUgZnJvbSBcIi4vZGlzdC9kZXhpZS5qc1wiO1xuY29uc3QgRGV4aWVTeW1ib2wgPSBTeW1ib2wuZm9yKFwiRGV4aWVcIik7XG5jb25zdCBEZXhpZSA9IGdsb2JhbFRoaXNbRGV4aWVTeW1ib2xdIHx8IChnbG9iYWxUaGlzW0RleGllU3ltYm9sXSA9IF9EZXhpZSk7XG5pZiAoX0RleGllLnNlbVZlciAhPT0gRGV4aWUuc2VtVmVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBUd28gZGlmZmVyZW50IHZlcnNpb25zIG9mIERleGllIGxvYWRlZCBpbiB0aGUgc2FtZSBhcHA6ICR7X0RleGllLnNlbVZlcn0gYW5kICR7RGV4aWUuc2VtVmVyfWApO1xufVxuY29uc3QgeyBsaXZlUXVlcnksIG1lcmdlUmFuZ2VzLCByYW5nZXNPdmVybGFwLCBSYW5nZVNldCwgY21wLCBFbnRpdHksXG4gICAgUHJvcE1vZGlmaWNhdGlvbiwgcmVwbGFjZVByZWZpeCwgYWRkLCByZW1vdmUsXG4gICAgRGV4aWVZUHJvdmlkZXIgfSA9IERleGllO1xuZXhwb3J0IHsgbGl2ZVF1ZXJ5LCBtZXJnZVJhbmdlcywgcmFuZ2VzT3ZlcmxhcCwgUmFuZ2VTZXQsIGNtcCwgRGV4aWUsIEVudGl0eSxcbiAgICBQcm9wTW9kaWZpY2F0aW9uLCByZXBsYWNlUHJlZml4LCBhZGQsIHJlbW92ZSxcbiAgICBEZXhpZVlQcm92aWRlcn07XG4gICAgXG5leHBvcnQgZGVmYXVsdCBEZXhpZTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/dexie/import-wrapper.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/zod/index.cjs":
/*!****************************************!*\
  !*** ../../node_modules/zod/index.cjs ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.z = void 0;\nconst z = __importStar(__webpack_require__(/*! ./v3/external.cjs */ \"(app-pages-browser)/../../node_modules/zod/v3/external.cjs\"));\nexports.z = z;\n__exportStar(__webpack_require__(/*! ./v3/external.cjs */ \"(app-pages-browser)/../../node_modules/zod/v3/external.cjs\"), exports);\nexports[\"default\"] = z;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvem9kL2luZGV4LmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsU0FBUztBQUNULHVCQUF1QixtQkFBTyxDQUFDLHFGQUFtQjtBQUNsRCxTQUFTO0FBQ1QsYUFBYSxtQkFBTyxDQUFDLHFGQUFtQjtBQUN4QyxrQkFBZSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxuYXRoYVxcT25lRHJpdmVcXERlc2t0b3BcXE1vbmV5UXVlc3RWM1xcbm9kZV9tb2R1bGVzXFx6b2RcXGluZGV4LmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMueiA9IHZvaWQgMDtcbmNvbnN0IHogPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vdjMvZXh0ZXJuYWwuY2pzXCIpKTtcbmV4cG9ydHMueiA9IHo7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdjMvZXh0ZXJuYWwuY2pzXCIpLCBleHBvcnRzKTtcbmV4cG9ydHMuZGVmYXVsdCA9IHo7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/zod/index.cjs\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/zod/v3/ZodError.cjs":
/*!**********************************************!*\
  !*** ../../node_modules/zod/v3/ZodError.cjs ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ZodError = exports.quotelessJson = exports.ZodIssueCode = void 0;\nconst util_js_1 = __webpack_require__(/*! ./helpers/util.cjs */ \"(app-pages-browser)/../../node_modules/zod/v3/helpers/util.cjs\");\nexports.ZodIssueCode = util_js_1.util.arrayToEnum([\n    \"invalid_type\",\n    \"invalid_literal\",\n    \"custom\",\n    \"invalid_union\",\n    \"invalid_union_discriminator\",\n    \"invalid_enum_value\",\n    \"unrecognized_keys\",\n    \"invalid_arguments\",\n    \"invalid_return_type\",\n    \"invalid_date\",\n    \"invalid_string\",\n    \"too_small\",\n    \"too_big\",\n    \"invalid_intersection_types\",\n    \"not_multiple_of\",\n    \"not_finite\",\n]);\nconst quotelessJson = (obj) => {\n    const json = JSON.stringify(obj, null, 2);\n    return json.replace(/\"([^\"]+)\":/g, \"$1:\");\n};\nexports.quotelessJson = quotelessJson;\nclass ZodError extends Error {\n    get errors() {\n        return this.issues;\n    }\n    constructor(issues) {\n        super();\n        this.issues = [];\n        this.addIssue = (sub) => {\n            this.issues = [...this.issues, sub];\n        };\n        this.addIssues = (subs = []) => {\n            this.issues = [...this.issues, ...subs];\n        };\n        const actualProto = new.target.prototype;\n        if (Object.setPrototypeOf) {\n            // eslint-disable-next-line ban/ban\n            Object.setPrototypeOf(this, actualProto);\n        }\n        else {\n            this.__proto__ = actualProto;\n        }\n        this.name = \"ZodError\";\n        this.issues = issues;\n    }\n    format(_mapper) {\n        const mapper = _mapper ||\n            function (issue) {\n                return issue.message;\n            };\n        const fieldErrors = { _errors: [] };\n        const processError = (error) => {\n            for (const issue of error.issues) {\n                if (issue.code === \"invalid_union\") {\n                    issue.unionErrors.map(processError);\n                }\n                else if (issue.code === \"invalid_return_type\") {\n                    processError(issue.returnTypeError);\n                }\n                else if (issue.code === \"invalid_arguments\") {\n                    processError(issue.argumentsError);\n                }\n                else if (issue.path.length === 0) {\n                    fieldErrors._errors.push(mapper(issue));\n                }\n                else {\n                    let curr = fieldErrors;\n                    let i = 0;\n                    while (i < issue.path.length) {\n                        const el = issue.path[i];\n                        const terminal = i === issue.path.length - 1;\n                        if (!terminal) {\n                            curr[el] = curr[el] || { _errors: [] };\n                            // if (typeof el === \"string\") {\n                            //   curr[el] = curr[el] || { _errors: [] };\n                            // } else if (typeof el === \"number\") {\n                            //   const errorArray: any = [];\n                            //   errorArray._errors = [];\n                            //   curr[el] = curr[el] || errorArray;\n                            // }\n                        }\n                        else {\n                            curr[el] = curr[el] || { _errors: [] };\n                            curr[el]._errors.push(mapper(issue));\n                        }\n                        curr = curr[el];\n                        i++;\n                    }\n                }\n            }\n        };\n        processError(this);\n        return fieldErrors;\n    }\n    static assert(value) {\n        if (!(value instanceof ZodError)) {\n            throw new Error(`Not a ZodError: ${value}`);\n        }\n    }\n    toString() {\n        return this.message;\n    }\n    get message() {\n        return JSON.stringify(this.issues, util_js_1.util.jsonStringifyReplacer, 2);\n    }\n    get isEmpty() {\n        return this.issues.length === 0;\n    }\n    flatten(mapper = (issue) => issue.message) {\n        const fieldErrors = {};\n        const formErrors = [];\n        for (const sub of this.issues) {\n            if (sub.path.length > 0) {\n                const firstEl = sub.path[0];\n                fieldErrors[firstEl] = fieldErrors[firstEl] || [];\n                fieldErrors[firstEl].push(mapper(sub));\n            }\n            else {\n                formErrors.push(mapper(sub));\n            }\n        }\n        return { formErrors, fieldErrors };\n    }\n    get formErrors() {\n        return this.flatten();\n    }\n}\nexports.ZodError = ZodError;\nZodError.create = (issues) => {\n    const error = new ZodError(issues);\n    return error;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvem9kL3YzL1pvZEVycm9yLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0IsR0FBRyxxQkFBcUIsR0FBRyxvQkFBb0I7QUFDL0Qsa0JBQWtCLG1CQUFPLENBQUMsMEZBQW9CO0FBQzlDLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQSwwREFBMEQ7QUFDMUQsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxNQUFNO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXG5hdGhhXFxPbmVEcml2ZVxcRGVza3RvcFxcTW9uZXlRdWVzdFYzXFxub2RlX21vZHVsZXNcXHpvZFxcdjNcXFpvZEVycm9yLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuWm9kRXJyb3IgPSBleHBvcnRzLnF1b3RlbGVzc0pzb24gPSBleHBvcnRzLlpvZElzc3VlQ29kZSA9IHZvaWQgMDtcbmNvbnN0IHV0aWxfanNfMSA9IHJlcXVpcmUoXCIuL2hlbHBlcnMvdXRpbC5janNcIik7XG5leHBvcnRzLlpvZElzc3VlQ29kZSA9IHV0aWxfanNfMS51dGlsLmFycmF5VG9FbnVtKFtcbiAgICBcImludmFsaWRfdHlwZVwiLFxuICAgIFwiaW52YWxpZF9saXRlcmFsXCIsXG4gICAgXCJjdXN0b21cIixcbiAgICBcImludmFsaWRfdW5pb25cIixcbiAgICBcImludmFsaWRfdW5pb25fZGlzY3JpbWluYXRvclwiLFxuICAgIFwiaW52YWxpZF9lbnVtX3ZhbHVlXCIsXG4gICAgXCJ1bnJlY29nbml6ZWRfa2V5c1wiLFxuICAgIFwiaW52YWxpZF9hcmd1bWVudHNcIixcbiAgICBcImludmFsaWRfcmV0dXJuX3R5cGVcIixcbiAgICBcImludmFsaWRfZGF0ZVwiLFxuICAgIFwiaW52YWxpZF9zdHJpbmdcIixcbiAgICBcInRvb19zbWFsbFwiLFxuICAgIFwidG9vX2JpZ1wiLFxuICAgIFwiaW52YWxpZF9pbnRlcnNlY3Rpb25fdHlwZXNcIixcbiAgICBcIm5vdF9tdWx0aXBsZV9vZlwiLFxuICAgIFwibm90X2Zpbml0ZVwiLFxuXSk7XG5jb25zdCBxdW90ZWxlc3NKc29uID0gKG9iaikgPT4ge1xuICAgIGNvbnN0IGpzb24gPSBKU09OLnN0cmluZ2lmeShvYmosIG51bGwsIDIpO1xuICAgIHJldHVybiBqc29uLnJlcGxhY2UoL1wiKFteXCJdKylcIjovZywgXCIkMTpcIik7XG59O1xuZXhwb3J0cy5xdW90ZWxlc3NKc29uID0gcXVvdGVsZXNzSnNvbjtcbmNsYXNzIFpvZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGdldCBlcnJvcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzc3VlcztcbiAgICB9XG4gICAgY29uc3RydWN0b3IoaXNzdWVzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuaXNzdWVzID0gW107XG4gICAgICAgIHRoaXMuYWRkSXNzdWUgPSAoc3ViKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmlzc3VlcyA9IFsuLi50aGlzLmlzc3Vlcywgc3ViXTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5hZGRJc3N1ZXMgPSAoc3VicyA9IFtdKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmlzc3VlcyA9IFsuLi50aGlzLmlzc3VlcywgLi4uc3Vic107XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGFjdHVhbFByb3RvID0gbmV3LnRhcmdldC5wcm90b3R5cGU7XG4gICAgICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBiYW4vYmFuXG4gICAgICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgYWN0dWFsUHJvdG8pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fX3Byb3RvX18gPSBhY3R1YWxQcm90bztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5hbWUgPSBcIlpvZEVycm9yXCI7XG4gICAgICAgIHRoaXMuaXNzdWVzID0gaXNzdWVzO1xuICAgIH1cbiAgICBmb3JtYXQoX21hcHBlcikge1xuICAgICAgICBjb25zdCBtYXBwZXIgPSBfbWFwcGVyIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoaXNzdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNzdWUubWVzc2FnZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNvbnN0IGZpZWxkRXJyb3JzID0geyBfZXJyb3JzOiBbXSB9O1xuICAgICAgICBjb25zdCBwcm9jZXNzRXJyb3IgPSAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXNzdWUgb2YgZXJyb3IuaXNzdWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzc3VlLmNvZGUgPT09IFwiaW52YWxpZF91bmlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzc3VlLnVuaW9uRXJyb3JzLm1hcChwcm9jZXNzRXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS5jb2RlID09PSBcImludmFsaWRfcmV0dXJuX3R5cGVcIikge1xuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzRXJyb3IoaXNzdWUucmV0dXJuVHlwZUVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUuY29kZSA9PT0gXCJpbnZhbGlkX2FyZ3VtZW50c1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3NFcnJvcihpc3N1ZS5hcmd1bWVudHNFcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkRXJyb3JzLl9lcnJvcnMucHVzaChtYXBwZXIoaXNzdWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjdXJyID0gZmllbGRFcnJvcnM7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGkgPCBpc3N1ZS5wYXRoLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZWwgPSBpc3N1ZS5wYXRoW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGVybWluYWwgPSBpID09PSBpc3N1ZS5wYXRoLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRlcm1pbmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycltlbF0gPSBjdXJyW2VsXSB8fCB7IF9lcnJvcnM6IFtdIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgKHR5cGVvZiBlbCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgY3VycltlbF0gPSBjdXJyW2VsXSB8fCB7IF9lcnJvcnM6IFtdIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gfSBlbHNlIGlmICh0eXBlb2YgZWwgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGNvbnN0IGVycm9yQXJyYXk6IGFueSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgZXJyb3JBcnJheS5fZXJyb3JzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBjdXJyW2VsXSA9IGN1cnJbZWxdIHx8IGVycm9yQXJyYXk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycltlbF0gPSBjdXJyW2VsXSB8fCB7IF9lcnJvcnM6IFtdIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycltlbF0uX2Vycm9ycy5wdXNoKG1hcHBlcihpc3N1ZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY3VyciA9IGN1cnJbZWxdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBwcm9jZXNzRXJyb3IodGhpcyk7XG4gICAgICAgIHJldHVybiBmaWVsZEVycm9ycztcbiAgICB9XG4gICAgc3RhdGljIGFzc2VydCh2YWx1ZSkge1xuICAgICAgICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIFpvZEVycm9yKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBOb3QgYSBab2RFcnJvcjogJHt2YWx1ZX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZTtcbiAgICB9XG4gICAgZ2V0IG1lc3NhZ2UoKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLmlzc3VlcywgdXRpbF9qc18xLnV0aWwuanNvblN0cmluZ2lmeVJlcGxhY2VyLCAyKTtcbiAgICB9XG4gICAgZ2V0IGlzRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzc3Vlcy5sZW5ndGggPT09IDA7XG4gICAgfVxuICAgIGZsYXR0ZW4obWFwcGVyID0gKGlzc3VlKSA9PiBpc3N1ZS5tZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkRXJyb3JzID0ge307XG4gICAgICAgIGNvbnN0IGZvcm1FcnJvcnMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBzdWIgb2YgdGhpcy5pc3N1ZXMpIHtcbiAgICAgICAgICAgIGlmIChzdWIucGF0aC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlyc3RFbCA9IHN1Yi5wYXRoWzBdO1xuICAgICAgICAgICAgICAgIGZpZWxkRXJyb3JzW2ZpcnN0RWxdID0gZmllbGRFcnJvcnNbZmlyc3RFbF0gfHwgW107XG4gICAgICAgICAgICAgICAgZmllbGRFcnJvcnNbZmlyc3RFbF0ucHVzaChtYXBwZXIoc3ViKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3JtRXJyb3JzLnB1c2gobWFwcGVyKHN1YikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGZvcm1FcnJvcnMsIGZpZWxkRXJyb3JzIH07XG4gICAgfVxuICAgIGdldCBmb3JtRXJyb3JzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mbGF0dGVuKCk7XG4gICAgfVxufVxuZXhwb3J0cy5ab2RFcnJvciA9IFpvZEVycm9yO1xuWm9kRXJyb3IuY3JlYXRlID0gKGlzc3VlcykgPT4ge1xuICAgIGNvbnN0IGVycm9yID0gbmV3IFpvZEVycm9yKGlzc3Vlcyk7XG4gICAgcmV0dXJuIGVycm9yO1xufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/zod/v3/ZodError.cjs\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/zod/v3/errors.cjs":
/*!********************************************!*\
  !*** ../../node_modules/zod/v3/errors.cjs ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.defaultErrorMap = void 0;\nexports.setErrorMap = setErrorMap;\nexports.getErrorMap = getErrorMap;\nconst en_js_1 = __importDefault(__webpack_require__(/*! ./locales/en.cjs */ \"(app-pages-browser)/../../node_modules/zod/v3/locales/en.cjs\"));\nexports.defaultErrorMap = en_js_1.default;\nlet overrideErrorMap = en_js_1.default;\nfunction setErrorMap(map) {\n    overrideErrorMap = map;\n}\nfunction getErrorMap() {\n    return overrideErrorMap;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvem9kL3YzL2Vycm9ycy5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx1QkFBdUI7QUFDdkIsbUJBQW1CO0FBQ25CLG1CQUFtQjtBQUNuQixnQ0FBZ0MsbUJBQU8sQ0FBQyxzRkFBa0I7QUFDMUQsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXG5hdGhhXFxPbmVEcml2ZVxcRGVza3RvcFxcTW9uZXlRdWVzdFYzXFxub2RlX21vZHVsZXNcXHpvZFxcdjNcXGVycm9ycy5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHRFcnJvck1hcCA9IHZvaWQgMDtcbmV4cG9ydHMuc2V0RXJyb3JNYXAgPSBzZXRFcnJvck1hcDtcbmV4cG9ydHMuZ2V0RXJyb3JNYXAgPSBnZXRFcnJvck1hcDtcbmNvbnN0IGVuX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vbG9jYWxlcy9lbi5janNcIikpO1xuZXhwb3J0cy5kZWZhdWx0RXJyb3JNYXAgPSBlbl9qc18xLmRlZmF1bHQ7XG5sZXQgb3ZlcnJpZGVFcnJvck1hcCA9IGVuX2pzXzEuZGVmYXVsdDtcbmZ1bmN0aW9uIHNldEVycm9yTWFwKG1hcCkge1xuICAgIG92ZXJyaWRlRXJyb3JNYXAgPSBtYXA7XG59XG5mdW5jdGlvbiBnZXRFcnJvck1hcCgpIHtcbiAgICByZXR1cm4gb3ZlcnJpZGVFcnJvck1hcDtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/zod/v3/errors.cjs\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/zod/v3/external.cjs":
/*!**********************************************!*\
  !*** ../../node_modules/zod/v3/external.cjs ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./errors.cjs */ \"(app-pages-browser)/../../node_modules/zod/v3/errors.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./helpers/parseUtil.cjs */ \"(app-pages-browser)/../../node_modules/zod/v3/helpers/parseUtil.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./helpers/typeAliases.cjs */ \"(app-pages-browser)/../../node_modules/zod/v3/helpers/typeAliases.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./helpers/util.cjs */ \"(app-pages-browser)/../../node_modules/zod/v3/helpers/util.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./types.cjs */ \"(app-pages-browser)/../../node_modules/zod/v3/types.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./ZodError.cjs */ \"(app-pages-browser)/../../node_modules/zod/v3/ZodError.cjs\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvem9kL3YzL2V4dGVybmFsLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxhQUFhLG1CQUFPLENBQUMsOEVBQWM7QUFDbkMsYUFBYSxtQkFBTyxDQUFDLG9HQUF5QjtBQUM5QyxhQUFhLG1CQUFPLENBQUMsd0dBQTJCO0FBQ2hELGFBQWEsbUJBQU8sQ0FBQywwRkFBb0I7QUFDekMsYUFBYSxtQkFBTyxDQUFDLDRFQUFhO0FBQ2xDLGFBQWEsbUJBQU8sQ0FBQyxrRkFBZ0IiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbmF0aGFcXE9uZURyaXZlXFxEZXNrdG9wXFxNb25leVF1ZXN0VjNcXG5vZGVfbW9kdWxlc1xcem9kXFx2M1xcZXh0ZXJuYWwuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZXJyb3JzLmNqc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaGVscGVycy9wYXJzZVV0aWwuY2pzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9oZWxwZXJzL3R5cGVBbGlhc2VzLmNqc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaGVscGVycy91dGlsLmNqc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdHlwZXMuY2pzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9ab2RFcnJvci5janNcIiksIGV4cG9ydHMpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/zod/v3/external.cjs\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/zod/v3/helpers/errorUtil.cjs":
/*!*******************************************************!*\
  !*** ../../node_modules/zod/v3/helpers/errorUtil.cjs ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.errorUtil = void 0;\nvar errorUtil;\n(function (errorUtil) {\n    errorUtil.errToObj = (message) => typeof message === \"string\" ? { message } : message || {};\n    // biome-ignore lint:\n    errorUtil.toString = (message) => typeof message === \"string\" ? message : message?.message;\n})(errorUtil || (exports.errorUtil = errorUtil = {}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvem9kL3YzL2hlbHBlcnMvZXJyb3JVdGlsLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLHNFQUFzRSxVQUFVO0FBQ2hGO0FBQ0E7QUFDQSxDQUFDLGdCQUFnQixpQkFBaUIsaUJBQWlCIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXG5hdGhhXFxPbmVEcml2ZVxcRGVza3RvcFxcTW9uZXlRdWVzdFYzXFxub2RlX21vZHVsZXNcXHpvZFxcdjNcXGhlbHBlcnNcXGVycm9yVXRpbC5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmVycm9yVXRpbCA9IHZvaWQgMDtcbnZhciBlcnJvclV0aWw7XG4oZnVuY3Rpb24gKGVycm9yVXRpbCkge1xuICAgIGVycm9yVXRpbC5lcnJUb09iaiA9IChtZXNzYWdlKSA9PiB0eXBlb2YgbWVzc2FnZSA9PT0gXCJzdHJpbmdcIiA/IHsgbWVzc2FnZSB9IDogbWVzc2FnZSB8fCB7fTtcbiAgICAvLyBiaW9tZS1pZ25vcmUgbGludDpcbiAgICBlcnJvclV0aWwudG9TdHJpbmcgPSAobWVzc2FnZSkgPT4gdHlwZW9mIG1lc3NhZ2UgPT09IFwic3RyaW5nXCIgPyBtZXNzYWdlIDogbWVzc2FnZT8ubWVzc2FnZTtcbn0pKGVycm9yVXRpbCB8fCAoZXhwb3J0cy5lcnJvclV0aWwgPSBlcnJvclV0aWwgPSB7fSkpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/zod/v3/helpers/errorUtil.cjs\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/zod/v3/helpers/parseUtil.cjs":
/*!*******************************************************!*\
  !*** ../../node_modules/zod/v3/helpers/parseUtil.cjs ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isAsync = exports.isValid = exports.isDirty = exports.isAborted = exports.OK = exports.DIRTY = exports.INVALID = exports.ParseStatus = exports.EMPTY_PATH = exports.makeIssue = void 0;\nexports.addIssueToContext = addIssueToContext;\nconst errors_js_1 = __webpack_require__(/*! ../errors.cjs */ \"(app-pages-browser)/../../node_modules/zod/v3/errors.cjs\");\nconst en_js_1 = __importDefault(__webpack_require__(/*! ../locales/en.cjs */ \"(app-pages-browser)/../../node_modules/zod/v3/locales/en.cjs\"));\nconst makeIssue = (params) => {\n    const { data, path, errorMaps, issueData } = params;\n    const fullPath = [...path, ...(issueData.path || [])];\n    const fullIssue = {\n        ...issueData,\n        path: fullPath,\n    };\n    if (issueData.message !== undefined) {\n        return {\n            ...issueData,\n            path: fullPath,\n            message: issueData.message,\n        };\n    }\n    let errorMessage = \"\";\n    const maps = errorMaps\n        .filter((m) => !!m)\n        .slice()\n        .reverse();\n    for (const map of maps) {\n        errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;\n    }\n    return {\n        ...issueData,\n        path: fullPath,\n        message: errorMessage,\n    };\n};\nexports.makeIssue = makeIssue;\nexports.EMPTY_PATH = [];\nfunction addIssueToContext(ctx, issueData) {\n    const overrideMap = (0, errors_js_1.getErrorMap)();\n    const issue = (0, exports.makeIssue)({\n        issueData: issueData,\n        data: ctx.data,\n        path: ctx.path,\n        errorMaps: [\n            ctx.common.contextualErrorMap, // contextual error map is first priority\n            ctx.schemaErrorMap, // then schema-bound map if available\n            overrideMap, // then global override map\n            overrideMap === en_js_1.default ? undefined : en_js_1.default, // then global default map\n        ].filter((x) => !!x),\n    });\n    ctx.common.issues.push(issue);\n}\nclass ParseStatus {\n    constructor() {\n        this.value = \"valid\";\n    }\n    dirty() {\n        if (this.value === \"valid\")\n            this.value = \"dirty\";\n    }\n    abort() {\n        if (this.value !== \"aborted\")\n            this.value = \"aborted\";\n    }\n    static mergeArray(status, results) {\n        const arrayValue = [];\n        for (const s of results) {\n            if (s.status === \"aborted\")\n                return exports.INVALID;\n            if (s.status === \"dirty\")\n                status.dirty();\n            arrayValue.push(s.value);\n        }\n        return { status: status.value, value: arrayValue };\n    }\n    static async mergeObjectAsync(status, pairs) {\n        const syncPairs = [];\n        for (const pair of pairs) {\n            const key = await pair.key;\n            const value = await pair.value;\n            syncPairs.push({\n                key,\n                value,\n            });\n        }\n        return ParseStatus.mergeObjectSync(status, syncPairs);\n    }\n    static mergeObjectSync(status, pairs) {\n        const finalObject = {};\n        for (const pair of pairs) {\n            const { key, value } = pair;\n            if (key.status === \"aborted\")\n                return exports.INVALID;\n            if (value.status === \"aborted\")\n                return exports.INVALID;\n            if (key.status === \"dirty\")\n                status.dirty();\n            if (value.status === \"dirty\")\n                status.dirty();\n            if (key.value !== \"__proto__\" && (typeof value.value !== \"undefined\" || pair.alwaysSet)) {\n                finalObject[key.value] = value.value;\n            }\n        }\n        return { status: status.value, value: finalObject };\n    }\n}\nexports.ParseStatus = ParseStatus;\nexports.INVALID = Object.freeze({\n    status: \"aborted\",\n});\nconst DIRTY = (value) => ({ status: \"dirty\", value });\nexports.DIRTY = DIRTY;\nconst OK = (value) => ({ status: \"valid\", value });\nexports.OK = OK;\nconst isAborted = (x) => x.status === \"aborted\";\nexports.isAborted = isAborted;\nconst isDirty = (x) => x.status === \"dirty\";\nexports.isDirty = isDirty;\nconst isValid = (x) => x.status === \"valid\";\nexports.isValid = isValid;\nconst isAsync = (x) => typeof Promise !== \"undefined\" && x instanceof Promise;\nexports.isAsync = isAsync;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvem9kL3YzL2hlbHBlcnMvcGFyc2VVdGlsLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGVBQWUsR0FBRyxlQUFlLEdBQUcsZUFBZSxHQUFHLGlCQUFpQixHQUFHLFVBQVUsR0FBRyxhQUFhLEdBQUcsZUFBZSxHQUFHLG1CQUFtQixHQUFHLGtCQUFrQixHQUFHLGlCQUFpQjtBQUNyTCx5QkFBeUI7QUFDekIsb0JBQW9CLG1CQUFPLENBQUMsK0VBQWU7QUFDM0MsZ0NBQWdDLG1CQUFPLENBQUMsdUZBQW1CO0FBQzNEO0FBQ0EsWUFBWSxtQ0FBbUM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGtDQUFrQztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLGVBQWU7QUFDZjtBQUNBLENBQUM7QUFDRCw0QkFBNEIsd0JBQXdCO0FBQ3BELGFBQWE7QUFDYix5QkFBeUIsd0JBQXdCO0FBQ2pELFVBQVU7QUFDVjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGVBQWU7QUFDZjtBQUNBLGVBQWU7QUFDZjtBQUNBLGVBQWUiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbmF0aGFcXE9uZURyaXZlXFxEZXNrdG9wXFxNb25leVF1ZXN0VjNcXG5vZGVfbW9kdWxlc1xcem9kXFx2M1xcaGVscGVyc1xccGFyc2VVdGlsLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaXNBc3luYyA9IGV4cG9ydHMuaXNWYWxpZCA9IGV4cG9ydHMuaXNEaXJ0eSA9IGV4cG9ydHMuaXNBYm9ydGVkID0gZXhwb3J0cy5PSyA9IGV4cG9ydHMuRElSVFkgPSBleHBvcnRzLklOVkFMSUQgPSBleHBvcnRzLlBhcnNlU3RhdHVzID0gZXhwb3J0cy5FTVBUWV9QQVRIID0gZXhwb3J0cy5tYWtlSXNzdWUgPSB2b2lkIDA7XG5leHBvcnRzLmFkZElzc3VlVG9Db250ZXh0ID0gYWRkSXNzdWVUb0NvbnRleHQ7XG5jb25zdCBlcnJvcnNfanNfMSA9IHJlcXVpcmUoXCIuLi9lcnJvcnMuY2pzXCIpO1xuY29uc3QgZW5fanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vbG9jYWxlcy9lbi5janNcIikpO1xuY29uc3QgbWFrZUlzc3VlID0gKHBhcmFtcykgPT4ge1xuICAgIGNvbnN0IHsgZGF0YSwgcGF0aCwgZXJyb3JNYXBzLCBpc3N1ZURhdGEgfSA9IHBhcmFtcztcbiAgICBjb25zdCBmdWxsUGF0aCA9IFsuLi5wYXRoLCAuLi4oaXNzdWVEYXRhLnBhdGggfHwgW10pXTtcbiAgICBjb25zdCBmdWxsSXNzdWUgPSB7XG4gICAgICAgIC4uLmlzc3VlRGF0YSxcbiAgICAgICAgcGF0aDogZnVsbFBhdGgsXG4gICAgfTtcbiAgICBpZiAoaXNzdWVEYXRhLm1lc3NhZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uaXNzdWVEYXRhLFxuICAgICAgICAgICAgcGF0aDogZnVsbFBhdGgsXG4gICAgICAgICAgICBtZXNzYWdlOiBpc3N1ZURhdGEubWVzc2FnZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgbGV0IGVycm9yTWVzc2FnZSA9IFwiXCI7XG4gICAgY29uc3QgbWFwcyA9IGVycm9yTWFwc1xuICAgICAgICAuZmlsdGVyKChtKSA9PiAhIW0pXG4gICAgICAgIC5zbGljZSgpXG4gICAgICAgIC5yZXZlcnNlKCk7XG4gICAgZm9yIChjb25zdCBtYXAgb2YgbWFwcykge1xuICAgICAgICBlcnJvck1lc3NhZ2UgPSBtYXAoZnVsbElzc3VlLCB7IGRhdGEsIGRlZmF1bHRFcnJvcjogZXJyb3JNZXNzYWdlIH0pLm1lc3NhZ2U7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIC4uLmlzc3VlRGF0YSxcbiAgICAgICAgcGF0aDogZnVsbFBhdGgsXG4gICAgICAgIG1lc3NhZ2U6IGVycm9yTWVzc2FnZSxcbiAgICB9O1xufTtcbmV4cG9ydHMubWFrZUlzc3VlID0gbWFrZUlzc3VlO1xuZXhwb3J0cy5FTVBUWV9QQVRIID0gW107XG5mdW5jdGlvbiBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIGlzc3VlRGF0YSkge1xuICAgIGNvbnN0IG92ZXJyaWRlTWFwID0gKDAsIGVycm9yc19qc18xLmdldEVycm9yTWFwKSgpO1xuICAgIGNvbnN0IGlzc3VlID0gKDAsIGV4cG9ydHMubWFrZUlzc3VlKSh7XG4gICAgICAgIGlzc3VlRGF0YTogaXNzdWVEYXRhLFxuICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgIGVycm9yTWFwczogW1xuICAgICAgICAgICAgY3R4LmNvbW1vbi5jb250ZXh0dWFsRXJyb3JNYXAsIC8vIGNvbnRleHR1YWwgZXJyb3IgbWFwIGlzIGZpcnN0IHByaW9yaXR5XG4gICAgICAgICAgICBjdHguc2NoZW1hRXJyb3JNYXAsIC8vIHRoZW4gc2NoZW1hLWJvdW5kIG1hcCBpZiBhdmFpbGFibGVcbiAgICAgICAgICAgIG92ZXJyaWRlTWFwLCAvLyB0aGVuIGdsb2JhbCBvdmVycmlkZSBtYXBcbiAgICAgICAgICAgIG92ZXJyaWRlTWFwID09PSBlbl9qc18xLmRlZmF1bHQgPyB1bmRlZmluZWQgOiBlbl9qc18xLmRlZmF1bHQsIC8vIHRoZW4gZ2xvYmFsIGRlZmF1bHQgbWFwXG4gICAgICAgIF0uZmlsdGVyKCh4KSA9PiAhIXgpLFxuICAgIH0pO1xuICAgIGN0eC5jb21tb24uaXNzdWVzLnB1c2goaXNzdWUpO1xufVxuY2xhc3MgUGFyc2VTdGF0dXMge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnZhbHVlID0gXCJ2YWxpZFwiO1xuICAgIH1cbiAgICBkaXJ0eSgpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWUgPT09IFwidmFsaWRcIilcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBcImRpcnR5XCI7XG4gICAgfVxuICAgIGFib3J0KCkge1xuICAgICAgICBpZiAodGhpcy52YWx1ZSAhPT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gXCJhYm9ydGVkXCI7XG4gICAgfVxuICAgIHN0YXRpYyBtZXJnZUFycmF5KHN0YXR1cywgcmVzdWx0cykge1xuICAgICAgICBjb25zdCBhcnJheVZhbHVlID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcyBvZiByZXN1bHRzKSB7XG4gICAgICAgICAgICBpZiAocy5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBleHBvcnRzLklOVkFMSUQ7XG4gICAgICAgICAgICBpZiAocy5zdGF0dXMgPT09IFwiZGlydHlcIilcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgIGFycmF5VmFsdWUucHVzaChzLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGFycmF5VmFsdWUgfTtcbiAgICB9XG4gICAgc3RhdGljIGFzeW5jIG1lcmdlT2JqZWN0QXN5bmMoc3RhdHVzLCBwYWlycykge1xuICAgICAgICBjb25zdCBzeW5jUGFpcnMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBwYWlyIG9mIHBhaXJzKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCBwYWlyLmtleTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgcGFpci52YWx1ZTtcbiAgICAgICAgICAgIHN5bmNQYWlycy5wdXNoKHtcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VPYmplY3RTeW5jKHN0YXR1cywgc3luY1BhaXJzKTtcbiAgICB9XG4gICAgc3RhdGljIG1lcmdlT2JqZWN0U3luYyhzdGF0dXMsIHBhaXJzKSB7XG4gICAgICAgIGNvbnN0IGZpbmFsT2JqZWN0ID0ge307XG4gICAgICAgIGZvciAoY29uc3QgcGFpciBvZiBwYWlycykge1xuICAgICAgICAgICAgY29uc3QgeyBrZXksIHZhbHVlIH0gPSBwYWlyO1xuICAgICAgICAgICAgaWYgKGtleS5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBleHBvcnRzLklOVkFMSUQ7XG4gICAgICAgICAgICBpZiAodmFsdWUuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5JTlZBTElEO1xuICAgICAgICAgICAgaWYgKGtleS5zdGF0dXMgPT09IFwiZGlydHlcIilcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5zdGF0dXMgPT09IFwiZGlydHlcIilcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgIGlmIChrZXkudmFsdWUgIT09IFwiX19wcm90b19fXCIgJiYgKHR5cGVvZiB2YWx1ZS52YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIiB8fCBwYWlyLmFsd2F5c1NldCkpIHtcbiAgICAgICAgICAgICAgICBmaW5hbE9iamVjdFtrZXkudmFsdWVdID0gdmFsdWUudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBmaW5hbE9iamVjdCB9O1xuICAgIH1cbn1cbmV4cG9ydHMuUGFyc2VTdGF0dXMgPSBQYXJzZVN0YXR1cztcbmV4cG9ydHMuSU5WQUxJRCA9IE9iamVjdC5mcmVlemUoe1xuICAgIHN0YXR1czogXCJhYm9ydGVkXCIsXG59KTtcbmNvbnN0IERJUlRZID0gKHZhbHVlKSA9PiAoeyBzdGF0dXM6IFwiZGlydHlcIiwgdmFsdWUgfSk7XG5leHBvcnRzLkRJUlRZID0gRElSVFk7XG5jb25zdCBPSyA9ICh2YWx1ZSkgPT4gKHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlIH0pO1xuZXhwb3J0cy5PSyA9IE9LO1xuY29uc3QgaXNBYm9ydGVkID0gKHgpID0+IHguc3RhdHVzID09PSBcImFib3J0ZWRcIjtcbmV4cG9ydHMuaXNBYm9ydGVkID0gaXNBYm9ydGVkO1xuY29uc3QgaXNEaXJ0eSA9ICh4KSA9PiB4LnN0YXR1cyA9PT0gXCJkaXJ0eVwiO1xuZXhwb3J0cy5pc0RpcnR5ID0gaXNEaXJ0eTtcbmNvbnN0IGlzVmFsaWQgPSAoeCkgPT4geC5zdGF0dXMgPT09IFwidmFsaWRcIjtcbmV4cG9ydHMuaXNWYWxpZCA9IGlzVmFsaWQ7XG5jb25zdCBpc0FzeW5jID0gKHgpID0+IHR5cGVvZiBQcm9taXNlICE9PSBcInVuZGVmaW5lZFwiICYmIHggaW5zdGFuY2VvZiBQcm9taXNlO1xuZXhwb3J0cy5pc0FzeW5jID0gaXNBc3luYztcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/zod/v3/helpers/parseUtil.cjs\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/zod/v3/helpers/typeAliases.cjs":
/*!*********************************************************!*\
  !*** ../../node_modules/zod/v3/helpers/typeAliases.cjs ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvem9kL3YzL2hlbHBlcnMvdHlwZUFsaWFzZXMuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXG5hdGhhXFxPbmVEcml2ZVxcRGVza3RvcFxcTW9uZXlRdWVzdFYzXFxub2RlX21vZHVsZXNcXHpvZFxcdjNcXGhlbHBlcnNcXHR5cGVBbGlhc2VzLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/zod/v3/helpers/typeAliases.cjs\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/zod/v3/helpers/util.cjs":
/*!**************************************************!*\
  !*** ../../node_modules/zod/v3/helpers/util.cjs ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getParsedType = exports.ZodParsedType = exports.objectUtil = exports.util = void 0;\nvar util;\n(function (util) {\n    util.assertEqual = (_) => { };\n    function assertIs(_arg) { }\n    util.assertIs = assertIs;\n    function assertNever(_x) {\n        throw new Error();\n    }\n    util.assertNever = assertNever;\n    util.arrayToEnum = (items) => {\n        const obj = {};\n        for (const item of items) {\n            obj[item] = item;\n        }\n        return obj;\n    };\n    util.getValidEnumValues = (obj) => {\n        const validKeys = util.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== \"number\");\n        const filtered = {};\n        for (const k of validKeys) {\n            filtered[k] = obj[k];\n        }\n        return util.objectValues(filtered);\n    };\n    util.objectValues = (obj) => {\n        return util.objectKeys(obj).map(function (e) {\n            return obj[e];\n        });\n    };\n    util.objectKeys = typeof Object.keys === \"function\" // eslint-disable-line ban/ban\n        ? (obj) => Object.keys(obj) // eslint-disable-line ban/ban\n        : (object) => {\n            const keys = [];\n            for (const key in object) {\n                if (Object.prototype.hasOwnProperty.call(object, key)) {\n                    keys.push(key);\n                }\n            }\n            return keys;\n        };\n    util.find = (arr, checker) => {\n        for (const item of arr) {\n            if (checker(item))\n                return item;\n        }\n        return undefined;\n    };\n    util.isInteger = typeof Number.isInteger === \"function\"\n        ? (val) => Number.isInteger(val) // eslint-disable-line ban/ban\n        : (val) => typeof val === \"number\" && Number.isFinite(val) && Math.floor(val) === val;\n    function joinValues(array, separator = \" | \") {\n        return array.map((val) => (typeof val === \"string\" ? `'${val}'` : val)).join(separator);\n    }\n    util.joinValues = joinValues;\n    util.jsonStringifyReplacer = (_, value) => {\n        if (typeof value === \"bigint\") {\n            return value.toString();\n        }\n        return value;\n    };\n})(util || (exports.util = util = {}));\nvar objectUtil;\n(function (objectUtil) {\n    objectUtil.mergeShapes = (first, second) => {\n        return {\n            ...first,\n            ...second, // second overwrites first\n        };\n    };\n})(objectUtil || (exports.objectUtil = objectUtil = {}));\nexports.ZodParsedType = util.arrayToEnum([\n    \"string\",\n    \"nan\",\n    \"number\",\n    \"integer\",\n    \"float\",\n    \"boolean\",\n    \"date\",\n    \"bigint\",\n    \"symbol\",\n    \"function\",\n    \"undefined\",\n    \"null\",\n    \"array\",\n    \"object\",\n    \"unknown\",\n    \"promise\",\n    \"void\",\n    \"never\",\n    \"map\",\n    \"set\",\n]);\nconst getParsedType = (data) => {\n    const t = typeof data;\n    switch (t) {\n        case \"undefined\":\n            return exports.ZodParsedType.undefined;\n        case \"string\":\n            return exports.ZodParsedType.string;\n        case \"number\":\n            return Number.isNaN(data) ? exports.ZodParsedType.nan : exports.ZodParsedType.number;\n        case \"boolean\":\n            return exports.ZodParsedType.boolean;\n        case \"function\":\n            return exports.ZodParsedType.function;\n        case \"bigint\":\n            return exports.ZodParsedType.bigint;\n        case \"symbol\":\n            return exports.ZodParsedType.symbol;\n        case \"object\":\n            if (Array.isArray(data)) {\n                return exports.ZodParsedType.array;\n            }\n            if (data === null) {\n                return exports.ZodParsedType.null;\n            }\n            if (data.then && typeof data.then === \"function\" && data.catch && typeof data.catch === \"function\") {\n                return exports.ZodParsedType.promise;\n            }\n            if (typeof Map !== \"undefined\" && data instanceof Map) {\n                return exports.ZodParsedType.map;\n            }\n            if (typeof Set !== \"undefined\" && data instanceof Set) {\n                return exports.ZodParsedType.set;\n            }\n            if (typeof Date !== \"undefined\" && data instanceof Date) {\n                return exports.ZodParsedType.date;\n            }\n            return exports.ZodParsedType.object;\n        default:\n            return exports.ZodParsedType.unknown;\n    }\n};\nexports.getParsedType = getParsedType;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvem9kL3YzL2hlbHBlcnMvdXRpbC5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcsa0JBQWtCLEdBQUcsWUFBWTtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxJQUFJO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLFdBQVcsWUFBWSxZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGlCQUFpQixrQkFBa0Isa0JBQWtCO0FBQ3RELHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXG5hdGhhXFxPbmVEcml2ZVxcRGVza3RvcFxcTW9uZXlRdWVzdFYzXFxub2RlX21vZHVsZXNcXHpvZFxcdjNcXGhlbHBlcnNcXHV0aWwuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRQYXJzZWRUeXBlID0gZXhwb3J0cy5ab2RQYXJzZWRUeXBlID0gZXhwb3J0cy5vYmplY3RVdGlsID0gZXhwb3J0cy51dGlsID0gdm9pZCAwO1xudmFyIHV0aWw7XG4oZnVuY3Rpb24gKHV0aWwpIHtcbiAgICB1dGlsLmFzc2VydEVxdWFsID0gKF8pID0+IHsgfTtcbiAgICBmdW5jdGlvbiBhc3NlcnRJcyhfYXJnKSB7IH1cbiAgICB1dGlsLmFzc2VydElzID0gYXNzZXJ0SXM7XG4gICAgZnVuY3Rpb24gYXNzZXJ0TmV2ZXIoX3gpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgfVxuICAgIHV0aWwuYXNzZXJ0TmV2ZXIgPSBhc3NlcnROZXZlcjtcbiAgICB1dGlsLmFycmF5VG9FbnVtID0gKGl0ZW1zKSA9PiB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlbXMpIHtcbiAgICAgICAgICAgIG9ialtpdGVtXSA9IGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xuICAgIHV0aWwuZ2V0VmFsaWRFbnVtVmFsdWVzID0gKG9iaikgPT4ge1xuICAgICAgICBjb25zdCB2YWxpZEtleXMgPSB1dGlsLm9iamVjdEtleXMob2JqKS5maWx0ZXIoKGspID0+IHR5cGVvZiBvYmpbb2JqW2tdXSAhPT0gXCJudW1iZXJcIik7XG4gICAgICAgIGNvbnN0IGZpbHRlcmVkID0ge307XG4gICAgICAgIGZvciAoY29uc3QgayBvZiB2YWxpZEtleXMpIHtcbiAgICAgICAgICAgIGZpbHRlcmVkW2tdID0gb2JqW2tdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1dGlsLm9iamVjdFZhbHVlcyhmaWx0ZXJlZCk7XG4gICAgfTtcbiAgICB1dGlsLm9iamVjdFZhbHVlcyA9IChvYmopID0+IHtcbiAgICAgICAgcmV0dXJuIHV0aWwub2JqZWN0S2V5cyhvYmopLm1hcChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIG9ialtlXTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICB1dGlsLm9iamVjdEtleXMgPSB0eXBlb2YgT2JqZWN0LmtleXMgPT09IFwiZnVuY3Rpb25cIiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGJhbi9iYW5cbiAgICAgICAgPyAob2JqKSA9PiBPYmplY3Qua2V5cyhvYmopIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgYmFuL2JhblxuICAgICAgICA6IChvYmplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBrZXlzO1xuICAgICAgICB9O1xuICAgIHV0aWwuZmluZCA9IChhcnIsIGNoZWNrZXIpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGFycikge1xuICAgICAgICAgICAgaWYgKGNoZWNrZXIoaXRlbSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIHV0aWwuaXNJbnRlZ2VyID0gdHlwZW9mIE51bWJlci5pc0ludGVnZXIgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICA/ICh2YWwpID0+IE51bWJlci5pc0ludGVnZXIodmFsKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGJhbi9iYW5cbiAgICAgICAgOiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSBcIm51bWJlclwiICYmIE51bWJlci5pc0Zpbml0ZSh2YWwpICYmIE1hdGguZmxvb3IodmFsKSA9PT0gdmFsO1xuICAgIGZ1bmN0aW9uIGpvaW5WYWx1ZXMoYXJyYXksIHNlcGFyYXRvciA9IFwiIHwgXCIpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5Lm1hcCgodmFsKSA9PiAodHlwZW9mIHZhbCA9PT0gXCJzdHJpbmdcIiA/IGAnJHt2YWx9J2AgOiB2YWwpKS5qb2luKHNlcGFyYXRvcik7XG4gICAgfVxuICAgIHV0aWwuam9pblZhbHVlcyA9IGpvaW5WYWx1ZXM7XG4gICAgdXRpbC5qc29uU3RyaW5naWZ5UmVwbGFjZXIgPSAoXywgdmFsdWUpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJiaWdpbnRcIikge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG59KSh1dGlsIHx8IChleHBvcnRzLnV0aWwgPSB1dGlsID0ge30pKTtcbnZhciBvYmplY3RVdGlsO1xuKGZ1bmN0aW9uIChvYmplY3RVdGlsKSB7XG4gICAgb2JqZWN0VXRpbC5tZXJnZVNoYXBlcyA9IChmaXJzdCwgc2Vjb25kKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5maXJzdCxcbiAgICAgICAgICAgIC4uLnNlY29uZCwgLy8gc2Vjb25kIG92ZXJ3cml0ZXMgZmlyc3RcbiAgICAgICAgfTtcbiAgICB9O1xufSkob2JqZWN0VXRpbCB8fCAoZXhwb3J0cy5vYmplY3RVdGlsID0gb2JqZWN0VXRpbCA9IHt9KSk7XG5leHBvcnRzLlpvZFBhcnNlZFR5cGUgPSB1dGlsLmFycmF5VG9FbnVtKFtcbiAgICBcInN0cmluZ1wiLFxuICAgIFwibmFuXCIsXG4gICAgXCJudW1iZXJcIixcbiAgICBcImludGVnZXJcIixcbiAgICBcImZsb2F0XCIsXG4gICAgXCJib29sZWFuXCIsXG4gICAgXCJkYXRlXCIsXG4gICAgXCJiaWdpbnRcIixcbiAgICBcInN5bWJvbFwiLFxuICAgIFwiZnVuY3Rpb25cIixcbiAgICBcInVuZGVmaW5lZFwiLFxuICAgIFwibnVsbFwiLFxuICAgIFwiYXJyYXlcIixcbiAgICBcIm9iamVjdFwiLFxuICAgIFwidW5rbm93blwiLFxuICAgIFwicHJvbWlzZVwiLFxuICAgIFwidm9pZFwiLFxuICAgIFwibmV2ZXJcIixcbiAgICBcIm1hcFwiLFxuICAgIFwic2V0XCIsXG5dKTtcbmNvbnN0IGdldFBhcnNlZFR5cGUgPSAoZGF0YSkgPT4ge1xuICAgIGNvbnN0IHQgPSB0eXBlb2YgZGF0YTtcbiAgICBzd2l0Y2ggKHQpIHtcbiAgICAgICAgY2FzZSBcInVuZGVmaW5lZFwiOlxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuWm9kUGFyc2VkVHlwZS51bmRlZmluZWQ7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLlpvZFBhcnNlZFR5cGUuc3RyaW5nO1xuICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyLmlzTmFOKGRhdGEpID8gZXhwb3J0cy5ab2RQYXJzZWRUeXBlLm5hbiA6IGV4cG9ydHMuWm9kUGFyc2VkVHlwZS5udW1iZXI7XG4gICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5ab2RQYXJzZWRUeXBlLmJvb2xlYW47XG4gICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuWm9kUGFyc2VkVHlwZS5mdW5jdGlvbjtcbiAgICAgICAgY2FzZSBcImJpZ2ludFwiOlxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuWm9kUGFyc2VkVHlwZS5iaWdpbnQ7XG4gICAgICAgIGNhc2UgXCJzeW1ib2xcIjpcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLlpvZFBhcnNlZFR5cGUuc3ltYm9sO1xuICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBleHBvcnRzLlpvZFBhcnNlZFR5cGUuYXJyYXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBleHBvcnRzLlpvZFBhcnNlZFR5cGUubnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRhLnRoZW4gJiYgdHlwZW9mIGRhdGEudGhlbiA9PT0gXCJmdW5jdGlvblwiICYmIGRhdGEuY2F0Y2ggJiYgdHlwZW9mIGRhdGEuY2F0Y2ggPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBleHBvcnRzLlpvZFBhcnNlZFR5cGUucHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgTWFwICE9PSBcInVuZGVmaW5lZFwiICYmIGRhdGEgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5ab2RQYXJzZWRUeXBlLm1hcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgU2V0ICE9PSBcInVuZGVmaW5lZFwiICYmIGRhdGEgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5ab2RQYXJzZWRUeXBlLnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgRGF0ZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkYXRhIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBleHBvcnRzLlpvZFBhcnNlZFR5cGUuZGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLlpvZFBhcnNlZFR5cGUub2JqZWN0O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuWm9kUGFyc2VkVHlwZS51bmtub3duO1xuICAgIH1cbn07XG5leHBvcnRzLmdldFBhcnNlZFR5cGUgPSBnZXRQYXJzZWRUeXBlO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/zod/v3/helpers/util.cjs\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/zod/v3/locales/en.cjs":
/*!************************************************!*\
  !*** ../../node_modules/zod/v3/locales/en.cjs ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst ZodError_js_1 = __webpack_require__(/*! ../ZodError.cjs */ \"(app-pages-browser)/../../node_modules/zod/v3/ZodError.cjs\");\nconst util_js_1 = __webpack_require__(/*! ../helpers/util.cjs */ \"(app-pages-browser)/../../node_modules/zod/v3/helpers/util.cjs\");\nconst errorMap = (issue, _ctx) => {\n    let message;\n    switch (issue.code) {\n        case ZodError_js_1.ZodIssueCode.invalid_type:\n            if (issue.received === util_js_1.ZodParsedType.undefined) {\n                message = \"Required\";\n            }\n            else {\n                message = `Expected ${issue.expected}, received ${issue.received}`;\n            }\n            break;\n        case ZodError_js_1.ZodIssueCode.invalid_literal:\n            message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util_js_1.util.jsonStringifyReplacer)}`;\n            break;\n        case ZodError_js_1.ZodIssueCode.unrecognized_keys:\n            message = `Unrecognized key(s) in object: ${util_js_1.util.joinValues(issue.keys, \", \")}`;\n            break;\n        case ZodError_js_1.ZodIssueCode.invalid_union:\n            message = `Invalid input`;\n            break;\n        case ZodError_js_1.ZodIssueCode.invalid_union_discriminator:\n            message = `Invalid discriminator value. Expected ${util_js_1.util.joinValues(issue.options)}`;\n            break;\n        case ZodError_js_1.ZodIssueCode.invalid_enum_value:\n            message = `Invalid enum value. Expected ${util_js_1.util.joinValues(issue.options)}, received '${issue.received}'`;\n            break;\n        case ZodError_js_1.ZodIssueCode.invalid_arguments:\n            message = `Invalid function arguments`;\n            break;\n        case ZodError_js_1.ZodIssueCode.invalid_return_type:\n            message = `Invalid function return type`;\n            break;\n        case ZodError_js_1.ZodIssueCode.invalid_date:\n            message = `Invalid date`;\n            break;\n        case ZodError_js_1.ZodIssueCode.invalid_string:\n            if (typeof issue.validation === \"object\") {\n                if (\"includes\" in issue.validation) {\n                    message = `Invalid input: must include \"${issue.validation.includes}\"`;\n                    if (typeof issue.validation.position === \"number\") {\n                        message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;\n                    }\n                }\n                else if (\"startsWith\" in issue.validation) {\n                    message = `Invalid input: must start with \"${issue.validation.startsWith}\"`;\n                }\n                else if (\"endsWith\" in issue.validation) {\n                    message = `Invalid input: must end with \"${issue.validation.endsWith}\"`;\n                }\n                else {\n                    util_js_1.util.assertNever(issue.validation);\n                }\n            }\n            else if (issue.validation !== \"regex\") {\n                message = `Invalid ${issue.validation}`;\n            }\n            else {\n                message = \"Invalid\";\n            }\n            break;\n        case ZodError_js_1.ZodIssueCode.too_small:\n            if (issue.type === \"array\")\n                message = `Array must contain ${issue.exact ? \"exactly\" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;\n            else if (issue.type === \"string\")\n                message = `String must contain ${issue.exact ? \"exactly\" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;\n            else if (issue.type === \"number\")\n                message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;\n            else if (issue.type === \"bigint\")\n                message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;\n            else if (issue.type === \"date\")\n                message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;\n            else\n                message = \"Invalid input\";\n            break;\n        case ZodError_js_1.ZodIssueCode.too_big:\n            if (issue.type === \"array\")\n                message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;\n            else if (issue.type === \"string\")\n                message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;\n            else if (issue.type === \"number\")\n                message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;\n            else if (issue.type === \"bigint\")\n                message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;\n            else if (issue.type === \"date\")\n                message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;\n            else\n                message = \"Invalid input\";\n            break;\n        case ZodError_js_1.ZodIssueCode.custom:\n            message = `Invalid input`;\n            break;\n        case ZodError_js_1.ZodIssueCode.invalid_intersection_types:\n            message = `Intersection results could not be merged`;\n            break;\n        case ZodError_js_1.ZodIssueCode.not_multiple_of:\n            message = `Number must be a multiple of ${issue.multipleOf}`;\n            break;\n        case ZodError_js_1.ZodIssueCode.not_finite:\n            message = \"Number must be finite\";\n            break;\n        default:\n            message = _ctx.defaultError;\n            util_js_1.util.assertNever(issue);\n    }\n    return { message };\n};\nexports[\"default\"] = errorMap;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvem9kL3YzL2xvY2FsZXMvZW4uY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHNCQUFzQixtQkFBTyxDQUFDLG1GQUFpQjtBQUMvQyxrQkFBa0IsbUJBQU8sQ0FBQywyRkFBcUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxlQUFlLGFBQWEsZUFBZTtBQUNqRjtBQUNBO0FBQ0E7QUFDQSx5REFBeUQscUVBQXFFO0FBQzlIO0FBQ0E7QUFDQSx3REFBd0QsNENBQTRDO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QseUNBQXlDO0FBQ3hHO0FBQ0E7QUFDQSxzREFBc0QseUNBQXlDLGNBQWMsZUFBZTtBQUM1SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCwwQkFBMEI7QUFDeEY7QUFDQSxxQ0FBcUMsU0FBUyxvREFBb0QsMEJBQTBCO0FBQzVIO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSw0QkFBNEI7QUFDN0Y7QUFDQTtBQUNBLCtEQUErRCwwQkFBMEI7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGlCQUFpQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxzRUFBc0UsRUFBRSxlQUFlO0FBQ3ZJO0FBQ0EsaURBQWlELGlFQUFpRSxFQUFFLGVBQWU7QUFDbkk7QUFDQSw0Q0FBNEMsb0dBQW9HLEVBQUUsY0FBYztBQUNoSztBQUNBLDRDQUE0QyxvR0FBb0csRUFBRSxjQUFjO0FBQ2hLO0FBQ0EsMENBQTBDLG9HQUFvRyxFQUFFLGdDQUFnQztBQUNoTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELHFFQUFxRSxFQUFFLGVBQWU7QUFDdEk7QUFDQSxpREFBaUQsaUVBQWlFLEVBQUUsZUFBZTtBQUNuSTtBQUNBLDRDQUE0QyxtRkFBbUYsRUFBRSxjQUFjO0FBQy9JO0FBQ0EsNENBQTRDLG1GQUFtRixFQUFFLGNBQWM7QUFDL0k7QUFDQSwwQ0FBMEMseUZBQXlGLEVBQUUsZ0NBQWdDO0FBQ3JLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELGlCQUFpQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0Esa0JBQWUiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbmF0aGFcXE9uZURyaXZlXFxEZXNrdG9wXFxNb25leVF1ZXN0VjNcXG5vZGVfbW9kdWxlc1xcem9kXFx2M1xcbG9jYWxlc1xcZW4uY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgWm9kRXJyb3JfanNfMSA9IHJlcXVpcmUoXCIuLi9ab2RFcnJvci5janNcIik7XG5jb25zdCB1dGlsX2pzXzEgPSByZXF1aXJlKFwiLi4vaGVscGVycy91dGlsLmNqc1wiKTtcbmNvbnN0IGVycm9yTWFwID0gKGlzc3VlLCBfY3R4KSA9PiB7XG4gICAgbGV0IG1lc3NhZ2U7XG4gICAgc3dpdGNoIChpc3N1ZS5jb2RlKSB7XG4gICAgICAgIGNhc2UgWm9kRXJyb3JfanNfMS5ab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlOlxuICAgICAgICAgICAgaWYgKGlzc3VlLnJlY2VpdmVkID09PSB1dGlsX2pzXzEuWm9kUGFyc2VkVHlwZS51bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gXCJSZXF1aXJlZFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBFeHBlY3RlZCAke2lzc3VlLmV4cGVjdGVkfSwgcmVjZWl2ZWQgJHtpc3N1ZS5yZWNlaXZlZH1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kRXJyb3JfanNfMS5ab2RJc3N1ZUNvZGUuaW52YWxpZF9saXRlcmFsOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGxpdGVyYWwgdmFsdWUsIGV4cGVjdGVkICR7SlNPTi5zdHJpbmdpZnkoaXNzdWUuZXhwZWN0ZWQsIHV0aWxfanNfMS51dGlsLmpzb25TdHJpbmdpZnlSZXBsYWNlcil9YDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZEVycm9yX2pzXzEuWm9kSXNzdWVDb2RlLnVucmVjb2duaXplZF9rZXlzOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBVbnJlY29nbml6ZWQga2V5KHMpIGluIG9iamVjdDogJHt1dGlsX2pzXzEudXRpbC5qb2luVmFsdWVzKGlzc3VlLmtleXMsIFwiLCBcIil9YDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZEVycm9yX2pzXzEuWm9kSXNzdWVDb2RlLmludmFsaWRfdW5pb246XG4gICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgaW5wdXRgO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kRXJyb3JfanNfMS5ab2RJc3N1ZUNvZGUuaW52YWxpZF91bmlvbl9kaXNjcmltaW5hdG9yOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGRpc2NyaW1pbmF0b3IgdmFsdWUuIEV4cGVjdGVkICR7dXRpbF9qc18xLnV0aWwuam9pblZhbHVlcyhpc3N1ZS5vcHRpb25zKX1gO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kRXJyb3JfanNfMS5ab2RJc3N1ZUNvZGUuaW52YWxpZF9lbnVtX3ZhbHVlOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGVudW0gdmFsdWUuIEV4cGVjdGVkICR7dXRpbF9qc18xLnV0aWwuam9pblZhbHVlcyhpc3N1ZS5vcHRpb25zKX0sIHJlY2VpdmVkICcke2lzc3VlLnJlY2VpdmVkfSdgO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kRXJyb3JfanNfMS5ab2RJc3N1ZUNvZGUuaW52YWxpZF9hcmd1bWVudHM6XG4gICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgZnVuY3Rpb24gYXJndW1lbnRzYDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZEVycm9yX2pzXzEuWm9kSXNzdWVDb2RlLmludmFsaWRfcmV0dXJuX3R5cGU6XG4gICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgZnVuY3Rpb24gcmV0dXJuIHR5cGVgO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kRXJyb3JfanNfMS5ab2RJc3N1ZUNvZGUuaW52YWxpZF9kYXRlOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGRhdGVgO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kRXJyb3JfanNfMS5ab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmc6XG4gICAgICAgICAgICBpZiAodHlwZW9mIGlzc3VlLnZhbGlkYXRpb24gPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoXCJpbmNsdWRlc1wiIGluIGlzc3VlLnZhbGlkYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGlucHV0OiBtdXN0IGluY2x1ZGUgXCIke2lzc3VlLnZhbGlkYXRpb24uaW5jbHVkZXN9XCJgO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGlzc3VlLnZhbGlkYXRpb24ucG9zaXRpb24gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgJHttZXNzYWdlfSBhdCBvbmUgb3IgbW9yZSBwb3NpdGlvbnMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvICR7aXNzdWUudmFsaWRhdGlvbi5wb3NpdGlvbn1gO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKFwic3RhcnRzV2l0aFwiIGluIGlzc3VlLnZhbGlkYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGlucHV0OiBtdXN0IHN0YXJ0IHdpdGggXCIke2lzc3VlLnZhbGlkYXRpb24uc3RhcnRzV2l0aH1cImA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKFwiZW5kc1dpdGhcIiBpbiBpc3N1ZS52YWxpZGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBpbnB1dDogbXVzdCBlbmQgd2l0aCBcIiR7aXNzdWUudmFsaWRhdGlvbi5lbmRzV2l0aH1cImA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB1dGlsX2pzXzEudXRpbC5hc3NlcnROZXZlcihpc3N1ZS52YWxpZGF0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS52YWxpZGF0aW9uICE9PSBcInJlZ2V4XCIpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgJHtpc3N1ZS52YWxpZGF0aW9ufWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gXCJJbnZhbGlkXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RFcnJvcl9qc18xLlpvZElzc3VlQ29kZS50b29fc21hbGw6XG4gICAgICAgICAgICBpZiAoaXNzdWUudHlwZSA9PT0gXCJhcnJheVwiKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgQXJyYXkgbXVzdCBjb250YWluICR7aXNzdWUuZXhhY3QgPyBcImV4YWN0bHlcIiA6IGlzc3VlLmluY2x1c2l2ZSA/IGBhdCBsZWFzdGAgOiBgbW9yZSB0aGFuYH0gJHtpc3N1ZS5taW5pbXVtfSBlbGVtZW50KHMpYDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnR5cGUgPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBTdHJpbmcgbXVzdCBjb250YWluICR7aXNzdWUuZXhhY3QgPyBcImV4YWN0bHlcIiA6IGlzc3VlLmluY2x1c2l2ZSA/IGBhdCBsZWFzdGAgOiBgb3ZlcmB9ICR7aXNzdWUubWluaW11bX0gY2hhcmFjdGVyKHMpYDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnR5cGUgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBOdW1iZXIgbXVzdCBiZSAke2lzc3VlLmV4YWN0ID8gYGV4YWN0bHkgZXF1YWwgdG8gYCA6IGlzc3VlLmluY2x1c2l2ZSA/IGBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gYCA6IGBncmVhdGVyIHRoYW4gYH0ke2lzc3VlLm1pbmltdW19YDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnR5cGUgPT09IFwiYmlnaW50XCIpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBOdW1iZXIgbXVzdCBiZSAke2lzc3VlLmV4YWN0ID8gYGV4YWN0bHkgZXF1YWwgdG8gYCA6IGlzc3VlLmluY2x1c2l2ZSA/IGBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gYCA6IGBncmVhdGVyIHRoYW4gYH0ke2lzc3VlLm1pbmltdW19YDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnR5cGUgPT09IFwiZGF0ZVwiKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgRGF0ZSBtdXN0IGJlICR7aXNzdWUuZXhhY3QgPyBgZXhhY3RseSBlcXVhbCB0byBgIDogaXNzdWUuaW5jbHVzaXZlID8gYGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBgIDogYGdyZWF0ZXIgdGhhbiBgfSR7bmV3IERhdGUoTnVtYmVyKGlzc3VlLm1pbmltdW0pKX1gO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBcIkludmFsaWQgaW5wdXRcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZEVycm9yX2pzXzEuWm9kSXNzdWVDb2RlLnRvb19iaWc6XG4gICAgICAgICAgICBpZiAoaXNzdWUudHlwZSA9PT0gXCJhcnJheVwiKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgQXJyYXkgbXVzdCBjb250YWluICR7aXNzdWUuZXhhY3QgPyBgZXhhY3RseWAgOiBpc3N1ZS5pbmNsdXNpdmUgPyBgYXQgbW9zdGAgOiBgbGVzcyB0aGFuYH0gJHtpc3N1ZS5tYXhpbXVtfSBlbGVtZW50KHMpYDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnR5cGUgPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBTdHJpbmcgbXVzdCBjb250YWluICR7aXNzdWUuZXhhY3QgPyBgZXhhY3RseWAgOiBpc3N1ZS5pbmNsdXNpdmUgPyBgYXQgbW9zdGAgOiBgdW5kZXJgfSAke2lzc3VlLm1heGltdW19IGNoYXJhY3RlcihzKWA7XG4gICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS50eXBlID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgTnVtYmVyIG11c3QgYmUgJHtpc3N1ZS5leGFjdCA/IGBleGFjdGx5YCA6IGlzc3VlLmluY2x1c2l2ZSA/IGBsZXNzIHRoYW4gb3IgZXF1YWwgdG9gIDogYGxlc3MgdGhhbmB9ICR7aXNzdWUubWF4aW11bX1gO1xuICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUudHlwZSA9PT0gXCJiaWdpbnRcIilcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYEJpZ0ludCBtdXN0IGJlICR7aXNzdWUuZXhhY3QgPyBgZXhhY3RseWAgOiBpc3N1ZS5pbmNsdXNpdmUgPyBgbGVzcyB0aGFuIG9yIGVxdWFsIHRvYCA6IGBsZXNzIHRoYW5gfSAke2lzc3VlLm1heGltdW19YDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnR5cGUgPT09IFwiZGF0ZVwiKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgRGF0ZSBtdXN0IGJlICR7aXNzdWUuZXhhY3QgPyBgZXhhY3RseWAgOiBpc3N1ZS5pbmNsdXNpdmUgPyBgc21hbGxlciB0aGFuIG9yIGVxdWFsIHRvYCA6IGBzbWFsbGVyIHRoYW5gfSAke25ldyBEYXRlKE51bWJlcihpc3N1ZS5tYXhpbXVtKSl9YDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gXCJJbnZhbGlkIGlucHV0XCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RFcnJvcl9qc18xLlpvZElzc3VlQ29kZS5jdXN0b206XG4gICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgaW5wdXRgO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kRXJyb3JfanNfMS5ab2RJc3N1ZUNvZGUuaW52YWxpZF9pbnRlcnNlY3Rpb25fdHlwZXM6XG4gICAgICAgICAgICBtZXNzYWdlID0gYEludGVyc2VjdGlvbiByZXN1bHRzIGNvdWxkIG5vdCBiZSBtZXJnZWRgO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kRXJyb3JfanNfMS5ab2RJc3N1ZUNvZGUubm90X211bHRpcGxlX29mOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBOdW1iZXIgbXVzdCBiZSBhIG11bHRpcGxlIG9mICR7aXNzdWUubXVsdGlwbGVPZn1gO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kRXJyb3JfanNfMS5ab2RJc3N1ZUNvZGUubm90X2Zpbml0ZTpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBcIk51bWJlciBtdXN0IGJlIGZpbml0ZVwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBtZXNzYWdlID0gX2N0eC5kZWZhdWx0RXJyb3I7XG4gICAgICAgICAgICB1dGlsX2pzXzEudXRpbC5hc3NlcnROZXZlcihpc3N1ZSk7XG4gICAgfVxuICAgIHJldHVybiB7IG1lc3NhZ2UgfTtcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBlcnJvck1hcDtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/zod/v3/locales/en.cjs\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/zod/v3/types.cjs":
/*!*******************************************!*\
  !*** ../../node_modules/zod/v3/types.cjs ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.discriminatedUnion = exports.date = exports.boolean = exports.bigint = exports.array = exports.any = exports.coerce = exports.ZodFirstPartyTypeKind = exports.late = exports.ZodSchema = exports.Schema = exports.ZodReadonly = exports.ZodPipeline = exports.ZodBranded = exports.BRAND = exports.ZodNaN = exports.ZodCatch = exports.ZodDefault = exports.ZodNullable = exports.ZodOptional = exports.ZodTransformer = exports.ZodEffects = exports.ZodPromise = exports.ZodNativeEnum = exports.ZodEnum = exports.ZodLiteral = exports.ZodLazy = exports.ZodFunction = exports.ZodSet = exports.ZodMap = exports.ZodRecord = exports.ZodTuple = exports.ZodIntersection = exports.ZodDiscriminatedUnion = exports.ZodUnion = exports.ZodObject = exports.ZodArray = exports.ZodVoid = exports.ZodNever = exports.ZodUnknown = exports.ZodAny = exports.ZodNull = exports.ZodUndefined = exports.ZodSymbol = exports.ZodDate = exports.ZodBoolean = exports.ZodBigInt = exports.ZodNumber = exports.ZodString = exports.ZodType = void 0;\nexports.NEVER = exports[\"void\"] = exports.unknown = exports.union = exports.undefined = exports.tuple = exports.transformer = exports.symbol = exports.string = exports.strictObject = exports.set = exports.record = exports.promise = exports.preprocess = exports.pipeline = exports.ostring = exports.optional = exports.onumber = exports.oboolean = exports.object = exports.number = exports.nullable = exports[\"null\"] = exports.never = exports.nativeEnum = exports.nan = exports.map = exports.literal = exports.lazy = exports.intersection = exports[\"instanceof\"] = exports[\"function\"] = exports[\"enum\"] = exports.effect = void 0;\nexports.datetimeRegex = datetimeRegex;\nexports.custom = custom;\nconst ZodError_js_1 = __webpack_require__(/*! ./ZodError.cjs */ \"(app-pages-browser)/../../node_modules/zod/v3/ZodError.cjs\");\nconst errors_js_1 = __webpack_require__(/*! ./errors.cjs */ \"(app-pages-browser)/../../node_modules/zod/v3/errors.cjs\");\nconst errorUtil_js_1 = __webpack_require__(/*! ./helpers/errorUtil.cjs */ \"(app-pages-browser)/../../node_modules/zod/v3/helpers/errorUtil.cjs\");\nconst parseUtil_js_1 = __webpack_require__(/*! ./helpers/parseUtil.cjs */ \"(app-pages-browser)/../../node_modules/zod/v3/helpers/parseUtil.cjs\");\nconst util_js_1 = __webpack_require__(/*! ./helpers/util.cjs */ \"(app-pages-browser)/../../node_modules/zod/v3/helpers/util.cjs\");\nclass ParseInputLazyPath {\n    constructor(parent, value, path, key) {\n        this._cachedPath = [];\n        this.parent = parent;\n        this.data = value;\n        this._path = path;\n        this._key = key;\n    }\n    get path() {\n        if (!this._cachedPath.length) {\n            if (Array.isArray(this._key)) {\n                this._cachedPath.push(...this._path, ...this._key);\n            }\n            else {\n                this._cachedPath.push(...this._path, this._key);\n            }\n        }\n        return this._cachedPath;\n    }\n}\nconst handleResult = (ctx, result) => {\n    if ((0, parseUtil_js_1.isValid)(result)) {\n        return { success: true, data: result.value };\n    }\n    else {\n        if (!ctx.common.issues.length) {\n            throw new Error(\"Validation failed but no issues detected.\");\n        }\n        return {\n            success: false,\n            get error() {\n                if (this._error)\n                    return this._error;\n                const error = new ZodError_js_1.ZodError(ctx.common.issues);\n                this._error = error;\n                return this._error;\n            },\n        };\n    }\n};\nfunction processCreateParams(params) {\n    if (!params)\n        return {};\n    const { errorMap, invalid_type_error, required_error, description } = params;\n    if (errorMap && (invalid_type_error || required_error)) {\n        throw new Error(`Can't use \"invalid_type_error\" or \"required_error\" in conjunction with custom error map.`);\n    }\n    if (errorMap)\n        return { errorMap: errorMap, description };\n    const customMap = (iss, ctx) => {\n        const { message } = params;\n        if (iss.code === \"invalid_enum_value\") {\n            return { message: message ?? ctx.defaultError };\n        }\n        if (typeof ctx.data === \"undefined\") {\n            return { message: message ?? required_error ?? ctx.defaultError };\n        }\n        if (iss.code !== \"invalid_type\")\n            return { message: ctx.defaultError };\n        return { message: message ?? invalid_type_error ?? ctx.defaultError };\n    };\n    return { errorMap: customMap, description };\n}\nclass ZodType {\n    get description() {\n        return this._def.description;\n    }\n    _getType(input) {\n        return (0, util_js_1.getParsedType)(input.data);\n    }\n    _getOrReturnCtx(input, ctx) {\n        return (ctx || {\n            common: input.parent.common,\n            data: input.data,\n            parsedType: (0, util_js_1.getParsedType)(input.data),\n            schemaErrorMap: this._def.errorMap,\n            path: input.path,\n            parent: input.parent,\n        });\n    }\n    _processInputParams(input) {\n        return {\n            status: new parseUtil_js_1.ParseStatus(),\n            ctx: {\n                common: input.parent.common,\n                data: input.data,\n                parsedType: (0, util_js_1.getParsedType)(input.data),\n                schemaErrorMap: this._def.errorMap,\n                path: input.path,\n                parent: input.parent,\n            },\n        };\n    }\n    _parseSync(input) {\n        const result = this._parse(input);\n        if ((0, parseUtil_js_1.isAsync)(result)) {\n            throw new Error(\"Synchronous parse encountered promise.\");\n        }\n        return result;\n    }\n    _parseAsync(input) {\n        const result = this._parse(input);\n        return Promise.resolve(result);\n    }\n    parse(data, params) {\n        const result = this.safeParse(data, params);\n        if (result.success)\n            return result.data;\n        throw result.error;\n    }\n    safeParse(data, params) {\n        const ctx = {\n            common: {\n                issues: [],\n                async: params?.async ?? false,\n                contextualErrorMap: params?.errorMap,\n            },\n            path: params?.path || [],\n            schemaErrorMap: this._def.errorMap,\n            parent: null,\n            data,\n            parsedType: (0, util_js_1.getParsedType)(data),\n        };\n        const result = this._parseSync({ data, path: ctx.path, parent: ctx });\n        return handleResult(ctx, result);\n    }\n    \"~validate\"(data) {\n        const ctx = {\n            common: {\n                issues: [],\n                async: !!this[\"~standard\"].async,\n            },\n            path: [],\n            schemaErrorMap: this._def.errorMap,\n            parent: null,\n            data,\n            parsedType: (0, util_js_1.getParsedType)(data),\n        };\n        if (!this[\"~standard\"].async) {\n            try {\n                const result = this._parseSync({ data, path: [], parent: ctx });\n                return (0, parseUtil_js_1.isValid)(result)\n                    ? {\n                        value: result.value,\n                    }\n                    : {\n                        issues: ctx.common.issues,\n                    };\n            }\n            catch (err) {\n                if (err?.message?.toLowerCase()?.includes(\"encountered\")) {\n                    this[\"~standard\"].async = true;\n                }\n                ctx.common = {\n                    issues: [],\n                    async: true,\n                };\n            }\n        }\n        return this._parseAsync({ data, path: [], parent: ctx }).then((result) => (0, parseUtil_js_1.isValid)(result)\n            ? {\n                value: result.value,\n            }\n            : {\n                issues: ctx.common.issues,\n            });\n    }\n    async parseAsync(data, params) {\n        const result = await this.safeParseAsync(data, params);\n        if (result.success)\n            return result.data;\n        throw result.error;\n    }\n    async safeParseAsync(data, params) {\n        const ctx = {\n            common: {\n                issues: [],\n                contextualErrorMap: params?.errorMap,\n                async: true,\n            },\n            path: params?.path || [],\n            schemaErrorMap: this._def.errorMap,\n            parent: null,\n            data,\n            parsedType: (0, util_js_1.getParsedType)(data),\n        };\n        const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });\n        const result = await ((0, parseUtil_js_1.isAsync)(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));\n        return handleResult(ctx, result);\n    }\n    refine(check, message) {\n        const getIssueProperties = (val) => {\n            if (typeof message === \"string\" || typeof message === \"undefined\") {\n                return { message };\n            }\n            else if (typeof message === \"function\") {\n                return message(val);\n            }\n            else {\n                return message;\n            }\n        };\n        return this._refinement((val, ctx) => {\n            const result = check(val);\n            const setError = () => ctx.addIssue({\n                code: ZodError_js_1.ZodIssueCode.custom,\n                ...getIssueProperties(val),\n            });\n            if (typeof Promise !== \"undefined\" && result instanceof Promise) {\n                return result.then((data) => {\n                    if (!data) {\n                        setError();\n                        return false;\n                    }\n                    else {\n                        return true;\n                    }\n                });\n            }\n            if (!result) {\n                setError();\n                return false;\n            }\n            else {\n                return true;\n            }\n        });\n    }\n    refinement(check, refinementData) {\n        return this._refinement((val, ctx) => {\n            if (!check(val)) {\n                ctx.addIssue(typeof refinementData === \"function\" ? refinementData(val, ctx) : refinementData);\n                return false;\n            }\n            else {\n                return true;\n            }\n        });\n    }\n    _refinement(refinement) {\n        return new ZodEffects({\n            schema: this,\n            typeName: ZodFirstPartyTypeKind.ZodEffects,\n            effect: { type: \"refinement\", refinement },\n        });\n    }\n    superRefine(refinement) {\n        return this._refinement(refinement);\n    }\n    constructor(def) {\n        /** Alias of safeParseAsync */\n        this.spa = this.safeParseAsync;\n        this._def = def;\n        this.parse = this.parse.bind(this);\n        this.safeParse = this.safeParse.bind(this);\n        this.parseAsync = this.parseAsync.bind(this);\n        this.safeParseAsync = this.safeParseAsync.bind(this);\n        this.spa = this.spa.bind(this);\n        this.refine = this.refine.bind(this);\n        this.refinement = this.refinement.bind(this);\n        this.superRefine = this.superRefine.bind(this);\n        this.optional = this.optional.bind(this);\n        this.nullable = this.nullable.bind(this);\n        this.nullish = this.nullish.bind(this);\n        this.array = this.array.bind(this);\n        this.promise = this.promise.bind(this);\n        this.or = this.or.bind(this);\n        this.and = this.and.bind(this);\n        this.transform = this.transform.bind(this);\n        this.brand = this.brand.bind(this);\n        this.default = this.default.bind(this);\n        this.catch = this.catch.bind(this);\n        this.describe = this.describe.bind(this);\n        this.pipe = this.pipe.bind(this);\n        this.readonly = this.readonly.bind(this);\n        this.isNullable = this.isNullable.bind(this);\n        this.isOptional = this.isOptional.bind(this);\n        this[\"~standard\"] = {\n            version: 1,\n            vendor: \"zod\",\n            validate: (data) => this[\"~validate\"](data),\n        };\n    }\n    optional() {\n        return ZodOptional.create(this, this._def);\n    }\n    nullable() {\n        return ZodNullable.create(this, this._def);\n    }\n    nullish() {\n        return this.nullable().optional();\n    }\n    array() {\n        return ZodArray.create(this);\n    }\n    promise() {\n        return ZodPromise.create(this, this._def);\n    }\n    or(option) {\n        return ZodUnion.create([this, option], this._def);\n    }\n    and(incoming) {\n        return ZodIntersection.create(this, incoming, this._def);\n    }\n    transform(transform) {\n        return new ZodEffects({\n            ...processCreateParams(this._def),\n            schema: this,\n            typeName: ZodFirstPartyTypeKind.ZodEffects,\n            effect: { type: \"transform\", transform },\n        });\n    }\n    default(def) {\n        const defaultValueFunc = typeof def === \"function\" ? def : () => def;\n        return new ZodDefault({\n            ...processCreateParams(this._def),\n            innerType: this,\n            defaultValue: defaultValueFunc,\n            typeName: ZodFirstPartyTypeKind.ZodDefault,\n        });\n    }\n    brand() {\n        return new ZodBranded({\n            typeName: ZodFirstPartyTypeKind.ZodBranded,\n            type: this,\n            ...processCreateParams(this._def),\n        });\n    }\n    catch(def) {\n        const catchValueFunc = typeof def === \"function\" ? def : () => def;\n        return new ZodCatch({\n            ...processCreateParams(this._def),\n            innerType: this,\n            catchValue: catchValueFunc,\n            typeName: ZodFirstPartyTypeKind.ZodCatch,\n        });\n    }\n    describe(description) {\n        const This = this.constructor;\n        return new This({\n            ...this._def,\n            description,\n        });\n    }\n    pipe(target) {\n        return ZodPipeline.create(this, target);\n    }\n    readonly() {\n        return ZodReadonly.create(this);\n    }\n    isOptional() {\n        return this.safeParse(undefined).success;\n    }\n    isNullable() {\n        return this.safeParse(null).success;\n    }\n}\nexports.ZodType = ZodType;\nexports.Schema = ZodType;\nexports.ZodSchema = ZodType;\nconst cuidRegex = /^c[^\\s-]{8,}$/i;\nconst cuid2Regex = /^[0-9a-z]+$/;\nconst ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;\n// const uuidRegex =\n//   /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;\nconst uuidRegex = /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/i;\nconst nanoidRegex = /^[a-z0-9_-]{21}$/i;\nconst jwtRegex = /^[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]*$/;\nconst durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\\d+Y)|(?:[-+]?\\d+[.,]\\d+Y$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:(?:[-+]?\\d+W)|(?:[-+]?\\d+[.,]\\d+W$))?(?:(?:[-+]?\\d+D)|(?:[-+]?\\d+[.,]\\d+D$))?(?:T(?=[\\d+-])(?:(?:[-+]?\\d+H)|(?:[-+]?\\d+[.,]\\d+H$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:[-+]?\\d+(?:[.,]\\d+)?S)?)??$/;\n// from https://stackoverflow.com/a/46181/1550155\n// old version: too slow, didn't support unicode\n// const emailRegex = /^((([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+(\\.([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+)*)|((\\x22)((((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(([\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f]|\\x21|[\\x23-\\x5b]|[\\x5d-\\x7e]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(\\\\([\\x01-\\x09\\x0b\\x0c\\x0d-\\x7f]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]))))*(((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(\\x22)))@((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))$/i;\n//old email regex\n// const emailRegex = /^(([^<>()[\\].,;:\\s@\"]+(\\.[^<>()[\\].,;:\\s@\"]+)*)|(\".+\"))@((?!-)([^<>()[\\].,;:\\s@\"]+\\.)+[^<>()[\\].,;:\\s@\"]{1,})[^-<>()[\\].,;:\\s@\"]$/i;\n// eslint-disable-next-line\n// const emailRegex =\n//   /^(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\])|(\\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\\.[A-Za-z]{2,})+))$/;\n// const emailRegex =\n//   /^[a-zA-Z0-9\\.\\!\\#\\$\\%\\&\\'\\*\\+\\/\\=\\?\\^\\_\\`\\{\\|\\}\\~\\-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\n// const emailRegex =\n//   /^(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|\"(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21\\x23-\\x5b\\x5d-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])*\")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21-\\x5a\\x53-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])+)\\])$/i;\nconst emailRegex = /^(?!\\.)(?!.*\\.\\.)([A-Z0-9_'+\\-\\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\\-]*\\.)+[A-Z]{2,}$/i;\n// const emailRegex =\n//   /^[a-z0-9.!#$%&’*+/=?^_`{|}~-]+@[a-z0-9-]+(?:\\.[a-z0-9\\-]+)*$/i;\n// from https://thekevinscott.com/emojis-in-javascript/#writing-a-regular-expression\nconst _emojiRegex = `^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$`;\nlet emojiRegex;\n// faster, simpler, safer\nconst ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;\nconst ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\/(3[0-2]|[12]?[0-9])$/;\n// const ipv6Regex =\n// /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;\nconst ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;\nconst ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;\n// https://stackoverflow.com/questions/7860392/determine-if-string-is-in-base64-using-javascript\nconst base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;\n// https://base64.guru/standards/base64url\nconst base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;\n// simple\n// const dateRegexSource = `\\\\d{4}-\\\\d{2}-\\\\d{2}`;\n// no leap year validation\n// const dateRegexSource = `\\\\d{4}-((0[13578]|10|12)-31|(0[13-9]|1[0-2])-30|(0[1-9]|1[0-2])-(0[1-9]|1\\\\d|2\\\\d))`;\n// with leap year validation\nconst dateRegexSource = `((\\\\d\\\\d[2468][048]|\\\\d\\\\d[13579][26]|\\\\d\\\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\\\d|30)|(02)-(0[1-9]|1\\\\d|2[0-8])))`;\nconst dateRegex = new RegExp(`^${dateRegexSource}$`);\nfunction timeRegexSource(args) {\n    let secondsRegexSource = `[0-5]\\\\d`;\n    if (args.precision) {\n        secondsRegexSource = `${secondsRegexSource}\\\\.\\\\d{${args.precision}}`;\n    }\n    else if (args.precision == null) {\n        secondsRegexSource = `${secondsRegexSource}(\\\\.\\\\d+)?`;\n    }\n    const secondsQuantifier = args.precision ? \"+\" : \"?\"; // require seconds if precision is nonzero\n    return `([01]\\\\d|2[0-3]):[0-5]\\\\d(:${secondsRegexSource})${secondsQuantifier}`;\n}\nfunction timeRegex(args) {\n    return new RegExp(`^${timeRegexSource(args)}$`);\n}\n// Adapted from https://stackoverflow.com/a/3143231\nfunction datetimeRegex(args) {\n    let regex = `${dateRegexSource}T${timeRegexSource(args)}`;\n    const opts = [];\n    opts.push(args.local ? `Z?` : `Z`);\n    if (args.offset)\n        opts.push(`([+-]\\\\d{2}:?\\\\d{2})`);\n    regex = `${regex}(${opts.join(\"|\")})`;\n    return new RegExp(`^${regex}$`);\n}\nfunction isValidIP(ip, version) {\n    if ((version === \"v4\" || !version) && ipv4Regex.test(ip)) {\n        return true;\n    }\n    if ((version === \"v6\" || !version) && ipv6Regex.test(ip)) {\n        return true;\n    }\n    return false;\n}\nfunction isValidJWT(jwt, alg) {\n    if (!jwtRegex.test(jwt))\n        return false;\n    try {\n        const [header] = jwt.split(\".\");\n        if (!header)\n            return false;\n        // Convert base64url to base64\n        const base64 = header\n            .replace(/-/g, \"+\")\n            .replace(/_/g, \"/\")\n            .padEnd(header.length + ((4 - (header.length % 4)) % 4), \"=\");\n        const decoded = JSON.parse(atob(base64));\n        if (typeof decoded !== \"object\" || decoded === null)\n            return false;\n        if (\"typ\" in decoded && decoded?.typ !== \"JWT\")\n            return false;\n        if (!decoded.alg)\n            return false;\n        if (alg && decoded.alg !== alg)\n            return false;\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\nfunction isValidCidr(ip, version) {\n    if ((version === \"v4\" || !version) && ipv4CidrRegex.test(ip)) {\n        return true;\n    }\n    if ((version === \"v6\" || !version) && ipv6CidrRegex.test(ip)) {\n        return true;\n    }\n    return false;\n}\nclass ZodString extends ZodType {\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = String(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== util_js_1.ZodParsedType.string) {\n            const ctx = this._getOrReturnCtx(input);\n            (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                code: ZodError_js_1.ZodIssueCode.invalid_type,\n                expected: util_js_1.ZodParsedType.string,\n                received: ctx.parsedType,\n            });\n            return parseUtil_js_1.INVALID;\n        }\n        const status = new parseUtil_js_1.ParseStatus();\n        let ctx = undefined;\n        for (const check of this._def.checks) {\n            if (check.kind === \"min\") {\n                if (input.data.length < check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                        code: ZodError_js_1.ZodIssueCode.too_small,\n                        minimum: check.value,\n                        type: \"string\",\n                        inclusive: true,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                if (input.data.length > check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                        code: ZodError_js_1.ZodIssueCode.too_big,\n                        maximum: check.value,\n                        type: \"string\",\n                        inclusive: true,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"length\") {\n                const tooBig = input.data.length > check.value;\n                const tooSmall = input.data.length < check.value;\n                if (tooBig || tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    if (tooBig) {\n                        (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                            code: ZodError_js_1.ZodIssueCode.too_big,\n                            maximum: check.value,\n                            type: \"string\",\n                            inclusive: true,\n                            exact: true,\n                            message: check.message,\n                        });\n                    }\n                    else if (tooSmall) {\n                        (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                            code: ZodError_js_1.ZodIssueCode.too_small,\n                            minimum: check.value,\n                            type: \"string\",\n                            inclusive: true,\n                            exact: true,\n                            message: check.message,\n                        });\n                    }\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"email\") {\n                if (!emailRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                        validation: \"email\",\n                        code: ZodError_js_1.ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"emoji\") {\n                if (!emojiRegex) {\n                    emojiRegex = new RegExp(_emojiRegex, \"u\");\n                }\n                if (!emojiRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                        validation: \"emoji\",\n                        code: ZodError_js_1.ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"uuid\") {\n                if (!uuidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                        validation: \"uuid\",\n                        code: ZodError_js_1.ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"nanoid\") {\n                if (!nanoidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                        validation: \"nanoid\",\n                        code: ZodError_js_1.ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"cuid\") {\n                if (!cuidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                        validation: \"cuid\",\n                        code: ZodError_js_1.ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"cuid2\") {\n                if (!cuid2Regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                        validation: \"cuid2\",\n                        code: ZodError_js_1.ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"ulid\") {\n                if (!ulidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                        validation: \"ulid\",\n                        code: ZodError_js_1.ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"url\") {\n                try {\n                    new URL(input.data);\n                }\n                catch {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                        validation: \"url\",\n                        code: ZodError_js_1.ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"regex\") {\n                check.regex.lastIndex = 0;\n                const testResult = check.regex.test(input.data);\n                if (!testResult) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                        validation: \"regex\",\n                        code: ZodError_js_1.ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"trim\") {\n                input.data = input.data.trim();\n            }\n            else if (check.kind === \"includes\") {\n                if (!input.data.includes(check.value, check.position)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                        code: ZodError_js_1.ZodIssueCode.invalid_string,\n                        validation: { includes: check.value, position: check.position },\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"toLowerCase\") {\n                input.data = input.data.toLowerCase();\n            }\n            else if (check.kind === \"toUpperCase\") {\n                input.data = input.data.toUpperCase();\n            }\n            else if (check.kind === \"startsWith\") {\n                if (!input.data.startsWith(check.value)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                        code: ZodError_js_1.ZodIssueCode.invalid_string,\n                        validation: { startsWith: check.value },\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"endsWith\") {\n                if (!input.data.endsWith(check.value)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                        code: ZodError_js_1.ZodIssueCode.invalid_string,\n                        validation: { endsWith: check.value },\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"datetime\") {\n                const regex = datetimeRegex(check);\n                if (!regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                        code: ZodError_js_1.ZodIssueCode.invalid_string,\n                        validation: \"datetime\",\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"date\") {\n                const regex = dateRegex;\n                if (!regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                        code: ZodError_js_1.ZodIssueCode.invalid_string,\n                        validation: \"date\",\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"time\") {\n                const regex = timeRegex(check);\n                if (!regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                        code: ZodError_js_1.ZodIssueCode.invalid_string,\n                        validation: \"time\",\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"duration\") {\n                if (!durationRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                        validation: \"duration\",\n                        code: ZodError_js_1.ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"ip\") {\n                if (!isValidIP(input.data, check.version)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                        validation: \"ip\",\n                        code: ZodError_js_1.ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"jwt\") {\n                if (!isValidJWT(input.data, check.alg)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                        validation: \"jwt\",\n                        code: ZodError_js_1.ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"cidr\") {\n                if (!isValidCidr(input.data, check.version)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                        validation: \"cidr\",\n                        code: ZodError_js_1.ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"base64\") {\n                if (!base64Regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                        validation: \"base64\",\n                        code: ZodError_js_1.ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"base64url\") {\n                if (!base64urlRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                        validation: \"base64url\",\n                        code: ZodError_js_1.ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util_js_1.util.assertNever(check);\n            }\n        }\n        return { status: status.value, value: input.data };\n    }\n    _regex(regex, validation, message) {\n        return this.refinement((data) => regex.test(data), {\n            validation,\n            code: ZodError_js_1.ZodIssueCode.invalid_string,\n            ...errorUtil_js_1.errorUtil.errToObj(message),\n        });\n    }\n    _addCheck(check) {\n        return new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    email(message) {\n        return this._addCheck({ kind: \"email\", ...errorUtil_js_1.errorUtil.errToObj(message) });\n    }\n    url(message) {\n        return this._addCheck({ kind: \"url\", ...errorUtil_js_1.errorUtil.errToObj(message) });\n    }\n    emoji(message) {\n        return this._addCheck({ kind: \"emoji\", ...errorUtil_js_1.errorUtil.errToObj(message) });\n    }\n    uuid(message) {\n        return this._addCheck({ kind: \"uuid\", ...errorUtil_js_1.errorUtil.errToObj(message) });\n    }\n    nanoid(message) {\n        return this._addCheck({ kind: \"nanoid\", ...errorUtil_js_1.errorUtil.errToObj(message) });\n    }\n    cuid(message) {\n        return this._addCheck({ kind: \"cuid\", ...errorUtil_js_1.errorUtil.errToObj(message) });\n    }\n    cuid2(message) {\n        return this._addCheck({ kind: \"cuid2\", ...errorUtil_js_1.errorUtil.errToObj(message) });\n    }\n    ulid(message) {\n        return this._addCheck({ kind: \"ulid\", ...errorUtil_js_1.errorUtil.errToObj(message) });\n    }\n    base64(message) {\n        return this._addCheck({ kind: \"base64\", ...errorUtil_js_1.errorUtil.errToObj(message) });\n    }\n    base64url(message) {\n        // base64url encoding is a modification of base64 that can safely be used in URLs and filenames\n        return this._addCheck({\n            kind: \"base64url\",\n            ...errorUtil_js_1.errorUtil.errToObj(message),\n        });\n    }\n    jwt(options) {\n        return this._addCheck({ kind: \"jwt\", ...errorUtil_js_1.errorUtil.errToObj(options) });\n    }\n    ip(options) {\n        return this._addCheck({ kind: \"ip\", ...errorUtil_js_1.errorUtil.errToObj(options) });\n    }\n    cidr(options) {\n        return this._addCheck({ kind: \"cidr\", ...errorUtil_js_1.errorUtil.errToObj(options) });\n    }\n    datetime(options) {\n        if (typeof options === \"string\") {\n            return this._addCheck({\n                kind: \"datetime\",\n                precision: null,\n                offset: false,\n                local: false,\n                message: options,\n            });\n        }\n        return this._addCheck({\n            kind: \"datetime\",\n            precision: typeof options?.precision === \"undefined\" ? null : options?.precision,\n            offset: options?.offset ?? false,\n            local: options?.local ?? false,\n            ...errorUtil_js_1.errorUtil.errToObj(options?.message),\n        });\n    }\n    date(message) {\n        return this._addCheck({ kind: \"date\", message });\n    }\n    time(options) {\n        if (typeof options === \"string\") {\n            return this._addCheck({\n                kind: \"time\",\n                precision: null,\n                message: options,\n            });\n        }\n        return this._addCheck({\n            kind: \"time\",\n            precision: typeof options?.precision === \"undefined\" ? null : options?.precision,\n            ...errorUtil_js_1.errorUtil.errToObj(options?.message),\n        });\n    }\n    duration(message) {\n        return this._addCheck({ kind: \"duration\", ...errorUtil_js_1.errorUtil.errToObj(message) });\n    }\n    regex(regex, message) {\n        return this._addCheck({\n            kind: \"regex\",\n            regex: regex,\n            ...errorUtil_js_1.errorUtil.errToObj(message),\n        });\n    }\n    includes(value, options) {\n        return this._addCheck({\n            kind: \"includes\",\n            value: value,\n            position: options?.position,\n            ...errorUtil_js_1.errorUtil.errToObj(options?.message),\n        });\n    }\n    startsWith(value, message) {\n        return this._addCheck({\n            kind: \"startsWith\",\n            value: value,\n            ...errorUtil_js_1.errorUtil.errToObj(message),\n        });\n    }\n    endsWith(value, message) {\n        return this._addCheck({\n            kind: \"endsWith\",\n            value: value,\n            ...errorUtil_js_1.errorUtil.errToObj(message),\n        });\n    }\n    min(minLength, message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: minLength,\n            ...errorUtil_js_1.errorUtil.errToObj(message),\n        });\n    }\n    max(maxLength, message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: maxLength,\n            ...errorUtil_js_1.errorUtil.errToObj(message),\n        });\n    }\n    length(len, message) {\n        return this._addCheck({\n            kind: \"length\",\n            value: len,\n            ...errorUtil_js_1.errorUtil.errToObj(message),\n        });\n    }\n    /**\n     * Equivalent to `.min(1)`\n     */\n    nonempty(message) {\n        return this.min(1, errorUtil_js_1.errorUtil.errToObj(message));\n    }\n    trim() {\n        return new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, { kind: \"trim\" }],\n        });\n    }\n    toLowerCase() {\n        return new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, { kind: \"toLowerCase\" }],\n        });\n    }\n    toUpperCase() {\n        return new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, { kind: \"toUpperCase\" }],\n        });\n    }\n    get isDatetime() {\n        return !!this._def.checks.find((ch) => ch.kind === \"datetime\");\n    }\n    get isDate() {\n        return !!this._def.checks.find((ch) => ch.kind === \"date\");\n    }\n    get isTime() {\n        return !!this._def.checks.find((ch) => ch.kind === \"time\");\n    }\n    get isDuration() {\n        return !!this._def.checks.find((ch) => ch.kind === \"duration\");\n    }\n    get isEmail() {\n        return !!this._def.checks.find((ch) => ch.kind === \"email\");\n    }\n    get isURL() {\n        return !!this._def.checks.find((ch) => ch.kind === \"url\");\n    }\n    get isEmoji() {\n        return !!this._def.checks.find((ch) => ch.kind === \"emoji\");\n    }\n    get isUUID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"uuid\");\n    }\n    get isNANOID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"nanoid\");\n    }\n    get isCUID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"cuid\");\n    }\n    get isCUID2() {\n        return !!this._def.checks.find((ch) => ch.kind === \"cuid2\");\n    }\n    get isULID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"ulid\");\n    }\n    get isIP() {\n        return !!this._def.checks.find((ch) => ch.kind === \"ip\");\n    }\n    get isCIDR() {\n        return !!this._def.checks.find((ch) => ch.kind === \"cidr\");\n    }\n    get isBase64() {\n        return !!this._def.checks.find((ch) => ch.kind === \"base64\");\n    }\n    get isBase64url() {\n        // base64url encoding is a modification of base64 that can safely be used in URLs and filenames\n        return !!this._def.checks.find((ch) => ch.kind === \"base64url\");\n    }\n    get minLength() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxLength() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max;\n    }\n}\nexports.ZodString = ZodString;\nZodString.create = (params) => {\n    return new ZodString({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodString,\n        coerce: params?.coerce ?? false,\n        ...processCreateParams(params),\n    });\n};\n// https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034\nfunction floatSafeRemainder(val, step) {\n    const valDecCount = (val.toString().split(\".\")[1] || \"\").length;\n    const stepDecCount = (step.toString().split(\".\")[1] || \"\").length;\n    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;\n    const valInt = Number.parseInt(val.toFixed(decCount).replace(\".\", \"\"));\n    const stepInt = Number.parseInt(step.toFixed(decCount).replace(\".\", \"\"));\n    return (valInt % stepInt) / 10 ** decCount;\n}\nclass ZodNumber extends ZodType {\n    constructor() {\n        super(...arguments);\n        this.min = this.gte;\n        this.max = this.lte;\n        this.step = this.multipleOf;\n    }\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = Number(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== util_js_1.ZodParsedType.number) {\n            const ctx = this._getOrReturnCtx(input);\n            (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                code: ZodError_js_1.ZodIssueCode.invalid_type,\n                expected: util_js_1.ZodParsedType.number,\n                received: ctx.parsedType,\n            });\n            return parseUtil_js_1.INVALID;\n        }\n        let ctx = undefined;\n        const status = new parseUtil_js_1.ParseStatus();\n        for (const check of this._def.checks) {\n            if (check.kind === \"int\") {\n                if (!util_js_1.util.isInteger(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                        code: ZodError_js_1.ZodIssueCode.invalid_type,\n                        expected: \"integer\",\n                        received: \"float\",\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"min\") {\n                const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;\n                if (tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                        code: ZodError_js_1.ZodIssueCode.too_small,\n                        minimum: check.value,\n                        type: \"number\",\n                        inclusive: check.inclusive,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;\n                if (tooBig) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                        code: ZodError_js_1.ZodIssueCode.too_big,\n                        maximum: check.value,\n                        type: \"number\",\n                        inclusive: check.inclusive,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"multipleOf\") {\n                if (floatSafeRemainder(input.data, check.value) !== 0) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                        code: ZodError_js_1.ZodIssueCode.not_multiple_of,\n                        multipleOf: check.value,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"finite\") {\n                if (!Number.isFinite(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                        code: ZodError_js_1.ZodIssueCode.not_finite,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util_js_1.util.assertNever(check);\n            }\n        }\n        return { status: status.value, value: input.data };\n    }\n    gte(value, message) {\n        return this.setLimit(\"min\", value, true, errorUtil_js_1.errorUtil.toString(message));\n    }\n    gt(value, message) {\n        return this.setLimit(\"min\", value, false, errorUtil_js_1.errorUtil.toString(message));\n    }\n    lte(value, message) {\n        return this.setLimit(\"max\", value, true, errorUtil_js_1.errorUtil.toString(message));\n    }\n    lt(value, message) {\n        return this.setLimit(\"max\", value, false, errorUtil_js_1.errorUtil.toString(message));\n    }\n    setLimit(kind, value, inclusive, message) {\n        return new ZodNumber({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                {\n                    kind,\n                    value,\n                    inclusive,\n                    message: errorUtil_js_1.errorUtil.toString(message),\n                },\n            ],\n        });\n    }\n    _addCheck(check) {\n        return new ZodNumber({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    int(message) {\n        return this._addCheck({\n            kind: \"int\",\n            message: errorUtil_js_1.errorUtil.toString(message),\n        });\n    }\n    positive(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: 0,\n            inclusive: false,\n            message: errorUtil_js_1.errorUtil.toString(message),\n        });\n    }\n    negative(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: 0,\n            inclusive: false,\n            message: errorUtil_js_1.errorUtil.toString(message),\n        });\n    }\n    nonpositive(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: 0,\n            inclusive: true,\n            message: errorUtil_js_1.errorUtil.toString(message),\n        });\n    }\n    nonnegative(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: 0,\n            inclusive: true,\n            message: errorUtil_js_1.errorUtil.toString(message),\n        });\n    }\n    multipleOf(value, message) {\n        return this._addCheck({\n            kind: \"multipleOf\",\n            value: value,\n            message: errorUtil_js_1.errorUtil.toString(message),\n        });\n    }\n    finite(message) {\n        return this._addCheck({\n            kind: \"finite\",\n            message: errorUtil_js_1.errorUtil.toString(message),\n        });\n    }\n    safe(message) {\n        return this._addCheck({\n            kind: \"min\",\n            inclusive: true,\n            value: Number.MIN_SAFE_INTEGER,\n            message: errorUtil_js_1.errorUtil.toString(message),\n        })._addCheck({\n            kind: \"max\",\n            inclusive: true,\n            value: Number.MAX_SAFE_INTEGER,\n            message: errorUtil_js_1.errorUtil.toString(message),\n        });\n    }\n    get minValue() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxValue() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max;\n    }\n    get isInt() {\n        return !!this._def.checks.find((ch) => ch.kind === \"int\" || (ch.kind === \"multipleOf\" && util_js_1.util.isInteger(ch.value)));\n    }\n    get isFinite() {\n        let max = null;\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"finite\" || ch.kind === \"int\" || ch.kind === \"multipleOf\") {\n                return true;\n            }\n            else if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n            else if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return Number.isFinite(min) && Number.isFinite(max);\n    }\n}\nexports.ZodNumber = ZodNumber;\nZodNumber.create = (params) => {\n    return new ZodNumber({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodNumber,\n        coerce: params?.coerce || false,\n        ...processCreateParams(params),\n    });\n};\nclass ZodBigInt extends ZodType {\n    constructor() {\n        super(...arguments);\n        this.min = this.gte;\n        this.max = this.lte;\n    }\n    _parse(input) {\n        if (this._def.coerce) {\n            try {\n                input.data = BigInt(input.data);\n            }\n            catch {\n                return this._getInvalidInput(input);\n            }\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== util_js_1.ZodParsedType.bigint) {\n            return this._getInvalidInput(input);\n        }\n        let ctx = undefined;\n        const status = new parseUtil_js_1.ParseStatus();\n        for (const check of this._def.checks) {\n            if (check.kind === \"min\") {\n                const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;\n                if (tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                        code: ZodError_js_1.ZodIssueCode.too_small,\n                        type: \"bigint\",\n                        minimum: check.value,\n                        inclusive: check.inclusive,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;\n                if (tooBig) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                        code: ZodError_js_1.ZodIssueCode.too_big,\n                        type: \"bigint\",\n                        maximum: check.value,\n                        inclusive: check.inclusive,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"multipleOf\") {\n                if (input.data % check.value !== BigInt(0)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                        code: ZodError_js_1.ZodIssueCode.not_multiple_of,\n                        multipleOf: check.value,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util_js_1.util.assertNever(check);\n            }\n        }\n        return { status: status.value, value: input.data };\n    }\n    _getInvalidInput(input) {\n        const ctx = this._getOrReturnCtx(input);\n        (0, parseUtil_js_1.addIssueToContext)(ctx, {\n            code: ZodError_js_1.ZodIssueCode.invalid_type,\n            expected: util_js_1.ZodParsedType.bigint,\n            received: ctx.parsedType,\n        });\n        return parseUtil_js_1.INVALID;\n    }\n    gte(value, message) {\n        return this.setLimit(\"min\", value, true, errorUtil_js_1.errorUtil.toString(message));\n    }\n    gt(value, message) {\n        return this.setLimit(\"min\", value, false, errorUtil_js_1.errorUtil.toString(message));\n    }\n    lte(value, message) {\n        return this.setLimit(\"max\", value, true, errorUtil_js_1.errorUtil.toString(message));\n    }\n    lt(value, message) {\n        return this.setLimit(\"max\", value, false, errorUtil_js_1.errorUtil.toString(message));\n    }\n    setLimit(kind, value, inclusive, message) {\n        return new ZodBigInt({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                {\n                    kind,\n                    value,\n                    inclusive,\n                    message: errorUtil_js_1.errorUtil.toString(message),\n                },\n            ],\n        });\n    }\n    _addCheck(check) {\n        return new ZodBigInt({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    positive(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: BigInt(0),\n            inclusive: false,\n            message: errorUtil_js_1.errorUtil.toString(message),\n        });\n    }\n    negative(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: BigInt(0),\n            inclusive: false,\n            message: errorUtil_js_1.errorUtil.toString(message),\n        });\n    }\n    nonpositive(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: BigInt(0),\n            inclusive: true,\n            message: errorUtil_js_1.errorUtil.toString(message),\n        });\n    }\n    nonnegative(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: BigInt(0),\n            inclusive: true,\n            message: errorUtil_js_1.errorUtil.toString(message),\n        });\n    }\n    multipleOf(value, message) {\n        return this._addCheck({\n            kind: \"multipleOf\",\n            value,\n            message: errorUtil_js_1.errorUtil.toString(message),\n        });\n    }\n    get minValue() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxValue() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max;\n    }\n}\nexports.ZodBigInt = ZodBigInt;\nZodBigInt.create = (params) => {\n    return new ZodBigInt({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodBigInt,\n        coerce: params?.coerce ?? false,\n        ...processCreateParams(params),\n    });\n};\nclass ZodBoolean extends ZodType {\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = Boolean(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== util_js_1.ZodParsedType.boolean) {\n            const ctx = this._getOrReturnCtx(input);\n            (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                code: ZodError_js_1.ZodIssueCode.invalid_type,\n                expected: util_js_1.ZodParsedType.boolean,\n                received: ctx.parsedType,\n            });\n            return parseUtil_js_1.INVALID;\n        }\n        return (0, parseUtil_js_1.OK)(input.data);\n    }\n}\nexports.ZodBoolean = ZodBoolean;\nZodBoolean.create = (params) => {\n    return new ZodBoolean({\n        typeName: ZodFirstPartyTypeKind.ZodBoolean,\n        coerce: params?.coerce || false,\n        ...processCreateParams(params),\n    });\n};\nclass ZodDate extends ZodType {\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = new Date(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== util_js_1.ZodParsedType.date) {\n            const ctx = this._getOrReturnCtx(input);\n            (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                code: ZodError_js_1.ZodIssueCode.invalid_type,\n                expected: util_js_1.ZodParsedType.date,\n                received: ctx.parsedType,\n            });\n            return parseUtil_js_1.INVALID;\n        }\n        if (Number.isNaN(input.data.getTime())) {\n            const ctx = this._getOrReturnCtx(input);\n            (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                code: ZodError_js_1.ZodIssueCode.invalid_date,\n            });\n            return parseUtil_js_1.INVALID;\n        }\n        const status = new parseUtil_js_1.ParseStatus();\n        let ctx = undefined;\n        for (const check of this._def.checks) {\n            if (check.kind === \"min\") {\n                if (input.data.getTime() < check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                        code: ZodError_js_1.ZodIssueCode.too_small,\n                        message: check.message,\n                        inclusive: true,\n                        exact: false,\n                        minimum: check.value,\n                        type: \"date\",\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                if (input.data.getTime() > check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                        code: ZodError_js_1.ZodIssueCode.too_big,\n                        message: check.message,\n                        inclusive: true,\n                        exact: false,\n                        maximum: check.value,\n                        type: \"date\",\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util_js_1.util.assertNever(check);\n            }\n        }\n        return {\n            status: status.value,\n            value: new Date(input.data.getTime()),\n        };\n    }\n    _addCheck(check) {\n        return new ZodDate({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    min(minDate, message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: minDate.getTime(),\n            message: errorUtil_js_1.errorUtil.toString(message),\n        });\n    }\n    max(maxDate, message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: maxDate.getTime(),\n            message: errorUtil_js_1.errorUtil.toString(message),\n        });\n    }\n    get minDate() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min != null ? new Date(min) : null;\n    }\n    get maxDate() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max != null ? new Date(max) : null;\n    }\n}\nexports.ZodDate = ZodDate;\nZodDate.create = (params) => {\n    return new ZodDate({\n        checks: [],\n        coerce: params?.coerce || false,\n        typeName: ZodFirstPartyTypeKind.ZodDate,\n        ...processCreateParams(params),\n    });\n};\nclass ZodSymbol extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== util_js_1.ZodParsedType.symbol) {\n            const ctx = this._getOrReturnCtx(input);\n            (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                code: ZodError_js_1.ZodIssueCode.invalid_type,\n                expected: util_js_1.ZodParsedType.symbol,\n                received: ctx.parsedType,\n            });\n            return parseUtil_js_1.INVALID;\n        }\n        return (0, parseUtil_js_1.OK)(input.data);\n    }\n}\nexports.ZodSymbol = ZodSymbol;\nZodSymbol.create = (params) => {\n    return new ZodSymbol({\n        typeName: ZodFirstPartyTypeKind.ZodSymbol,\n        ...processCreateParams(params),\n    });\n};\nclass ZodUndefined extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== util_js_1.ZodParsedType.undefined) {\n            const ctx = this._getOrReturnCtx(input);\n            (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                code: ZodError_js_1.ZodIssueCode.invalid_type,\n                expected: util_js_1.ZodParsedType.undefined,\n                received: ctx.parsedType,\n            });\n            return parseUtil_js_1.INVALID;\n        }\n        return (0, parseUtil_js_1.OK)(input.data);\n    }\n}\nexports.ZodUndefined = ZodUndefined;\nZodUndefined.create = (params) => {\n    return new ZodUndefined({\n        typeName: ZodFirstPartyTypeKind.ZodUndefined,\n        ...processCreateParams(params),\n    });\n};\nclass ZodNull extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== util_js_1.ZodParsedType.null) {\n            const ctx = this._getOrReturnCtx(input);\n            (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                code: ZodError_js_1.ZodIssueCode.invalid_type,\n                expected: util_js_1.ZodParsedType.null,\n                received: ctx.parsedType,\n            });\n            return parseUtil_js_1.INVALID;\n        }\n        return (0, parseUtil_js_1.OK)(input.data);\n    }\n}\nexports.ZodNull = ZodNull;\nZodNull.create = (params) => {\n    return new ZodNull({\n        typeName: ZodFirstPartyTypeKind.ZodNull,\n        ...processCreateParams(params),\n    });\n};\nclass ZodAny extends ZodType {\n    constructor() {\n        super(...arguments);\n        // to prevent instances of other classes from extending ZodAny. this causes issues with catchall in ZodObject.\n        this._any = true;\n    }\n    _parse(input) {\n        return (0, parseUtil_js_1.OK)(input.data);\n    }\n}\nexports.ZodAny = ZodAny;\nZodAny.create = (params) => {\n    return new ZodAny({\n        typeName: ZodFirstPartyTypeKind.ZodAny,\n        ...processCreateParams(params),\n    });\n};\nclass ZodUnknown extends ZodType {\n    constructor() {\n        super(...arguments);\n        // required\n        this._unknown = true;\n    }\n    _parse(input) {\n        return (0, parseUtil_js_1.OK)(input.data);\n    }\n}\nexports.ZodUnknown = ZodUnknown;\nZodUnknown.create = (params) => {\n    return new ZodUnknown({\n        typeName: ZodFirstPartyTypeKind.ZodUnknown,\n        ...processCreateParams(params),\n    });\n};\nclass ZodNever extends ZodType {\n    _parse(input) {\n        const ctx = this._getOrReturnCtx(input);\n        (0, parseUtil_js_1.addIssueToContext)(ctx, {\n            code: ZodError_js_1.ZodIssueCode.invalid_type,\n            expected: util_js_1.ZodParsedType.never,\n            received: ctx.parsedType,\n        });\n        return parseUtil_js_1.INVALID;\n    }\n}\nexports.ZodNever = ZodNever;\nZodNever.create = (params) => {\n    return new ZodNever({\n        typeName: ZodFirstPartyTypeKind.ZodNever,\n        ...processCreateParams(params),\n    });\n};\nclass ZodVoid extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== util_js_1.ZodParsedType.undefined) {\n            const ctx = this._getOrReturnCtx(input);\n            (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                code: ZodError_js_1.ZodIssueCode.invalid_type,\n                expected: util_js_1.ZodParsedType.void,\n                received: ctx.parsedType,\n            });\n            return parseUtil_js_1.INVALID;\n        }\n        return (0, parseUtil_js_1.OK)(input.data);\n    }\n}\nexports.ZodVoid = ZodVoid;\nZodVoid.create = (params) => {\n    return new ZodVoid({\n        typeName: ZodFirstPartyTypeKind.ZodVoid,\n        ...processCreateParams(params),\n    });\n};\nclass ZodArray extends ZodType {\n    _parse(input) {\n        const { ctx, status } = this._processInputParams(input);\n        const def = this._def;\n        if (ctx.parsedType !== util_js_1.ZodParsedType.array) {\n            (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                code: ZodError_js_1.ZodIssueCode.invalid_type,\n                expected: util_js_1.ZodParsedType.array,\n                received: ctx.parsedType,\n            });\n            return parseUtil_js_1.INVALID;\n        }\n        if (def.exactLength !== null) {\n            const tooBig = ctx.data.length > def.exactLength.value;\n            const tooSmall = ctx.data.length < def.exactLength.value;\n            if (tooBig || tooSmall) {\n                (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                    code: tooBig ? ZodError_js_1.ZodIssueCode.too_big : ZodError_js_1.ZodIssueCode.too_small,\n                    minimum: (tooSmall ? def.exactLength.value : undefined),\n                    maximum: (tooBig ? def.exactLength.value : undefined),\n                    type: \"array\",\n                    inclusive: true,\n                    exact: true,\n                    message: def.exactLength.message,\n                });\n                status.dirty();\n            }\n        }\n        if (def.minLength !== null) {\n            if (ctx.data.length < def.minLength.value) {\n                (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                    code: ZodError_js_1.ZodIssueCode.too_small,\n                    minimum: def.minLength.value,\n                    type: \"array\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.minLength.message,\n                });\n                status.dirty();\n            }\n        }\n        if (def.maxLength !== null) {\n            if (ctx.data.length > def.maxLength.value) {\n                (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                    code: ZodError_js_1.ZodIssueCode.too_big,\n                    maximum: def.maxLength.value,\n                    type: \"array\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.maxLength.message,\n                });\n                status.dirty();\n            }\n        }\n        if (ctx.common.async) {\n            return Promise.all([...ctx.data].map((item, i) => {\n                return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));\n            })).then((result) => {\n                return parseUtil_js_1.ParseStatus.mergeArray(status, result);\n            });\n        }\n        const result = [...ctx.data].map((item, i) => {\n            return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));\n        });\n        return parseUtil_js_1.ParseStatus.mergeArray(status, result);\n    }\n    get element() {\n        return this._def.type;\n    }\n    min(minLength, message) {\n        return new ZodArray({\n            ...this._def,\n            minLength: { value: minLength, message: errorUtil_js_1.errorUtil.toString(message) },\n        });\n    }\n    max(maxLength, message) {\n        return new ZodArray({\n            ...this._def,\n            maxLength: { value: maxLength, message: errorUtil_js_1.errorUtil.toString(message) },\n        });\n    }\n    length(len, message) {\n        return new ZodArray({\n            ...this._def,\n            exactLength: { value: len, message: errorUtil_js_1.errorUtil.toString(message) },\n        });\n    }\n    nonempty(message) {\n        return this.min(1, message);\n    }\n}\nexports.ZodArray = ZodArray;\nZodArray.create = (schema, params) => {\n    return new ZodArray({\n        type: schema,\n        minLength: null,\n        maxLength: null,\n        exactLength: null,\n        typeName: ZodFirstPartyTypeKind.ZodArray,\n        ...processCreateParams(params),\n    });\n};\nfunction deepPartialify(schema) {\n    if (schema instanceof ZodObject) {\n        const newShape = {};\n        for (const key in schema.shape) {\n            const fieldSchema = schema.shape[key];\n            newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));\n        }\n        return new ZodObject({\n            ...schema._def,\n            shape: () => newShape,\n        });\n    }\n    else if (schema instanceof ZodArray) {\n        return new ZodArray({\n            ...schema._def,\n            type: deepPartialify(schema.element),\n        });\n    }\n    else if (schema instanceof ZodOptional) {\n        return ZodOptional.create(deepPartialify(schema.unwrap()));\n    }\n    else if (schema instanceof ZodNullable) {\n        return ZodNullable.create(deepPartialify(schema.unwrap()));\n    }\n    else if (schema instanceof ZodTuple) {\n        return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));\n    }\n    else {\n        return schema;\n    }\n}\nclass ZodObject extends ZodType {\n    constructor() {\n        super(...arguments);\n        this._cached = null;\n        /**\n         * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.\n         * If you want to pass through unknown properties, use `.passthrough()` instead.\n         */\n        this.nonstrict = this.passthrough;\n        // extend<\n        //   Augmentation extends ZodRawShape,\n        //   NewOutput extends util.flatten<{\n        //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation\n        //       ? Augmentation[k][\"_output\"]\n        //       : k extends keyof Output\n        //       ? Output[k]\n        //       : never;\n        //   }>,\n        //   NewInput extends util.flatten<{\n        //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation\n        //       ? Augmentation[k][\"_input\"]\n        //       : k extends keyof Input\n        //       ? Input[k]\n        //       : never;\n        //   }>\n        // >(\n        //   augmentation: Augmentation\n        // ): ZodObject<\n        //   extendShape<T, Augmentation>,\n        //   UnknownKeys,\n        //   Catchall,\n        //   NewOutput,\n        //   NewInput\n        // > {\n        //   return new ZodObject({\n        //     ...this._def,\n        //     shape: () => ({\n        //       ...this._def.shape(),\n        //       ...augmentation,\n        //     }),\n        //   }) as any;\n        // }\n        /**\n         * @deprecated Use `.extend` instead\n         *  */\n        this.augment = this.extend;\n    }\n    _getCached() {\n        if (this._cached !== null)\n            return this._cached;\n        const shape = this._def.shape();\n        const keys = util_js_1.util.objectKeys(shape);\n        this._cached = { shape, keys };\n        return this._cached;\n    }\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== util_js_1.ZodParsedType.object) {\n            const ctx = this._getOrReturnCtx(input);\n            (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                code: ZodError_js_1.ZodIssueCode.invalid_type,\n                expected: util_js_1.ZodParsedType.object,\n                received: ctx.parsedType,\n            });\n            return parseUtil_js_1.INVALID;\n        }\n        const { status, ctx } = this._processInputParams(input);\n        const { shape, keys: shapeKeys } = this._getCached();\n        const extraKeys = [];\n        if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === \"strip\")) {\n            for (const key in ctx.data) {\n                if (!shapeKeys.includes(key)) {\n                    extraKeys.push(key);\n                }\n            }\n        }\n        const pairs = [];\n        for (const key of shapeKeys) {\n            const keyValidator = shape[key];\n            const value = ctx.data[key];\n            pairs.push({\n                key: { status: \"valid\", value: key },\n                value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),\n                alwaysSet: key in ctx.data,\n            });\n        }\n        if (this._def.catchall instanceof ZodNever) {\n            const unknownKeys = this._def.unknownKeys;\n            if (unknownKeys === \"passthrough\") {\n                for (const key of extraKeys) {\n                    pairs.push({\n                        key: { status: \"valid\", value: key },\n                        value: { status: \"valid\", value: ctx.data[key] },\n                    });\n                }\n            }\n            else if (unknownKeys === \"strict\") {\n                if (extraKeys.length > 0) {\n                    (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                        code: ZodError_js_1.ZodIssueCode.unrecognized_keys,\n                        keys: extraKeys,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (unknownKeys === \"strip\") {\n            }\n            else {\n                throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);\n            }\n        }\n        else {\n            // run catchall validation\n            const catchall = this._def.catchall;\n            for (const key of extraKeys) {\n                const value = ctx.data[key];\n                pairs.push({\n                    key: { status: \"valid\", value: key },\n                    value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key) //, ctx.child(key), value, getParsedType(value)\n                    ),\n                    alwaysSet: key in ctx.data,\n                });\n            }\n        }\n        if (ctx.common.async) {\n            return Promise.resolve()\n                .then(async () => {\n                const syncPairs = [];\n                for (const pair of pairs) {\n                    const key = await pair.key;\n                    const value = await pair.value;\n                    syncPairs.push({\n                        key,\n                        value,\n                        alwaysSet: pair.alwaysSet,\n                    });\n                }\n                return syncPairs;\n            })\n                .then((syncPairs) => {\n                return parseUtil_js_1.ParseStatus.mergeObjectSync(status, syncPairs);\n            });\n        }\n        else {\n            return parseUtil_js_1.ParseStatus.mergeObjectSync(status, pairs);\n        }\n    }\n    get shape() {\n        return this._def.shape();\n    }\n    strict(message) {\n        errorUtil_js_1.errorUtil.errToObj;\n        return new ZodObject({\n            ...this._def,\n            unknownKeys: \"strict\",\n            ...(message !== undefined\n                ? {\n                    errorMap: (issue, ctx) => {\n                        const defaultError = this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;\n                        if (issue.code === \"unrecognized_keys\")\n                            return {\n                                message: errorUtil_js_1.errorUtil.errToObj(message).message ?? defaultError,\n                            };\n                        return {\n                            message: defaultError,\n                        };\n                    },\n                }\n                : {}),\n        });\n    }\n    strip() {\n        return new ZodObject({\n            ...this._def,\n            unknownKeys: \"strip\",\n        });\n    }\n    passthrough() {\n        return new ZodObject({\n            ...this._def,\n            unknownKeys: \"passthrough\",\n        });\n    }\n    // const AugmentFactory =\n    //   <Def extends ZodObjectDef>(def: Def) =>\n    //   <Augmentation extends ZodRawShape>(\n    //     augmentation: Augmentation\n    //   ): ZodObject<\n    //     extendShape<ReturnType<Def[\"shape\"]>, Augmentation>,\n    //     Def[\"unknownKeys\"],\n    //     Def[\"catchall\"]\n    //   > => {\n    //     return new ZodObject({\n    //       ...def,\n    //       shape: () => ({\n    //         ...def.shape(),\n    //         ...augmentation,\n    //       }),\n    //     }) as any;\n    //   };\n    extend(augmentation) {\n        return new ZodObject({\n            ...this._def,\n            shape: () => ({\n                ...this._def.shape(),\n                ...augmentation,\n            }),\n        });\n    }\n    /**\n     * Prior to zod@1.0.12 there was a bug in the\n     * inferred type of merged objects. Please\n     * upgrade if you are experiencing issues.\n     */\n    merge(merging) {\n        const merged = new ZodObject({\n            unknownKeys: merging._def.unknownKeys,\n            catchall: merging._def.catchall,\n            shape: () => ({\n                ...this._def.shape(),\n                ...merging._def.shape(),\n            }),\n            typeName: ZodFirstPartyTypeKind.ZodObject,\n        });\n        return merged;\n    }\n    // merge<\n    //   Incoming extends AnyZodObject,\n    //   Augmentation extends Incoming[\"shape\"],\n    //   NewOutput extends {\n    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation\n    //       ? Augmentation[k][\"_output\"]\n    //       : k extends keyof Output\n    //       ? Output[k]\n    //       : never;\n    //   },\n    //   NewInput extends {\n    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation\n    //       ? Augmentation[k][\"_input\"]\n    //       : k extends keyof Input\n    //       ? Input[k]\n    //       : never;\n    //   }\n    // >(\n    //   merging: Incoming\n    // ): ZodObject<\n    //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\n    //   Incoming[\"_def\"][\"unknownKeys\"],\n    //   Incoming[\"_def\"][\"catchall\"],\n    //   NewOutput,\n    //   NewInput\n    // > {\n    //   const merged: any = new ZodObject({\n    //     unknownKeys: merging._def.unknownKeys,\n    //     catchall: merging._def.catchall,\n    //     shape: () =>\n    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\n    //     typeName: ZodFirstPartyTypeKind.ZodObject,\n    //   }) as any;\n    //   return merged;\n    // }\n    setKey(key, schema) {\n        return this.augment({ [key]: schema });\n    }\n    // merge<Incoming extends AnyZodObject>(\n    //   merging: Incoming\n    // ): //ZodObject<T & Incoming[\"_shape\"], UnknownKeys, Catchall> = (merging) => {\n    // ZodObject<\n    //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\n    //   Incoming[\"_def\"][\"unknownKeys\"],\n    //   Incoming[\"_def\"][\"catchall\"]\n    // > {\n    //   // const mergedShape = objectUtil.mergeShapes(\n    //   //   this._def.shape(),\n    //   //   merging._def.shape()\n    //   // );\n    //   const merged: any = new ZodObject({\n    //     unknownKeys: merging._def.unknownKeys,\n    //     catchall: merging._def.catchall,\n    //     shape: () =>\n    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\n    //     typeName: ZodFirstPartyTypeKind.ZodObject,\n    //   }) as any;\n    //   return merged;\n    // }\n    catchall(index) {\n        return new ZodObject({\n            ...this._def,\n            catchall: index,\n        });\n    }\n    pick(mask) {\n        const shape = {};\n        for (const key of util_js_1.util.objectKeys(mask)) {\n            if (mask[key] && this.shape[key]) {\n                shape[key] = this.shape[key];\n            }\n        }\n        return new ZodObject({\n            ...this._def,\n            shape: () => shape,\n        });\n    }\n    omit(mask) {\n        const shape = {};\n        for (const key of util_js_1.util.objectKeys(this.shape)) {\n            if (!mask[key]) {\n                shape[key] = this.shape[key];\n            }\n        }\n        return new ZodObject({\n            ...this._def,\n            shape: () => shape,\n        });\n    }\n    /**\n     * @deprecated\n     */\n    deepPartial() {\n        return deepPartialify(this);\n    }\n    partial(mask) {\n        const newShape = {};\n        for (const key of util_js_1.util.objectKeys(this.shape)) {\n            const fieldSchema = this.shape[key];\n            if (mask && !mask[key]) {\n                newShape[key] = fieldSchema;\n            }\n            else {\n                newShape[key] = fieldSchema.optional();\n            }\n        }\n        return new ZodObject({\n            ...this._def,\n            shape: () => newShape,\n        });\n    }\n    required(mask) {\n        const newShape = {};\n        for (const key of util_js_1.util.objectKeys(this.shape)) {\n            if (mask && !mask[key]) {\n                newShape[key] = this.shape[key];\n            }\n            else {\n                const fieldSchema = this.shape[key];\n                let newField = fieldSchema;\n                while (newField instanceof ZodOptional) {\n                    newField = newField._def.innerType;\n                }\n                newShape[key] = newField;\n            }\n        }\n        return new ZodObject({\n            ...this._def,\n            shape: () => newShape,\n        });\n    }\n    keyof() {\n        return createZodEnum(util_js_1.util.objectKeys(this.shape));\n    }\n}\nexports.ZodObject = ZodObject;\nZodObject.create = (shape, params) => {\n    return new ZodObject({\n        shape: () => shape,\n        unknownKeys: \"strip\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params),\n    });\n};\nZodObject.strictCreate = (shape, params) => {\n    return new ZodObject({\n        shape: () => shape,\n        unknownKeys: \"strict\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params),\n    });\n};\nZodObject.lazycreate = (shape, params) => {\n    return new ZodObject({\n        shape,\n        unknownKeys: \"strip\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params),\n    });\n};\nclass ZodUnion extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const options = this._def.options;\n        function handleResults(results) {\n            // return first issue-free validation if it exists\n            for (const result of results) {\n                if (result.result.status === \"valid\") {\n                    return result.result;\n                }\n            }\n            for (const result of results) {\n                if (result.result.status === \"dirty\") {\n                    // add issues from dirty option\n                    ctx.common.issues.push(...result.ctx.common.issues);\n                    return result.result;\n                }\n            }\n            // return invalid\n            const unionErrors = results.map((result) => new ZodError_js_1.ZodError(result.ctx.common.issues));\n            (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                code: ZodError_js_1.ZodIssueCode.invalid_union,\n                unionErrors,\n            });\n            return parseUtil_js_1.INVALID;\n        }\n        if (ctx.common.async) {\n            return Promise.all(options.map(async (option) => {\n                const childCtx = {\n                    ...ctx,\n                    common: {\n                        ...ctx.common,\n                        issues: [],\n                    },\n                    parent: null,\n                };\n                return {\n                    result: await option._parseAsync({\n                        data: ctx.data,\n                        path: ctx.path,\n                        parent: childCtx,\n                    }),\n                    ctx: childCtx,\n                };\n            })).then(handleResults);\n        }\n        else {\n            let dirty = undefined;\n            const issues = [];\n            for (const option of options) {\n                const childCtx = {\n                    ...ctx,\n                    common: {\n                        ...ctx.common,\n                        issues: [],\n                    },\n                    parent: null,\n                };\n                const result = option._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: childCtx,\n                });\n                if (result.status === \"valid\") {\n                    return result;\n                }\n                else if (result.status === \"dirty\" && !dirty) {\n                    dirty = { result, ctx: childCtx };\n                }\n                if (childCtx.common.issues.length) {\n                    issues.push(childCtx.common.issues);\n                }\n            }\n            if (dirty) {\n                ctx.common.issues.push(...dirty.ctx.common.issues);\n                return dirty.result;\n            }\n            const unionErrors = issues.map((issues) => new ZodError_js_1.ZodError(issues));\n            (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                code: ZodError_js_1.ZodIssueCode.invalid_union,\n                unionErrors,\n            });\n            return parseUtil_js_1.INVALID;\n        }\n    }\n    get options() {\n        return this._def.options;\n    }\n}\nexports.ZodUnion = ZodUnion;\nZodUnion.create = (types, params) => {\n    return new ZodUnion({\n        options: types,\n        typeName: ZodFirstPartyTypeKind.ZodUnion,\n        ...processCreateParams(params),\n    });\n};\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n//////////                                 //////////\n//////////      ZodDiscriminatedUnion      //////////\n//////////                                 //////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\nconst getDiscriminator = (type) => {\n    if (type instanceof ZodLazy) {\n        return getDiscriminator(type.schema);\n    }\n    else if (type instanceof ZodEffects) {\n        return getDiscriminator(type.innerType());\n    }\n    else if (type instanceof ZodLiteral) {\n        return [type.value];\n    }\n    else if (type instanceof ZodEnum) {\n        return type.options;\n    }\n    else if (type instanceof ZodNativeEnum) {\n        // eslint-disable-next-line ban/ban\n        return util_js_1.util.objectValues(type.enum);\n    }\n    else if (type instanceof ZodDefault) {\n        return getDiscriminator(type._def.innerType);\n    }\n    else if (type instanceof ZodUndefined) {\n        return [undefined];\n    }\n    else if (type instanceof ZodNull) {\n        return [null];\n    }\n    else if (type instanceof ZodOptional) {\n        return [undefined, ...getDiscriminator(type.unwrap())];\n    }\n    else if (type instanceof ZodNullable) {\n        return [null, ...getDiscriminator(type.unwrap())];\n    }\n    else if (type instanceof ZodBranded) {\n        return getDiscriminator(type.unwrap());\n    }\n    else if (type instanceof ZodReadonly) {\n        return getDiscriminator(type.unwrap());\n    }\n    else if (type instanceof ZodCatch) {\n        return getDiscriminator(type._def.innerType);\n    }\n    else {\n        return [];\n    }\n};\nclass ZodDiscriminatedUnion extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== util_js_1.ZodParsedType.object) {\n            (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                code: ZodError_js_1.ZodIssueCode.invalid_type,\n                expected: util_js_1.ZodParsedType.object,\n                received: ctx.parsedType,\n            });\n            return parseUtil_js_1.INVALID;\n        }\n        const discriminator = this.discriminator;\n        const discriminatorValue = ctx.data[discriminator];\n        const option = this.optionsMap.get(discriminatorValue);\n        if (!option) {\n            (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                code: ZodError_js_1.ZodIssueCode.invalid_union_discriminator,\n                options: Array.from(this.optionsMap.keys()),\n                path: [discriminator],\n            });\n            return parseUtil_js_1.INVALID;\n        }\n        if (ctx.common.async) {\n            return option._parseAsync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            });\n        }\n        else {\n            return option._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            });\n        }\n    }\n    get discriminator() {\n        return this._def.discriminator;\n    }\n    get options() {\n        return this._def.options;\n    }\n    get optionsMap() {\n        return this._def.optionsMap;\n    }\n    /**\n     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.\n     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must\n     * have a different value for each object in the union.\n     * @param discriminator the name of the discriminator property\n     * @param types an array of object schemas\n     * @param params\n     */\n    static create(discriminator, options, params) {\n        // Get all the valid discriminator values\n        const optionsMap = new Map();\n        // try {\n        for (const type of options) {\n            const discriminatorValues = getDiscriminator(type.shape[discriminator]);\n            if (!discriminatorValues.length) {\n                throw new Error(`A discriminator value for key \\`${discriminator}\\` could not be extracted from all schema options`);\n            }\n            for (const value of discriminatorValues) {\n                if (optionsMap.has(value)) {\n                    throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);\n                }\n                optionsMap.set(value, type);\n            }\n        }\n        return new ZodDiscriminatedUnion({\n            typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,\n            discriminator,\n            options,\n            optionsMap,\n            ...processCreateParams(params),\n        });\n    }\n}\nexports.ZodDiscriminatedUnion = ZodDiscriminatedUnion;\nfunction mergeValues(a, b) {\n    const aType = (0, util_js_1.getParsedType)(a);\n    const bType = (0, util_js_1.getParsedType)(b);\n    if (a === b) {\n        return { valid: true, data: a };\n    }\n    else if (aType === util_js_1.ZodParsedType.object && bType === util_js_1.ZodParsedType.object) {\n        const bKeys = util_js_1.util.objectKeys(b);\n        const sharedKeys = util_js_1.util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);\n        const newObj = { ...a, ...b };\n        for (const key of sharedKeys) {\n            const sharedValue = mergeValues(a[key], b[key]);\n            if (!sharedValue.valid) {\n                return { valid: false };\n            }\n            newObj[key] = sharedValue.data;\n        }\n        return { valid: true, data: newObj };\n    }\n    else if (aType === util_js_1.ZodParsedType.array && bType === util_js_1.ZodParsedType.array) {\n        if (a.length !== b.length) {\n            return { valid: false };\n        }\n        const newArray = [];\n        for (let index = 0; index < a.length; index++) {\n            const itemA = a[index];\n            const itemB = b[index];\n            const sharedValue = mergeValues(itemA, itemB);\n            if (!sharedValue.valid) {\n                return { valid: false };\n            }\n            newArray.push(sharedValue.data);\n        }\n        return { valid: true, data: newArray };\n    }\n    else if (aType === util_js_1.ZodParsedType.date && bType === util_js_1.ZodParsedType.date && +a === +b) {\n        return { valid: true, data: a };\n    }\n    else {\n        return { valid: false };\n    }\n}\nclass ZodIntersection extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        const handleParsed = (parsedLeft, parsedRight) => {\n            if ((0, parseUtil_js_1.isAborted)(parsedLeft) || (0, parseUtil_js_1.isAborted)(parsedRight)) {\n                return parseUtil_js_1.INVALID;\n            }\n            const merged = mergeValues(parsedLeft.value, parsedRight.value);\n            if (!merged.valid) {\n                (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                    code: ZodError_js_1.ZodIssueCode.invalid_intersection_types,\n                });\n                return parseUtil_js_1.INVALID;\n            }\n            if ((0, parseUtil_js_1.isDirty)(parsedLeft) || (0, parseUtil_js_1.isDirty)(parsedRight)) {\n                status.dirty();\n            }\n            return { status: status.value, value: merged.data };\n        };\n        if (ctx.common.async) {\n            return Promise.all([\n                this._def.left._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                }),\n                this._def.right._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                }),\n            ]).then(([left, right]) => handleParsed(left, right));\n        }\n        else {\n            return handleParsed(this._def.left._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            }), this._def.right._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            }));\n        }\n    }\n}\nexports.ZodIntersection = ZodIntersection;\nZodIntersection.create = (left, right, params) => {\n    return new ZodIntersection({\n        left: left,\n        right: right,\n        typeName: ZodFirstPartyTypeKind.ZodIntersection,\n        ...processCreateParams(params),\n    });\n};\n// type ZodTupleItems = [ZodTypeAny, ...ZodTypeAny[]];\nclass ZodTuple extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== util_js_1.ZodParsedType.array) {\n            (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                code: ZodError_js_1.ZodIssueCode.invalid_type,\n                expected: util_js_1.ZodParsedType.array,\n                received: ctx.parsedType,\n            });\n            return parseUtil_js_1.INVALID;\n        }\n        if (ctx.data.length < this._def.items.length) {\n            (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                code: ZodError_js_1.ZodIssueCode.too_small,\n                minimum: this._def.items.length,\n                inclusive: true,\n                exact: false,\n                type: \"array\",\n            });\n            return parseUtil_js_1.INVALID;\n        }\n        const rest = this._def.rest;\n        if (!rest && ctx.data.length > this._def.items.length) {\n            (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                code: ZodError_js_1.ZodIssueCode.too_big,\n                maximum: this._def.items.length,\n                inclusive: true,\n                exact: false,\n                type: \"array\",\n            });\n            status.dirty();\n        }\n        const items = [...ctx.data]\n            .map((item, itemIndex) => {\n            const schema = this._def.items[itemIndex] || this._def.rest;\n            if (!schema)\n                return null;\n            return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));\n        })\n            .filter((x) => !!x); // filter nulls\n        if (ctx.common.async) {\n            return Promise.all(items).then((results) => {\n                return parseUtil_js_1.ParseStatus.mergeArray(status, results);\n            });\n        }\n        else {\n            return parseUtil_js_1.ParseStatus.mergeArray(status, items);\n        }\n    }\n    get items() {\n        return this._def.items;\n    }\n    rest(rest) {\n        return new ZodTuple({\n            ...this._def,\n            rest,\n        });\n    }\n}\nexports.ZodTuple = ZodTuple;\nZodTuple.create = (schemas, params) => {\n    if (!Array.isArray(schemas)) {\n        throw new Error(\"You must pass an array of schemas to z.tuple([ ... ])\");\n    }\n    return new ZodTuple({\n        items: schemas,\n        typeName: ZodFirstPartyTypeKind.ZodTuple,\n        rest: null,\n        ...processCreateParams(params),\n    });\n};\nclass ZodRecord extends ZodType {\n    get keySchema() {\n        return this._def.keyType;\n    }\n    get valueSchema() {\n        return this._def.valueType;\n    }\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== util_js_1.ZodParsedType.object) {\n            (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                code: ZodError_js_1.ZodIssueCode.invalid_type,\n                expected: util_js_1.ZodParsedType.object,\n                received: ctx.parsedType,\n            });\n            return parseUtil_js_1.INVALID;\n        }\n        const pairs = [];\n        const keyType = this._def.keyType;\n        const valueType = this._def.valueType;\n        for (const key in ctx.data) {\n            pairs.push({\n                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),\n                value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),\n                alwaysSet: key in ctx.data,\n            });\n        }\n        if (ctx.common.async) {\n            return parseUtil_js_1.ParseStatus.mergeObjectAsync(status, pairs);\n        }\n        else {\n            return parseUtil_js_1.ParseStatus.mergeObjectSync(status, pairs);\n        }\n    }\n    get element() {\n        return this._def.valueType;\n    }\n    static create(first, second, third) {\n        if (second instanceof ZodType) {\n            return new ZodRecord({\n                keyType: first,\n                valueType: second,\n                typeName: ZodFirstPartyTypeKind.ZodRecord,\n                ...processCreateParams(third),\n            });\n        }\n        return new ZodRecord({\n            keyType: ZodString.create(),\n            valueType: first,\n            typeName: ZodFirstPartyTypeKind.ZodRecord,\n            ...processCreateParams(second),\n        });\n    }\n}\nexports.ZodRecord = ZodRecord;\nclass ZodMap extends ZodType {\n    get keySchema() {\n        return this._def.keyType;\n    }\n    get valueSchema() {\n        return this._def.valueType;\n    }\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== util_js_1.ZodParsedType.map) {\n            (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                code: ZodError_js_1.ZodIssueCode.invalid_type,\n                expected: util_js_1.ZodParsedType.map,\n                received: ctx.parsedType,\n            });\n            return parseUtil_js_1.INVALID;\n        }\n        const keyType = this._def.keyType;\n        const valueType = this._def.valueType;\n        const pairs = [...ctx.data.entries()].map(([key, value], index) => {\n            return {\n                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, \"key\"])),\n                value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, \"value\"])),\n            };\n        });\n        if (ctx.common.async) {\n            const finalMap = new Map();\n            return Promise.resolve().then(async () => {\n                for (const pair of pairs) {\n                    const key = await pair.key;\n                    const value = await pair.value;\n                    if (key.status === \"aborted\" || value.status === \"aborted\") {\n                        return parseUtil_js_1.INVALID;\n                    }\n                    if (key.status === \"dirty\" || value.status === \"dirty\") {\n                        status.dirty();\n                    }\n                    finalMap.set(key.value, value.value);\n                }\n                return { status: status.value, value: finalMap };\n            });\n        }\n        else {\n            const finalMap = new Map();\n            for (const pair of pairs) {\n                const key = pair.key;\n                const value = pair.value;\n                if (key.status === \"aborted\" || value.status === \"aborted\") {\n                    return parseUtil_js_1.INVALID;\n                }\n                if (key.status === \"dirty\" || value.status === \"dirty\") {\n                    status.dirty();\n                }\n                finalMap.set(key.value, value.value);\n            }\n            return { status: status.value, value: finalMap };\n        }\n    }\n}\nexports.ZodMap = ZodMap;\nZodMap.create = (keyType, valueType, params) => {\n    return new ZodMap({\n        valueType,\n        keyType,\n        typeName: ZodFirstPartyTypeKind.ZodMap,\n        ...processCreateParams(params),\n    });\n};\nclass ZodSet extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== util_js_1.ZodParsedType.set) {\n            (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                code: ZodError_js_1.ZodIssueCode.invalid_type,\n                expected: util_js_1.ZodParsedType.set,\n                received: ctx.parsedType,\n            });\n            return parseUtil_js_1.INVALID;\n        }\n        const def = this._def;\n        if (def.minSize !== null) {\n            if (ctx.data.size < def.minSize.value) {\n                (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                    code: ZodError_js_1.ZodIssueCode.too_small,\n                    minimum: def.minSize.value,\n                    type: \"set\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.minSize.message,\n                });\n                status.dirty();\n            }\n        }\n        if (def.maxSize !== null) {\n            if (ctx.data.size > def.maxSize.value) {\n                (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                    code: ZodError_js_1.ZodIssueCode.too_big,\n                    maximum: def.maxSize.value,\n                    type: \"set\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.maxSize.message,\n                });\n                status.dirty();\n            }\n        }\n        const valueType = this._def.valueType;\n        function finalizeSet(elements) {\n            const parsedSet = new Set();\n            for (const element of elements) {\n                if (element.status === \"aborted\")\n                    return parseUtil_js_1.INVALID;\n                if (element.status === \"dirty\")\n                    status.dirty();\n                parsedSet.add(element.value);\n            }\n            return { status: status.value, value: parsedSet };\n        }\n        const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));\n        if (ctx.common.async) {\n            return Promise.all(elements).then((elements) => finalizeSet(elements));\n        }\n        else {\n            return finalizeSet(elements);\n        }\n    }\n    min(minSize, message) {\n        return new ZodSet({\n            ...this._def,\n            minSize: { value: minSize, message: errorUtil_js_1.errorUtil.toString(message) },\n        });\n    }\n    max(maxSize, message) {\n        return new ZodSet({\n            ...this._def,\n            maxSize: { value: maxSize, message: errorUtil_js_1.errorUtil.toString(message) },\n        });\n    }\n    size(size, message) {\n        return this.min(size, message).max(size, message);\n    }\n    nonempty(message) {\n        return this.min(1, message);\n    }\n}\nexports.ZodSet = ZodSet;\nZodSet.create = (valueType, params) => {\n    return new ZodSet({\n        valueType,\n        minSize: null,\n        maxSize: null,\n        typeName: ZodFirstPartyTypeKind.ZodSet,\n        ...processCreateParams(params),\n    });\n};\nclass ZodFunction extends ZodType {\n    constructor() {\n        super(...arguments);\n        this.validate = this.implement;\n    }\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== util_js_1.ZodParsedType.function) {\n            (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                code: ZodError_js_1.ZodIssueCode.invalid_type,\n                expected: util_js_1.ZodParsedType.function,\n                received: ctx.parsedType,\n            });\n            return parseUtil_js_1.INVALID;\n        }\n        function makeArgsIssue(args, error) {\n            return (0, parseUtil_js_1.makeIssue)({\n                data: args,\n                path: ctx.path,\n                errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, (0, errors_js_1.getErrorMap)(), errors_js_1.defaultErrorMap].filter((x) => !!x),\n                issueData: {\n                    code: ZodError_js_1.ZodIssueCode.invalid_arguments,\n                    argumentsError: error,\n                },\n            });\n        }\n        function makeReturnsIssue(returns, error) {\n            return (0, parseUtil_js_1.makeIssue)({\n                data: returns,\n                path: ctx.path,\n                errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, (0, errors_js_1.getErrorMap)(), errors_js_1.defaultErrorMap].filter((x) => !!x),\n                issueData: {\n                    code: ZodError_js_1.ZodIssueCode.invalid_return_type,\n                    returnTypeError: error,\n                },\n            });\n        }\n        const params = { errorMap: ctx.common.contextualErrorMap };\n        const fn = ctx.data;\n        if (this._def.returns instanceof ZodPromise) {\n            // Would love a way to avoid disabling this rule, but we need\n            // an alias (using an arrow function was what caused 2651).\n            // eslint-disable-next-line @typescript-eslint/no-this-alias\n            const me = this;\n            return (0, parseUtil_js_1.OK)(async function (...args) {\n                const error = new ZodError_js_1.ZodError([]);\n                const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {\n                    error.addIssue(makeArgsIssue(args, e));\n                    throw error;\n                });\n                const result = await Reflect.apply(fn, this, parsedArgs);\n                const parsedReturns = await me._def.returns._def.type\n                    .parseAsync(result, params)\n                    .catch((e) => {\n                    error.addIssue(makeReturnsIssue(result, e));\n                    throw error;\n                });\n                return parsedReturns;\n            });\n        }\n        else {\n            // Would love a way to avoid disabling this rule, but we need\n            // an alias (using an arrow function was what caused 2651).\n            // eslint-disable-next-line @typescript-eslint/no-this-alias\n            const me = this;\n            return (0, parseUtil_js_1.OK)(function (...args) {\n                const parsedArgs = me._def.args.safeParse(args, params);\n                if (!parsedArgs.success) {\n                    throw new ZodError_js_1.ZodError([makeArgsIssue(args, parsedArgs.error)]);\n                }\n                const result = Reflect.apply(fn, this, parsedArgs.data);\n                const parsedReturns = me._def.returns.safeParse(result, params);\n                if (!parsedReturns.success) {\n                    throw new ZodError_js_1.ZodError([makeReturnsIssue(result, parsedReturns.error)]);\n                }\n                return parsedReturns.data;\n            });\n        }\n    }\n    parameters() {\n        return this._def.args;\n    }\n    returnType() {\n        return this._def.returns;\n    }\n    args(...items) {\n        return new ZodFunction({\n            ...this._def,\n            args: ZodTuple.create(items).rest(ZodUnknown.create()),\n        });\n    }\n    returns(returnType) {\n        return new ZodFunction({\n            ...this._def,\n            returns: returnType,\n        });\n    }\n    implement(func) {\n        const validatedFunc = this.parse(func);\n        return validatedFunc;\n    }\n    strictImplement(func) {\n        const validatedFunc = this.parse(func);\n        return validatedFunc;\n    }\n    static create(args, returns, params) {\n        return new ZodFunction({\n            args: (args ? args : ZodTuple.create([]).rest(ZodUnknown.create())),\n            returns: returns || ZodUnknown.create(),\n            typeName: ZodFirstPartyTypeKind.ZodFunction,\n            ...processCreateParams(params),\n        });\n    }\n}\nexports.ZodFunction = ZodFunction;\nclass ZodLazy extends ZodType {\n    get schema() {\n        return this._def.getter();\n    }\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const lazySchema = this._def.getter();\n        return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });\n    }\n}\nexports.ZodLazy = ZodLazy;\nZodLazy.create = (getter, params) => {\n    return new ZodLazy({\n        getter: getter,\n        typeName: ZodFirstPartyTypeKind.ZodLazy,\n        ...processCreateParams(params),\n    });\n};\nclass ZodLiteral extends ZodType {\n    _parse(input) {\n        if (input.data !== this._def.value) {\n            const ctx = this._getOrReturnCtx(input);\n            (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                received: ctx.data,\n                code: ZodError_js_1.ZodIssueCode.invalid_literal,\n                expected: this._def.value,\n            });\n            return parseUtil_js_1.INVALID;\n        }\n        return { status: \"valid\", value: input.data };\n    }\n    get value() {\n        return this._def.value;\n    }\n}\nexports.ZodLiteral = ZodLiteral;\nZodLiteral.create = (value, params) => {\n    return new ZodLiteral({\n        value: value,\n        typeName: ZodFirstPartyTypeKind.ZodLiteral,\n        ...processCreateParams(params),\n    });\n};\nfunction createZodEnum(values, params) {\n    return new ZodEnum({\n        values,\n        typeName: ZodFirstPartyTypeKind.ZodEnum,\n        ...processCreateParams(params),\n    });\n}\nclass ZodEnum extends ZodType {\n    _parse(input) {\n        if (typeof input.data !== \"string\") {\n            const ctx = this._getOrReturnCtx(input);\n            const expectedValues = this._def.values;\n            (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                expected: util_js_1.util.joinValues(expectedValues),\n                received: ctx.parsedType,\n                code: ZodError_js_1.ZodIssueCode.invalid_type,\n            });\n            return parseUtil_js_1.INVALID;\n        }\n        if (!this._cache) {\n            this._cache = new Set(this._def.values);\n        }\n        if (!this._cache.has(input.data)) {\n            const ctx = this._getOrReturnCtx(input);\n            const expectedValues = this._def.values;\n            (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                received: ctx.data,\n                code: ZodError_js_1.ZodIssueCode.invalid_enum_value,\n                options: expectedValues,\n            });\n            return parseUtil_js_1.INVALID;\n        }\n        return (0, parseUtil_js_1.OK)(input.data);\n    }\n    get options() {\n        return this._def.values;\n    }\n    get enum() {\n        const enumValues = {};\n        for (const val of this._def.values) {\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    get Values() {\n        const enumValues = {};\n        for (const val of this._def.values) {\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    get Enum() {\n        const enumValues = {};\n        for (const val of this._def.values) {\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    extract(values, newDef = this._def) {\n        return ZodEnum.create(values, {\n            ...this._def,\n            ...newDef,\n        });\n    }\n    exclude(values, newDef = this._def) {\n        return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {\n            ...this._def,\n            ...newDef,\n        });\n    }\n}\nexports.ZodEnum = ZodEnum;\nZodEnum.create = createZodEnum;\nclass ZodNativeEnum extends ZodType {\n    _parse(input) {\n        const nativeEnumValues = util_js_1.util.getValidEnumValues(this._def.values);\n        const ctx = this._getOrReturnCtx(input);\n        if (ctx.parsedType !== util_js_1.ZodParsedType.string && ctx.parsedType !== util_js_1.ZodParsedType.number) {\n            const expectedValues = util_js_1.util.objectValues(nativeEnumValues);\n            (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                expected: util_js_1.util.joinValues(expectedValues),\n                received: ctx.parsedType,\n                code: ZodError_js_1.ZodIssueCode.invalid_type,\n            });\n            return parseUtil_js_1.INVALID;\n        }\n        if (!this._cache) {\n            this._cache = new Set(util_js_1.util.getValidEnumValues(this._def.values));\n        }\n        if (!this._cache.has(input.data)) {\n            const expectedValues = util_js_1.util.objectValues(nativeEnumValues);\n            (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                received: ctx.data,\n                code: ZodError_js_1.ZodIssueCode.invalid_enum_value,\n                options: expectedValues,\n            });\n            return parseUtil_js_1.INVALID;\n        }\n        return (0, parseUtil_js_1.OK)(input.data);\n    }\n    get enum() {\n        return this._def.values;\n    }\n}\nexports.ZodNativeEnum = ZodNativeEnum;\nZodNativeEnum.create = (values, params) => {\n    return new ZodNativeEnum({\n        values: values,\n        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,\n        ...processCreateParams(params),\n    });\n};\nclass ZodPromise extends ZodType {\n    unwrap() {\n        return this._def.type;\n    }\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== util_js_1.ZodParsedType.promise && ctx.common.async === false) {\n            (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                code: ZodError_js_1.ZodIssueCode.invalid_type,\n                expected: util_js_1.ZodParsedType.promise,\n                received: ctx.parsedType,\n            });\n            return parseUtil_js_1.INVALID;\n        }\n        const promisified = ctx.parsedType === util_js_1.ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);\n        return (0, parseUtil_js_1.OK)(promisified.then((data) => {\n            return this._def.type.parseAsync(data, {\n                path: ctx.path,\n                errorMap: ctx.common.contextualErrorMap,\n            });\n        }));\n    }\n}\nexports.ZodPromise = ZodPromise;\nZodPromise.create = (schema, params) => {\n    return new ZodPromise({\n        type: schema,\n        typeName: ZodFirstPartyTypeKind.ZodPromise,\n        ...processCreateParams(params),\n    });\n};\nclass ZodEffects extends ZodType {\n    innerType() {\n        return this._def.schema;\n    }\n    sourceType() {\n        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects\n            ? this._def.schema.sourceType()\n            : this._def.schema;\n    }\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        const effect = this._def.effect || null;\n        const checkCtx = {\n            addIssue: (arg) => {\n                (0, parseUtil_js_1.addIssueToContext)(ctx, arg);\n                if (arg.fatal) {\n                    status.abort();\n                }\n                else {\n                    status.dirty();\n                }\n            },\n            get path() {\n                return ctx.path;\n            },\n        };\n        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);\n        if (effect.type === \"preprocess\") {\n            const processed = effect.transform(ctx.data, checkCtx);\n            if (ctx.common.async) {\n                return Promise.resolve(processed).then(async (processed) => {\n                    if (status.value === \"aborted\")\n                        return parseUtil_js_1.INVALID;\n                    const result = await this._def.schema._parseAsync({\n                        data: processed,\n                        path: ctx.path,\n                        parent: ctx,\n                    });\n                    if (result.status === \"aborted\")\n                        return parseUtil_js_1.INVALID;\n                    if (result.status === \"dirty\")\n                        return (0, parseUtil_js_1.DIRTY)(result.value);\n                    if (status.value === \"dirty\")\n                        return (0, parseUtil_js_1.DIRTY)(result.value);\n                    return result;\n                });\n            }\n            else {\n                if (status.value === \"aborted\")\n                    return parseUtil_js_1.INVALID;\n                const result = this._def.schema._parseSync({\n                    data: processed,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (result.status === \"aborted\")\n                    return parseUtil_js_1.INVALID;\n                if (result.status === \"dirty\")\n                    return (0, parseUtil_js_1.DIRTY)(result.value);\n                if (status.value === \"dirty\")\n                    return (0, parseUtil_js_1.DIRTY)(result.value);\n                return result;\n            }\n        }\n        if (effect.type === \"refinement\") {\n            const executeRefinement = (acc) => {\n                const result = effect.refinement(acc, checkCtx);\n                if (ctx.common.async) {\n                    return Promise.resolve(result);\n                }\n                if (result instanceof Promise) {\n                    throw new Error(\"Async refinement encountered during synchronous parse operation. Use .parseAsync instead.\");\n                }\n                return acc;\n            };\n            if (ctx.common.async === false) {\n                const inner = this._def.schema._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (inner.status === \"aborted\")\n                    return parseUtil_js_1.INVALID;\n                if (inner.status === \"dirty\")\n                    status.dirty();\n                // return value is ignored\n                executeRefinement(inner.value);\n                return { status: status.value, value: inner.value };\n            }\n            else {\n                return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {\n                    if (inner.status === \"aborted\")\n                        return parseUtil_js_1.INVALID;\n                    if (inner.status === \"dirty\")\n                        status.dirty();\n                    return executeRefinement(inner.value).then(() => {\n                        return { status: status.value, value: inner.value };\n                    });\n                });\n            }\n        }\n        if (effect.type === \"transform\") {\n            if (ctx.common.async === false) {\n                const base = this._def.schema._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (!(0, parseUtil_js_1.isValid)(base))\n                    return parseUtil_js_1.INVALID;\n                const result = effect.transform(base.value, checkCtx);\n                if (result instanceof Promise) {\n                    throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);\n                }\n                return { status: status.value, value: result };\n            }\n            else {\n                return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {\n                    if (!(0, parseUtil_js_1.isValid)(base))\n                        return parseUtil_js_1.INVALID;\n                    return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({\n                        status: status.value,\n                        value: result,\n                    }));\n                });\n            }\n        }\n        util_js_1.util.assertNever(effect);\n    }\n}\nexports.ZodEffects = ZodEffects;\nexports.ZodTransformer = ZodEffects;\nZodEffects.create = (schema, effect, params) => {\n    return new ZodEffects({\n        schema,\n        typeName: ZodFirstPartyTypeKind.ZodEffects,\n        effect,\n        ...processCreateParams(params),\n    });\n};\nZodEffects.createWithPreprocess = (preprocess, schema, params) => {\n    return new ZodEffects({\n        schema,\n        effect: { type: \"preprocess\", transform: preprocess },\n        typeName: ZodFirstPartyTypeKind.ZodEffects,\n        ...processCreateParams(params),\n    });\n};\nclass ZodOptional extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType === util_js_1.ZodParsedType.undefined) {\n            return (0, parseUtil_js_1.OK)(undefined);\n        }\n        return this._def.innerType._parse(input);\n    }\n    unwrap() {\n        return this._def.innerType;\n    }\n}\nexports.ZodOptional = ZodOptional;\nZodOptional.create = (type, params) => {\n    return new ZodOptional({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodOptional,\n        ...processCreateParams(params),\n    });\n};\nclass ZodNullable extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType === util_js_1.ZodParsedType.null) {\n            return (0, parseUtil_js_1.OK)(null);\n        }\n        return this._def.innerType._parse(input);\n    }\n    unwrap() {\n        return this._def.innerType;\n    }\n}\nexports.ZodNullable = ZodNullable;\nZodNullable.create = (type, params) => {\n    return new ZodNullable({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodNullable,\n        ...processCreateParams(params),\n    });\n};\nclass ZodDefault extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        let data = ctx.data;\n        if (ctx.parsedType === util_js_1.ZodParsedType.undefined) {\n            data = this._def.defaultValue();\n        }\n        return this._def.innerType._parse({\n            data,\n            path: ctx.path,\n            parent: ctx,\n        });\n    }\n    removeDefault() {\n        return this._def.innerType;\n    }\n}\nexports.ZodDefault = ZodDefault;\nZodDefault.create = (type, params) => {\n    return new ZodDefault({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodDefault,\n        defaultValue: typeof params.default === \"function\" ? params.default : () => params.default,\n        ...processCreateParams(params),\n    });\n};\nclass ZodCatch extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        // newCtx is used to not collect issues from inner types in ctx\n        const newCtx = {\n            ...ctx,\n            common: {\n                ...ctx.common,\n                issues: [],\n            },\n        };\n        const result = this._def.innerType._parse({\n            data: newCtx.data,\n            path: newCtx.path,\n            parent: {\n                ...newCtx,\n            },\n        });\n        if ((0, parseUtil_js_1.isAsync)(result)) {\n            return result.then((result) => {\n                return {\n                    status: \"valid\",\n                    value: result.status === \"valid\"\n                        ? result.value\n                        : this._def.catchValue({\n                            get error() {\n                                return new ZodError_js_1.ZodError(newCtx.common.issues);\n                            },\n                            input: newCtx.data,\n                        }),\n                };\n            });\n        }\n        else {\n            return {\n                status: \"valid\",\n                value: result.status === \"valid\"\n                    ? result.value\n                    : this._def.catchValue({\n                        get error() {\n                            return new ZodError_js_1.ZodError(newCtx.common.issues);\n                        },\n                        input: newCtx.data,\n                    }),\n            };\n        }\n    }\n    removeCatch() {\n        return this._def.innerType;\n    }\n}\nexports.ZodCatch = ZodCatch;\nZodCatch.create = (type, params) => {\n    return new ZodCatch({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodCatch,\n        catchValue: typeof params.catch === \"function\" ? params.catch : () => params.catch,\n        ...processCreateParams(params),\n    });\n};\nclass ZodNaN extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== util_js_1.ZodParsedType.nan) {\n            const ctx = this._getOrReturnCtx(input);\n            (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                code: ZodError_js_1.ZodIssueCode.invalid_type,\n                expected: util_js_1.ZodParsedType.nan,\n                received: ctx.parsedType,\n            });\n            return parseUtil_js_1.INVALID;\n        }\n        return { status: \"valid\", value: input.data };\n    }\n}\nexports.ZodNaN = ZodNaN;\nZodNaN.create = (params) => {\n    return new ZodNaN({\n        typeName: ZodFirstPartyTypeKind.ZodNaN,\n        ...processCreateParams(params),\n    });\n};\nexports.BRAND = Symbol(\"zod_brand\");\nclass ZodBranded extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const data = ctx.data;\n        return this._def.type._parse({\n            data,\n            path: ctx.path,\n            parent: ctx,\n        });\n    }\n    unwrap() {\n        return this._def.type;\n    }\n}\nexports.ZodBranded = ZodBranded;\nclass ZodPipeline extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.common.async) {\n            const handleAsync = async () => {\n                const inResult = await this._def.in._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (inResult.status === \"aborted\")\n                    return parseUtil_js_1.INVALID;\n                if (inResult.status === \"dirty\") {\n                    status.dirty();\n                    return (0, parseUtil_js_1.DIRTY)(inResult.value);\n                }\n                else {\n                    return this._def.out._parseAsync({\n                        data: inResult.value,\n                        path: ctx.path,\n                        parent: ctx,\n                    });\n                }\n            };\n            return handleAsync();\n        }\n        else {\n            const inResult = this._def.in._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            });\n            if (inResult.status === \"aborted\")\n                return parseUtil_js_1.INVALID;\n            if (inResult.status === \"dirty\") {\n                status.dirty();\n                return {\n                    status: \"dirty\",\n                    value: inResult.value,\n                };\n            }\n            else {\n                return this._def.out._parseSync({\n                    data: inResult.value,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n            }\n        }\n    }\n    static create(a, b) {\n        return new ZodPipeline({\n            in: a,\n            out: b,\n            typeName: ZodFirstPartyTypeKind.ZodPipeline,\n        });\n    }\n}\nexports.ZodPipeline = ZodPipeline;\nclass ZodReadonly extends ZodType {\n    _parse(input) {\n        const result = this._def.innerType._parse(input);\n        const freeze = (data) => {\n            if ((0, parseUtil_js_1.isValid)(data)) {\n                data.value = Object.freeze(data.value);\n            }\n            return data;\n        };\n        return (0, parseUtil_js_1.isAsync)(result) ? result.then((data) => freeze(data)) : freeze(result);\n    }\n    unwrap() {\n        return this._def.innerType;\n    }\n}\nexports.ZodReadonly = ZodReadonly;\nZodReadonly.create = (type, params) => {\n    return new ZodReadonly({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodReadonly,\n        ...processCreateParams(params),\n    });\n};\n////////////////////////////////////////\n////////////////////////////////////////\n//////////                    //////////\n//////////      z.custom      //////////\n//////////                    //////////\n////////////////////////////////////////\n////////////////////////////////////////\nfunction cleanParams(params, data) {\n    const p = typeof params === \"function\" ? params(data) : typeof params === \"string\" ? { message: params } : params;\n    const p2 = typeof p === \"string\" ? { message: p } : p;\n    return p2;\n}\nfunction custom(check, _params = {}, \n/**\n * @deprecated\n *\n * Pass `fatal` into the params object instead:\n *\n * ```ts\n * z.string().custom((val) => val.length > 5, { fatal: false })\n * ```\n *\n */\nfatal) {\n    if (check)\n        return ZodAny.create().superRefine((data, ctx) => {\n            const r = check(data);\n            if (r instanceof Promise) {\n                return r.then((r) => {\n                    if (!r) {\n                        const params = cleanParams(_params, data);\n                        const _fatal = params.fatal ?? fatal ?? true;\n                        ctx.addIssue({ code: \"custom\", ...params, fatal: _fatal });\n                    }\n                });\n            }\n            if (!r) {\n                const params = cleanParams(_params, data);\n                const _fatal = params.fatal ?? fatal ?? true;\n                ctx.addIssue({ code: \"custom\", ...params, fatal: _fatal });\n            }\n            return;\n        });\n    return ZodAny.create();\n}\nexports.late = {\n    object: ZodObject.lazycreate,\n};\nvar ZodFirstPartyTypeKind;\n(function (ZodFirstPartyTypeKind) {\n    ZodFirstPartyTypeKind[\"ZodString\"] = \"ZodString\";\n    ZodFirstPartyTypeKind[\"ZodNumber\"] = \"ZodNumber\";\n    ZodFirstPartyTypeKind[\"ZodNaN\"] = \"ZodNaN\";\n    ZodFirstPartyTypeKind[\"ZodBigInt\"] = \"ZodBigInt\";\n    ZodFirstPartyTypeKind[\"ZodBoolean\"] = \"ZodBoolean\";\n    ZodFirstPartyTypeKind[\"ZodDate\"] = \"ZodDate\";\n    ZodFirstPartyTypeKind[\"ZodSymbol\"] = \"ZodSymbol\";\n    ZodFirstPartyTypeKind[\"ZodUndefined\"] = \"ZodUndefined\";\n    ZodFirstPartyTypeKind[\"ZodNull\"] = \"ZodNull\";\n    ZodFirstPartyTypeKind[\"ZodAny\"] = \"ZodAny\";\n    ZodFirstPartyTypeKind[\"ZodUnknown\"] = \"ZodUnknown\";\n    ZodFirstPartyTypeKind[\"ZodNever\"] = \"ZodNever\";\n    ZodFirstPartyTypeKind[\"ZodVoid\"] = \"ZodVoid\";\n    ZodFirstPartyTypeKind[\"ZodArray\"] = \"ZodArray\";\n    ZodFirstPartyTypeKind[\"ZodObject\"] = \"ZodObject\";\n    ZodFirstPartyTypeKind[\"ZodUnion\"] = \"ZodUnion\";\n    ZodFirstPartyTypeKind[\"ZodDiscriminatedUnion\"] = \"ZodDiscriminatedUnion\";\n    ZodFirstPartyTypeKind[\"ZodIntersection\"] = \"ZodIntersection\";\n    ZodFirstPartyTypeKind[\"ZodTuple\"] = \"ZodTuple\";\n    ZodFirstPartyTypeKind[\"ZodRecord\"] = \"ZodRecord\";\n    ZodFirstPartyTypeKind[\"ZodMap\"] = \"ZodMap\";\n    ZodFirstPartyTypeKind[\"ZodSet\"] = \"ZodSet\";\n    ZodFirstPartyTypeKind[\"ZodFunction\"] = \"ZodFunction\";\n    ZodFirstPartyTypeKind[\"ZodLazy\"] = \"ZodLazy\";\n    ZodFirstPartyTypeKind[\"ZodLiteral\"] = \"ZodLiteral\";\n    ZodFirstPartyTypeKind[\"ZodEnum\"] = \"ZodEnum\";\n    ZodFirstPartyTypeKind[\"ZodEffects\"] = \"ZodEffects\";\n    ZodFirstPartyTypeKind[\"ZodNativeEnum\"] = \"ZodNativeEnum\";\n    ZodFirstPartyTypeKind[\"ZodOptional\"] = \"ZodOptional\";\n    ZodFirstPartyTypeKind[\"ZodNullable\"] = \"ZodNullable\";\n    ZodFirstPartyTypeKind[\"ZodDefault\"] = \"ZodDefault\";\n    ZodFirstPartyTypeKind[\"ZodCatch\"] = \"ZodCatch\";\n    ZodFirstPartyTypeKind[\"ZodPromise\"] = \"ZodPromise\";\n    ZodFirstPartyTypeKind[\"ZodBranded\"] = \"ZodBranded\";\n    ZodFirstPartyTypeKind[\"ZodPipeline\"] = \"ZodPipeline\";\n    ZodFirstPartyTypeKind[\"ZodReadonly\"] = \"ZodReadonly\";\n})(ZodFirstPartyTypeKind || (exports.ZodFirstPartyTypeKind = ZodFirstPartyTypeKind = {}));\n// requires TS 4.4+\nclass Class {\n    constructor(..._) { }\n}\nconst instanceOfType = (\n// const instanceOfType = <T extends new (...args: any[]) => any>(\ncls, params = {\n    message: `Input not instance of ${cls.name}`,\n}) => custom((data) => data instanceof cls, params);\nexports[\"instanceof\"] = instanceOfType;\nconst stringType = ZodString.create;\nexports.string = stringType;\nconst numberType = ZodNumber.create;\nexports.number = numberType;\nconst nanType = ZodNaN.create;\nexports.nan = nanType;\nconst bigIntType = ZodBigInt.create;\nexports.bigint = bigIntType;\nconst booleanType = ZodBoolean.create;\nexports.boolean = booleanType;\nconst dateType = ZodDate.create;\nexports.date = dateType;\nconst symbolType = ZodSymbol.create;\nexports.symbol = symbolType;\nconst undefinedType = ZodUndefined.create;\nexports.undefined = undefinedType;\nconst nullType = ZodNull.create;\nexports[\"null\"] = nullType;\nconst anyType = ZodAny.create;\nexports.any = anyType;\nconst unknownType = ZodUnknown.create;\nexports.unknown = unknownType;\nconst neverType = ZodNever.create;\nexports.never = neverType;\nconst voidType = ZodVoid.create;\nexports[\"void\"] = voidType;\nconst arrayType = ZodArray.create;\nexports.array = arrayType;\nconst objectType = ZodObject.create;\nexports.object = objectType;\nconst strictObjectType = ZodObject.strictCreate;\nexports.strictObject = strictObjectType;\nconst unionType = ZodUnion.create;\nexports.union = unionType;\nconst discriminatedUnionType = ZodDiscriminatedUnion.create;\nexports.discriminatedUnion = discriminatedUnionType;\nconst intersectionType = ZodIntersection.create;\nexports.intersection = intersectionType;\nconst tupleType = ZodTuple.create;\nexports.tuple = tupleType;\nconst recordType = ZodRecord.create;\nexports.record = recordType;\nconst mapType = ZodMap.create;\nexports.map = mapType;\nconst setType = ZodSet.create;\nexports.set = setType;\nconst functionType = ZodFunction.create;\nexports[\"function\"] = functionType;\nconst lazyType = ZodLazy.create;\nexports.lazy = lazyType;\nconst literalType = ZodLiteral.create;\nexports.literal = literalType;\nconst enumType = ZodEnum.create;\nexports[\"enum\"] = enumType;\nconst nativeEnumType = ZodNativeEnum.create;\nexports.nativeEnum = nativeEnumType;\nconst promiseType = ZodPromise.create;\nexports.promise = promiseType;\nconst effectsType = ZodEffects.create;\nexports.effect = effectsType;\nexports.transformer = effectsType;\nconst optionalType = ZodOptional.create;\nexports.optional = optionalType;\nconst nullableType = ZodNullable.create;\nexports.nullable = nullableType;\nconst preprocessType = ZodEffects.createWithPreprocess;\nexports.preprocess = preprocessType;\nconst pipelineType = ZodPipeline.create;\nexports.pipeline = pipelineType;\nconst ostring = () => stringType().optional();\nexports.ostring = ostring;\nconst onumber = () => numberType().optional();\nexports.onumber = onumber;\nconst oboolean = () => booleanType().optional();\nexports.oboolean = oboolean;\nexports.coerce = {\n    string: ((arg) => ZodString.create({ ...arg, coerce: true })),\n    number: ((arg) => ZodNumber.create({ ...arg, coerce: true })),\n    boolean: ((arg) => ZodBoolean.create({\n        ...arg,\n        coerce: true,\n    })),\n    bigint: ((arg) => ZodBigInt.create({ ...arg, coerce: true })),\n    date: ((arg) => ZodDate.create({ ...arg, coerce: true })),\n};\nexports.NEVER = parseUtil_js_1.INVALID;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvem9kL3YzL3R5cGVzLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwwQkFBMEIsR0FBRyxZQUFZLEdBQUcsZUFBZSxHQUFHLGNBQWMsR0FBRyxhQUFhLEdBQUcsV0FBVyxHQUFHLGNBQWMsR0FBRyw2QkFBNkIsR0FBRyxZQUFZLEdBQUcsaUJBQWlCLEdBQUcsY0FBYyxHQUFHLG1CQUFtQixHQUFHLG1CQUFtQixHQUFHLGtCQUFrQixHQUFHLGFBQWEsR0FBRyxjQUFjLEdBQUcsZ0JBQWdCLEdBQUcsa0JBQWtCLEdBQUcsbUJBQW1CLEdBQUcsbUJBQW1CLEdBQUcsc0JBQXNCLEdBQUcsa0JBQWtCLEdBQUcsa0JBQWtCLEdBQUcscUJBQXFCLEdBQUcsZUFBZSxHQUFHLGtCQUFrQixHQUFHLGVBQWUsR0FBRyxtQkFBbUIsR0FBRyxjQUFjLEdBQUcsY0FBYyxHQUFHLGlCQUFpQixHQUFHLGdCQUFnQixHQUFHLHVCQUF1QixHQUFHLDZCQUE2QixHQUFHLGdCQUFnQixHQUFHLGlCQUFpQixHQUFHLGdCQUFnQixHQUFHLGVBQWUsR0FBRyxnQkFBZ0IsR0FBRyxrQkFBa0IsR0FBRyxjQUFjLEdBQUcsZUFBZSxHQUFHLG9CQUFvQixHQUFHLGlCQUFpQixHQUFHLGVBQWUsR0FBRyxrQkFBa0IsR0FBRyxpQkFBaUIsR0FBRyxpQkFBaUIsR0FBRyxpQkFBaUIsR0FBRyxlQUFlO0FBQ3orQixhQUFhLEdBQUcsZUFBWSxHQUFHLGVBQWUsR0FBRyxhQUFhLEdBQUcsaUJBQWlCLEdBQUcsYUFBYSxHQUFHLG1CQUFtQixHQUFHLGNBQWMsR0FBRyxjQUFjLEdBQUcsb0JBQW9CLEdBQUcsV0FBVyxHQUFHLGNBQWMsR0FBRyxlQUFlLEdBQUcsa0JBQWtCLEdBQUcsZ0JBQWdCLEdBQUcsZUFBZSxHQUFHLGdCQUFnQixHQUFHLGVBQWUsR0FBRyxnQkFBZ0IsR0FBRyxjQUFj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QUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsaURBQWlEO0FBQ3ZGO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MseUJBQXlCO0FBQy9EO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsdUJBQXVCO0FBQzdEO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxnQ0FBZ0MsOERBQThEO0FBQzlGO0FBQ0E7QUFDQSxnQ0FBZ0MsNERBQTREO0FBQzVGO0FBQ0E7QUFDQSxnQ0FBZ0MsOERBQThEO0FBQzlGO0FBQ0E7QUFDQSxnQ0FBZ0MsNkRBQTZEO0FBQzdGO0FBQ0E7QUFDQSxnQ0FBZ0MsK0RBQStEO0FBQy9GO0FBQ0E7QUFDQSxnQ0FBZ0MsNkRBQTZEO0FBQzdGO0FBQ0E7QUFDQSxnQ0FBZ0MsOERBQThEO0FBQzlGO0FBQ0E7QUFDQSxnQ0FBZ0MsNkRBQTZEO0FBQzdGO0FBQ0E7QUFDQSxnQ0FBZ0MsK0RBQStEO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsZ0NBQWdDLDREQUE0RDtBQUM1RjtBQUNBO0FBQ0EsZ0NBQWdDLDJEQUEyRDtBQUMzRjtBQUNBO0FBQ0EsZ0NBQWdDLDZEQUE2RDtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGdDQUFnQyx1QkFBdUI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsZ0NBQWdDLGlFQUFpRTtBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxjQUFjO0FBQzFELFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxxQkFBcUI7QUFDakUsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLHFCQUFxQjtBQUNqRSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixNQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FB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QVc7QUFDWDtBQUNBLGNBQWM7QUFDZDtBQUNBLGVBQWU7QUFDZjtBQUNBLFlBQVk7QUFDWjtBQUNBLGNBQWM7QUFDZDtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGVBQVk7QUFDWjtBQUNBLFdBQVc7QUFDWDtBQUNBLGVBQWU7QUFDZjtBQUNBLGFBQWE7QUFDYjtBQUNBLGVBQVk7QUFDWjtBQUNBLGFBQWE7QUFDYjtBQUNBLGNBQWM7QUFDZDtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLGFBQWE7QUFDYjtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLGFBQWE7QUFDYjtBQUNBLGNBQWM7QUFDZDtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDtBQUNBLG1CQUFnQjtBQUNoQjtBQUNBLFlBQVk7QUFDWjtBQUNBLGVBQWU7QUFDZjtBQUNBLGVBQVk7QUFDWjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLGVBQWU7QUFDZjtBQUNBLGNBQWM7QUFDZCxtQkFBbUI7QUFDbkI7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxnQkFBZ0I7QUFDaEIsY0FBYztBQUNkLHlDQUF5QyxzQkFBc0I7QUFDL0QseUNBQXlDLHNCQUFzQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wseUNBQXlDLHNCQUFzQjtBQUMvRCxxQ0FBcUMsc0JBQXNCO0FBQzNEO0FBQ0EsYUFBYSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxuYXRoYVxcT25lRHJpdmVcXERlc2t0b3BcXE1vbmV5UXVlc3RWM1xcbm9kZV9tb2R1bGVzXFx6b2RcXHYzXFx0eXBlcy5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRpc2NyaW1pbmF0ZWRVbmlvbiA9IGV4cG9ydHMuZGF0ZSA9IGV4cG9ydHMuYm9vbGVhbiA9IGV4cG9ydHMuYmlnaW50ID0gZXhwb3J0cy5hcnJheSA9IGV4cG9ydHMuYW55ID0gZXhwb3J0cy5jb2VyY2UgPSBleHBvcnRzLlpvZEZpcnN0UGFydHlUeXBlS2luZCA9IGV4cG9ydHMubGF0ZSA9IGV4cG9ydHMuWm9kU2NoZW1hID0gZXhwb3J0cy5TY2hlbWEgPSBleHBvcnRzLlpvZFJlYWRvbmx5ID0gZXhwb3J0cy5ab2RQaXBlbGluZSA9IGV4cG9ydHMuWm9kQnJhbmRlZCA9IGV4cG9ydHMuQlJBTkQgPSBleHBvcnRzLlpvZE5hTiA9IGV4cG9ydHMuWm9kQ2F0Y2ggPSBleHBvcnRzLlpvZERlZmF1bHQgPSBleHBvcnRzLlpvZE51bGxhYmxlID0gZXhwb3J0cy5ab2RPcHRpb25hbCA9IGV4cG9ydHMuWm9kVHJhbnNmb3JtZXIgPSBleHBvcnRzLlpvZEVmZmVjdHMgPSBleHBvcnRzLlpvZFByb21pc2UgPSBleHBvcnRzLlpvZE5hdGl2ZUVudW0gPSBleHBvcnRzLlpvZEVudW0gPSBleHBvcnRzLlpvZExpdGVyYWwgPSBleHBvcnRzLlpvZExhenkgPSBleHBvcnRzLlpvZEZ1bmN0aW9uID0gZXhwb3J0cy5ab2RTZXQgPSBleHBvcnRzLlpvZE1hcCA9IGV4cG9ydHMuWm9kUmVjb3JkID0gZXhwb3J0cy5ab2RUdXBsZSA9IGV4cG9ydHMuWm9kSW50ZXJzZWN0aW9uID0gZXhwb3J0cy5ab2REaXNjcmltaW5hdGVkVW5pb24gPSBleHBvcnRzLlpvZFVuaW9uID0gZXhwb3J0cy5ab2RPYmplY3QgPSBleHBvcnRzLlpvZEFycmF5ID0gZXhwb3J0cy5ab2RWb2lkID0gZXhwb3J0cy5ab2ROZXZlciA9IGV4cG9ydHMuWm9kVW5rbm93biA9IGV4cG9ydHMuWm9kQW55ID0gZXhwb3J0cy5ab2ROdWxsID0gZXhwb3J0cy5ab2RVbmRlZmluZWQgPSBleHBvcnRzLlpvZFN5bWJvbCA9IGV4cG9ydHMuWm9kRGF0ZSA9IGV4cG9ydHMuWm9kQm9vbGVhbiA9IGV4cG9ydHMuWm9kQmlnSW50ID0gZXhwb3J0cy5ab2ROdW1iZXIgPSBleHBvcnRzLlpvZFN0cmluZyA9IGV4cG9ydHMuWm9kVHlwZSA9IHZvaWQgMDtcbmV4cG9ydHMuTkVWRVIgPSBleHBvcnRzLnZvaWQgPSBleHBvcnRzLnVua25vd24gPSBleHBvcnRzLnVuaW9uID0gZXhwb3J0cy51bmRlZmluZWQgPSBleHBvcnRzLnR1cGxlID0gZXhwb3J0cy50cmFuc2Zvcm1lciA9IGV4cG9ydHMuc3ltYm9sID0gZXhwb3J0cy5zdHJpbmcgPSBleHBvcnRzLnN0cmljdE9iamVjdCA9IGV4cG9ydHMuc2V0ID0gZXhwb3J0cy5yZWNvcmQgPSBleHBvcnRzLnByb21pc2UgPSBleHBvcnRzLnByZXByb2Nlc3MgPSBleHBvcnRzLnBpcGVsaW5lID0gZXhwb3J0cy5vc3RyaW5nID0gZXhwb3J0cy5vcHRpb25hbCA9IGV4cG9ydHMub251bWJlciA9IGV4cG9ydHMub2Jvb2xlYW4gPSBleHBvcnRzLm9iamVjdCA9IGV4cG9ydHMubnVtYmVyID0gZXhwb3J0cy5udWxsYWJsZSA9IGV4cG9ydHMubnVsbCA9IGV4cG9ydHMubmV2ZXIgPSBleHBvcnRzLm5hdGl2ZUVudW0gPSBleHBvcnRzLm5hbiA9IGV4cG9ydHMubWFwID0gZXhwb3J0cy5saXRlcmFsID0gZXhwb3J0cy5sYXp5ID0gZXhwb3J0cy5pbnRlcnNlY3Rpb24gPSBleHBvcnRzLmluc3RhbmNlb2YgPSBleHBvcnRzLmZ1bmN0aW9uID0gZXhwb3J0cy5lbnVtID0gZXhwb3J0cy5lZmZlY3QgPSB2b2lkIDA7XG5leHBvcnRzLmRhdGV0aW1lUmVnZXggPSBkYXRldGltZVJlZ2V4O1xuZXhwb3J0cy5jdXN0b20gPSBjdXN0b207XG5jb25zdCBab2RFcnJvcl9qc18xID0gcmVxdWlyZShcIi4vWm9kRXJyb3IuY2pzXCIpO1xuY29uc3QgZXJyb3JzX2pzXzEgPSByZXF1aXJlKFwiLi9lcnJvcnMuY2pzXCIpO1xuY29uc3QgZXJyb3JVdGlsX2pzXzEgPSByZXF1aXJlKFwiLi9oZWxwZXJzL2Vycm9yVXRpbC5janNcIik7XG5jb25zdCBwYXJzZVV0aWxfanNfMSA9IHJlcXVpcmUoXCIuL2hlbHBlcnMvcGFyc2VVdGlsLmNqc1wiKTtcbmNvbnN0IHV0aWxfanNfMSA9IHJlcXVpcmUoXCIuL2hlbHBlcnMvdXRpbC5janNcIik7XG5jbGFzcyBQYXJzZUlucHV0TGF6eVBhdGgge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgdmFsdWUsIHBhdGgsIGtleSkge1xuICAgICAgICB0aGlzLl9jYWNoZWRQYXRoID0gW107XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICB0aGlzLmRhdGEgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5fcGF0aCA9IHBhdGg7XG4gICAgICAgIHRoaXMuX2tleSA9IGtleTtcbiAgICB9XG4gICAgZ2V0IHBhdGgoKSB7XG4gICAgICAgIGlmICghdGhpcy5fY2FjaGVkUGF0aC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuX2tleSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZWRQYXRoLnB1c2goLi4udGhpcy5fcGF0aCwgLi4udGhpcy5fa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlZFBhdGgucHVzaCguLi50aGlzLl9wYXRoLCB0aGlzLl9rZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWNoZWRQYXRoO1xuICAgIH1cbn1cbmNvbnN0IGhhbmRsZVJlc3VsdCA9IChjdHgsIHJlc3VsdCkgPT4ge1xuICAgIGlmICgoMCwgcGFyc2VVdGlsX2pzXzEuaXNWYWxpZCkocmVzdWx0KSkge1xuICAgICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCBkYXRhOiByZXN1bHQudmFsdWUgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmICghY3R4LmNvbW1vbi5pc3N1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJWYWxpZGF0aW9uIGZhaWxlZCBidXQgbm8gaXNzdWVzIGRldGVjdGVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICBnZXQgZXJyb3IoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2Vycm9yKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZXJyb3I7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgWm9kRXJyb3JfanNfMS5ab2RFcnJvcihjdHguY29tbW9uLmlzc3Vlcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZXJyb3I7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbn07XG5mdW5jdGlvbiBwcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcykge1xuICAgIGlmICghcGFyYW1zKVxuICAgICAgICByZXR1cm4ge307XG4gICAgY29uc3QgeyBlcnJvck1hcCwgaW52YWxpZF90eXBlX2Vycm9yLCByZXF1aXJlZF9lcnJvciwgZGVzY3JpcHRpb24gfSA9IHBhcmFtcztcbiAgICBpZiAoZXJyb3JNYXAgJiYgKGludmFsaWRfdHlwZV9lcnJvciB8fCByZXF1aXJlZF9lcnJvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW4ndCB1c2UgXCJpbnZhbGlkX3R5cGVfZXJyb3JcIiBvciBcInJlcXVpcmVkX2Vycm9yXCIgaW4gY29uanVuY3Rpb24gd2l0aCBjdXN0b20gZXJyb3IgbWFwLmApO1xuICAgIH1cbiAgICBpZiAoZXJyb3JNYXApXG4gICAgICAgIHJldHVybiB7IGVycm9yTWFwOiBlcnJvck1hcCwgZGVzY3JpcHRpb24gfTtcbiAgICBjb25zdCBjdXN0b21NYXAgPSAoaXNzLCBjdHgpID0+IHtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlIH0gPSBwYXJhbXM7XG4gICAgICAgIGlmIChpc3MuY29kZSA9PT0gXCJpbnZhbGlkX2VudW1fdmFsdWVcIikge1xuICAgICAgICAgICAgcmV0dXJuIHsgbWVzc2FnZTogbWVzc2FnZSA/PyBjdHguZGVmYXVsdEVycm9yIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBjdHguZGF0YSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgcmV0dXJuIHsgbWVzc2FnZTogbWVzc2FnZSA/PyByZXF1aXJlZF9lcnJvciA/PyBjdHguZGVmYXVsdEVycm9yIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzcy5jb2RlICE9PSBcImludmFsaWRfdHlwZVwiKVxuICAgICAgICAgICAgcmV0dXJuIHsgbWVzc2FnZTogY3R4LmRlZmF1bHRFcnJvciB9O1xuICAgICAgICByZXR1cm4geyBtZXNzYWdlOiBtZXNzYWdlID8/IGludmFsaWRfdHlwZV9lcnJvciA/PyBjdHguZGVmYXVsdEVycm9yIH07XG4gICAgfTtcbiAgICByZXR1cm4geyBlcnJvck1hcDogY3VzdG9tTWFwLCBkZXNjcmlwdGlvbiB9O1xufVxuY2xhc3MgWm9kVHlwZSB7XG4gICAgZ2V0IGRlc2NyaXB0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmRlc2NyaXB0aW9uO1xuICAgIH1cbiAgICBfZ2V0VHlwZShpbnB1dCkge1xuICAgICAgICByZXR1cm4gKDAsIHV0aWxfanNfMS5nZXRQYXJzZWRUeXBlKShpbnB1dC5kYXRhKTtcbiAgICB9XG4gICAgX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpIHtcbiAgICAgICAgcmV0dXJuIChjdHggfHwge1xuICAgICAgICAgICAgY29tbW9uOiBpbnB1dC5wYXJlbnQuY29tbW9uLFxuICAgICAgICAgICAgZGF0YTogaW5wdXQuZGF0YSxcbiAgICAgICAgICAgIHBhcnNlZFR5cGU6ICgwLCB1dGlsX2pzXzEuZ2V0UGFyc2VkVHlwZSkoaW5wdXQuZGF0YSksXG4gICAgICAgICAgICBzY2hlbWFFcnJvck1hcDogdGhpcy5fZGVmLmVycm9yTWFwLFxuICAgICAgICAgICAgcGF0aDogaW5wdXQucGF0aCxcbiAgICAgICAgICAgIHBhcmVudDogaW5wdXQucGFyZW50LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhdHVzOiBuZXcgcGFyc2VVdGlsX2pzXzEuUGFyc2VTdGF0dXMoKSxcbiAgICAgICAgICAgIGN0eDoge1xuICAgICAgICAgICAgICAgIGNvbW1vbjogaW5wdXQucGFyZW50LmNvbW1vbixcbiAgICAgICAgICAgICAgICBkYXRhOiBpbnB1dC5kYXRhLFxuICAgICAgICAgICAgICAgIHBhcnNlZFR5cGU6ICgwLCB1dGlsX2pzXzEuZ2V0UGFyc2VkVHlwZSkoaW5wdXQuZGF0YSksXG4gICAgICAgICAgICAgICAgc2NoZW1hRXJyb3JNYXA6IHRoaXMuX2RlZi5lcnJvck1hcCxcbiAgICAgICAgICAgICAgICBwYXRoOiBpbnB1dC5wYXRoLFxuICAgICAgICAgICAgICAgIHBhcmVudDogaW5wdXQucGFyZW50LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgX3BhcnNlU3luYyhpbnB1dCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9wYXJzZShpbnB1dCk7XG4gICAgICAgIGlmICgoMCwgcGFyc2VVdGlsX2pzXzEuaXNBc3luYykocmVzdWx0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3luY2hyb25vdXMgcGFyc2UgZW5jb3VudGVyZWQgcHJvbWlzZS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgX3BhcnNlQXN5bmMoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fcGFyc2UoaW5wdXQpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XG4gICAgfVxuICAgIHBhcnNlKGRhdGEsIHBhcmFtcykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnNhZmVQYXJzZShkYXRhLCBwYXJhbXMpO1xuICAgICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LmRhdGE7XG4gICAgICAgIHRocm93IHJlc3VsdC5lcnJvcjtcbiAgICB9XG4gICAgc2FmZVBhcnNlKGRhdGEsIHBhcmFtcykge1xuICAgICAgICBjb25zdCBjdHggPSB7XG4gICAgICAgICAgICBjb21tb246IHtcbiAgICAgICAgICAgICAgICBpc3N1ZXM6IFtdLFxuICAgICAgICAgICAgICAgIGFzeW5jOiBwYXJhbXM/LmFzeW5jID8/IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNvbnRleHR1YWxFcnJvck1hcDogcGFyYW1zPy5lcnJvck1hcCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwYXRoOiBwYXJhbXM/LnBhdGggfHwgW10sXG4gICAgICAgICAgICBzY2hlbWFFcnJvck1hcDogdGhpcy5fZGVmLmVycm9yTWFwLFxuICAgICAgICAgICAgcGFyZW50OiBudWxsLFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIHBhcnNlZFR5cGU6ICgwLCB1dGlsX2pzXzEuZ2V0UGFyc2VkVHlwZSkoZGF0YSksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX3BhcnNlU3luYyh7IGRhdGEsIHBhdGg6IGN0eC5wYXRoLCBwYXJlbnQ6IGN0eCB9KTtcbiAgICAgICAgcmV0dXJuIGhhbmRsZVJlc3VsdChjdHgsIHJlc3VsdCk7XG4gICAgfVxuICAgIFwifnZhbGlkYXRlXCIoZGF0YSkge1xuICAgICAgICBjb25zdCBjdHggPSB7XG4gICAgICAgICAgICBjb21tb246IHtcbiAgICAgICAgICAgICAgICBpc3N1ZXM6IFtdLFxuICAgICAgICAgICAgICAgIGFzeW5jOiAhIXRoaXNbXCJ+c3RhbmRhcmRcIl0uYXN5bmMsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGF0aDogW10sXG4gICAgICAgICAgICBzY2hlbWFFcnJvck1hcDogdGhpcy5fZGVmLmVycm9yTWFwLFxuICAgICAgICAgICAgcGFyZW50OiBudWxsLFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIHBhcnNlZFR5cGU6ICgwLCB1dGlsX2pzXzEuZ2V0UGFyc2VkVHlwZSkoZGF0YSksXG4gICAgICAgIH07XG4gICAgICAgIGlmICghdGhpc1tcIn5zdGFuZGFyZFwiXS5hc3luYykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9wYXJzZVN5bmMoeyBkYXRhLCBwYXRoOiBbXSwgcGFyZW50OiBjdHggfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBwYXJzZVV0aWxfanNfMS5pc1ZhbGlkKShyZXN1bHQpXG4gICAgICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHJlc3VsdC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzc3VlczogY3R4LmNvbW1vbi5pc3N1ZXMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycj8ubWVzc2FnZT8udG9Mb3dlckNhc2UoKT8uaW5jbHVkZXMoXCJlbmNvdW50ZXJlZFwiKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzW1wifnN0YW5kYXJkXCJdLmFzeW5jID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3R4LmNvbW1vbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgaXNzdWVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgYXN5bmM6IHRydWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcGFyc2VBc3luYyh7IGRhdGEsIHBhdGg6IFtdLCBwYXJlbnQ6IGN0eCB9KS50aGVuKChyZXN1bHQpID0+ICgwLCBwYXJzZVV0aWxfanNfMS5pc1ZhbGlkKShyZXN1bHQpXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogcmVzdWx0LnZhbHVlLFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgaXNzdWVzOiBjdHguY29tbW9uLmlzc3VlcyxcbiAgICAgICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBwYXJzZUFzeW5jKGRhdGEsIHBhcmFtcykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnNhZmVQYXJzZUFzeW5jKGRhdGEsIHBhcmFtcyk7XG4gICAgICAgIGlmIChyZXN1bHQuc3VjY2VzcylcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQuZGF0YTtcbiAgICAgICAgdGhyb3cgcmVzdWx0LmVycm9yO1xuICAgIH1cbiAgICBhc3luYyBzYWZlUGFyc2VBc3luYyhkYXRhLCBwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgY3R4ID0ge1xuICAgICAgICAgICAgY29tbW9uOiB7XG4gICAgICAgICAgICAgICAgaXNzdWVzOiBbXSxcbiAgICAgICAgICAgICAgICBjb250ZXh0dWFsRXJyb3JNYXA6IHBhcmFtcz8uZXJyb3JNYXAsXG4gICAgICAgICAgICAgICAgYXN5bmM6IHRydWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGF0aDogcGFyYW1zPy5wYXRoIHx8IFtdLFxuICAgICAgICAgICAgc2NoZW1hRXJyb3JNYXA6IHRoaXMuX2RlZi5lcnJvck1hcCxcbiAgICAgICAgICAgIHBhcmVudDogbnVsbCxcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBwYXJzZWRUeXBlOiAoMCwgdXRpbF9qc18xLmdldFBhcnNlZFR5cGUpKGRhdGEpLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBtYXliZUFzeW5jUmVzdWx0ID0gdGhpcy5fcGFyc2UoeyBkYXRhLCBwYXRoOiBjdHgucGF0aCwgcGFyZW50OiBjdHggfSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0ICgoMCwgcGFyc2VVdGlsX2pzXzEuaXNBc3luYykobWF5YmVBc3luY1Jlc3VsdCkgPyBtYXliZUFzeW5jUmVzdWx0IDogUHJvbWlzZS5yZXNvbHZlKG1heWJlQXN5bmNSZXN1bHQpKTtcbiAgICAgICAgcmV0dXJuIGhhbmRsZVJlc3VsdChjdHgsIHJlc3VsdCk7XG4gICAgfVxuICAgIHJlZmluZShjaGVjaywgbWVzc2FnZSkge1xuICAgICAgICBjb25zdCBnZXRJc3N1ZVByb3BlcnRpZXMgPSAodmFsKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIG1lc3NhZ2UgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBtZXNzYWdlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2UodmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVmaW5lbWVudCgodmFsLCBjdHgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGNoZWNrKHZhbCk7XG4gICAgICAgICAgICBjb25zdCBzZXRFcnJvciA9ICgpID0+IGN0eC5hZGRJc3N1ZSh7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kRXJyb3JfanNfMS5ab2RJc3N1ZUNvZGUuY3VzdG9tLFxuICAgICAgICAgICAgICAgIC4uLmdldElzc3VlUHJvcGVydGllcyh2YWwpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIFByb21pc2UgIT09IFwidW5kZWZpbmVkXCIgJiYgcmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEVycm9yKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBzZXRFcnJvcigpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVmaW5lbWVudChjaGVjaywgcmVmaW5lbWVudERhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlZmluZW1lbnQoKHZhbCwgY3R4KSA9PiB7XG4gICAgICAgICAgICBpZiAoIWNoZWNrKHZhbCkpIHtcbiAgICAgICAgICAgICAgICBjdHguYWRkSXNzdWUodHlwZW9mIHJlZmluZW1lbnREYXRhID09PSBcImZ1bmN0aW9uXCIgPyByZWZpbmVtZW50RGF0YSh2YWwsIGN0eCkgOiByZWZpbmVtZW50RGF0YSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfcmVmaW5lbWVudChyZWZpbmVtZW50KSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kRWZmZWN0cyh7XG4gICAgICAgICAgICBzY2hlbWE6IHRoaXMsXG4gICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEVmZmVjdHMsXG4gICAgICAgICAgICBlZmZlY3Q6IHsgdHlwZTogXCJyZWZpbmVtZW50XCIsIHJlZmluZW1lbnQgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN1cGVyUmVmaW5lKHJlZmluZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlZmluZW1lbnQocmVmaW5lbWVudCk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGRlZikge1xuICAgICAgICAvKiogQWxpYXMgb2Ygc2FmZVBhcnNlQXN5bmMgKi9cbiAgICAgICAgdGhpcy5zcGEgPSB0aGlzLnNhZmVQYXJzZUFzeW5jO1xuICAgICAgICB0aGlzLl9kZWYgPSBkZWY7XG4gICAgICAgIHRoaXMucGFyc2UgPSB0aGlzLnBhcnNlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2FmZVBhcnNlID0gdGhpcy5zYWZlUGFyc2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5wYXJzZUFzeW5jID0gdGhpcy5wYXJzZUFzeW5jLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2FmZVBhcnNlQXN5bmMgPSB0aGlzLnNhZmVQYXJzZUFzeW5jLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc3BhID0gdGhpcy5zcGEuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5yZWZpbmUgPSB0aGlzLnJlZmluZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnJlZmluZW1lbnQgPSB0aGlzLnJlZmluZW1lbnQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zdXBlclJlZmluZSA9IHRoaXMuc3VwZXJSZWZpbmUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vcHRpb25hbCA9IHRoaXMub3B0aW9uYWwuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5udWxsYWJsZSA9IHRoaXMubnVsbGFibGUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5udWxsaXNoID0gdGhpcy5udWxsaXNoLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYXJyYXkgPSB0aGlzLmFycmF5LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucHJvbWlzZSA9IHRoaXMucHJvbWlzZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9yID0gdGhpcy5vci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmFuZCA9IHRoaXMuYW5kLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtID0gdGhpcy50cmFuc2Zvcm0uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5icmFuZCA9IHRoaXMuYnJhbmQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5kZWZhdWx0ID0gdGhpcy5kZWZhdWx0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuY2F0Y2ggPSB0aGlzLmNhdGNoLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZGVzY3JpYmUgPSB0aGlzLmRlc2NyaWJlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucGlwZSA9IHRoaXMucGlwZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnJlYWRvbmx5ID0gdGhpcy5yZWFkb25seS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmlzTnVsbGFibGUgPSB0aGlzLmlzTnVsbGFibGUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5pc09wdGlvbmFsID0gdGhpcy5pc09wdGlvbmFsLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXNbXCJ+c3RhbmRhcmRcIl0gPSB7XG4gICAgICAgICAgICB2ZXJzaW9uOiAxLFxuICAgICAgICAgICAgdmVuZG9yOiBcInpvZFwiLFxuICAgICAgICAgICAgdmFsaWRhdGU6IChkYXRhKSA9PiB0aGlzW1wifnZhbGlkYXRlXCJdKGRhdGEpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBvcHRpb25hbCgpIHtcbiAgICAgICAgcmV0dXJuIFpvZE9wdGlvbmFsLmNyZWF0ZSh0aGlzLCB0aGlzLl9kZWYpO1xuICAgIH1cbiAgICBudWxsYWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIFpvZE51bGxhYmxlLmNyZWF0ZSh0aGlzLCB0aGlzLl9kZWYpO1xuICAgIH1cbiAgICBudWxsaXNoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5udWxsYWJsZSgpLm9wdGlvbmFsKCk7XG4gICAgfVxuICAgIGFycmF5KCkge1xuICAgICAgICByZXR1cm4gWm9kQXJyYXkuY3JlYXRlKHRoaXMpO1xuICAgIH1cbiAgICBwcm9taXNlKCkge1xuICAgICAgICByZXR1cm4gWm9kUHJvbWlzZS5jcmVhdGUodGhpcywgdGhpcy5fZGVmKTtcbiAgICB9XG4gICAgb3Iob3B0aW9uKSB7XG4gICAgICAgIHJldHVybiBab2RVbmlvbi5jcmVhdGUoW3RoaXMsIG9wdGlvbl0sIHRoaXMuX2RlZik7XG4gICAgfVxuICAgIGFuZChpbmNvbWluZykge1xuICAgICAgICByZXR1cm4gWm9kSW50ZXJzZWN0aW9uLmNyZWF0ZSh0aGlzLCBpbmNvbWluZywgdGhpcy5fZGVmKTtcbiAgICB9XG4gICAgdHJhbnNmb3JtKHRyYW5zZm9ybSkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEVmZmVjdHMoe1xuICAgICAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyh0aGlzLl9kZWYpLFxuICAgICAgICAgICAgc2NoZW1hOiB0aGlzLFxuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RFZmZlY3RzLFxuICAgICAgICAgICAgZWZmZWN0OiB7IHR5cGU6IFwidHJhbnNmb3JtXCIsIHRyYW5zZm9ybSB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGVmYXVsdChkZWYpIHtcbiAgICAgICAgY29uc3QgZGVmYXVsdFZhbHVlRnVuYyA9IHR5cGVvZiBkZWYgPT09IFwiZnVuY3Rpb25cIiA/IGRlZiA6ICgpID0+IGRlZjtcbiAgICAgICAgcmV0dXJuIG5ldyBab2REZWZhdWx0KHtcbiAgICAgICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXModGhpcy5fZGVmKSxcbiAgICAgICAgICAgIGlubmVyVHlwZTogdGhpcyxcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogZGVmYXVsdFZhbHVlRnVuYyxcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRGVmYXVsdCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGJyYW5kKCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEJyYW5kZWQoe1xuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RCcmFuZGVkLFxuICAgICAgICAgICAgdHlwZTogdGhpcyxcbiAgICAgICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXModGhpcy5fZGVmKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNhdGNoKGRlZikge1xuICAgICAgICBjb25zdCBjYXRjaFZhbHVlRnVuYyA9IHR5cGVvZiBkZWYgPT09IFwiZnVuY3Rpb25cIiA/IGRlZiA6ICgpID0+IGRlZjtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RDYXRjaCh7XG4gICAgICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHRoaXMuX2RlZiksXG4gICAgICAgICAgICBpbm5lclR5cGU6IHRoaXMsXG4gICAgICAgICAgICBjYXRjaFZhbHVlOiBjYXRjaFZhbHVlRnVuYyxcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQ2F0Y2gsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkZXNjcmliZShkZXNjcmlwdGlvbikge1xuICAgICAgICBjb25zdCBUaGlzID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgcmV0dXJuIG5ldyBUaGlzKHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcGlwZSh0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIFpvZFBpcGVsaW5lLmNyZWF0ZSh0aGlzLCB0YXJnZXQpO1xuICAgIH1cbiAgICByZWFkb25seSgpIHtcbiAgICAgICAgcmV0dXJuIFpvZFJlYWRvbmx5LmNyZWF0ZSh0aGlzKTtcbiAgICB9XG4gICAgaXNPcHRpb25hbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2FmZVBhcnNlKHVuZGVmaW5lZCkuc3VjY2VzcztcbiAgICB9XG4gICAgaXNOdWxsYWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2FmZVBhcnNlKG51bGwpLnN1Y2Nlc3M7XG4gICAgfVxufVxuZXhwb3J0cy5ab2RUeXBlID0gWm9kVHlwZTtcbmV4cG9ydHMuU2NoZW1hID0gWm9kVHlwZTtcbmV4cG9ydHMuWm9kU2NoZW1hID0gWm9kVHlwZTtcbmNvbnN0IGN1aWRSZWdleCA9IC9eY1teXFxzLV17OCx9JC9pO1xuY29uc3QgY3VpZDJSZWdleCA9IC9eWzAtOWEtel0rJC87XG5jb25zdCB1bGlkUmVnZXggPSAvXlswLTlBLUhKS01OUC1UVi1aXXsyNn0kL2k7XG4vLyBjb25zdCB1dWlkUmVnZXggPVxuLy8gICAvXihbYS1mMC05XXs4fS1bYS1mMC05XXs0fS1bMS01XVthLWYwLTldezN9LVthLWYwLTldezR9LVthLWYwLTldezEyfXwwMDAwMDAwMC0wMDAwLTAwMDAtMDAwMC0wMDAwMDAwMDAwMDApJC9pO1xuY29uc3QgdXVpZFJlZ2V4ID0gL15bMC05YS1mQS1GXXs4fVxcYi1bMC05YS1mQS1GXXs0fVxcYi1bMC05YS1mQS1GXXs0fVxcYi1bMC05YS1mQS1GXXs0fVxcYi1bMC05YS1mQS1GXXsxMn0kL2k7XG5jb25zdCBuYW5vaWRSZWdleCA9IC9eW2EtejAtOV8tXXsyMX0kL2k7XG5jb25zdCBqd3RSZWdleCA9IC9eW0EtWmEtejAtOS1fXStcXC5bQS1aYS16MC05LV9dK1xcLltBLVphLXowLTktX10qJC87XG5jb25zdCBkdXJhdGlvblJlZ2V4ID0gL15bLStdP1AoPyEkKSg/Oig/OlstK10/XFxkK1kpfCg/OlstK10/XFxkK1suLF1cXGQrWSQpKT8oPzooPzpbLStdP1xcZCtNKXwoPzpbLStdP1xcZCtbLixdXFxkK00kKSk/KD86KD86Wy0rXT9cXGQrVyl8KD86Wy0rXT9cXGQrWy4sXVxcZCtXJCkpPyg/Oig/OlstK10/XFxkK0QpfCg/OlstK10/XFxkK1suLF1cXGQrRCQpKT8oPzpUKD89W1xcZCstXSkoPzooPzpbLStdP1xcZCtIKXwoPzpbLStdP1xcZCtbLixdXFxkK0gkKSk/KD86KD86Wy0rXT9cXGQrTSl8KD86Wy0rXT9cXGQrWy4sXVxcZCtNJCkpPyg/OlstK10/XFxkKyg/OlsuLF1cXGQrKT9TKT8pPz8kLztcbi8vIGZyb20gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzQ2MTgxLzE1NTAxNTVcbi8vIG9sZCB2ZXJzaW9uOiB0b28gc2xvdywgZGlkbid0IHN1cHBvcnQgdW5pY29kZVxuLy8gY29uc3QgZW1haWxSZWdleCA9IC9eKCgoW2Etel18XFxkfFshI1xcJCUmJ1xcKlxcK1xcLVxcLz1cXD9cXF5fYHtcXHx9fl18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKyhcXC4oW2Etel18XFxkfFshI1xcJCUmJ1xcKlxcK1xcLVxcLz1cXD9cXF5fYHtcXHx9fl18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKykqKXwoKFxceDIyKSgoKChcXHgyMHxcXHgwOSkqKFxceDBkXFx4MGEpKT8oXFx4MjB8XFx4MDkpKyk/KChbXFx4MDEtXFx4MDhcXHgwYlxceDBjXFx4MGUtXFx4MWZcXHg3Zl18XFx4MjF8W1xceDIzLVxceDViXXxbXFx4NWQtXFx4N2VdfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoXFxcXChbXFx4MDEtXFx4MDlcXHgwYlxceDBjXFx4MGQtXFx4N2ZdfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSkpKSooKChcXHgyMHxcXHgwOSkqKFxceDBkXFx4MGEpKT8oXFx4MjB8XFx4MDkpKyk/KFxceDIyKSkpQCgoKFthLXpdfFxcZHxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KChbYS16XXxcXGR8W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKFthLXpdfFxcZHwtfFxcLnxffH58W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKihbYS16XXxcXGR8W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKSlcXC4pKygoW2Etel18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfCgoW2Etel18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKFthLXpdfFxcZHwtfFxcLnxffH58W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKihbYS16XXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkpKSQvaTtcbi8vb2xkIGVtYWlsIHJlZ2V4XG4vLyBjb25zdCBlbWFpbFJlZ2V4ID0gL14oKFtePD4oKVtcXF0uLDs6XFxzQFwiXSsoXFwuW148PigpW1xcXS4sOzpcXHNAXCJdKykqKXwoXCIuK1wiKSlAKCg/IS0pKFtePD4oKVtcXF0uLDs6XFxzQFwiXStcXC4pK1tePD4oKVtcXF0uLDs6XFxzQFwiXXsxLH0pW14tPD4oKVtcXF0uLDs6XFxzQFwiXSQvaTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuLy8gY29uc3QgZW1haWxSZWdleCA9XG4vLyAgIC9eKChbXjw+KClbXFxdXFxcXC4sOzpcXHNAXFxcIl0rKFxcLltePD4oKVtcXF1cXFxcLiw7Olxcc0BcXFwiXSspKil8KFxcXCIuK1xcXCIpKUAoKFxcWygoKDI1WzAtNV0pfCgyWzAtNF1bMC05XSl8KDFbMC05XXsyfSl8KFswLTldezEsMn0pKVxcLil7M30oKDI1WzAtNV0pfCgyWzAtNF1bMC05XSl8KDFbMC05XXsyfSl8KFswLTldezEsMn0pKVxcXSl8KFxcW0lQdjY6KChbYS1mMC05XXsxLDR9Oil7N318OjooW2EtZjAtOV17MSw0fTopezAsNn18KFthLWYwLTldezEsNH06KXsxfTooW2EtZjAtOV17MSw0fTopezAsNX18KFthLWYwLTldezEsNH06KXsyfTooW2EtZjAtOV17MSw0fTopezAsNH18KFthLWYwLTldezEsNH06KXszfTooW2EtZjAtOV17MSw0fTopezAsM318KFthLWYwLTldezEsNH06KXs0fTooW2EtZjAtOV17MSw0fTopezAsMn18KFthLWYwLTldezEsNH06KXs1fTooW2EtZjAtOV17MSw0fTopezAsMX0pKFthLWYwLTldezEsNH18KCgoMjVbMC01XSl8KDJbMC00XVswLTldKXwoMVswLTldezJ9KXwoWzAtOV17MSwyfSkpXFwuKXszfSgoMjVbMC01XSl8KDJbMC00XVswLTldKXwoMVswLTldezJ9KXwoWzAtOV17MSwyfSkpKVxcXSl8KFtBLVphLXowLTldKFtBLVphLXowLTktXSpbQS1aYS16MC05XSkqKFxcLltBLVphLXpdezIsfSkrKSkkLztcbi8vIGNvbnN0IGVtYWlsUmVnZXggPVxuLy8gICAvXlthLXpBLVowLTlcXC5cXCFcXCNcXCRcXCVcXCZcXCdcXCpcXCtcXC9cXD1cXD9cXF5cXF9cXGBcXHtcXHxcXH1cXH5cXC1dK0BbYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8oPzpcXC5bYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8pKiQvO1xuLy8gY29uc3QgZW1haWxSZWdleCA9XG4vLyAgIC9eKD86W2EtejAtOSEjJCUmJyorLz0/Xl9ge3x9fi1dKyg/OlxcLlthLXowLTkhIyQlJicqKy89P15fYHt8fX4tXSspKnxcIig/OltcXHgwMS1cXHgwOFxceDBiXFx4MGNcXHgwZS1cXHgxZlxceDIxXFx4MjMtXFx4NWJcXHg1ZC1cXHg3Zl18XFxcXFtcXHgwMS1cXHgwOVxceDBiXFx4MGNcXHgwZS1cXHg3Zl0pKlwiKUAoPzooPzpbYS16MC05XSg/OlthLXowLTktXSpbYS16MC05XSk/XFwuKStbYS16MC05XSg/OlthLXowLTktXSpbYS16MC05XSk/fFxcWyg/Oig/OjI1WzAtNV18MlswLTRdWzAtOV18WzAxXT9bMC05XVswLTldPylcXC4pezN9KD86MjVbMC01XXwyWzAtNF1bMC05XXxbMDFdP1swLTldWzAtOV0/fFthLXowLTktXSpbYS16MC05XTooPzpbXFx4MDEtXFx4MDhcXHgwYlxceDBjXFx4MGUtXFx4MWZcXHgyMS1cXHg1YVxceDUzLVxceDdmXXxcXFxcW1xceDAxLVxceDA5XFx4MGJcXHgwY1xceDBlLVxceDdmXSkrKVxcXSkkL2k7XG5jb25zdCBlbWFpbFJlZ2V4ID0gL14oPyFcXC4pKD8hLipcXC5cXC4pKFtBLVowLTlfJytcXC1cXC5dKilbQS1aMC05XystXUAoW0EtWjAtOV1bQS1aMC05XFwtXSpcXC4pK1tBLVpdezIsfSQvaTtcbi8vIGNvbnN0IGVtYWlsUmVnZXggPVxuLy8gICAvXlthLXowLTkuISMkJSbigJkqKy89P15fYHt8fX4tXStAW2EtejAtOS1dKyg/OlxcLlthLXowLTlcXC1dKykqJC9pO1xuLy8gZnJvbSBodHRwczovL3RoZWtldmluc2NvdHQuY29tL2Vtb2ppcy1pbi1qYXZhc2NyaXB0LyN3cml0aW5nLWEtcmVndWxhci1leHByZXNzaW9uXG5jb25zdCBfZW1vamlSZWdleCA9IGBeKFxcXFxwe0V4dGVuZGVkX1BpY3RvZ3JhcGhpY318XFxcXHB7RW1vamlfQ29tcG9uZW50fSkrJGA7XG5sZXQgZW1vamlSZWdleDtcbi8vIGZhc3Rlciwgc2ltcGxlciwgc2FmZXJcbmNvbnN0IGlwdjRSZWdleCA9IC9eKD86KD86MjVbMC01XXwyWzAtNF1bMC05XXwxWzAtOV1bMC05XXxbMS05XVswLTldfFswLTldKVxcLil7M30oPzoyNVswLTVdfDJbMC00XVswLTldfDFbMC05XVswLTldfFsxLTldWzAtOV18WzAtOV0pJC87XG5jb25zdCBpcHY0Q2lkclJlZ2V4ID0gL14oPzooPzoyNVswLTVdfDJbMC00XVswLTldfDFbMC05XVswLTldfFsxLTldWzAtOV18WzAtOV0pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdWzAtOV18MVswLTldWzAtOV18WzEtOV1bMC05XXxbMC05XSlcXC8oM1swLTJdfFsxMl0/WzAtOV0pJC87XG4vLyBjb25zdCBpcHY2UmVnZXggPVxuLy8gL14oKFthLWYwLTldezEsNH06KXs3fXw6OihbYS1mMC05XXsxLDR9Oil7MCw2fXwoW2EtZjAtOV17MSw0fTopezF9OihbYS1mMC05XXsxLDR9Oil7MCw1fXwoW2EtZjAtOV17MSw0fTopezJ9OihbYS1mMC05XXsxLDR9Oil7MCw0fXwoW2EtZjAtOV17MSw0fTopezN9OihbYS1mMC05XXsxLDR9Oil7MCwzfXwoW2EtZjAtOV17MSw0fTopezR9OihbYS1mMC05XXsxLDR9Oil7MCwyfXwoW2EtZjAtOV17MSw0fTopezV9OihbYS1mMC05XXsxLDR9Oil7MCwxfSkoW2EtZjAtOV17MSw0fXwoKCgyNVswLTVdKXwoMlswLTRdWzAtOV0pfCgxWzAtOV17Mn0pfChbMC05XXsxLDJ9KSlcXC4pezN9KCgyNVswLTVdKXwoMlswLTRdWzAtOV0pfCgxWzAtOV17Mn0pfChbMC05XXsxLDJ9KSkpJC87XG5jb25zdCBpcHY2UmVnZXggPSAvXigoWzAtOWEtZkEtRl17MSw0fTopezcsN31bMC05YS1mQS1GXXsxLDR9fChbMC05YS1mQS1GXXsxLDR9Oil7MSw3fTp8KFswLTlhLWZBLUZdezEsNH06KXsxLDZ9OlswLTlhLWZBLUZdezEsNH18KFswLTlhLWZBLUZdezEsNH06KXsxLDV9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDJ9fChbMC05YS1mQS1GXXsxLDR9Oil7MSw0fSg6WzAtOWEtZkEtRl17MSw0fSl7MSwzfXwoWzAtOWEtZkEtRl17MSw0fTopezEsM30oOlswLTlhLWZBLUZdezEsNH0pezEsNH18KFswLTlhLWZBLUZdezEsNH06KXsxLDJ9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDV9fFswLTlhLWZBLUZdezEsNH06KCg6WzAtOWEtZkEtRl17MSw0fSl7MSw2fSl8OigoOlswLTlhLWZBLUZdezEsNH0pezEsN318Oil8ZmU4MDooOlswLTlhLWZBLUZdezAsNH0pezAsNH0lWzAtOWEtekEtWl17MSx9fDo6KGZmZmYoOjB7MSw0fSl7MCwxfTopezAsMX0oKDI1WzAtNV18KDJbMC00XXwxezAsMX1bMC05XSl7MCwxfVswLTldKVxcLil7MywzfSgyNVswLTVdfCgyWzAtNF18MXswLDF9WzAtOV0pezAsMX1bMC05XSl8KFswLTlhLWZBLUZdezEsNH06KXsxLDR9OigoMjVbMC01XXwoMlswLTRdfDF7MCwxfVswLTldKXswLDF9WzAtOV0pXFwuKXszLDN9KDI1WzAtNV18KDJbMC00XXwxezAsMX1bMC05XSl7MCwxfVswLTldKSkkLztcbmNvbnN0IGlwdjZDaWRyUmVnZXggPSAvXigoWzAtOWEtZkEtRl17MSw0fTopezcsN31bMC05YS1mQS1GXXsxLDR9fChbMC05YS1mQS1GXXsxLDR9Oil7MSw3fTp8KFswLTlhLWZBLUZdezEsNH06KXsxLDZ9OlswLTlhLWZBLUZdezEsNH18KFswLTlhLWZBLUZdezEsNH06KXsxLDV9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDJ9fChbMC05YS1mQS1GXXsxLDR9Oil7MSw0fSg6WzAtOWEtZkEtRl17MSw0fSl7MSwzfXwoWzAtOWEtZkEtRl17MSw0fTopezEsM30oOlswLTlhLWZBLUZdezEsNH0pezEsNH18KFswLTlhLWZBLUZdezEsNH06KXsxLDJ9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDV9fFswLTlhLWZBLUZdezEsNH06KCg6WzAtOWEtZkEtRl17MSw0fSl7MSw2fSl8OigoOlswLTlhLWZBLUZdezEsNH0pezEsN318Oil8ZmU4MDooOlswLTlhLWZBLUZdezAsNH0pezAsNH0lWzAtOWEtekEtWl17MSx9fDo6KGZmZmYoOjB7MSw0fSl7MCwxfTopezAsMX0oKDI1WzAtNV18KDJbMC00XXwxezAsMX1bMC05XSl7MCwxfVswLTldKVxcLil7MywzfSgyNVswLTVdfCgyWzAtNF18MXswLDF9WzAtOV0pezAsMX1bMC05XSl8KFswLTlhLWZBLUZdezEsNH06KXsxLDR9OigoMjVbMC01XXwoMlswLTRdfDF7MCwxfVswLTldKXswLDF9WzAtOV0pXFwuKXszLDN9KDI1WzAtNV18KDJbMC00XXwxezAsMX1bMC05XSl7MCwxfVswLTldKSlcXC8oMTJbMC04XXwxWzAxXVswLTldfFsxLTldP1swLTldKSQvO1xuLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNzg2MDM5Mi9kZXRlcm1pbmUtaWYtc3RyaW5nLWlzLWluLWJhc2U2NC11c2luZy1qYXZhc2NyaXB0XG5jb25zdCBiYXNlNjRSZWdleCA9IC9eKFswLTlhLXpBLVorL117NH0pKigoWzAtOWEtekEtWisvXXsyfT09KXwoWzAtOWEtekEtWisvXXszfT0pKT8kLztcbi8vIGh0dHBzOi8vYmFzZTY0Lmd1cnUvc3RhbmRhcmRzL2Jhc2U2NHVybFxuY29uc3QgYmFzZTY0dXJsUmVnZXggPSAvXihbMC05YS16QS1aLV9dezR9KSooKFswLTlhLXpBLVotX117Mn0oPT0pPyl8KFswLTlhLXpBLVotX117M30oPSk/KSk/JC87XG4vLyBzaW1wbGVcbi8vIGNvbnN0IGRhdGVSZWdleFNvdXJjZSA9IGBcXFxcZHs0fS1cXFxcZHsyfS1cXFxcZHsyfWA7XG4vLyBubyBsZWFwIHllYXIgdmFsaWRhdGlvblxuLy8gY29uc3QgZGF0ZVJlZ2V4U291cmNlID0gYFxcXFxkezR9LSgoMFsxMzU3OF18MTB8MTIpLTMxfCgwWzEzLTldfDFbMC0yXSktMzB8KDBbMS05XXwxWzAtMl0pLSgwWzEtOV18MVxcXFxkfDJcXFxcZCkpYDtcbi8vIHdpdGggbGVhcCB5ZWFyIHZhbGlkYXRpb25cbmNvbnN0IGRhdGVSZWdleFNvdXJjZSA9IGAoKFxcXFxkXFxcXGRbMjQ2OF1bMDQ4XXxcXFxcZFxcXFxkWzEzNTc5XVsyNl18XFxcXGRcXFxcZDBbNDhdfFswMjQ2OF1bMDQ4XTAwfFsxMzU3OV1bMjZdMDApLTAyLTI5fFxcXFxkezR9LSgoMFsxMzU3OF18MVswMl0pLSgwWzEtOV18WzEyXVxcXFxkfDNbMDFdKXwoMFs0NjldfDExKS0oMFsxLTldfFsxMl1cXFxcZHwzMCl8KDAyKS0oMFsxLTldfDFcXFxcZHwyWzAtOF0pKSlgO1xuY29uc3QgZGF0ZVJlZ2V4ID0gbmV3IFJlZ0V4cChgXiR7ZGF0ZVJlZ2V4U291cmNlfSRgKTtcbmZ1bmN0aW9uIHRpbWVSZWdleFNvdXJjZShhcmdzKSB7XG4gICAgbGV0IHNlY29uZHNSZWdleFNvdXJjZSA9IGBbMC01XVxcXFxkYDtcbiAgICBpZiAoYXJncy5wcmVjaXNpb24pIHtcbiAgICAgICAgc2Vjb25kc1JlZ2V4U291cmNlID0gYCR7c2Vjb25kc1JlZ2V4U291cmNlfVxcXFwuXFxcXGR7JHthcmdzLnByZWNpc2lvbn19YDtcbiAgICB9XG4gICAgZWxzZSBpZiAoYXJncy5wcmVjaXNpb24gPT0gbnVsbCkge1xuICAgICAgICBzZWNvbmRzUmVnZXhTb3VyY2UgPSBgJHtzZWNvbmRzUmVnZXhTb3VyY2V9KFxcXFwuXFxcXGQrKT9gO1xuICAgIH1cbiAgICBjb25zdCBzZWNvbmRzUXVhbnRpZmllciA9IGFyZ3MucHJlY2lzaW9uID8gXCIrXCIgOiBcIj9cIjsgLy8gcmVxdWlyZSBzZWNvbmRzIGlmIHByZWNpc2lvbiBpcyBub256ZXJvXG4gICAgcmV0dXJuIGAoWzAxXVxcXFxkfDJbMC0zXSk6WzAtNV1cXFxcZCg6JHtzZWNvbmRzUmVnZXhTb3VyY2V9KSR7c2Vjb25kc1F1YW50aWZpZXJ9YDtcbn1cbmZ1bmN0aW9uIHRpbWVSZWdleChhcmdzKSB7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoYF4ke3RpbWVSZWdleFNvdXJjZShhcmdzKX0kYCk7XG59XG4vLyBBZGFwdGVkIGZyb20gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzMxNDMyMzFcbmZ1bmN0aW9uIGRhdGV0aW1lUmVnZXgoYXJncykge1xuICAgIGxldCByZWdleCA9IGAke2RhdGVSZWdleFNvdXJjZX1UJHt0aW1lUmVnZXhTb3VyY2UoYXJncyl9YDtcbiAgICBjb25zdCBvcHRzID0gW107XG4gICAgb3B0cy5wdXNoKGFyZ3MubG9jYWwgPyBgWj9gIDogYFpgKTtcbiAgICBpZiAoYXJncy5vZmZzZXQpXG4gICAgICAgIG9wdHMucHVzaChgKFsrLV1cXFxcZHsyfTo/XFxcXGR7Mn0pYCk7XG4gICAgcmVnZXggPSBgJHtyZWdleH0oJHtvcHRzLmpvaW4oXCJ8XCIpfSlgO1xuICAgIHJldHVybiBuZXcgUmVnRXhwKGBeJHtyZWdleH0kYCk7XG59XG5mdW5jdGlvbiBpc1ZhbGlkSVAoaXAsIHZlcnNpb24pIHtcbiAgICBpZiAoKHZlcnNpb24gPT09IFwidjRcIiB8fCAhdmVyc2lvbikgJiYgaXB2NFJlZ2V4LnRlc3QoaXApKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoKHZlcnNpb24gPT09IFwidjZcIiB8fCAhdmVyc2lvbikgJiYgaXB2NlJlZ2V4LnRlc3QoaXApKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc1ZhbGlkSldUKGp3dCwgYWxnKSB7XG4gICAgaWYgKCFqd3RSZWdleC50ZXN0KGp3dCkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBbaGVhZGVyXSA9IGp3dC5zcGxpdChcIi5cIik7XG4gICAgICAgIGlmICghaGVhZGVyKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAvLyBDb252ZXJ0IGJhc2U2NHVybCB0byBiYXNlNjRcbiAgICAgICAgY29uc3QgYmFzZTY0ID0gaGVhZGVyXG4gICAgICAgICAgICAucmVwbGFjZSgvLS9nLCBcIitcIilcbiAgICAgICAgICAgIC5yZXBsYWNlKC9fL2csIFwiL1wiKVxuICAgICAgICAgICAgLnBhZEVuZChoZWFkZXIubGVuZ3RoICsgKCg0IC0gKGhlYWRlci5sZW5ndGggJSA0KSkgJSA0KSwgXCI9XCIpO1xuICAgICAgICBjb25zdCBkZWNvZGVkID0gSlNPTi5wYXJzZShhdG9iKGJhc2U2NCkpO1xuICAgICAgICBpZiAodHlwZW9mIGRlY29kZWQgIT09IFwib2JqZWN0XCIgfHwgZGVjb2RlZCA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKFwidHlwXCIgaW4gZGVjb2RlZCAmJiBkZWNvZGVkPy50eXAgIT09IFwiSldUXCIpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICghZGVjb2RlZC5hbGcpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChhbGcgJiYgZGVjb2RlZC5hbGcgIT09IGFsZylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzVmFsaWRDaWRyKGlwLCB2ZXJzaW9uKSB7XG4gICAgaWYgKCh2ZXJzaW9uID09PSBcInY0XCIgfHwgIXZlcnNpb24pICYmIGlwdjRDaWRyUmVnZXgudGVzdChpcCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICgodmVyc2lvbiA9PT0gXCJ2NlwiIHx8ICF2ZXJzaW9uKSAmJiBpcHY2Q2lkclJlZ2V4LnRlc3QoaXApKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5jbGFzcyBab2RTdHJpbmcgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RlZi5jb2VyY2UpIHtcbiAgICAgICAgICAgIGlucHV0LmRhdGEgPSBTdHJpbmcoaW5wdXQuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gdXRpbF9qc18xLlpvZFBhcnNlZFR5cGUuc3RyaW5nKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICAoMCwgcGFyc2VVdGlsX2pzXzEuYWRkSXNzdWVUb0NvbnRleHQpKGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZEVycm9yX2pzXzEuWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogdXRpbF9qc18xLlpvZFBhcnNlZFR5cGUuc3RyaW5nLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlVXRpbF9qc18xLklOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhdHVzID0gbmV3IHBhcnNlVXRpbF9qc18xLlBhcnNlU3RhdHVzKCk7XG4gICAgICAgIGxldCBjdHggPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3QgY2hlY2sgb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoZWNrLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuZGF0YS5sZW5ndGggPCBjaGVjay52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgKDAsIHBhcnNlVXRpbF9qc18xLmFkZElzc3VlVG9Db250ZXh0KShjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZEVycm9yX2pzXzEuWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbmltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmRhdGEubGVuZ3RoID4gY2hlY2sudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgICgwLCBwYXJzZVV0aWxfanNfMS5hZGRJc3N1ZVRvQ29udGV4dCkoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RFcnJvcl9qc18xLlpvZElzc3VlQ29kZS50b29fYmlnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4aW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwibGVuZ3RoXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b29CaWcgPSBpbnB1dC5kYXRhLmxlbmd0aCA+IGNoZWNrLnZhbHVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvb1NtYWxsID0gaW5wdXQuZGF0YS5sZW5ndGggPCBjaGVjay52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAodG9vQmlnIHx8IHRvb1NtYWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9vQmlnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgcGFyc2VVdGlsX2pzXzEuYWRkSXNzdWVUb0NvbnRleHQpKGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZEVycm9yX2pzXzEuWm9kSXNzdWVDb2RlLnRvb19iaWcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4aW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRvb1NtYWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgcGFyc2VVdGlsX2pzXzEuYWRkSXNzdWVUb0NvbnRleHQpKGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZEVycm9yX2pzXzEuWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5pbXVtOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGFjdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJlbWFpbFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFlbWFpbFJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgICgwLCBwYXJzZVV0aWxfanNfMS5hZGRJc3N1ZVRvQ29udGV4dCkoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImVtYWlsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RFcnJvcl9qc18xLlpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImVtb2ppXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWVtb2ppUmVnZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgZW1vamlSZWdleCA9IG5ldyBSZWdFeHAoX2Vtb2ppUmVnZXgsIFwidVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFlbW9qaVJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgICgwLCBwYXJzZVV0aWxfanNfMS5hZGRJc3N1ZVRvQ29udGV4dCkoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImVtb2ppXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RFcnJvcl9qc18xLlpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInV1aWRcIikge1xuICAgICAgICAgICAgICAgIGlmICghdXVpZFJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgICgwLCBwYXJzZVV0aWxfanNfMS5hZGRJc3N1ZVRvQ29udGV4dCkoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcInV1aWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZEVycm9yX2pzXzEuWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwibmFub2lkXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW5hbm9pZFJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgICgwLCBwYXJzZVV0aWxfanNfMS5hZGRJc3N1ZVRvQ29udGV4dCkoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcIm5hbm9pZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kRXJyb3JfanNfMS5ab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJjdWlkXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWN1aWRSZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICAoMCwgcGFyc2VVdGlsX2pzXzEuYWRkSXNzdWVUb0NvbnRleHQpKGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJjdWlkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RFcnJvcl9qc18xLlpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImN1aWQyXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWN1aWQyUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgKDAsIHBhcnNlVXRpbF9qc18xLmFkZElzc3VlVG9Db250ZXh0KShjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiY3VpZDJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZEVycm9yX2pzXzEuWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwidWxpZFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF1bGlkUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgKDAsIHBhcnNlVXRpbF9qc18xLmFkZElzc3VlVG9Db250ZXh0KShjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwidWxpZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kRXJyb3JfanNfMS5ab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ1cmxcIikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIG5ldyBVUkwoaW5wdXQuZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgICgwLCBwYXJzZVV0aWxfanNfMS5hZGRJc3N1ZVRvQ29udGV4dCkoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcInVybFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kRXJyb3JfanNfMS5ab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJyZWdleFwiKSB7XG4gICAgICAgICAgICAgICAgY2hlY2sucmVnZXgubGFzdEluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXN0UmVzdWx0ID0gY2hlY2sucmVnZXgudGVzdChpbnB1dC5kYXRhKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRlc3RSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgICgwLCBwYXJzZVV0aWxfanNfMS5hZGRJc3N1ZVRvQ29udGV4dCkoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcInJlZ2V4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RFcnJvcl9qc18xLlpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInRyaW1cIikge1xuICAgICAgICAgICAgICAgIGlucHV0LmRhdGEgPSBpbnB1dC5kYXRhLnRyaW0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiaW5jbHVkZXNcIikge1xuICAgICAgICAgICAgICAgIGlmICghaW5wdXQuZGF0YS5pbmNsdWRlcyhjaGVjay52YWx1ZSwgY2hlY2sucG9zaXRpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICAoMCwgcGFyc2VVdGlsX2pzXzEuYWRkSXNzdWVUb0NvbnRleHQpKGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kRXJyb3JfanNfMS5ab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiB7IGluY2x1ZGVzOiBjaGVjay52YWx1ZSwgcG9zaXRpb246IGNoZWNrLnBvc2l0aW9uIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ0b0xvd2VyQ2FzZVwiKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQuZGF0YSA9IGlucHV0LmRhdGEudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwidG9VcHBlckNhc2VcIikge1xuICAgICAgICAgICAgICAgIGlucHV0LmRhdGEgPSBpbnB1dC5kYXRhLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInN0YXJ0c1dpdGhcIikge1xuICAgICAgICAgICAgICAgIGlmICghaW5wdXQuZGF0YS5zdGFydHNXaXRoKGNoZWNrLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgKDAsIHBhcnNlVXRpbF9qc18xLmFkZElzc3VlVG9Db250ZXh0KShjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZEVycm9yX2pzXzEuWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogeyBzdGFydHNXaXRoOiBjaGVjay52YWx1ZSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiZW5kc1dpdGhcIikge1xuICAgICAgICAgICAgICAgIGlmICghaW5wdXQuZGF0YS5lbmRzV2l0aChjaGVjay52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgICgwLCBwYXJzZVV0aWxfanNfMS5hZGRJc3N1ZVRvQ29udGV4dCkoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RFcnJvcl9qc18xLlpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IHsgZW5kc1dpdGg6IGNoZWNrLnZhbHVlIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJkYXRldGltZVwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVnZXggPSBkYXRldGltZVJlZ2V4KGNoZWNrKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgICgwLCBwYXJzZVV0aWxfanNfMS5hZGRJc3N1ZVRvQ29udGV4dCkoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RFcnJvcl9qc18xLlpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiZGF0ZXRpbWVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImRhdGVcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZ2V4ID0gZGF0ZVJlZ2V4O1xuICAgICAgICAgICAgICAgIGlmICghcmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgKDAsIHBhcnNlVXRpbF9qc18xLmFkZElzc3VlVG9Db250ZXh0KShjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZEVycm9yX2pzXzEuWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJkYXRlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ0aW1lXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWdleCA9IHRpbWVSZWdleChjaGVjayk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICAoMCwgcGFyc2VVdGlsX2pzXzEuYWRkSXNzdWVUb0NvbnRleHQpKGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kRXJyb3JfanNfMS5ab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcInRpbWVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImR1cmF0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWR1cmF0aW9uUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgKDAsIHBhcnNlVXRpbF9qc18xLmFkZElzc3VlVG9Db250ZXh0KShjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiZHVyYXRpb25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZEVycm9yX2pzXzEuWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiaXBcIikge1xuICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZElQKGlucHV0LmRhdGEsIGNoZWNrLnZlcnNpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICAoMCwgcGFyc2VVdGlsX2pzXzEuYWRkSXNzdWVUb0NvbnRleHQpKGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJpcFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kRXJyb3JfanNfMS5ab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJqd3RcIikge1xuICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZEpXVChpbnB1dC5kYXRhLCBjaGVjay5hbGcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICAoMCwgcGFyc2VVdGlsX2pzXzEuYWRkSXNzdWVUb0NvbnRleHQpKGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJqd3RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZEVycm9yX2pzXzEuWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiY2lkclwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkQ2lkcihpbnB1dC5kYXRhLCBjaGVjay52ZXJzaW9uKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgKDAsIHBhcnNlVXRpbF9qc18xLmFkZElzc3VlVG9Db250ZXh0KShjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiY2lkclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kRXJyb3JfanNfMS5ab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJiYXNlNjRcIikge1xuICAgICAgICAgICAgICAgIGlmICghYmFzZTY0UmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgKDAsIHBhcnNlVXRpbF9qc18xLmFkZElzc3VlVG9Db250ZXh0KShjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiYmFzZTY0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RFcnJvcl9qc18xLlpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImJhc2U2NHVybFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFiYXNlNjR1cmxSZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICAoMCwgcGFyc2VVdGlsX2pzXzEuYWRkSXNzdWVUb0NvbnRleHQpKGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJiYXNlNjR1cmxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZEVycm9yX2pzXzEuWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHV0aWxfanNfMS51dGlsLmFzc2VydE5ldmVyKGNoZWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGlucHV0LmRhdGEgfTtcbiAgICB9XG4gICAgX3JlZ2V4KHJlZ2V4LCB2YWxpZGF0aW9uLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZmluZW1lbnQoKGRhdGEpID0+IHJlZ2V4LnRlc3QoZGF0YSksIHtcbiAgICAgICAgICAgIHZhbGlkYXRpb24sXG4gICAgICAgICAgICBjb2RlOiBab2RFcnJvcl9qc18xLlpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgIC4uLmVycm9yVXRpbF9qc18xLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9hZGRDaGVjayhjaGVjaykge1xuICAgICAgICByZXR1cm4gbmV3IFpvZFN0cmluZyh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBjaGVja3M6IFsuLi50aGlzLl9kZWYuY2hlY2tzLCBjaGVja10sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbWFpbChtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiZW1haWxcIiwgLi4uZXJyb3JVdGlsX2pzXzEuZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICAgIH1cbiAgICB1cmwobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcInVybFwiLCAuLi5lcnJvclV0aWxfanNfMS5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkgfSk7XG4gICAgfVxuICAgIGVtb2ppKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJlbW9qaVwiLCAuLi5lcnJvclV0aWxfanNfMS5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkgfSk7XG4gICAgfVxuICAgIHV1aWQobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcInV1aWRcIiwgLi4uZXJyb3JVdGlsX2pzXzEuZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICAgIH1cbiAgICBuYW5vaWQobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcIm5hbm9pZFwiLCAuLi5lcnJvclV0aWxfanNfMS5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkgfSk7XG4gICAgfVxuICAgIGN1aWQobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImN1aWRcIiwgLi4uZXJyb3JVdGlsX2pzXzEuZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICAgIH1cbiAgICBjdWlkMihtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiY3VpZDJcIiwgLi4uZXJyb3JVdGlsX2pzXzEuZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICAgIH1cbiAgICB1bGlkKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJ1bGlkXCIsIC4uLmVycm9yVXRpbF9qc18xLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgICB9XG4gICAgYmFzZTY0KG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJiYXNlNjRcIiwgLi4uZXJyb3JVdGlsX2pzXzEuZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICAgIH1cbiAgICBiYXNlNjR1cmwobWVzc2FnZSkge1xuICAgICAgICAvLyBiYXNlNjR1cmwgZW5jb2RpbmcgaXMgYSBtb2RpZmljYXRpb24gb2YgYmFzZTY0IHRoYXQgY2FuIHNhZmVseSBiZSB1c2VkIGluIFVSTHMgYW5kIGZpbGVuYW1lc1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJiYXNlNjR1cmxcIixcbiAgICAgICAgICAgIC4uLmVycm9yVXRpbF9qc18xLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGp3dChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiand0XCIsIC4uLmVycm9yVXRpbF9qc18xLmVycm9yVXRpbC5lcnJUb09iaihvcHRpb25zKSB9KTtcbiAgICB9XG4gICAgaXAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImlwXCIsIC4uLmVycm9yVXRpbF9qc18xLmVycm9yVXRpbC5lcnJUb09iaihvcHRpb25zKSB9KTtcbiAgICB9XG4gICAgY2lkcihvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiY2lkclwiLCAuLi5lcnJvclV0aWxfanNfMS5lcnJvclV0aWwuZXJyVG9PYmoob3B0aW9ucykgfSk7XG4gICAgfVxuICAgIGRhdGV0aW1lKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAgICAgIGtpbmQ6IFwiZGF0ZXRpbWVcIixcbiAgICAgICAgICAgICAgICBwcmVjaXNpb246IG51bGwsXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBsb2NhbDogZmFsc2UsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogb3B0aW9ucyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcImRhdGV0aW1lXCIsXG4gICAgICAgICAgICBwcmVjaXNpb246IHR5cGVvZiBvcHRpb25zPy5wcmVjaXNpb24gPT09IFwidW5kZWZpbmVkXCIgPyBudWxsIDogb3B0aW9ucz8ucHJlY2lzaW9uLFxuICAgICAgICAgICAgb2Zmc2V0OiBvcHRpb25zPy5vZmZzZXQgPz8gZmFsc2UsXG4gICAgICAgICAgICBsb2NhbDogb3B0aW9ucz8ubG9jYWwgPz8gZmFsc2UsXG4gICAgICAgICAgICAuLi5lcnJvclV0aWxfanNfMS5lcnJvclV0aWwuZXJyVG9PYmoob3B0aW9ucz8ubWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkYXRlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJkYXRlXCIsIG1lc3NhZ2UgfSk7XG4gICAgfVxuICAgIHRpbWUob3B0aW9ucykge1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICAgICAga2luZDogXCJ0aW1lXCIsXG4gICAgICAgICAgICAgICAgcHJlY2lzaW9uOiBudWxsLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG9wdGlvbnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJ0aW1lXCIsXG4gICAgICAgICAgICBwcmVjaXNpb246IHR5cGVvZiBvcHRpb25zPy5wcmVjaXNpb24gPT09IFwidW5kZWZpbmVkXCIgPyBudWxsIDogb3B0aW9ucz8ucHJlY2lzaW9uLFxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsX2pzXzEuZXJyb3JVdGlsLmVyclRvT2JqKG9wdGlvbnM/Lm1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZHVyYXRpb24obWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImR1cmF0aW9uXCIsIC4uLmVycm9yVXRpbF9qc18xLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgICB9XG4gICAgcmVnZXgocmVnZXgsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwicmVnZXhcIixcbiAgICAgICAgICAgIHJlZ2V4OiByZWdleCxcbiAgICAgICAgICAgIC4uLmVycm9yVXRpbF9qc18xLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGluY2x1ZGVzKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcImluY2x1ZGVzXCIsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBwb3NpdGlvbjogb3B0aW9ucz8ucG9zaXRpb24sXG4gICAgICAgICAgICAuLi5lcnJvclV0aWxfanNfMS5lcnJvclV0aWwuZXJyVG9PYmoob3B0aW9ucz8ubWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGFydHNXaXRoKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcInN0YXJ0c1dpdGhcIixcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIC4uLmVycm9yVXRpbF9qc18xLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVuZHNXaXRoKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcImVuZHNXaXRoXCIsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAuLi5lcnJvclV0aWxfanNfMS5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtaW4obWluTGVuZ3RoLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1pblwiLFxuICAgICAgICAgICAgdmFsdWU6IG1pbkxlbmd0aCxcbiAgICAgICAgICAgIC4uLmVycm9yVXRpbF9qc18xLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG1heChtYXhMZW5ndGgsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWF4XCIsXG4gICAgICAgICAgICB2YWx1ZTogbWF4TGVuZ3RoLFxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsX2pzXzEuZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbGVuZ3RoKGxlbiwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJsZW5ndGhcIixcbiAgICAgICAgICAgIHZhbHVlOiBsZW4sXG4gICAgICAgICAgICAuLi5lcnJvclV0aWxfanNfMS5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFcXVpdmFsZW50IHRvIGAubWluKDEpYFxuICAgICAqL1xuICAgIG5vbmVtcHR5KG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWluKDEsIGVycm9yVXRpbF9qc18xLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSk7XG4gICAgfVxuICAgIHRyaW0oKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kU3RyaW5nKHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGNoZWNrczogWy4uLnRoaXMuX2RlZi5jaGVja3MsIHsga2luZDogXCJ0cmltXCIgfV0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB0b0xvd2VyQ2FzZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RTdHJpbmcoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgeyBraW5kOiBcInRvTG93ZXJDYXNlXCIgfV0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB0b1VwcGVyQ2FzZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RTdHJpbmcoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgeyBraW5kOiBcInRvVXBwZXJDYXNlXCIgfV0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgaXNEYXRldGltZSgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJkYXRldGltZVwiKTtcbiAgICB9XG4gICAgZ2V0IGlzRGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJkYXRlXCIpO1xuICAgIH1cbiAgICBnZXQgaXNUaW1lKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcInRpbWVcIik7XG4gICAgfVxuICAgIGdldCBpc0R1cmF0aW9uKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImR1cmF0aW9uXCIpO1xuICAgIH1cbiAgICBnZXQgaXNFbWFpbCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJlbWFpbFwiKTtcbiAgICB9XG4gICAgZ2V0IGlzVVJMKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcInVybFwiKTtcbiAgICB9XG4gICAgZ2V0IGlzRW1vamkoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiZW1vamlcIik7XG4gICAgfVxuICAgIGdldCBpc1VVSUQoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwidXVpZFwiKTtcbiAgICB9XG4gICAgZ2V0IGlzTkFOT0lEKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcIm5hbm9pZFwiKTtcbiAgICB9XG4gICAgZ2V0IGlzQ1VJRCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJjdWlkXCIpO1xuICAgIH1cbiAgICBnZXQgaXNDVUlEMigpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJjdWlkMlwiKTtcbiAgICB9XG4gICAgZ2V0IGlzVUxJRCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJ1bGlkXCIpO1xuICAgIH1cbiAgICBnZXQgaXNJUCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJpcFwiKTtcbiAgICB9XG4gICAgZ2V0IGlzQ0lEUigpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJjaWRyXCIpO1xuICAgIH1cbiAgICBnZXQgaXNCYXNlNjQoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiYmFzZTY0XCIpO1xuICAgIH1cbiAgICBnZXQgaXNCYXNlNjR1cmwoKSB7XG4gICAgICAgIC8vIGJhc2U2NHVybCBlbmNvZGluZyBpcyBhIG1vZGlmaWNhdGlvbiBvZiBiYXNlNjQgdGhhdCBjYW4gc2FmZWx5IGJlIHVzZWQgaW4gVVJMcyBhbmQgZmlsZW5hbWVzXG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiYmFzZTY0dXJsXCIpO1xuICAgIH1cbiAgICBnZXQgbWluTGVuZ3RoKCkge1xuICAgICAgICBsZXQgbWluID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICAgICAgICAgIGlmIChtaW4gPT09IG51bGwgfHwgY2gudmFsdWUgPiBtaW4pXG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IGNoLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtaW47XG4gICAgfVxuICAgIGdldCBtYXhMZW5ndGgoKSB7XG4gICAgICAgIGxldCBtYXggPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaC5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1heCA9PT0gbnVsbCB8fCBjaC52YWx1ZSA8IG1heClcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gY2gudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1heDtcbiAgICB9XG59XG5leHBvcnRzLlpvZFN0cmluZyA9IFpvZFN0cmluZztcblpvZFN0cmluZy5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RTdHJpbmcoe1xuICAgICAgICBjaGVja3M6IFtdLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFN0cmluZyxcbiAgICAgICAgY29lcmNlOiBwYXJhbXM/LmNvZXJjZSA/PyBmYWxzZSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbi8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzM5NjY0ODQvd2h5LWRvZXMtbW9kdWx1cy1vcGVyYXRvci1yZXR1cm4tZnJhY3Rpb25hbC1udW1iZXItaW4tamF2YXNjcmlwdC8zMTcxMTAzNCMzMTcxMTAzNFxuZnVuY3Rpb24gZmxvYXRTYWZlUmVtYWluZGVyKHZhbCwgc3RlcCkge1xuICAgIGNvbnN0IHZhbERlY0NvdW50ID0gKHZhbC50b1N0cmluZygpLnNwbGl0KFwiLlwiKVsxXSB8fCBcIlwiKS5sZW5ndGg7XG4gICAgY29uc3Qgc3RlcERlY0NvdW50ID0gKHN0ZXAudG9TdHJpbmcoKS5zcGxpdChcIi5cIilbMV0gfHwgXCJcIikubGVuZ3RoO1xuICAgIGNvbnN0IGRlY0NvdW50ID0gdmFsRGVjQ291bnQgPiBzdGVwRGVjQ291bnQgPyB2YWxEZWNDb3VudCA6IHN0ZXBEZWNDb3VudDtcbiAgICBjb25zdCB2YWxJbnQgPSBOdW1iZXIucGFyc2VJbnQodmFsLnRvRml4ZWQoZGVjQ291bnQpLnJlcGxhY2UoXCIuXCIsIFwiXCIpKTtcbiAgICBjb25zdCBzdGVwSW50ID0gTnVtYmVyLnBhcnNlSW50KHN0ZXAudG9GaXhlZChkZWNDb3VudCkucmVwbGFjZShcIi5cIiwgXCJcIikpO1xuICAgIHJldHVybiAodmFsSW50ICUgc3RlcEludCkgLyAxMCAqKiBkZWNDb3VudDtcbn1cbmNsYXNzIFpvZE51bWJlciBleHRlbmRzIFpvZFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm1pbiA9IHRoaXMuZ3RlO1xuICAgICAgICB0aGlzLm1heCA9IHRoaXMubHRlO1xuICAgICAgICB0aGlzLnN0ZXAgPSB0aGlzLm11bHRpcGxlT2Y7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBpZiAodGhpcy5fZGVmLmNvZXJjZSkge1xuICAgICAgICAgICAgaW5wdXQuZGF0YSA9IE51bWJlcihpbnB1dC5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSB1dGlsX2pzXzEuWm9kUGFyc2VkVHlwZS5udW1iZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgICgwLCBwYXJzZVV0aWxfanNfMS5hZGRJc3N1ZVRvQ29udGV4dCkoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kRXJyb3JfanNfMS5ab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiB1dGlsX2pzXzEuWm9kUGFyc2VkVHlwZS5udW1iZXIsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VVdGlsX2pzXzEuSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY3R4ID0gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBzdGF0dXMgPSBuZXcgcGFyc2VVdGlsX2pzXzEuUGFyc2VTdGF0dXMoKTtcbiAgICAgICAgZm9yIChjb25zdCBjaGVjayBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2hlY2sua2luZCA9PT0gXCJpbnRcIikge1xuICAgICAgICAgICAgICAgIGlmICghdXRpbF9qc18xLnV0aWwuaXNJbnRlZ2VyKGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICAoMCwgcGFyc2VVdGlsX2pzXzEuYWRkSXNzdWVUb0NvbnRleHQpKGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kRXJyb3JfanNfMS5ab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFwiaW50ZWdlclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IFwiZmxvYXRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm1pblwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9vU21hbGwgPSBjaGVjay5pbmNsdXNpdmUgPyBpbnB1dC5kYXRhIDwgY2hlY2sudmFsdWUgOiBpbnB1dC5kYXRhIDw9IGNoZWNrLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICh0b29TbWFsbCkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgKDAsIHBhcnNlVXRpbF9qc18xLmFkZElzc3VlVG9Db250ZXh0KShjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZEVycm9yX2pzXzEuWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbmltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogY2hlY2suaW5jbHVzaXZlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwibWF4XCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b29CaWcgPSBjaGVjay5pbmNsdXNpdmUgPyBpbnB1dC5kYXRhID4gY2hlY2sudmFsdWUgOiBpbnB1dC5kYXRhID49IGNoZWNrLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICh0b29CaWcpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgICgwLCBwYXJzZVV0aWxfanNfMS5hZGRJc3N1ZVRvQ29udGV4dCkoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RFcnJvcl9qc18xLlpvZElzc3VlQ29kZS50b29fYmlnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4aW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiBjaGVjay5pbmNsdXNpdmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJtdWx0aXBsZU9mXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmxvYXRTYWZlUmVtYWluZGVyKGlucHV0LmRhdGEsIGNoZWNrLnZhbHVlKSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgKDAsIHBhcnNlVXRpbF9qc18xLmFkZElzc3VlVG9Db250ZXh0KShjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZEVycm9yX2pzXzEuWm9kSXNzdWVDb2RlLm5vdF9tdWx0aXBsZV9vZixcbiAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpcGxlT2Y6IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiZmluaXRlXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgKDAsIHBhcnNlVXRpbF9qc18xLmFkZElzc3VlVG9Db250ZXh0KShjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZEVycm9yX2pzXzEuWm9kSXNzdWVDb2RlLm5vdF9maW5pdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdXRpbF9qc18xLnV0aWwuYXNzZXJ0TmV2ZXIoY2hlY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogaW5wdXQuZGF0YSB9O1xuICAgIH1cbiAgICBndGUodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtaW5cIiwgdmFsdWUsIHRydWUsIGVycm9yVXRpbF9qc18xLmVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSk7XG4gICAgfVxuICAgIGd0KHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWluXCIsIHZhbHVlLCBmYWxzZSwgZXJyb3JVdGlsX2pzXzEuZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpKTtcbiAgICB9XG4gICAgbHRlKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWF4XCIsIHZhbHVlLCB0cnVlLCBlcnJvclV0aWxfanNfMS5lcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xuICAgIH1cbiAgICBsdCh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1heFwiLCB2YWx1ZSwgZmFsc2UsIGVycm9yVXRpbF9qc18xLmVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSk7XG4gICAgfVxuICAgIHNldExpbWl0KGtpbmQsIHZhbHVlLCBpbmNsdXNpdmUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2ROdW1iZXIoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgY2hlY2tzOiBbXG4gICAgICAgICAgICAgICAgLi4udGhpcy5fZGVmLmNoZWNrcyxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGtpbmQsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmUsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbF9qc18xLmVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9hZGRDaGVjayhjaGVjaykge1xuICAgICAgICByZXR1cm4gbmV3IFpvZE51bWJlcih7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBjaGVja3M6IFsuLi50aGlzLl9kZWYuY2hlY2tzLCBjaGVja10sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpbnQobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJpbnRcIixcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbF9qc18xLmVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHBvc2l0aXZlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWluXCIsXG4gICAgICAgICAgICB2YWx1ZTogMCxcbiAgICAgICAgICAgIGluY2x1c2l2ZTogZmFsc2UsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWxfanNfMS5lcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBuZWdhdGl2ZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1heFwiLFxuICAgICAgICAgICAgdmFsdWU6IDAsXG4gICAgICAgICAgICBpbmNsdXNpdmU6IGZhbHNlLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsX2pzXzEuZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbm9ucG9zaXRpdmUobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtYXhcIixcbiAgICAgICAgICAgIHZhbHVlOiAwLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsX2pzXzEuZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbm9ubmVnYXRpdmUobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtaW5cIixcbiAgICAgICAgICAgIHZhbHVlOiAwLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsX2pzXzEuZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbXVsdGlwbGVPZih2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtdWx0aXBsZU9mXCIsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWxfanNfMS5lcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmaW5pdGUobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJmaW5pdGVcIixcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbF9qc18xLmVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNhZmUobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtaW5cIixcbiAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUixcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbF9qc18xLmVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSkuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWF4XCIsXG4gICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWxfanNfMS5lcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgbWluVmFsdWUoKSB7XG4gICAgICAgIGxldCBtaW4gPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaC5raW5kID09PSBcIm1pblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1pbiA9PT0gbnVsbCB8fCBjaC52YWx1ZSA+IG1pbilcbiAgICAgICAgICAgICAgICAgICAgbWluID0gY2gudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1pbjtcbiAgICB9XG4gICAgZ2V0IG1heFZhbHVlKCkge1xuICAgICAgICBsZXQgbWF4ID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJtYXhcIikge1xuICAgICAgICAgICAgICAgIGlmIChtYXggPT09IG51bGwgfHwgY2gudmFsdWUgPCBtYXgpXG4gICAgICAgICAgICAgICAgICAgIG1heCA9IGNoLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXg7XG4gICAgfVxuICAgIGdldCBpc0ludCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJpbnRcIiB8fCAoY2gua2luZCA9PT0gXCJtdWx0aXBsZU9mXCIgJiYgdXRpbF9qc18xLnV0aWwuaXNJbnRlZ2VyKGNoLnZhbHVlKSkpO1xuICAgIH1cbiAgICBnZXQgaXNGaW5pdGUoKSB7XG4gICAgICAgIGxldCBtYXggPSBudWxsO1xuICAgICAgICBsZXQgbWluID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJmaW5pdGVcIiB8fCBjaC5raW5kID09PSBcImludFwiIHx8IGNoLmtpbmQgPT09IFwibXVsdGlwbGVPZlwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaC5raW5kID09PSBcIm1pblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1pbiA9PT0gbnVsbCB8fCBjaC52YWx1ZSA+IG1pbilcbiAgICAgICAgICAgICAgICAgICAgbWluID0gY2gudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaC5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1heCA9PT0gbnVsbCB8fCBjaC52YWx1ZSA8IG1heClcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gY2gudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE51bWJlci5pc0Zpbml0ZShtaW4pICYmIE51bWJlci5pc0Zpbml0ZShtYXgpO1xuICAgIH1cbn1cbmV4cG9ydHMuWm9kTnVtYmVyID0gWm9kTnVtYmVyO1xuWm9kTnVtYmVyLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE51bWJlcih7XG4gICAgICAgIGNoZWNrczogW10sXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTnVtYmVyLFxuICAgICAgICBjb2VyY2U6IHBhcmFtcz8uY29lcmNlIHx8IGZhbHNlLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kQmlnSW50IGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubWluID0gdGhpcy5ndGU7XG4gICAgICAgIHRoaXMubWF4ID0gdGhpcy5sdGU7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBpZiAodGhpcy5fZGVmLmNvZXJjZSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpbnB1dC5kYXRhID0gQmlnSW50KGlucHV0LmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRJbnZhbGlkSW5wdXQoaW5wdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IHV0aWxfanNfMS5ab2RQYXJzZWRUeXBlLmJpZ2ludCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldEludmFsaWRJbnB1dChpbnB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGN0eCA9IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3Qgc3RhdHVzID0gbmV3IHBhcnNlVXRpbF9qc18xLlBhcnNlU3RhdHVzKCk7XG4gICAgICAgIGZvciAoY29uc3QgY2hlY2sgb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoZWNrLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b29TbWFsbCA9IGNoZWNrLmluY2x1c2l2ZSA/IGlucHV0LmRhdGEgPCBjaGVjay52YWx1ZSA6IGlucHV0LmRhdGEgPD0gY2hlY2sudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHRvb1NtYWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICAoMCwgcGFyc2VVdGlsX2pzXzEuYWRkSXNzdWVUb0NvbnRleHQpKGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kRXJyb3JfanNfMS5ab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJiaWdpbnRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbmltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiBjaGVjay5pbmNsdXNpdmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJtYXhcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvb0JpZyA9IGNoZWNrLmluY2x1c2l2ZSA/IGlucHV0LmRhdGEgPiBjaGVjay52YWx1ZSA6IGlucHV0LmRhdGEgPj0gY2hlY2sudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHRvb0JpZykge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgKDAsIHBhcnNlVXRpbF9qc18xLmFkZElzc3VlVG9Db250ZXh0KShjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZEVycm9yX2pzXzEuWm9kSXNzdWVDb2RlLnRvb19iaWcsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImJpZ2ludFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4aW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IGNoZWNrLmluY2x1c2l2ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm11bHRpcGxlT2ZcIikge1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5kYXRhICUgY2hlY2sudmFsdWUgIT09IEJpZ0ludCgwKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgKDAsIHBhcnNlVXRpbF9qc18xLmFkZElzc3VlVG9Db250ZXh0KShjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZEVycm9yX2pzXzEuWm9kSXNzdWVDb2RlLm5vdF9tdWx0aXBsZV9vZixcbiAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpcGxlT2Y6IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHV0aWxfanNfMS51dGlsLmFzc2VydE5ldmVyKGNoZWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGlucHV0LmRhdGEgfTtcbiAgICB9XG4gICAgX2dldEludmFsaWRJbnB1dChpbnB1dCkge1xuICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICgwLCBwYXJzZVV0aWxfanNfMS5hZGRJc3N1ZVRvQ29udGV4dCkoY3R4LCB7XG4gICAgICAgICAgICBjb2RlOiBab2RFcnJvcl9qc18xLlpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICBleHBlY3RlZDogdXRpbF9qc18xLlpvZFBhcnNlZFR5cGUuYmlnaW50LFxuICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBhcnNlVXRpbF9qc18xLklOVkFMSUQ7XG4gICAgfVxuICAgIGd0ZSh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1pblwiLCB2YWx1ZSwgdHJ1ZSwgZXJyb3JVdGlsX2pzXzEuZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpKTtcbiAgICB9XG4gICAgZ3QodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtaW5cIiwgdmFsdWUsIGZhbHNlLCBlcnJvclV0aWxfanNfMS5lcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xuICAgIH1cbiAgICBsdGUodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtYXhcIiwgdmFsdWUsIHRydWUsIGVycm9yVXRpbF9qc18xLmVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSk7XG4gICAgfVxuICAgIGx0KHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWF4XCIsIHZhbHVlLCBmYWxzZSwgZXJyb3JVdGlsX2pzXzEuZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpKTtcbiAgICB9XG4gICAgc2V0TGltaXQoa2luZCwgdmFsdWUsIGluY2x1c2l2ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEJpZ0ludCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBjaGVja3M6IFtcbiAgICAgICAgICAgICAgICAuLi50aGlzLl9kZWYuY2hlY2tzLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAga2luZCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsX2pzXzEuZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2FkZENoZWNrKGNoZWNrKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kQmlnSW50KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGNoZWNrczogWy4uLnRoaXMuX2RlZi5jaGVja3MsIGNoZWNrXSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHBvc2l0aXZlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWluXCIsXG4gICAgICAgICAgICB2YWx1ZTogQmlnSW50KDApLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiBmYWxzZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbF9qc18xLmVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5lZ2F0aXZlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWF4XCIsXG4gICAgICAgICAgICB2YWx1ZTogQmlnSW50KDApLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiBmYWxzZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbF9qc18xLmVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5vbnBvc2l0aXZlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWF4XCIsXG4gICAgICAgICAgICB2YWx1ZTogQmlnSW50KDApLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsX2pzXzEuZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbm9ubmVnYXRpdmUobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtaW5cIixcbiAgICAgICAgICAgIHZhbHVlOiBCaWdJbnQoMCksXG4gICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWxfanNfMS5lcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtdWx0aXBsZU9mKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm11bHRpcGxlT2ZcIixcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsX2pzXzEuZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IG1pblZhbHVlKCkge1xuICAgICAgICBsZXQgbWluID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICAgICAgICAgIGlmIChtaW4gPT09IG51bGwgfHwgY2gudmFsdWUgPiBtaW4pXG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IGNoLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtaW47XG4gICAgfVxuICAgIGdldCBtYXhWYWx1ZSgpIHtcbiAgICAgICAgbGV0IG1heCA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWF4XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobWF4ID09PSBudWxsIHx8IGNoLnZhbHVlIDwgbWF4KVxuICAgICAgICAgICAgICAgICAgICBtYXggPSBjaC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF4O1xuICAgIH1cbn1cbmV4cG9ydHMuWm9kQmlnSW50ID0gWm9kQmlnSW50O1xuWm9kQmlnSW50LmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZEJpZ0ludCh7XG4gICAgICAgIGNoZWNrczogW10sXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQmlnSW50LFxuICAgICAgICBjb2VyY2U6IHBhcmFtcz8uY29lcmNlID8/IGZhbHNlLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kQm9vbGVhbiBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBpZiAodGhpcy5fZGVmLmNvZXJjZSkge1xuICAgICAgICAgICAgaW5wdXQuZGF0YSA9IEJvb2xlYW4oaW5wdXQuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gdXRpbF9qc18xLlpvZFBhcnNlZFR5cGUuYm9vbGVhbikge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgKDAsIHBhcnNlVXRpbF9qc18xLmFkZElzc3VlVG9Db250ZXh0KShjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RFcnJvcl9qc18xLlpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IHV0aWxfanNfMS5ab2RQYXJzZWRUeXBlLmJvb2xlYW4sXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VVdGlsX2pzXzEuSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKDAsIHBhcnNlVXRpbF9qc18xLk9LKShpbnB1dC5kYXRhKTtcbiAgICB9XG59XG5leHBvcnRzLlpvZEJvb2xlYW4gPSBab2RCb29sZWFuO1xuWm9kQm9vbGVhbi5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RCb29sZWFuKHtcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RCb29sZWFuLFxuICAgICAgICBjb2VyY2U6IHBhcmFtcz8uY29lcmNlIHx8IGZhbHNlLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kRGF0ZSBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBpZiAodGhpcy5fZGVmLmNvZXJjZSkge1xuICAgICAgICAgICAgaW5wdXQuZGF0YSA9IG5ldyBEYXRlKGlucHV0LmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IHV0aWxfanNfMS5ab2RQYXJzZWRUeXBlLmRhdGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgICgwLCBwYXJzZVV0aWxfanNfMS5hZGRJc3N1ZVRvQ29udGV4dCkoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kRXJyb3JfanNfMS5ab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiB1dGlsX2pzXzEuWm9kUGFyc2VkVHlwZS5kYXRlLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlVXRpbF9qc18xLklOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE51bWJlci5pc05hTihpbnB1dC5kYXRhLmdldFRpbWUoKSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgICgwLCBwYXJzZVV0aWxfanNfMS5hZGRJc3N1ZVRvQ29udGV4dCkoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kRXJyb3JfanNfMS5ab2RJc3N1ZUNvZGUuaW52YWxpZF9kYXRlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VVdGlsX2pzXzEuSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGF0dXMgPSBuZXcgcGFyc2VVdGlsX2pzXzEuUGFyc2VTdGF0dXMoKTtcbiAgICAgICAgbGV0IGN0eCA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yIChjb25zdCBjaGVjayBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2hlY2sua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5kYXRhLmdldFRpbWUoKSA8IGNoZWNrLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICAoMCwgcGFyc2VVdGlsX2pzXzEuYWRkSXNzdWVUb0NvbnRleHQpKGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kRXJyb3JfanNfMS5ab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbmltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJkYXRlXCIsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmRhdGEuZ2V0VGltZSgpID4gY2hlY2sudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgICgwLCBwYXJzZVV0aWxfanNfMS5hZGRJc3N1ZVRvQ29udGV4dCkoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RFcnJvcl9qc18xLlpvZElzc3VlQ29kZS50b29fYmlnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heGltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJkYXRlXCIsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB1dGlsX2pzXzEudXRpbC5hc3NlcnROZXZlcihjaGVjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0YXR1czogc3RhdHVzLnZhbHVlLFxuICAgICAgICAgICAgdmFsdWU6IG5ldyBEYXRlKGlucHV0LmRhdGEuZ2V0VGltZSgpKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgX2FkZENoZWNrKGNoZWNrKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kRGF0ZSh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBjaGVja3M6IFsuLi50aGlzLl9kZWYuY2hlY2tzLCBjaGVja10sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtaW4obWluRGF0ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtaW5cIixcbiAgICAgICAgICAgIHZhbHVlOiBtaW5EYXRlLmdldFRpbWUoKSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbF9qc18xLmVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG1heChtYXhEYXRlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1heFwiLFxuICAgICAgICAgICAgdmFsdWU6IG1heERhdGUuZ2V0VGltZSgpLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsX2pzXzEuZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IG1pbkRhdGUoKSB7XG4gICAgICAgIGxldCBtaW4gPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaC5raW5kID09PSBcIm1pblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1pbiA9PT0gbnVsbCB8fCBjaC52YWx1ZSA+IG1pbilcbiAgICAgICAgICAgICAgICAgICAgbWluID0gY2gudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1pbiAhPSBudWxsID8gbmV3IERhdGUobWluKSA6IG51bGw7XG4gICAgfVxuICAgIGdldCBtYXhEYXRlKCkge1xuICAgICAgICBsZXQgbWF4ID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJtYXhcIikge1xuICAgICAgICAgICAgICAgIGlmIChtYXggPT09IG51bGwgfHwgY2gudmFsdWUgPCBtYXgpXG4gICAgICAgICAgICAgICAgICAgIG1heCA9IGNoLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXggIT0gbnVsbCA/IG5ldyBEYXRlKG1heCkgOiBudWxsO1xuICAgIH1cbn1cbmV4cG9ydHMuWm9kRGF0ZSA9IFpvZERhdGU7XG5ab2REYXRlLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZERhdGUoe1xuICAgICAgICBjaGVja3M6IFtdLFxuICAgICAgICBjb2VyY2U6IHBhcmFtcz8uY29lcmNlIHx8IGZhbHNlLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZERhdGUsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2RTeW1ib2wgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gdXRpbF9qc18xLlpvZFBhcnNlZFR5cGUuc3ltYm9sKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICAoMCwgcGFyc2VVdGlsX2pzXzEuYWRkSXNzdWVUb0NvbnRleHQpKGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZEVycm9yX2pzXzEuWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogdXRpbF9qc18xLlpvZFBhcnNlZFR5cGUuc3ltYm9sLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlVXRpbF9qc18xLklOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgwLCBwYXJzZVV0aWxfanNfMS5PSykoaW5wdXQuZGF0YSk7XG4gICAgfVxufVxuZXhwb3J0cy5ab2RTeW1ib2wgPSBab2RTeW1ib2w7XG5ab2RTeW1ib2wuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kU3ltYm9sKHtcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RTeW1ib2wsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2RVbmRlZmluZWQgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gdXRpbF9qc18xLlpvZFBhcnNlZFR5cGUudW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICAoMCwgcGFyc2VVdGlsX2pzXzEuYWRkSXNzdWVUb0NvbnRleHQpKGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZEVycm9yX2pzXzEuWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogdXRpbF9qc18xLlpvZFBhcnNlZFR5cGUudW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlVXRpbF9qc18xLklOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgwLCBwYXJzZVV0aWxfanNfMS5PSykoaW5wdXQuZGF0YSk7XG4gICAgfVxufVxuZXhwb3J0cy5ab2RVbmRlZmluZWQgPSBab2RVbmRlZmluZWQ7XG5ab2RVbmRlZmluZWQuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kVW5kZWZpbmVkKHtcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RVbmRlZmluZWQsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2ROdWxsIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IHV0aWxfanNfMS5ab2RQYXJzZWRUeXBlLm51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgICgwLCBwYXJzZVV0aWxfanNfMS5hZGRJc3N1ZVRvQ29udGV4dCkoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kRXJyb3JfanNfMS5ab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiB1dGlsX2pzXzEuWm9kUGFyc2VkVHlwZS5udWxsLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlVXRpbF9qc18xLklOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgwLCBwYXJzZVV0aWxfanNfMS5PSykoaW5wdXQuZGF0YSk7XG4gICAgfVxufVxuZXhwb3J0cy5ab2ROdWxsID0gWm9kTnVsbDtcblpvZE51bGwuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kTnVsbCh7XG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTnVsbCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZEFueSBleHRlbmRzIFpvZFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICAvLyB0byBwcmV2ZW50IGluc3RhbmNlcyBvZiBvdGhlciBjbGFzc2VzIGZyb20gZXh0ZW5kaW5nIFpvZEFueS4gdGhpcyBjYXVzZXMgaXNzdWVzIHdpdGggY2F0Y2hhbGwgaW4gWm9kT2JqZWN0LlxuICAgICAgICB0aGlzLl9hbnkgPSB0cnVlO1xuICAgIH1cbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuICgwLCBwYXJzZVV0aWxfanNfMS5PSykoaW5wdXQuZGF0YSk7XG4gICAgfVxufVxuZXhwb3J0cy5ab2RBbnkgPSBab2RBbnk7XG5ab2RBbnkuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kQW55KHtcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RBbnksXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2RVbmtub3duIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIC8vIHJlcXVpcmVkXG4gICAgICAgIHRoaXMuX3Vua25vd24gPSB0cnVlO1xuICAgIH1cbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuICgwLCBwYXJzZVV0aWxfanNfMS5PSykoaW5wdXQuZGF0YSk7XG4gICAgfVxufVxuZXhwb3J0cy5ab2RVbmtub3duID0gWm9kVW5rbm93bjtcblpvZFVua25vd24uY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kVW5rbm93bih7XG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kVW5rbm93bixcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZE5ldmVyIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgKDAsIHBhcnNlVXRpbF9qc18xLmFkZElzc3VlVG9Db250ZXh0KShjdHgsIHtcbiAgICAgICAgICAgIGNvZGU6IFpvZEVycm9yX2pzXzEuWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgIGV4cGVjdGVkOiB1dGlsX2pzXzEuWm9kUGFyc2VkVHlwZS5uZXZlcixcbiAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwYXJzZVV0aWxfanNfMS5JTlZBTElEO1xuICAgIH1cbn1cbmV4cG9ydHMuWm9kTmV2ZXIgPSBab2ROZXZlcjtcblpvZE5ldmVyLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE5ldmVyKHtcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2ROZXZlcixcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZFZvaWQgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gdXRpbF9qc18xLlpvZFBhcnNlZFR5cGUudW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICAoMCwgcGFyc2VVdGlsX2pzXzEuYWRkSXNzdWVUb0NvbnRleHQpKGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZEVycm9yX2pzXzEuWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogdXRpbF9qc18xLlpvZFBhcnNlZFR5cGUudm9pZCxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVV0aWxfanNfMS5JTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoMCwgcGFyc2VVdGlsX2pzXzEuT0spKGlucHV0LmRhdGEpO1xuICAgIH1cbn1cbmV4cG9ydHMuWm9kVm9pZCA9IFpvZFZvaWQ7XG5ab2RWb2lkLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZFZvaWQoe1xuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFZvaWQsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2RBcnJheSBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IGN0eCwgc3RhdHVzIH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBjb25zdCBkZWYgPSB0aGlzLl9kZWY7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gdXRpbF9qc18xLlpvZFBhcnNlZFR5cGUuYXJyYXkpIHtcbiAgICAgICAgICAgICgwLCBwYXJzZVV0aWxfanNfMS5hZGRJc3N1ZVRvQ29udGV4dCkoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kRXJyb3JfanNfMS5ab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiB1dGlsX2pzXzEuWm9kUGFyc2VkVHlwZS5hcnJheSxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVV0aWxfanNfMS5JTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWYuZXhhY3RMZW5ndGggIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHRvb0JpZyA9IGN0eC5kYXRhLmxlbmd0aCA+IGRlZi5leGFjdExlbmd0aC52YWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IHRvb1NtYWxsID0gY3R4LmRhdGEubGVuZ3RoIDwgZGVmLmV4YWN0TGVuZ3RoLnZhbHVlO1xuICAgICAgICAgICAgaWYgKHRvb0JpZyB8fCB0b29TbWFsbCkge1xuICAgICAgICAgICAgICAgICgwLCBwYXJzZVV0aWxfanNfMS5hZGRJc3N1ZVRvQ29udGV4dCkoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IHRvb0JpZyA/IFpvZEVycm9yX2pzXzEuWm9kSXNzdWVDb2RlLnRvb19iaWcgOiBab2RFcnJvcl9qc18xLlpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgICAgICAgICAgIG1pbmltdW06ICh0b29TbWFsbCA/IGRlZi5leGFjdExlbmd0aC52YWx1ZSA6IHVuZGVmaW5lZCksXG4gICAgICAgICAgICAgICAgICAgIG1heGltdW06ICh0b29CaWcgPyBkZWYuZXhhY3RMZW5ndGgudmFsdWUgOiB1bmRlZmluZWQpLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGRlZi5leGFjdExlbmd0aC5tZXNzYWdlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkZWYubWluTGVuZ3RoICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoY3R4LmRhdGEubGVuZ3RoIDwgZGVmLm1pbkxlbmd0aC52YWx1ZSkge1xuICAgICAgICAgICAgICAgICgwLCBwYXJzZVV0aWxfanNfMS5hZGRJc3N1ZVRvQ29udGV4dCkoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZEVycm9yX2pzXzEuWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcbiAgICAgICAgICAgICAgICAgICAgbWluaW11bTogZGVmLm1pbkxlbmd0aC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZGVmLm1pbkxlbmd0aC5tZXNzYWdlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkZWYubWF4TGVuZ3RoICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoY3R4LmRhdGEubGVuZ3RoID4gZGVmLm1heExlbmd0aC52YWx1ZSkge1xuICAgICAgICAgICAgICAgICgwLCBwYXJzZVV0aWxfanNfMS5hZGRJc3N1ZVRvQ29udGV4dCkoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZEVycm9yX2pzXzEuWm9kSXNzdWVDb2RlLnRvb19iaWcsXG4gICAgICAgICAgICAgICAgICAgIG1heGltdW06IGRlZi5tYXhMZW5ndGgudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGRlZi5tYXhMZW5ndGgubWVzc2FnZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFsuLi5jdHguZGF0YV0ubWFwKChpdGVtLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZi50eXBlLl9wYXJzZUFzeW5jKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCBpdGVtLCBjdHgucGF0aCwgaSkpO1xuICAgICAgICAgICAgfSkpLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZVV0aWxfanNfMS5QYXJzZVN0YXR1cy5tZXJnZUFycmF5KHN0YXR1cywgcmVzdWx0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFsuLi5jdHguZGF0YV0ubWFwKChpdGVtLCBpKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZGVmLnR5cGUuX3BhcnNlU3luYyhuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwgaXRlbSwgY3R4LnBhdGgsIGkpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwYXJzZVV0aWxfanNfMS5QYXJzZVN0YXR1cy5tZXJnZUFycmF5KHN0YXR1cywgcmVzdWx0KTtcbiAgICB9XG4gICAgZ2V0IGVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudHlwZTtcbiAgICB9XG4gICAgbWluKG1pbkxlbmd0aCwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEFycmF5KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIG1pbkxlbmd0aDogeyB2YWx1ZTogbWluTGVuZ3RoLCBtZXNzYWdlOiBlcnJvclV0aWxfanNfMS5lcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG1heChtYXhMZW5ndGgsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RBcnJheSh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBtYXhMZW5ndGg6IHsgdmFsdWU6IG1heExlbmd0aCwgbWVzc2FnZTogZXJyb3JVdGlsX2pzXzEuZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBsZW5ndGgobGVuLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kQXJyYXkoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgZXhhY3RMZW5ndGg6IHsgdmFsdWU6IGxlbiwgbWVzc2FnZTogZXJyb3JVdGlsX2pzXzEuZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBub25lbXB0eShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbigxLCBtZXNzYWdlKTtcbiAgICB9XG59XG5leHBvcnRzLlpvZEFycmF5ID0gWm9kQXJyYXk7XG5ab2RBcnJheS5jcmVhdGUgPSAoc2NoZW1hLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZEFycmF5KHtcbiAgICAgICAgdHlwZTogc2NoZW1hLFxuICAgICAgICBtaW5MZW5ndGg6IG51bGwsXG4gICAgICAgIG1heExlbmd0aDogbnVsbCxcbiAgICAgICAgZXhhY3RMZW5ndGg6IG51bGwsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQXJyYXksXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5mdW5jdGlvbiBkZWVwUGFydGlhbGlmeShzY2hlbWEpIHtcbiAgICBpZiAoc2NoZW1hIGluc3RhbmNlb2YgWm9kT2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG5ld1NoYXBlID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYS5zaGFwZSkge1xuICAgICAgICAgICAgY29uc3QgZmllbGRTY2hlbWEgPSBzY2hlbWEuc2hhcGVba2V5XTtcbiAgICAgICAgICAgIG5ld1NoYXBlW2tleV0gPSBab2RPcHRpb25hbC5jcmVhdGUoZGVlcFBhcnRpYWxpZnkoZmllbGRTY2hlbWEpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgICAgICAuLi5zY2hlbWEuX2RlZixcbiAgICAgICAgICAgIHNoYXBlOiAoKSA9PiBuZXdTaGFwZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHNjaGVtYSBpbnN0YW5jZW9mIFpvZEFycmF5KSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kQXJyYXkoe1xuICAgICAgICAgICAgLi4uc2NoZW1hLl9kZWYsXG4gICAgICAgICAgICB0eXBlOiBkZWVwUGFydGlhbGlmeShzY2hlbWEuZWxlbWVudCksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChzY2hlbWEgaW5zdGFuY2VvZiBab2RPcHRpb25hbCkge1xuICAgICAgICByZXR1cm4gWm9kT3B0aW9uYWwuY3JlYXRlKGRlZXBQYXJ0aWFsaWZ5KHNjaGVtYS51bndyYXAoKSkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChzY2hlbWEgaW5zdGFuY2VvZiBab2ROdWxsYWJsZSkge1xuICAgICAgICByZXR1cm4gWm9kTnVsbGFibGUuY3JlYXRlKGRlZXBQYXJ0aWFsaWZ5KHNjaGVtYS51bndyYXAoKSkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChzY2hlbWEgaW5zdGFuY2VvZiBab2RUdXBsZSkge1xuICAgICAgICByZXR1cm4gWm9kVHVwbGUuY3JlYXRlKHNjaGVtYS5pdGVtcy5tYXAoKGl0ZW0pID0+IGRlZXBQYXJ0aWFsaWZ5KGl0ZW0pKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gc2NoZW1hO1xuICAgIH1cbn1cbmNsYXNzIFpvZE9iamVjdCBleHRlbmRzIFpvZFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLl9jYWNoZWQgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGRlcHJlY2F0ZWQgSW4gbW9zdCBjYXNlcywgdGhpcyBpcyBubyBsb25nZXIgbmVlZGVkIC0gdW5rbm93biBwcm9wZXJ0aWVzIGFyZSBub3cgc2lsZW50bHkgc3RyaXBwZWQuXG4gICAgICAgICAqIElmIHlvdSB3YW50IHRvIHBhc3MgdGhyb3VnaCB1bmtub3duIHByb3BlcnRpZXMsIHVzZSBgLnBhc3N0aHJvdWdoKClgIGluc3RlYWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5vbnN0cmljdCA9IHRoaXMucGFzc3Rocm91Z2g7XG4gICAgICAgIC8vIGV4dGVuZDxcbiAgICAgICAgLy8gICBBdWdtZW50YXRpb24gZXh0ZW5kcyBab2RSYXdTaGFwZSxcbiAgICAgICAgLy8gICBOZXdPdXRwdXQgZXh0ZW5kcyB1dGlsLmZsYXR0ZW48e1xuICAgICAgICAvLyAgICAgW2sgaW4ga2V5b2YgQXVnbWVudGF0aW9uIHwga2V5b2YgT3V0cHV0XTogayBleHRlbmRzIGtleW9mIEF1Z21lbnRhdGlvblxuICAgICAgICAvLyAgICAgICA/IEF1Z21lbnRhdGlvbltrXVtcIl9vdXRwdXRcIl1cbiAgICAgICAgLy8gICAgICAgOiBrIGV4dGVuZHMga2V5b2YgT3V0cHV0XG4gICAgICAgIC8vICAgICAgID8gT3V0cHV0W2tdXG4gICAgICAgIC8vICAgICAgIDogbmV2ZXI7XG4gICAgICAgIC8vICAgfT4sXG4gICAgICAgIC8vICAgTmV3SW5wdXQgZXh0ZW5kcyB1dGlsLmZsYXR0ZW48e1xuICAgICAgICAvLyAgICAgW2sgaW4ga2V5b2YgQXVnbWVudGF0aW9uIHwga2V5b2YgSW5wdXRdOiBrIGV4dGVuZHMga2V5b2YgQXVnbWVudGF0aW9uXG4gICAgICAgIC8vICAgICAgID8gQXVnbWVudGF0aW9uW2tdW1wiX2lucHV0XCJdXG4gICAgICAgIC8vICAgICAgIDogayBleHRlbmRzIGtleW9mIElucHV0XG4gICAgICAgIC8vICAgICAgID8gSW5wdXRba11cbiAgICAgICAgLy8gICAgICAgOiBuZXZlcjtcbiAgICAgICAgLy8gICB9PlxuICAgICAgICAvLyA+KFxuICAgICAgICAvLyAgIGF1Z21lbnRhdGlvbjogQXVnbWVudGF0aW9uXG4gICAgICAgIC8vICk6IFpvZE9iamVjdDxcbiAgICAgICAgLy8gICBleHRlbmRTaGFwZTxULCBBdWdtZW50YXRpb24+LFxuICAgICAgICAvLyAgIFVua25vd25LZXlzLFxuICAgICAgICAvLyAgIENhdGNoYWxsLFxuICAgICAgICAvLyAgIE5ld091dHB1dCxcbiAgICAgICAgLy8gICBOZXdJbnB1dFxuICAgICAgICAvLyA+IHtcbiAgICAgICAgLy8gICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgIC8vICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgIC8vICAgICBzaGFwZTogKCkgPT4gKHtcbiAgICAgICAgLy8gICAgICAgLi4udGhpcy5fZGVmLnNoYXBlKCksXG4gICAgICAgIC8vICAgICAgIC4uLmF1Z21lbnRhdGlvbixcbiAgICAgICAgLy8gICAgIH0pLFxuICAgICAgICAvLyAgIH0pIGFzIGFueTtcbiAgICAgICAgLy8gfVxuICAgICAgICAvKipcbiAgICAgICAgICogQGRlcHJlY2F0ZWQgVXNlIGAuZXh0ZW5kYCBpbnN0ZWFkXG4gICAgICAgICAqICAqL1xuICAgICAgICB0aGlzLmF1Z21lbnQgPSB0aGlzLmV4dGVuZDtcbiAgICB9XG4gICAgX2dldENhY2hlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NhY2hlZCAhPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYWNoZWQ7XG4gICAgICAgIGNvbnN0IHNoYXBlID0gdGhpcy5fZGVmLnNoYXBlKCk7XG4gICAgICAgIGNvbnN0IGtleXMgPSB1dGlsX2pzXzEudXRpbC5vYmplY3RLZXlzKHNoYXBlKTtcbiAgICAgICAgdGhpcy5fY2FjaGVkID0geyBzaGFwZSwga2V5cyB9O1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVkO1xuICAgIH1cbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gdXRpbF9qc18xLlpvZFBhcnNlZFR5cGUub2JqZWN0KSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICAoMCwgcGFyc2VVdGlsX2pzXzEuYWRkSXNzdWVUb0NvbnRleHQpKGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZEVycm9yX2pzXzEuWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogdXRpbF9qc18xLlpvZFBhcnNlZFR5cGUub2JqZWN0LFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlVXRpbF9qc18xLklOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgY29uc3QgeyBzaGFwZSwga2V5czogc2hhcGVLZXlzIH0gPSB0aGlzLl9nZXRDYWNoZWQoKTtcbiAgICAgICAgY29uc3QgZXh0cmFLZXlzID0gW107XG4gICAgICAgIGlmICghKHRoaXMuX2RlZi5jYXRjaGFsbCBpbnN0YW5jZW9mIFpvZE5ldmVyICYmIHRoaXMuX2RlZi51bmtub3duS2V5cyA9PT0gXCJzdHJpcFwiKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gY3R4LmRhdGEpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXNoYXBlS2V5cy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4dHJhS2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhaXJzID0gW107XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHNoYXBlS2V5cykge1xuICAgICAgICAgICAgY29uc3Qga2V5VmFsaWRhdG9yID0gc2hhcGVba2V5XTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gY3R4LmRhdGFba2V5XTtcbiAgICAgICAgICAgIHBhaXJzLnB1c2goe1xuICAgICAgICAgICAgICAgIGtleTogeyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWU6IGtleSB9LFxuICAgICAgICAgICAgICAgIHZhbHVlOiBrZXlWYWxpZGF0b3IuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCB2YWx1ZSwgY3R4LnBhdGgsIGtleSkpLFxuICAgICAgICAgICAgICAgIGFsd2F5c1NldDoga2V5IGluIGN0eC5kYXRhLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2RlZi5jYXRjaGFsbCBpbnN0YW5jZW9mIFpvZE5ldmVyKSB7XG4gICAgICAgICAgICBjb25zdCB1bmtub3duS2V5cyA9IHRoaXMuX2RlZi51bmtub3duS2V5cztcbiAgICAgICAgICAgIGlmICh1bmtub3duS2V5cyA9PT0gXCJwYXNzdGhyb3VnaFwiKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgZXh0cmFLZXlzKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhaXJzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiB7IHN0YXR1czogXCJ2YWxpZFwiLCB2YWx1ZToga2V5IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogeyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWU6IGN0eC5kYXRhW2tleV0gfSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodW5rbm93bktleXMgPT09IFwic3RyaWN0XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXh0cmFLZXlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgKDAsIHBhcnNlVXRpbF9qc18xLmFkZElzc3VlVG9Db250ZXh0KShjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZEVycm9yX2pzXzEuWm9kSXNzdWVDb2RlLnVucmVjb2duaXplZF9rZXlzLFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5czogZXh0cmFLZXlzLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodW5rbm93bktleXMgPT09IFwic3RyaXBcIikge1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnRlcm5hbCBab2RPYmplY3QgZXJyb3I6IGludmFsaWQgdW5rbm93bktleXMgdmFsdWUuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBydW4gY2F0Y2hhbGwgdmFsaWRhdGlvblxuICAgICAgICAgICAgY29uc3QgY2F0Y2hhbGwgPSB0aGlzLl9kZWYuY2F0Y2hhbGw7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBleHRyYUtleXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGN0eC5kYXRhW2tleV07XG4gICAgICAgICAgICAgICAgcGFpcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGtleTogeyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWU6IGtleSB9LFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY2F0Y2hhbGwuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCB2YWx1ZSwgY3R4LnBhdGgsIGtleSkgLy8sIGN0eC5jaGlsZChrZXkpLCB2YWx1ZSwgZ2V0UGFyc2VkVHlwZSh2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgYWx3YXlzU2V0OiBrZXkgaW4gY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgICAgICAgICAgIC50aGVuKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzeW5jUGFpcnMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHBhaXIgb2YgcGFpcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgcGFpci5rZXk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgcGFpci52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgc3luY1BhaXJzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbHdheXNTZXQ6IHBhaXIuYWx3YXlzU2V0LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN5bmNQYWlycztcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKHN5bmNQYWlycykgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZVV0aWxfanNfMS5QYXJzZVN0YXR1cy5tZXJnZU9iamVjdFN5bmMoc3RhdHVzLCBzeW5jUGFpcnMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VVdGlsX2pzXzEuUGFyc2VTdGF0dXMubWVyZ2VPYmplY3RTeW5jKHN0YXR1cywgcGFpcnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBzaGFwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5zaGFwZSgpO1xuICAgIH1cbiAgICBzdHJpY3QobWVzc2FnZSkge1xuICAgICAgICBlcnJvclV0aWxfanNfMS5lcnJvclV0aWwuZXJyVG9PYmo7XG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIHVua25vd25LZXlzOiBcInN0cmljdFwiLFxuICAgICAgICAgICAgLi4uKG1lc3NhZ2UgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICBlcnJvck1hcDogKGlzc3VlLCBjdHgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRFcnJvciA9IHRoaXMuX2RlZi5lcnJvck1hcD8uKGlzc3VlLCBjdHgpLm1lc3NhZ2UgPz8gY3R4LmRlZmF1bHRFcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc3N1ZS5jb2RlID09PSBcInVucmVjb2duaXplZF9rZXlzXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsX2pzXzEuZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpLm1lc3NhZ2UgPz8gZGVmYXVsdEVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGRlZmF1bHRFcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDoge30pLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RyaXAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIHVua25vd25LZXlzOiBcInN0cmlwXCIsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwYXNzdGhyb3VnaCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgdW5rbm93bktleXM6IFwicGFzc3Rocm91Z2hcIixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIGNvbnN0IEF1Z21lbnRGYWN0b3J5ID1cbiAgICAvLyAgIDxEZWYgZXh0ZW5kcyBab2RPYmplY3REZWY+KGRlZjogRGVmKSA9PlxuICAgIC8vICAgPEF1Z21lbnRhdGlvbiBleHRlbmRzIFpvZFJhd1NoYXBlPihcbiAgICAvLyAgICAgYXVnbWVudGF0aW9uOiBBdWdtZW50YXRpb25cbiAgICAvLyAgICk6IFpvZE9iamVjdDxcbiAgICAvLyAgICAgZXh0ZW5kU2hhcGU8UmV0dXJuVHlwZTxEZWZbXCJzaGFwZVwiXT4sIEF1Z21lbnRhdGlvbj4sXG4gICAgLy8gICAgIERlZltcInVua25vd25LZXlzXCJdLFxuICAgIC8vICAgICBEZWZbXCJjYXRjaGFsbFwiXVxuICAgIC8vICAgPiA9PiB7XG4gICAgLy8gICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAvLyAgICAgICAuLi5kZWYsXG4gICAgLy8gICAgICAgc2hhcGU6ICgpID0+ICh7XG4gICAgLy8gICAgICAgICAuLi5kZWYuc2hhcGUoKSxcbiAgICAvLyAgICAgICAgIC4uLmF1Z21lbnRhdGlvbixcbiAgICAvLyAgICAgICB9KSxcbiAgICAvLyAgICAgfSkgYXMgYW55O1xuICAgIC8vICAgfTtcbiAgICBleHRlbmQoYXVnbWVudGF0aW9uKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIHNoYXBlOiAoKSA9PiAoe1xuICAgICAgICAgICAgICAgIC4uLnRoaXMuX2RlZi5zaGFwZSgpLFxuICAgICAgICAgICAgICAgIC4uLmF1Z21lbnRhdGlvbixcbiAgICAgICAgICAgIH0pLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJpb3IgdG8gem9kQDEuMC4xMiB0aGVyZSB3YXMgYSBidWcgaW4gdGhlXG4gICAgICogaW5mZXJyZWQgdHlwZSBvZiBtZXJnZWQgb2JqZWN0cy4gUGxlYXNlXG4gICAgICogdXBncmFkZSBpZiB5b3UgYXJlIGV4cGVyaWVuY2luZyBpc3N1ZXMuXG4gICAgICovXG4gICAgbWVyZ2UobWVyZ2luZykge1xuICAgICAgICBjb25zdCBtZXJnZWQgPSBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIHVua25vd25LZXlzOiBtZXJnaW5nLl9kZWYudW5rbm93bktleXMsXG4gICAgICAgICAgICBjYXRjaGFsbDogbWVyZ2luZy5fZGVmLmNhdGNoYWxsLFxuICAgICAgICAgICAgc2hhcGU6ICgpID0+ICh7XG4gICAgICAgICAgICAgICAgLi4udGhpcy5fZGVmLnNoYXBlKCksXG4gICAgICAgICAgICAgICAgLi4ubWVyZ2luZy5fZGVmLnNoYXBlKCksXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kT2JqZWN0LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG1lcmdlZDtcbiAgICB9XG4gICAgLy8gbWVyZ2U8XG4gICAgLy8gICBJbmNvbWluZyBleHRlbmRzIEFueVpvZE9iamVjdCxcbiAgICAvLyAgIEF1Z21lbnRhdGlvbiBleHRlbmRzIEluY29taW5nW1wic2hhcGVcIl0sXG4gICAgLy8gICBOZXdPdXRwdXQgZXh0ZW5kcyB7XG4gICAgLy8gICAgIFtrIGluIGtleW9mIEF1Z21lbnRhdGlvbiB8IGtleW9mIE91dHB1dF06IGsgZXh0ZW5kcyBrZXlvZiBBdWdtZW50YXRpb25cbiAgICAvLyAgICAgICA/IEF1Z21lbnRhdGlvbltrXVtcIl9vdXRwdXRcIl1cbiAgICAvLyAgICAgICA6IGsgZXh0ZW5kcyBrZXlvZiBPdXRwdXRcbiAgICAvLyAgICAgICA/IE91dHB1dFtrXVxuICAgIC8vICAgICAgIDogbmV2ZXI7XG4gICAgLy8gICB9LFxuICAgIC8vICAgTmV3SW5wdXQgZXh0ZW5kcyB7XG4gICAgLy8gICAgIFtrIGluIGtleW9mIEF1Z21lbnRhdGlvbiB8IGtleW9mIElucHV0XTogayBleHRlbmRzIGtleW9mIEF1Z21lbnRhdGlvblxuICAgIC8vICAgICAgID8gQXVnbWVudGF0aW9uW2tdW1wiX2lucHV0XCJdXG4gICAgLy8gICAgICAgOiBrIGV4dGVuZHMga2V5b2YgSW5wdXRcbiAgICAvLyAgICAgICA/IElucHV0W2tdXG4gICAgLy8gICAgICAgOiBuZXZlcjtcbiAgICAvLyAgIH1cbiAgICAvLyA+KFxuICAgIC8vICAgbWVyZ2luZzogSW5jb21pbmdcbiAgICAvLyApOiBab2RPYmplY3Q8XG4gICAgLy8gICBleHRlbmRTaGFwZTxULCBSZXR1cm5UeXBlPEluY29taW5nW1wiX2RlZlwiXVtcInNoYXBlXCJdPj4sXG4gICAgLy8gICBJbmNvbWluZ1tcIl9kZWZcIl1bXCJ1bmtub3duS2V5c1wiXSxcbiAgICAvLyAgIEluY29taW5nW1wiX2RlZlwiXVtcImNhdGNoYWxsXCJdLFxuICAgIC8vICAgTmV3T3V0cHV0LFxuICAgIC8vICAgTmV3SW5wdXRcbiAgICAvLyA+IHtcbiAgICAvLyAgIGNvbnN0IG1lcmdlZDogYW55ID0gbmV3IFpvZE9iamVjdCh7XG4gICAgLy8gICAgIHVua25vd25LZXlzOiBtZXJnaW5nLl9kZWYudW5rbm93bktleXMsXG4gICAgLy8gICAgIGNhdGNoYWxsOiBtZXJnaW5nLl9kZWYuY2F0Y2hhbGwsXG4gICAgLy8gICAgIHNoYXBlOiAoKSA9PlxuICAgIC8vICAgICAgIG9iamVjdFV0aWwubWVyZ2VTaGFwZXModGhpcy5fZGVmLnNoYXBlKCksIG1lcmdpbmcuX2RlZi5zaGFwZSgpKSxcbiAgICAvLyAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPYmplY3QsXG4gICAgLy8gICB9KSBhcyBhbnk7XG4gICAgLy8gICByZXR1cm4gbWVyZ2VkO1xuICAgIC8vIH1cbiAgICBzZXRLZXkoa2V5LCBzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXVnbWVudCh7IFtrZXldOiBzY2hlbWEgfSk7XG4gICAgfVxuICAgIC8vIG1lcmdlPEluY29taW5nIGV4dGVuZHMgQW55Wm9kT2JqZWN0PihcbiAgICAvLyAgIG1lcmdpbmc6IEluY29taW5nXG4gICAgLy8gKTogLy9ab2RPYmplY3Q8VCAmIEluY29taW5nW1wiX3NoYXBlXCJdLCBVbmtub3duS2V5cywgQ2F0Y2hhbGw+ID0gKG1lcmdpbmcpID0+IHtcbiAgICAvLyBab2RPYmplY3Q8XG4gICAgLy8gICBleHRlbmRTaGFwZTxULCBSZXR1cm5UeXBlPEluY29taW5nW1wiX2RlZlwiXVtcInNoYXBlXCJdPj4sXG4gICAgLy8gICBJbmNvbWluZ1tcIl9kZWZcIl1bXCJ1bmtub3duS2V5c1wiXSxcbiAgICAvLyAgIEluY29taW5nW1wiX2RlZlwiXVtcImNhdGNoYWxsXCJdXG4gICAgLy8gPiB7XG4gICAgLy8gICAvLyBjb25zdCBtZXJnZWRTaGFwZSA9IG9iamVjdFV0aWwubWVyZ2VTaGFwZXMoXG4gICAgLy8gICAvLyAgIHRoaXMuX2RlZi5zaGFwZSgpLFxuICAgIC8vICAgLy8gICBtZXJnaW5nLl9kZWYuc2hhcGUoKVxuICAgIC8vICAgLy8gKTtcbiAgICAvLyAgIGNvbnN0IG1lcmdlZDogYW55ID0gbmV3IFpvZE9iamVjdCh7XG4gICAgLy8gICAgIHVua25vd25LZXlzOiBtZXJnaW5nLl9kZWYudW5rbm93bktleXMsXG4gICAgLy8gICAgIGNhdGNoYWxsOiBtZXJnaW5nLl9kZWYuY2F0Y2hhbGwsXG4gICAgLy8gICAgIHNoYXBlOiAoKSA9PlxuICAgIC8vICAgICAgIG9iamVjdFV0aWwubWVyZ2VTaGFwZXModGhpcy5fZGVmLnNoYXBlKCksIG1lcmdpbmcuX2RlZi5zaGFwZSgpKSxcbiAgICAvLyAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPYmplY3QsXG4gICAgLy8gICB9KSBhcyBhbnk7XG4gICAgLy8gICByZXR1cm4gbWVyZ2VkO1xuICAgIC8vIH1cbiAgICBjYXRjaGFsbChpbmRleCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBjYXRjaGFsbDogaW5kZXgsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwaWNrKG1hc2spIHtcbiAgICAgICAgY29uc3Qgc2hhcGUgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgdXRpbF9qc18xLnV0aWwub2JqZWN0S2V5cyhtYXNrKSkge1xuICAgICAgICAgICAgaWYgKG1hc2tba2V5XSAmJiB0aGlzLnNoYXBlW2tleV0pIHtcbiAgICAgICAgICAgICAgICBzaGFwZVtrZXldID0gdGhpcy5zaGFwZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIHNoYXBlOiAoKSA9PiBzaGFwZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG9taXQobWFzaykge1xuICAgICAgICBjb25zdCBzaGFwZSA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiB1dGlsX2pzXzEudXRpbC5vYmplY3RLZXlzKHRoaXMuc2hhcGUpKSB7XG4gICAgICAgICAgICBpZiAoIW1hc2tba2V5XSkge1xuICAgICAgICAgICAgICAgIHNoYXBlW2tleV0gPSB0aGlzLnNoYXBlW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgc2hhcGU6ICgpID0+IHNoYXBlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKi9cbiAgICBkZWVwUGFydGlhbCgpIHtcbiAgICAgICAgcmV0dXJuIGRlZXBQYXJ0aWFsaWZ5KHRoaXMpO1xuICAgIH1cbiAgICBwYXJ0aWFsKG1hc2spIHtcbiAgICAgICAgY29uc3QgbmV3U2hhcGUgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgdXRpbF9qc18xLnV0aWwub2JqZWN0S2V5cyh0aGlzLnNoYXBlKSkge1xuICAgICAgICAgICAgY29uc3QgZmllbGRTY2hlbWEgPSB0aGlzLnNoYXBlW2tleV07XG4gICAgICAgICAgICBpZiAobWFzayAmJiAhbWFza1trZXldKSB7XG4gICAgICAgICAgICAgICAgbmV3U2hhcGVba2V5XSA9IGZpZWxkU2NoZW1hO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3U2hhcGVba2V5XSA9IGZpZWxkU2NoZW1hLm9wdGlvbmFsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgc2hhcGU6ICgpID0+IG5ld1NoYXBlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVxdWlyZWQobWFzaykge1xuICAgICAgICBjb25zdCBuZXdTaGFwZSA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiB1dGlsX2pzXzEudXRpbC5vYmplY3RLZXlzKHRoaXMuc2hhcGUpKSB7XG4gICAgICAgICAgICBpZiAobWFzayAmJiAhbWFza1trZXldKSB7XG4gICAgICAgICAgICAgICAgbmV3U2hhcGVba2V5XSA9IHRoaXMuc2hhcGVba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkU2NoZW1hID0gdGhpcy5zaGFwZVtrZXldO1xuICAgICAgICAgICAgICAgIGxldCBuZXdGaWVsZCA9IGZpZWxkU2NoZW1hO1xuICAgICAgICAgICAgICAgIHdoaWxlIChuZXdGaWVsZCBpbnN0YW5jZW9mIFpvZE9wdGlvbmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0ZpZWxkID0gbmV3RmllbGQuX2RlZi5pbm5lclR5cGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5ld1NoYXBlW2tleV0gPSBuZXdGaWVsZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBzaGFwZTogKCkgPT4gbmV3U2hhcGUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBrZXlvZigpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVpvZEVudW0odXRpbF9qc18xLnV0aWwub2JqZWN0S2V5cyh0aGlzLnNoYXBlKSk7XG4gICAgfVxufVxuZXhwb3J0cy5ab2RPYmplY3QgPSBab2RPYmplY3Q7XG5ab2RPYmplY3QuY3JlYXRlID0gKHNoYXBlLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgIHNoYXBlOiAoKSA9PiBzaGFwZSxcbiAgICAgICAgdW5rbm93bktleXM6IFwic3RyaXBcIixcbiAgICAgICAgY2F0Y2hhbGw6IFpvZE5ldmVyLmNyZWF0ZSgpLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE9iamVjdCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcblpvZE9iamVjdC5zdHJpY3RDcmVhdGUgPSAoc2hhcGUsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgc2hhcGU6ICgpID0+IHNoYXBlLFxuICAgICAgICB1bmtub3duS2V5czogXCJzdHJpY3RcIixcbiAgICAgICAgY2F0Y2hhbGw6IFpvZE5ldmVyLmNyZWF0ZSgpLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE9iamVjdCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcblpvZE9iamVjdC5sYXp5Y3JlYXRlID0gKHNoYXBlLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgIHNoYXBlLFxuICAgICAgICB1bmtub3duS2V5czogXCJzdHJpcFwiLFxuICAgICAgICBjYXRjaGFsbDogWm9kTmV2ZXIuY3JlYXRlKCksXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kT2JqZWN0LFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kVW5pb24gZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9kZWYub3B0aW9ucztcbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlUmVzdWx0cyhyZXN1bHRzKSB7XG4gICAgICAgICAgICAvLyByZXR1cm4gZmlyc3QgaXNzdWUtZnJlZSB2YWxpZGF0aW9uIGlmIGl0IGV4aXN0c1xuICAgICAgICAgICAgZm9yIChjb25zdCByZXN1bHQgb2YgcmVzdWx0cykge1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQucmVzdWx0LnN0YXR1cyA9PT0gXCJ2YWxpZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQucmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgcmVzdWx0IG9mIHJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnJlc3VsdC5zdGF0dXMgPT09IFwiZGlydHlcIikge1xuICAgICAgICAgICAgICAgICAgICAvLyBhZGQgaXNzdWVzIGZyb20gZGlydHkgb3B0aW9uXG4gICAgICAgICAgICAgICAgICAgIGN0eC5jb21tb24uaXNzdWVzLnB1c2goLi4ucmVzdWx0LmN0eC5jb21tb24uaXNzdWVzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcmV0dXJuIGludmFsaWRcbiAgICAgICAgICAgIGNvbnN0IHVuaW9uRXJyb3JzID0gcmVzdWx0cy5tYXAoKHJlc3VsdCkgPT4gbmV3IFpvZEVycm9yX2pzXzEuWm9kRXJyb3IocmVzdWx0LmN0eC5jb21tb24uaXNzdWVzKSk7XG4gICAgICAgICAgICAoMCwgcGFyc2VVdGlsX2pzXzEuYWRkSXNzdWVUb0NvbnRleHQpKGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZEVycm9yX2pzXzEuWm9kSXNzdWVDb2RlLmludmFsaWRfdW5pb24sXG4gICAgICAgICAgICAgICAgdW5pb25FcnJvcnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVV0aWxfanNfMS5JTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwob3B0aW9ucy5tYXAoYXN5bmMgKG9wdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkQ3R4ID0ge1xuICAgICAgICAgICAgICAgICAgICAuLi5jdHgsXG4gICAgICAgICAgICAgICAgICAgIGNvbW1vbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uY3R4LmNvbW1vbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzc3VlczogW10sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogbnVsbCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDogYXdhaXQgb3B0aW9uLl9wYXJzZUFzeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGNoaWxkQ3R4LFxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgY3R4OiBjaGlsZEN0eCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkpLnRoZW4oaGFuZGxlUmVzdWx0cyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgZGlydHkgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb25zdCBpc3N1ZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgb3B0aW9uIG9mIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZEN0eCA9IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uY3R4LFxuICAgICAgICAgICAgICAgICAgICBjb21tb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmN0eC5jb21tb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBpc3N1ZXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IG51bGwsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBvcHRpb24uX3BhcnNlU3luYyh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjaGlsZEN0eCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gXCJ2YWxpZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlc3VsdC5zdGF0dXMgPT09IFwiZGlydHlcIiAmJiAhZGlydHkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlydHkgPSB7IHJlc3VsdCwgY3R4OiBjaGlsZEN0eCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRDdHguY29tbW9uLmlzc3Vlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNzdWVzLnB1c2goY2hpbGRDdHguY29tbW9uLmlzc3Vlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRpcnR5KSB7XG4gICAgICAgICAgICAgICAgY3R4LmNvbW1vbi5pc3N1ZXMucHVzaCguLi5kaXJ0eS5jdHguY29tbW9uLmlzc3Vlcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpcnR5LnJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHVuaW9uRXJyb3JzID0gaXNzdWVzLm1hcCgoaXNzdWVzKSA9PiBuZXcgWm9kRXJyb3JfanNfMS5ab2RFcnJvcihpc3N1ZXMpKTtcbiAgICAgICAgICAgICgwLCBwYXJzZVV0aWxfanNfMS5hZGRJc3N1ZVRvQ29udGV4dCkoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kRXJyb3JfanNfMS5ab2RJc3N1ZUNvZGUuaW52YWxpZF91bmlvbixcbiAgICAgICAgICAgICAgICB1bmlvbkVycm9ycyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlVXRpbF9qc18xLklOVkFMSUQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYub3B0aW9ucztcbiAgICB9XG59XG5leHBvcnRzLlpvZFVuaW9uID0gWm9kVW5pb247XG5ab2RVbmlvbi5jcmVhdGUgPSAodHlwZXMsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kVW5pb24oe1xuICAgICAgICBvcHRpb25zOiB0eXBlcyxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RVbmlvbixcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vLy8vLy8vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vLy8vLy8vLy9cbi8vLy8vLy8vLy8gICAgICBab2REaXNjcmltaW5hdGVkVW5pb24gICAgICAvLy8vLy8vLy8vXG4vLy8vLy8vLy8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8vLy8vLy8vL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5jb25zdCBnZXREaXNjcmltaW5hdG9yID0gKHR5cGUpID0+IHtcbiAgICBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZExhenkpIHtcbiAgICAgICAgcmV0dXJuIGdldERpc2NyaW1pbmF0b3IodHlwZS5zY2hlbWEpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kRWZmZWN0cykge1xuICAgICAgICByZXR1cm4gZ2V0RGlzY3JpbWluYXRvcih0eXBlLmlubmVyVHlwZSgpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZExpdGVyYWwpIHtcbiAgICAgICAgcmV0dXJuIFt0eXBlLnZhbHVlXTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZEVudW0pIHtcbiAgICAgICAgcmV0dXJuIHR5cGUub3B0aW9ucztcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZE5hdGl2ZUVudW0pIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGJhbi9iYW5cbiAgICAgICAgcmV0dXJuIHV0aWxfanNfMS51dGlsLm9iamVjdFZhbHVlcyh0eXBlLmVudW0pO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kRGVmYXVsdCkge1xuICAgICAgICByZXR1cm4gZ2V0RGlzY3JpbWluYXRvcih0eXBlLl9kZWYuaW5uZXJUeXBlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZFVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gW3VuZGVmaW5lZF07XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2ROdWxsKSB7XG4gICAgICAgIHJldHVybiBbbnVsbF07XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2RPcHRpb25hbCkge1xuICAgICAgICByZXR1cm4gW3VuZGVmaW5lZCwgLi4uZ2V0RGlzY3JpbWluYXRvcih0eXBlLnVud3JhcCgpKV07XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2ROdWxsYWJsZSkge1xuICAgICAgICByZXR1cm4gW251bGwsIC4uLmdldERpc2NyaW1pbmF0b3IodHlwZS51bndyYXAoKSldO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kQnJhbmRlZCkge1xuICAgICAgICByZXR1cm4gZ2V0RGlzY3JpbWluYXRvcih0eXBlLnVud3JhcCgpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZFJlYWRvbmx5KSB7XG4gICAgICAgIHJldHVybiBnZXREaXNjcmltaW5hdG9yKHR5cGUudW53cmFwKCkpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kQ2F0Y2gpIHtcbiAgICAgICAgcmV0dXJuIGdldERpc2NyaW1pbmF0b3IodHlwZS5fZGVmLmlubmVyVHlwZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxufTtcbmNsYXNzIFpvZERpc2NyaW1pbmF0ZWRVbmlvbiBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSB1dGlsX2pzXzEuWm9kUGFyc2VkVHlwZS5vYmplY3QpIHtcbiAgICAgICAgICAgICgwLCBwYXJzZVV0aWxfanNfMS5hZGRJc3N1ZVRvQ29udGV4dCkoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kRXJyb3JfanNfMS5ab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiB1dGlsX2pzXzEuWm9kUGFyc2VkVHlwZS5vYmplY3QsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VVdGlsX2pzXzEuSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkaXNjcmltaW5hdG9yID0gdGhpcy5kaXNjcmltaW5hdG9yO1xuICAgICAgICBjb25zdCBkaXNjcmltaW5hdG9yVmFsdWUgPSBjdHguZGF0YVtkaXNjcmltaW5hdG9yXTtcbiAgICAgICAgY29uc3Qgb3B0aW9uID0gdGhpcy5vcHRpb25zTWFwLmdldChkaXNjcmltaW5hdG9yVmFsdWUpO1xuICAgICAgICBpZiAoIW9wdGlvbikge1xuICAgICAgICAgICAgKDAsIHBhcnNlVXRpbF9qc18xLmFkZElzc3VlVG9Db250ZXh0KShjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RFcnJvcl9qc18xLlpvZElzc3VlQ29kZS5pbnZhbGlkX3VuaW9uX2Rpc2NyaW1pbmF0b3IsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogQXJyYXkuZnJvbSh0aGlzLm9wdGlvbnNNYXAua2V5cygpKSxcbiAgICAgICAgICAgICAgICBwYXRoOiBbZGlzY3JpbWluYXRvcl0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVV0aWxfanNfMS5JTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9uLl9wYXJzZUFzeW5jKHtcbiAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbi5fcGFyc2VTeW5jKHtcbiAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBkaXNjcmltaW5hdG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmRpc2NyaW1pbmF0b3I7XG4gICAgfVxuICAgIGdldCBvcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLm9wdGlvbnM7XG4gICAgfVxuICAgIGdldCBvcHRpb25zTWFwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLm9wdGlvbnNNYXA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgZGlzY3JpbWluYXRlZCB1bmlvbiBzY2hlbWEuIEl0cyBiZWhhdmlvdXIgaXMgdmVyeSBzaW1pbGFyIHRvIHRoYXQgb2YgdGhlIG5vcm1hbCB6LnVuaW9uKCkgY29uc3RydWN0b3IuXG4gICAgICogSG93ZXZlciwgaXQgb25seSBhbGxvd3MgYSB1bmlvbiBvZiBvYmplY3RzLCBhbGwgb2Ygd2hpY2ggbmVlZCB0byBzaGFyZSBhIGRpc2NyaW1pbmF0b3IgcHJvcGVydHkuIFRoaXMgcHJvcGVydHkgbXVzdFxuICAgICAqIGhhdmUgYSBkaWZmZXJlbnQgdmFsdWUgZm9yIGVhY2ggb2JqZWN0IGluIHRoZSB1bmlvbi5cbiAgICAgKiBAcGFyYW0gZGlzY3JpbWluYXRvciB0aGUgbmFtZSBvZiB0aGUgZGlzY3JpbWluYXRvciBwcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB0eXBlcyBhbiBhcnJheSBvZiBvYmplY3Qgc2NoZW1hc1xuICAgICAqIEBwYXJhbSBwYXJhbXNcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKGRpc2NyaW1pbmF0b3IsIG9wdGlvbnMsIHBhcmFtcykge1xuICAgICAgICAvLyBHZXQgYWxsIHRoZSB2YWxpZCBkaXNjcmltaW5hdG9yIHZhbHVlc1xuICAgICAgICBjb25zdCBvcHRpb25zTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyB0cnkge1xuICAgICAgICBmb3IgKGNvbnN0IHR5cGUgb2Ygb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgZGlzY3JpbWluYXRvclZhbHVlcyA9IGdldERpc2NyaW1pbmF0b3IodHlwZS5zaGFwZVtkaXNjcmltaW5hdG9yXSk7XG4gICAgICAgICAgICBpZiAoIWRpc2NyaW1pbmF0b3JWYWx1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBIGRpc2NyaW1pbmF0b3IgdmFsdWUgZm9yIGtleSBcXGAke2Rpc2NyaW1pbmF0b3J9XFxgIGNvdWxkIG5vdCBiZSBleHRyYWN0ZWQgZnJvbSBhbGwgc2NoZW1hIG9wdGlvbnNgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgZGlzY3JpbWluYXRvclZhbHVlcykge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zTWFwLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEaXNjcmltaW5hdG9yIHByb3BlcnR5ICR7U3RyaW5nKGRpc2NyaW1pbmF0b3IpfSBoYXMgZHVwbGljYXRlIHZhbHVlICR7U3RyaW5nKHZhbHVlKX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3B0aW9uc01hcC5zZXQodmFsdWUsIHR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgWm9kRGlzY3JpbWluYXRlZFVuaW9uKHtcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRGlzY3JpbWluYXRlZFVuaW9uLFxuICAgICAgICAgICAgZGlzY3JpbWluYXRvcixcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICBvcHRpb25zTWFwLFxuICAgICAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLlpvZERpc2NyaW1pbmF0ZWRVbmlvbiA9IFpvZERpc2NyaW1pbmF0ZWRVbmlvbjtcbmZ1bmN0aW9uIG1lcmdlVmFsdWVzKGEsIGIpIHtcbiAgICBjb25zdCBhVHlwZSA9ICgwLCB1dGlsX2pzXzEuZ2V0UGFyc2VkVHlwZSkoYSk7XG4gICAgY29uc3QgYlR5cGUgPSAoMCwgdXRpbF9qc18xLmdldFBhcnNlZFR5cGUpKGIpO1xuICAgIGlmIChhID09PSBiKSB7XG4gICAgICAgIHJldHVybiB7IHZhbGlkOiB0cnVlLCBkYXRhOiBhIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGFUeXBlID09PSB1dGlsX2pzXzEuWm9kUGFyc2VkVHlwZS5vYmplY3QgJiYgYlR5cGUgPT09IHV0aWxfanNfMS5ab2RQYXJzZWRUeXBlLm9iamVjdCkge1xuICAgICAgICBjb25zdCBiS2V5cyA9IHV0aWxfanNfMS51dGlsLm9iamVjdEtleXMoYik7XG4gICAgICAgIGNvbnN0IHNoYXJlZEtleXMgPSB1dGlsX2pzXzEudXRpbC5vYmplY3RLZXlzKGEpLmZpbHRlcigoa2V5KSA9PiBiS2V5cy5pbmRleE9mKGtleSkgIT09IC0xKTtcbiAgICAgICAgY29uc3QgbmV3T2JqID0geyAuLi5hLCAuLi5iIH07XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHNoYXJlZEtleXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHNoYXJlZFZhbHVlID0gbWVyZ2VWYWx1ZXMoYVtrZXldLCBiW2tleV0pO1xuICAgICAgICAgICAgaWYgKCFzaGFyZWRWYWx1ZS52YWxpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3T2JqW2tleV0gPSBzaGFyZWRWYWx1ZS5kYXRhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHZhbGlkOiB0cnVlLCBkYXRhOiBuZXdPYmogfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYVR5cGUgPT09IHV0aWxfanNfMS5ab2RQYXJzZWRUeXBlLmFycmF5ICYmIGJUeXBlID09PSB1dGlsX2pzXzEuWm9kUGFyc2VkVHlwZS5hcnJheSkge1xuICAgICAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdBcnJheSA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgYS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1BID0gYVtpbmRleF07XG4gICAgICAgICAgICBjb25zdCBpdGVtQiA9IGJbaW5kZXhdO1xuICAgICAgICAgICAgY29uc3Qgc2hhcmVkVmFsdWUgPSBtZXJnZVZhbHVlcyhpdGVtQSwgaXRlbUIpO1xuICAgICAgICAgICAgaWYgKCFzaGFyZWRWYWx1ZS52YWxpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3QXJyYXkucHVzaChzaGFyZWRWYWx1ZS5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB2YWxpZDogdHJ1ZSwgZGF0YTogbmV3QXJyYXkgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYVR5cGUgPT09IHV0aWxfanNfMS5ab2RQYXJzZWRUeXBlLmRhdGUgJiYgYlR5cGUgPT09IHV0aWxfanNfMS5ab2RQYXJzZWRUeXBlLmRhdGUgJiYgK2EgPT09ICtiKSB7XG4gICAgICAgIHJldHVybiB7IHZhbGlkOiB0cnVlLCBkYXRhOiBhIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UgfTtcbiAgICB9XG59XG5jbGFzcyBab2RJbnRlcnNlY3Rpb24gZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgY29uc3QgaGFuZGxlUGFyc2VkID0gKHBhcnNlZExlZnQsIHBhcnNlZFJpZ2h0KSA9PiB7XG4gICAgICAgICAgICBpZiAoKDAsIHBhcnNlVXRpbF9qc18xLmlzQWJvcnRlZCkocGFyc2VkTGVmdCkgfHwgKDAsIHBhcnNlVXRpbF9qc18xLmlzQWJvcnRlZCkocGFyc2VkUmlnaHQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlVXRpbF9qc18xLklOVkFMSUQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtZXJnZWQgPSBtZXJnZVZhbHVlcyhwYXJzZWRMZWZ0LnZhbHVlLCBwYXJzZWRSaWdodC52YWx1ZSk7XG4gICAgICAgICAgICBpZiAoIW1lcmdlZC52YWxpZCkge1xuICAgICAgICAgICAgICAgICgwLCBwYXJzZVV0aWxfanNfMS5hZGRJc3N1ZVRvQ29udGV4dCkoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZEVycm9yX2pzXzEuWm9kSXNzdWVDb2RlLmludmFsaWRfaW50ZXJzZWN0aW9uX3R5cGVzLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZVV0aWxfanNfMS5JTlZBTElEO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCgwLCBwYXJzZVV0aWxfanNfMS5pc0RpcnR5KShwYXJzZWRMZWZ0KSB8fCAoMCwgcGFyc2VVdGlsX2pzXzEuaXNEaXJ0eSkocGFyc2VkUmlnaHQpKSB7XG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IG1lcmdlZC5kYXRhIH07XG4gICAgICAgIH07XG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgIHRoaXMuX2RlZi5sZWZ0Ll9wYXJzZUFzeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWYucmlnaHQuX3BhcnNlQXN5bmMoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgXSkudGhlbigoW2xlZnQsIHJpZ2h0XSkgPT4gaGFuZGxlUGFyc2VkKGxlZnQsIHJpZ2h0KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlUGFyc2VkKHRoaXMuX2RlZi5sZWZ0Ll9wYXJzZVN5bmMoe1xuICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgfSksIHRoaXMuX2RlZi5yaWdodC5fcGFyc2VTeW5jKHtcbiAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuWm9kSW50ZXJzZWN0aW9uID0gWm9kSW50ZXJzZWN0aW9uO1xuWm9kSW50ZXJzZWN0aW9uLmNyZWF0ZSA9IChsZWZ0LCByaWdodCwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RJbnRlcnNlY3Rpb24oe1xuICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICByaWdodDogcmlnaHQsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kSW50ZXJzZWN0aW9uLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuLy8gdHlwZSBab2RUdXBsZUl0ZW1zID0gW1pvZFR5cGVBbnksIC4uLlpvZFR5cGVBbnlbXV07XG5jbGFzcyBab2RUdXBsZSBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBpZiAoY3R4LnBhcnNlZFR5cGUgIT09IHV0aWxfanNfMS5ab2RQYXJzZWRUeXBlLmFycmF5KSB7XG4gICAgICAgICAgICAoMCwgcGFyc2VVdGlsX2pzXzEuYWRkSXNzdWVUb0NvbnRleHQpKGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZEVycm9yX2pzXzEuWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogdXRpbF9qc18xLlpvZFBhcnNlZFR5cGUuYXJyYXksXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VVdGlsX2pzXzEuSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3R4LmRhdGEubGVuZ3RoIDwgdGhpcy5fZGVmLml0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgKDAsIHBhcnNlVXRpbF9qc18xLmFkZElzc3VlVG9Db250ZXh0KShjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RFcnJvcl9qc18xLlpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgICAgICAgbWluaW11bTogdGhpcy5fZGVmLml0ZW1zLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlVXRpbF9qc18xLklOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdCA9IHRoaXMuX2RlZi5yZXN0O1xuICAgICAgICBpZiAoIXJlc3QgJiYgY3R4LmRhdGEubGVuZ3RoID4gdGhpcy5fZGVmLml0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgKDAsIHBhcnNlVXRpbF9qc18xLmFkZElzc3VlVG9Db250ZXh0KShjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RFcnJvcl9qc18xLlpvZElzc3VlQ29kZS50b29fYmlnLFxuICAgICAgICAgICAgICAgIG1heGltdW06IHRoaXMuX2RlZi5pdGVtcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGl0ZW1zID0gWy4uLmN0eC5kYXRhXVxuICAgICAgICAgICAgLm1hcCgoaXRlbSwgaXRlbUluZGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzY2hlbWEgPSB0aGlzLl9kZWYuaXRlbXNbaXRlbUluZGV4XSB8fCB0aGlzLl9kZWYucmVzdDtcbiAgICAgICAgICAgIGlmICghc2NoZW1hKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHNjaGVtYS5fcGFyc2UobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIGl0ZW0sIGN0eC5wYXRoLCBpdGVtSW5kZXgpKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5maWx0ZXIoKHgpID0+ICEheCk7IC8vIGZpbHRlciBudWxsc1xuICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGl0ZW1zKS50aGVuKChyZXN1bHRzKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlVXRpbF9qc18xLlBhcnNlU3RhdHVzLm1lcmdlQXJyYXkoc3RhdHVzLCByZXN1bHRzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlVXRpbF9qc18xLlBhcnNlU3RhdHVzLm1lcmdlQXJyYXkoc3RhdHVzLCBpdGVtcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGl0ZW1zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLml0ZW1zO1xuICAgIH1cbiAgICByZXN0KHJlc3QpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RUdXBsZSh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICByZXN0LFxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLlpvZFR1cGxlID0gWm9kVHVwbGU7XG5ab2RUdXBsZS5jcmVhdGUgPSAoc2NoZW1hcywgcGFyYW1zKSA9PiB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHNjaGVtYXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBtdXN0IHBhc3MgYW4gYXJyYXkgb2Ygc2NoZW1hcyB0byB6LnR1cGxlKFsgLi4uIF0pXCIpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFpvZFR1cGxlKHtcbiAgICAgICAgaXRlbXM6IHNjaGVtYXMsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kVHVwbGUsXG4gICAgICAgIHJlc3Q6IG51bGwsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2RSZWNvcmQgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBnZXQga2V5U2NoZW1hKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmtleVR5cGU7XG4gICAgfVxuICAgIGdldCB2YWx1ZVNjaGVtYSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi52YWx1ZVR5cGU7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBpZiAoY3R4LnBhcnNlZFR5cGUgIT09IHV0aWxfanNfMS5ab2RQYXJzZWRUeXBlLm9iamVjdCkge1xuICAgICAgICAgICAgKDAsIHBhcnNlVXRpbF9qc18xLmFkZElzc3VlVG9Db250ZXh0KShjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RFcnJvcl9qc18xLlpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IHV0aWxfanNfMS5ab2RQYXJzZWRUeXBlLm9iamVjdCxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVV0aWxfanNfMS5JTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhaXJzID0gW107XG4gICAgICAgIGNvbnN0IGtleVR5cGUgPSB0aGlzLl9kZWYua2V5VHlwZTtcbiAgICAgICAgY29uc3QgdmFsdWVUeXBlID0gdGhpcy5fZGVmLnZhbHVlVHlwZTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gY3R4LmRhdGEpIHtcbiAgICAgICAgICAgIHBhaXJzLnB1c2goe1xuICAgICAgICAgICAgICAgIGtleToga2V5VHlwZS5fcGFyc2UobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIGtleSwgY3R4LnBhdGgsIGtleSkpLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVR5cGUuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCBjdHguZGF0YVtrZXldLCBjdHgucGF0aCwga2V5KSksXG4gICAgICAgICAgICAgICAgYWx3YXlzU2V0OiBrZXkgaW4gY3R4LmRhdGEsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlVXRpbF9qc18xLlBhcnNlU3RhdHVzLm1lcmdlT2JqZWN0QXN5bmMoc3RhdHVzLCBwYWlycyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VVdGlsX2pzXzEuUGFyc2VTdGF0dXMubWVyZ2VPYmplY3RTeW5jKHN0YXR1cywgcGFpcnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBlbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnZhbHVlVHlwZTtcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZShmaXJzdCwgc2Vjb25kLCB0aGlyZCkge1xuICAgICAgICBpZiAoc2Vjb25kIGluc3RhbmNlb2YgWm9kVHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBab2RSZWNvcmQoe1xuICAgICAgICAgICAgICAgIGtleVR5cGU6IGZpcnN0LFxuICAgICAgICAgICAgICAgIHZhbHVlVHlwZTogc2Vjb25kLFxuICAgICAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kUmVjb3JkLFxuICAgICAgICAgICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXModGhpcmQpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBab2RSZWNvcmQoe1xuICAgICAgICAgICAga2V5VHlwZTogWm9kU3RyaW5nLmNyZWF0ZSgpLFxuICAgICAgICAgICAgdmFsdWVUeXBlOiBmaXJzdCxcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kUmVjb3JkLFxuICAgICAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhzZWNvbmQpLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLlpvZFJlY29yZCA9IFpvZFJlY29yZDtcbmNsYXNzIFpvZE1hcCBleHRlbmRzIFpvZFR5cGUge1xuICAgIGdldCBrZXlTY2hlbWEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYua2V5VHlwZTtcbiAgICB9XG4gICAgZ2V0IHZhbHVlU2NoZW1hKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnZhbHVlVHlwZTtcbiAgICB9XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gdXRpbF9qc18xLlpvZFBhcnNlZFR5cGUubWFwKSB7XG4gICAgICAgICAgICAoMCwgcGFyc2VVdGlsX2pzXzEuYWRkSXNzdWVUb0NvbnRleHQpKGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZEVycm9yX2pzXzEuWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogdXRpbF9qc18xLlpvZFBhcnNlZFR5cGUubWFwLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlVXRpbF9qc18xLklOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qga2V5VHlwZSA9IHRoaXMuX2RlZi5rZXlUeXBlO1xuICAgICAgICBjb25zdCB2YWx1ZVR5cGUgPSB0aGlzLl9kZWYudmFsdWVUeXBlO1xuICAgICAgICBjb25zdCBwYWlycyA9IFsuLi5jdHguZGF0YS5lbnRyaWVzKCldLm1hcCgoW2tleSwgdmFsdWVdLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBrZXk6IGtleVR5cGUuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCBrZXksIGN0eC5wYXRoLCBbaW5kZXgsIFwia2V5XCJdKSksXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlVHlwZS5fcGFyc2UobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIHZhbHVlLCBjdHgucGF0aCwgW2luZGV4LCBcInZhbHVlXCJdKSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpbmFsTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcGFpciBvZiBwYWlycykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCBwYWlyLmtleTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCBwYWlyLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIgfHwgdmFsdWUuc3RhdHVzID09PSBcImFib3J0ZWRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlVXRpbF9qc18xLklOVkFMSUQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleS5zdGF0dXMgPT09IFwiZGlydHlcIiB8fCB2YWx1ZS5zdGF0dXMgPT09IFwiZGlydHlcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZmluYWxNYXAuc2V0KGtleS52YWx1ZSwgdmFsdWUudmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGZpbmFsTWFwIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGZpbmFsTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBwYWlyIG9mIHBhaXJzKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gcGFpci5rZXk7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBwYWlyLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChrZXkuc3RhdHVzID09PSBcImFib3J0ZWRcIiB8fCB2YWx1ZS5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZVV0aWxfanNfMS5JTlZBTElEO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoa2V5LnN0YXR1cyA9PT0gXCJkaXJ0eVwiIHx8IHZhbHVlLnN0YXR1cyA9PT0gXCJkaXJ0eVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbE1hcC5zZXQoa2V5LnZhbHVlLCB2YWx1ZS52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGZpbmFsTWFwIH07XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLlpvZE1hcCA9IFpvZE1hcDtcblpvZE1hcC5jcmVhdGUgPSAoa2V5VHlwZSwgdmFsdWVUeXBlLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE1hcCh7XG4gICAgICAgIHZhbHVlVHlwZSxcbiAgICAgICAga2V5VHlwZSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RNYXAsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2RTZXQgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSB1dGlsX2pzXzEuWm9kUGFyc2VkVHlwZS5zZXQpIHtcbiAgICAgICAgICAgICgwLCBwYXJzZVV0aWxfanNfMS5hZGRJc3N1ZVRvQ29udGV4dCkoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kRXJyb3JfanNfMS5ab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiB1dGlsX2pzXzEuWm9kUGFyc2VkVHlwZS5zZXQsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VVdGlsX2pzXzEuSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZWYgPSB0aGlzLl9kZWY7XG4gICAgICAgIGlmIChkZWYubWluU2l6ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGN0eC5kYXRhLnNpemUgPCBkZWYubWluU2l6ZS52YWx1ZSkge1xuICAgICAgICAgICAgICAgICgwLCBwYXJzZVV0aWxfanNfMS5hZGRJc3N1ZVRvQ29udGV4dCkoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZEVycm9yX2pzXzEuWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcbiAgICAgICAgICAgICAgICAgICAgbWluaW11bTogZGVmLm1pblNpemUudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic2V0XCIsXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBkZWYubWluU2l6ZS5tZXNzYWdlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkZWYubWF4U2l6ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGN0eC5kYXRhLnNpemUgPiBkZWYubWF4U2l6ZS52YWx1ZSkge1xuICAgICAgICAgICAgICAgICgwLCBwYXJzZVV0aWxfanNfMS5hZGRJc3N1ZVRvQ29udGV4dCkoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZEVycm9yX2pzXzEuWm9kSXNzdWVDb2RlLnRvb19iaWcsXG4gICAgICAgICAgICAgICAgICAgIG1heGltdW06IGRlZi5tYXhTaXplLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInNldFwiLFxuICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZGVmLm1heFNpemUubWVzc2FnZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZVR5cGUgPSB0aGlzLl9kZWYudmFsdWVUeXBlO1xuICAgICAgICBmdW5jdGlvbiBmaW5hbGl6ZVNldChlbGVtZW50cykge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkU2V0ID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGVsZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlVXRpbF9qc18xLklOVkFMSUQ7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuc3RhdHVzID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIHBhcnNlZFNldC5hZGQoZWxlbWVudC52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IHBhcnNlZFNldCB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVsZW1lbnRzID0gWy4uLmN0eC5kYXRhLnZhbHVlcygpXS5tYXAoKGl0ZW0sIGkpID0+IHZhbHVlVHlwZS5fcGFyc2UobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIGl0ZW0sIGN0eC5wYXRoLCBpKSkpO1xuICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGVsZW1lbnRzKS50aGVuKChlbGVtZW50cykgPT4gZmluYWxpemVTZXQoZWxlbWVudHMpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmaW5hbGl6ZVNldChlbGVtZW50cyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbWluKG1pblNpemUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RTZXQoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgbWluU2l6ZTogeyB2YWx1ZTogbWluU2l6ZSwgbWVzc2FnZTogZXJyb3JVdGlsX2pzXzEuZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtYXgobWF4U2l6ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZFNldCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBtYXhTaXplOiB7IHZhbHVlOiBtYXhTaXplLCBtZXNzYWdlOiBlcnJvclV0aWxfanNfMS5lcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNpemUoc2l6ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5taW4oc2l6ZSwgbWVzc2FnZSkubWF4KHNpemUsIG1lc3NhZ2UpO1xuICAgIH1cbiAgICBub25lbXB0eShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbigxLCBtZXNzYWdlKTtcbiAgICB9XG59XG5leHBvcnRzLlpvZFNldCA9IFpvZFNldDtcblpvZFNldC5jcmVhdGUgPSAodmFsdWVUeXBlLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZFNldCh7XG4gICAgICAgIHZhbHVlVHlwZSxcbiAgICAgICAgbWluU2l6ZTogbnVsbCxcbiAgICAgICAgbWF4U2l6ZTogbnVsbCxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RTZXQsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2RGdW5jdGlvbiBleHRlbmRzIFpvZFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnZhbGlkYXRlID0gdGhpcy5pbXBsZW1lbnQ7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSB1dGlsX2pzXzEuWm9kUGFyc2VkVHlwZS5mdW5jdGlvbikge1xuICAgICAgICAgICAgKDAsIHBhcnNlVXRpbF9qc18xLmFkZElzc3VlVG9Db250ZXh0KShjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RFcnJvcl9qc18xLlpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IHV0aWxfanNfMS5ab2RQYXJzZWRUeXBlLmZ1bmN0aW9uLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlVXRpbF9qc18xLklOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbWFrZUFyZ3NJc3N1ZShhcmdzLCBlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBwYXJzZVV0aWxfanNfMS5tYWtlSXNzdWUpKHtcbiAgICAgICAgICAgICAgICBkYXRhOiBhcmdzLFxuICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgIGVycm9yTWFwczogW2N0eC5jb21tb24uY29udGV4dHVhbEVycm9yTWFwLCBjdHguc2NoZW1hRXJyb3JNYXAsICgwLCBlcnJvcnNfanNfMS5nZXRFcnJvck1hcCkoKSwgZXJyb3JzX2pzXzEuZGVmYXVsdEVycm9yTWFwXS5maWx0ZXIoKHgpID0+ICEheCksXG4gICAgICAgICAgICAgICAgaXNzdWVEYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZEVycm9yX2pzXzEuWm9kSXNzdWVDb2RlLmludmFsaWRfYXJndW1lbnRzLFxuICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHNFcnJvcjogZXJyb3IsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG1ha2VSZXR1cm5zSXNzdWUocmV0dXJucywgZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgcGFyc2VVdGlsX2pzXzEubWFrZUlzc3VlKSh7XG4gICAgICAgICAgICAgICAgZGF0YTogcmV0dXJucyxcbiAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICBlcnJvck1hcHM6IFtjdHguY29tbW9uLmNvbnRleHR1YWxFcnJvck1hcCwgY3R4LnNjaGVtYUVycm9yTWFwLCAoMCwgZXJyb3JzX2pzXzEuZ2V0RXJyb3JNYXApKCksIGVycm9yc19qc18xLmRlZmF1bHRFcnJvck1hcF0uZmlsdGVyKCh4KSA9PiAhIXgpLFxuICAgICAgICAgICAgICAgIGlzc3VlRGF0YToge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RFcnJvcl9qc18xLlpvZElzc3VlQ29kZS5pbnZhbGlkX3JldHVybl90eXBlLFxuICAgICAgICAgICAgICAgICAgICByZXR1cm5UeXBlRXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJhbXMgPSB7IGVycm9yTWFwOiBjdHguY29tbW9uLmNvbnRleHR1YWxFcnJvck1hcCB9O1xuICAgICAgICBjb25zdCBmbiA9IGN0eC5kYXRhO1xuICAgICAgICBpZiAodGhpcy5fZGVmLnJldHVybnMgaW5zdGFuY2VvZiBab2RQcm9taXNlKSB7XG4gICAgICAgICAgICAvLyBXb3VsZCBsb3ZlIGEgd2F5IHRvIGF2b2lkIGRpc2FibGluZyB0aGlzIHJ1bGUsIGJ1dCB3ZSBuZWVkXG4gICAgICAgICAgICAvLyBhbiBhbGlhcyAodXNpbmcgYW4gYXJyb3cgZnVuY3Rpb24gd2FzIHdoYXQgY2F1c2VkIDI2NTEpLlxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby10aGlzLWFsaWFzXG4gICAgICAgICAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gKDAsIHBhcnNlVXRpbF9qc18xLk9LKShhc3luYyBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IFpvZEVycm9yX2pzXzEuWm9kRXJyb3IoW10pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZEFyZ3MgPSBhd2FpdCBtZS5fZGVmLmFyZ3MucGFyc2VBc3luYyhhcmdzLCBwYXJhbXMpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLmFkZElzc3VlKG1ha2VBcmdzSXNzdWUoYXJncywgZSkpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBSZWZsZWN0LmFwcGx5KGZuLCB0aGlzLCBwYXJzZWRBcmdzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRSZXR1cm5zID0gYXdhaXQgbWUuX2RlZi5yZXR1cm5zLl9kZWYudHlwZVxuICAgICAgICAgICAgICAgICAgICAucGFyc2VBc3luYyhyZXN1bHQsIHBhcmFtcylcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLmFkZElzc3VlKG1ha2VSZXR1cm5zSXNzdWUocmVzdWx0LCBlKSk7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZWRSZXR1cm5zO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBXb3VsZCBsb3ZlIGEgd2F5IHRvIGF2b2lkIGRpc2FibGluZyB0aGlzIHJ1bGUsIGJ1dCB3ZSBuZWVkXG4gICAgICAgICAgICAvLyBhbiBhbGlhcyAodXNpbmcgYW4gYXJyb3cgZnVuY3Rpb24gd2FzIHdoYXQgY2F1c2VkIDI2NTEpLlxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby10aGlzLWFsaWFzXG4gICAgICAgICAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gKDAsIHBhcnNlVXRpbF9qc18xLk9LKShmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZEFyZ3MgPSBtZS5fZGVmLmFyZ3Muc2FmZVBhcnNlKGFyZ3MsIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJzZWRBcmdzLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFpvZEVycm9yX2pzXzEuWm9kRXJyb3IoW21ha2VBcmdzSXNzdWUoYXJncywgcGFyc2VkQXJncy5lcnJvcildKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gUmVmbGVjdC5hcHBseShmbiwgdGhpcywgcGFyc2VkQXJncy5kYXRhKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRSZXR1cm5zID0gbWUuX2RlZi5yZXR1cm5zLnNhZmVQYXJzZShyZXN1bHQsIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJzZWRSZXR1cm5zLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFpvZEVycm9yX2pzXzEuWm9kRXJyb3IoW21ha2VSZXR1cm5zSXNzdWUocmVzdWx0LCBwYXJzZWRSZXR1cm5zLmVycm9yKV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VkUmV0dXJucy5kYXRhO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcGFyYW1ldGVycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5hcmdzO1xuICAgIH1cbiAgICByZXR1cm5UeXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnJldHVybnM7XG4gICAgfVxuICAgIGFyZ3MoLi4uaXRlbXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RGdW5jdGlvbih7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBhcmdzOiBab2RUdXBsZS5jcmVhdGUoaXRlbXMpLnJlc3QoWm9kVW5rbm93bi5jcmVhdGUoKSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm5zKHJldHVyblR5cGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RGdW5jdGlvbih7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICByZXR1cm5zOiByZXR1cm5UeXBlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaW1wbGVtZW50KGZ1bmMpIHtcbiAgICAgICAgY29uc3QgdmFsaWRhdGVkRnVuYyA9IHRoaXMucGFyc2UoZnVuYyk7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZWRGdW5jO1xuICAgIH1cbiAgICBzdHJpY3RJbXBsZW1lbnQoZnVuYykge1xuICAgICAgICBjb25zdCB2YWxpZGF0ZWRGdW5jID0gdGhpcy5wYXJzZShmdW5jKTtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlZEZ1bmM7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGUoYXJncywgcmV0dXJucywgcGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kRnVuY3Rpb24oe1xuICAgICAgICAgICAgYXJnczogKGFyZ3MgPyBhcmdzIDogWm9kVHVwbGUuY3JlYXRlKFtdKS5yZXN0KFpvZFVua25vd24uY3JlYXRlKCkpKSxcbiAgICAgICAgICAgIHJldHVybnM6IHJldHVybnMgfHwgWm9kVW5rbm93bi5jcmVhdGUoKSxcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRnVuY3Rpb24sXG4gICAgICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuWm9kRnVuY3Rpb24gPSBab2RGdW5jdGlvbjtcbmNsYXNzIFpvZExhenkgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBnZXQgc2NoZW1hKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmdldHRlcigpO1xuICAgIH1cbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGNvbnN0IGxhenlTY2hlbWEgPSB0aGlzLl9kZWYuZ2V0dGVyKCk7XG4gICAgICAgIHJldHVybiBsYXp5U2NoZW1hLl9wYXJzZSh7IGRhdGE6IGN0eC5kYXRhLCBwYXRoOiBjdHgucGF0aCwgcGFyZW50OiBjdHggfSk7XG4gICAgfVxufVxuZXhwb3J0cy5ab2RMYXp5ID0gWm9kTGF6eTtcblpvZExhenkuY3JlYXRlID0gKGdldHRlciwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RMYXp5KHtcbiAgICAgICAgZ2V0dGVyOiBnZXR0ZXIsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTGF6eSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZExpdGVyYWwgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgaWYgKGlucHV0LmRhdGEgIT09IHRoaXMuX2RlZi52YWx1ZSkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgKDAsIHBhcnNlVXRpbF9qc18xLmFkZElzc3VlVG9Db250ZXh0KShjdHgsIHtcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgY29kZTogWm9kRXJyb3JfanNfMS5ab2RJc3N1ZUNvZGUuaW52YWxpZF9saXRlcmFsLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiB0aGlzLl9kZWYudmFsdWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVV0aWxfanNfMS5JTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHN0YXR1czogXCJ2YWxpZFwiLCB2YWx1ZTogaW5wdXQuZGF0YSB9O1xuICAgIH1cbiAgICBnZXQgdmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudmFsdWU7XG4gICAgfVxufVxuZXhwb3J0cy5ab2RMaXRlcmFsID0gWm9kTGl0ZXJhbDtcblpvZExpdGVyYWwuY3JlYXRlID0gKHZhbHVlLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZExpdGVyYWwoe1xuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTGl0ZXJhbCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmZ1bmN0aW9uIGNyZWF0ZVpvZEVudW0odmFsdWVzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IFpvZEVudW0oe1xuICAgICAgICB2YWx1ZXMsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRW51bSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuY2xhc3MgWm9kRW51bSBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0LmRhdGEgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkVmFsdWVzID0gdGhpcy5fZGVmLnZhbHVlcztcbiAgICAgICAgICAgICgwLCBwYXJzZVV0aWxfanNfMS5hZGRJc3N1ZVRvQ29udGV4dCkoY3R4LCB7XG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IHV0aWxfanNfMS51dGlsLmpvaW5WYWx1ZXMoZXhwZWN0ZWRWYWx1ZXMpLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RFcnJvcl9qc18xLlpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVV0aWxfanNfMS5JTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fY2FjaGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlID0gbmV3IFNldCh0aGlzLl9kZWYudmFsdWVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2NhY2hlLmhhcyhpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRWYWx1ZXMgPSB0aGlzLl9kZWYudmFsdWVzO1xuICAgICAgICAgICAgKDAsIHBhcnNlVXRpbF9qc18xLmFkZElzc3VlVG9Db250ZXh0KShjdHgsIHtcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgY29kZTogWm9kRXJyb3JfanNfMS5ab2RJc3N1ZUNvZGUuaW52YWxpZF9lbnVtX3ZhbHVlLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGV4cGVjdGVkVmFsdWVzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VVdGlsX2pzXzEuSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKDAsIHBhcnNlVXRpbF9qc18xLk9LKShpbnB1dC5kYXRhKTtcbiAgICB9XG4gICAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudmFsdWVzO1xuICAgIH1cbiAgICBnZXQgZW51bSgpIHtcbiAgICAgICAgY29uc3QgZW51bVZhbHVlcyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IHZhbCBvZiB0aGlzLl9kZWYudmFsdWVzKSB7XG4gICAgICAgICAgICBlbnVtVmFsdWVzW3ZhbF0gPSB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVudW1WYWx1ZXM7XG4gICAgfVxuICAgIGdldCBWYWx1ZXMoKSB7XG4gICAgICAgIGNvbnN0IGVudW1WYWx1ZXMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCB2YWwgb2YgdGhpcy5fZGVmLnZhbHVlcykge1xuICAgICAgICAgICAgZW51bVZhbHVlc1t2YWxdID0gdmFsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbnVtVmFsdWVzO1xuICAgIH1cbiAgICBnZXQgRW51bSgpIHtcbiAgICAgICAgY29uc3QgZW51bVZhbHVlcyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IHZhbCBvZiB0aGlzLl9kZWYudmFsdWVzKSB7XG4gICAgICAgICAgICBlbnVtVmFsdWVzW3ZhbF0gPSB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVudW1WYWx1ZXM7XG4gICAgfVxuICAgIGV4dHJhY3QodmFsdWVzLCBuZXdEZWYgPSB0aGlzLl9kZWYpIHtcbiAgICAgICAgcmV0dXJuIFpvZEVudW0uY3JlYXRlKHZhbHVlcywge1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgLi4ubmV3RGVmLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZXhjbHVkZSh2YWx1ZXMsIG5ld0RlZiA9IHRoaXMuX2RlZikge1xuICAgICAgICByZXR1cm4gWm9kRW51bS5jcmVhdGUodGhpcy5vcHRpb25zLmZpbHRlcigob3B0KSA9PiAhdmFsdWVzLmluY2x1ZGVzKG9wdCkpLCB7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICAuLi5uZXdEZWYsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuWm9kRW51bSA9IFpvZEVudW07XG5ab2RFbnVtLmNyZWF0ZSA9IGNyZWF0ZVpvZEVudW07XG5jbGFzcyBab2ROYXRpdmVFbnVtIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IG5hdGl2ZUVudW1WYWx1ZXMgPSB1dGlsX2pzXzEudXRpbC5nZXRWYWxpZEVudW1WYWx1ZXModGhpcy5fZGVmLnZhbHVlcyk7XG4gICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSB1dGlsX2pzXzEuWm9kUGFyc2VkVHlwZS5zdHJpbmcgJiYgY3R4LnBhcnNlZFR5cGUgIT09IHV0aWxfanNfMS5ab2RQYXJzZWRUeXBlLm51bWJlcikge1xuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRWYWx1ZXMgPSB1dGlsX2pzXzEudXRpbC5vYmplY3RWYWx1ZXMobmF0aXZlRW51bVZhbHVlcyk7XG4gICAgICAgICAgICAoMCwgcGFyc2VVdGlsX2pzXzEuYWRkSXNzdWVUb0NvbnRleHQpKGN0eCwge1xuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiB1dGlsX2pzXzEudXRpbC5qb2luVmFsdWVzKGV4cGVjdGVkVmFsdWVzKSxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICAgICAgY29kZTogWm9kRXJyb3JfanNfMS5ab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VVdGlsX2pzXzEuSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2NhY2hlKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZSA9IG5ldyBTZXQodXRpbF9qc18xLnV0aWwuZ2V0VmFsaWRFbnVtVmFsdWVzKHRoaXMuX2RlZi52YWx1ZXMpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2NhY2hlLmhhcyhpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRWYWx1ZXMgPSB1dGlsX2pzXzEudXRpbC5vYmplY3RWYWx1ZXMobmF0aXZlRW51bVZhbHVlcyk7XG4gICAgICAgICAgICAoMCwgcGFyc2VVdGlsX2pzXzEuYWRkSXNzdWVUb0NvbnRleHQpKGN0eCwge1xuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RFcnJvcl9qc18xLlpvZElzc3VlQ29kZS5pbnZhbGlkX2VudW1fdmFsdWUsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogZXhwZWN0ZWRWYWx1ZXMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVV0aWxfanNfMS5JTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoMCwgcGFyc2VVdGlsX2pzXzEuT0spKGlucHV0LmRhdGEpO1xuICAgIH1cbiAgICBnZXQgZW51bSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi52YWx1ZXM7XG4gICAgfVxufVxuZXhwb3J0cy5ab2ROYXRpdmVFbnVtID0gWm9kTmF0aXZlRW51bTtcblpvZE5hdGl2ZUVudW0uY3JlYXRlID0gKHZhbHVlcywgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2ROYXRpdmVFbnVtKHtcbiAgICAgICAgdmFsdWVzOiB2YWx1ZXMsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTmF0aXZlRW51bSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZFByb21pc2UgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICB1bndyYXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudHlwZTtcbiAgICB9XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBpZiAoY3R4LnBhcnNlZFR5cGUgIT09IHV0aWxfanNfMS5ab2RQYXJzZWRUeXBlLnByb21pc2UgJiYgY3R4LmNvbW1vbi5hc3luYyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICgwLCBwYXJzZVV0aWxfanNfMS5hZGRJc3N1ZVRvQ29udGV4dCkoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kRXJyb3JfanNfMS5ab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiB1dGlsX2pzXzEuWm9kUGFyc2VkVHlwZS5wcm9taXNlLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlVXRpbF9qc18xLklOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJvbWlzaWZpZWQgPSBjdHgucGFyc2VkVHlwZSA9PT0gdXRpbF9qc18xLlpvZFBhcnNlZFR5cGUucHJvbWlzZSA/IGN0eC5kYXRhIDogUHJvbWlzZS5yZXNvbHZlKGN0eC5kYXRhKTtcbiAgICAgICAgcmV0dXJuICgwLCBwYXJzZVV0aWxfanNfMS5PSykocHJvbWlzaWZpZWQudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi50eXBlLnBhcnNlQXN5bmMoZGF0YSwge1xuICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgIGVycm9yTWFwOiBjdHguY29tbW9uLmNvbnRleHR1YWxFcnJvck1hcCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KSk7XG4gICAgfVxufVxuZXhwb3J0cy5ab2RQcm9taXNlID0gWm9kUHJvbWlzZTtcblpvZFByb21pc2UuY3JlYXRlID0gKHNjaGVtYSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RQcm9taXNlKHtcbiAgICAgICAgdHlwZTogc2NoZW1hLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFByb21pc2UsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2RFZmZlY3RzIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgaW5uZXJUeXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnNjaGVtYTtcbiAgICB9XG4gICAgc291cmNlVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5zY2hlbWEuX2RlZi50eXBlTmFtZSA9PT0gWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEVmZmVjdHNcbiAgICAgICAgICAgID8gdGhpcy5fZGVmLnNjaGVtYS5zb3VyY2VUeXBlKClcbiAgICAgICAgICAgIDogdGhpcy5fZGVmLnNjaGVtYTtcbiAgICB9XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGNvbnN0IGVmZmVjdCA9IHRoaXMuX2RlZi5lZmZlY3QgfHwgbnVsbDtcbiAgICAgICAgY29uc3QgY2hlY2tDdHggPSB7XG4gICAgICAgICAgICBhZGRJc3N1ZTogKGFyZykgPT4ge1xuICAgICAgICAgICAgICAgICgwLCBwYXJzZVV0aWxfanNfMS5hZGRJc3N1ZVRvQ29udGV4dCkoY3R4LCBhcmcpO1xuICAgICAgICAgICAgICAgIGlmIChhcmcuZmF0YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmFib3J0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IHBhdGgoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN0eC5wYXRoO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgY2hlY2tDdHguYWRkSXNzdWUgPSBjaGVja0N0eC5hZGRJc3N1ZS5iaW5kKGNoZWNrQ3R4KTtcbiAgICAgICAgaWYgKGVmZmVjdC50eXBlID09PSBcInByZXByb2Nlc3NcIikge1xuICAgICAgICAgICAgY29uc3QgcHJvY2Vzc2VkID0gZWZmZWN0LnRyYW5zZm9ybShjdHguZGF0YSwgY2hlY2tDdHgpO1xuICAgICAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHByb2Nlc3NlZCkudGhlbihhc3luYyAocHJvY2Vzc2VkKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0dXMudmFsdWUgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlVXRpbF9qc18xLklOVkFMSUQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuX2RlZi5zY2hlbWEuX3BhcnNlQXN5bmMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogcHJvY2Vzc2VkLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZVV0aWxfanNfMS5JTlZBTElEO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgwLCBwYXJzZVV0aWxfanNfMS5ESVJUWSkocmVzdWx0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1cy52YWx1ZSA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgwLCBwYXJzZVV0aWxfanNfMS5ESVJUWSkocmVzdWx0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChzdGF0dXMudmFsdWUgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VVdGlsX2pzXzEuSU5WQUxJRDtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9kZWYuc2NoZW1hLl9wYXJzZVN5bmMoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBwcm9jZXNzZWQsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZVV0aWxfanNfMS5JTlZBTElEO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuc3RhdHVzID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoMCwgcGFyc2VVdGlsX2pzXzEuRElSVFkpKHJlc3VsdC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cy52YWx1ZSA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKDAsIHBhcnNlVXRpbF9qc18xLkRJUlRZKShyZXN1bHQudmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVmZmVjdC50eXBlID09PSBcInJlZmluZW1lbnRcIikge1xuICAgICAgICAgICAgY29uc3QgZXhlY3V0ZVJlZmluZW1lbnQgPSAoYWNjKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gZWZmZWN0LnJlZmluZW1lbnQoYWNjLCBjaGVja0N0eCk7XG4gICAgICAgICAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBc3luYyByZWZpbmVtZW50IGVuY291bnRlcmVkIGR1cmluZyBzeW5jaHJvbm91cyBwYXJzZSBvcGVyYXRpb24uIFVzZSAucGFyc2VBc3luYyBpbnN0ZWFkLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbm5lciA9IHRoaXMuX2RlZi5zY2hlbWEuX3BhcnNlU3luYyh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGlubmVyLnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZVV0aWxfanNfMS5JTlZBTElEO1xuICAgICAgICAgICAgICAgIGlmIChpbm5lci5zdGF0dXMgPT09IFwiZGlydHlcIilcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIHZhbHVlIGlzIGlnbm9yZWRcbiAgICAgICAgICAgICAgICBleGVjdXRlUmVmaW5lbWVudChpbm5lci52YWx1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBpbm5lci52YWx1ZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5zY2hlbWEuX3BhcnNlQXN5bmMoeyBkYXRhOiBjdHguZGF0YSwgcGF0aDogY3R4LnBhdGgsIHBhcmVudDogY3R4IH0pLnRoZW4oKGlubmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbm5lci5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlVXRpbF9qc18xLklOVkFMSUQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbm5lci5zdGF0dXMgPT09IFwiZGlydHlcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXhlY3V0ZVJlZmluZW1lbnQoaW5uZXIudmFsdWUpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBpbm5lci52YWx1ZSB9O1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZWZmZWN0LnR5cGUgPT09IFwidHJhbnNmb3JtXCIpIHtcbiAgICAgICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJhc2UgPSB0aGlzLl9kZWYuc2NoZW1hLl9wYXJzZVN5bmMoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICghKDAsIHBhcnNlVXRpbF9qc18xLmlzVmFsaWQpKGJhc2UpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VVdGlsX2pzXzEuSU5WQUxJRDtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBlZmZlY3QudHJhbnNmb3JtKGJhc2UudmFsdWUsIGNoZWNrQ3R4KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFzeW5jaHJvbm91cyB0cmFuc2Zvcm0gZW5jb3VudGVyZWQgZHVyaW5nIHN5bmNocm9ub3VzIHBhcnNlIG9wZXJhdGlvbi4gVXNlIC5wYXJzZUFzeW5jIGluc3RlYWQuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogcmVzdWx0IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnNjaGVtYS5fcGFyc2VBc3luYyh7IGRhdGE6IGN0eC5kYXRhLCBwYXRoOiBjdHgucGF0aCwgcGFyZW50OiBjdHggfSkudGhlbigoYmFzZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoISgwLCBwYXJzZVV0aWxfanNfMS5pc1ZhbGlkKShiYXNlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZVV0aWxfanNfMS5JTlZBTElEO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGVmZmVjdC50cmFuc2Zvcm0oYmFzZS52YWx1ZSwgY2hlY2tDdHgpKS50aGVuKChyZXN1bHQpID0+ICh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IHN0YXR1cy52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiByZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB1dGlsX2pzXzEudXRpbC5hc3NlcnROZXZlcihlZmZlY3QpO1xuICAgIH1cbn1cbmV4cG9ydHMuWm9kRWZmZWN0cyA9IFpvZEVmZmVjdHM7XG5leHBvcnRzLlpvZFRyYW5zZm9ybWVyID0gWm9kRWZmZWN0cztcblpvZEVmZmVjdHMuY3JlYXRlID0gKHNjaGVtYSwgZWZmZWN0LCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZEVmZmVjdHMoe1xuICAgICAgICBzY2hlbWEsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRWZmZWN0cyxcbiAgICAgICAgZWZmZWN0LFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuWm9kRWZmZWN0cy5jcmVhdGVXaXRoUHJlcHJvY2VzcyA9IChwcmVwcm9jZXNzLCBzY2hlbWEsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kRWZmZWN0cyh7XG4gICAgICAgIHNjaGVtYSxcbiAgICAgICAgZWZmZWN0OiB7IHR5cGU6IFwicHJlcHJvY2Vzc1wiLCB0cmFuc2Zvcm06IHByZXByb2Nlc3MgfSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RFZmZlY3RzLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kT3B0aW9uYWwgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSA9PT0gdXRpbF9qc18xLlpvZFBhcnNlZFR5cGUudW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIHBhcnNlVXRpbF9qc18xLk9LKSh1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlLl9wYXJzZShpbnB1dCk7XG4gICAgfVxuICAgIHVud3JhcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGU7XG4gICAgfVxufVxuZXhwb3J0cy5ab2RPcHRpb25hbCA9IFpvZE9wdGlvbmFsO1xuWm9kT3B0aW9uYWwuY3JlYXRlID0gKHR5cGUsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kT3B0aW9uYWwoe1xuICAgICAgICBpbm5lclR5cGU6IHR5cGUsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kT3B0aW9uYWwsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2ROdWxsYWJsZSBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlID09PSB1dGlsX2pzXzEuWm9kUGFyc2VkVHlwZS5udWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIHBhcnNlVXRpbF9qc18xLk9LKShudWxsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZS5fcGFyc2UoaW5wdXQpO1xuICAgIH1cbiAgICB1bndyYXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlO1xuICAgIH1cbn1cbmV4cG9ydHMuWm9kTnVsbGFibGUgPSBab2ROdWxsYWJsZTtcblpvZE51bGxhYmxlLmNyZWF0ZSA9ICh0eXBlLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE51bGxhYmxlKHtcbiAgICAgICAgaW5uZXJUeXBlOiB0eXBlLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE51bGxhYmxlLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kRGVmYXVsdCBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgbGV0IGRhdGEgPSBjdHguZGF0YTtcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlID09PSB1dGlsX2pzXzEuWm9kUGFyc2VkVHlwZS51bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRhdGEgPSB0aGlzLl9kZWYuZGVmYXVsdFZhbHVlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGUuX3BhcnNlKHtcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVtb3ZlRGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGU7XG4gICAgfVxufVxuZXhwb3J0cy5ab2REZWZhdWx0ID0gWm9kRGVmYXVsdDtcblpvZERlZmF1bHQuY3JlYXRlID0gKHR5cGUsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kRGVmYXVsdCh7XG4gICAgICAgIGlubmVyVHlwZTogdHlwZSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2REZWZhdWx0LFxuICAgICAgICBkZWZhdWx0VmFsdWU6IHR5cGVvZiBwYXJhbXMuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiID8gcGFyYW1zLmRlZmF1bHQgOiAoKSA9PiBwYXJhbXMuZGVmYXVsdCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZENhdGNoIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICAvLyBuZXdDdHggaXMgdXNlZCB0byBub3QgY29sbGVjdCBpc3N1ZXMgZnJvbSBpbm5lciB0eXBlcyBpbiBjdHhcbiAgICAgICAgY29uc3QgbmV3Q3R4ID0ge1xuICAgICAgICAgICAgLi4uY3R4LFxuICAgICAgICAgICAgY29tbW9uOiB7XG4gICAgICAgICAgICAgICAgLi4uY3R4LmNvbW1vbixcbiAgICAgICAgICAgICAgICBpc3N1ZXM6IFtdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fZGVmLmlubmVyVHlwZS5fcGFyc2Uoe1xuICAgICAgICAgICAgZGF0YTogbmV3Q3R4LmRhdGEsXG4gICAgICAgICAgICBwYXRoOiBuZXdDdHgucGF0aCxcbiAgICAgICAgICAgIHBhcmVudDoge1xuICAgICAgICAgICAgICAgIC4uLm5ld0N0eCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoKDAsIHBhcnNlVXRpbF9qc18xLmlzQXN5bmMpKHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBcInZhbGlkXCIsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiByZXN1bHQuc3RhdHVzID09PSBcInZhbGlkXCJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcmVzdWx0LnZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHRoaXMuX2RlZi5jYXRjaFZhbHVlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQgZXJyb3IoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgWm9kRXJyb3JfanNfMS5ab2RFcnJvcihuZXdDdHguY29tbW9uLmlzc3Vlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dDogbmV3Q3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0YXR1czogXCJ2YWxpZFwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiByZXN1bHQuc3RhdHVzID09PSBcInZhbGlkXCJcbiAgICAgICAgICAgICAgICAgICAgPyByZXN1bHQudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLl9kZWYuY2F0Y2hWYWx1ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQgZXJyb3IoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBab2RFcnJvcl9qc18xLlpvZEVycm9yKG5ld0N0eC5jb21tb24uaXNzdWVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dDogbmV3Q3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW1vdmVDYXRjaCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGU7XG4gICAgfVxufVxuZXhwb3J0cy5ab2RDYXRjaCA9IFpvZENhdGNoO1xuWm9kQ2F0Y2guY3JlYXRlID0gKHR5cGUsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kQ2F0Y2goe1xuICAgICAgICBpbm5lclR5cGU6IHR5cGUsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQ2F0Y2gsXG4gICAgICAgIGNhdGNoVmFsdWU6IHR5cGVvZiBwYXJhbXMuY2F0Y2ggPT09IFwiZnVuY3Rpb25cIiA/IHBhcmFtcy5jYXRjaCA6ICgpID0+IHBhcmFtcy5jYXRjaCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZE5hTiBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSB1dGlsX2pzXzEuWm9kUGFyc2VkVHlwZS5uYW4pIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgICgwLCBwYXJzZVV0aWxfanNfMS5hZGRJc3N1ZVRvQ29udGV4dCkoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kRXJyb3JfanNfMS5ab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiB1dGlsX2pzXzEuWm9kUGFyc2VkVHlwZS5uYW4sXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VVdGlsX2pzXzEuSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWU6IGlucHV0LmRhdGEgfTtcbiAgICB9XG59XG5leHBvcnRzLlpvZE5hTiA9IFpvZE5hTjtcblpvZE5hTi5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2ROYU4oe1xuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE5hTixcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmV4cG9ydHMuQlJBTkQgPSBTeW1ib2woXCJ6b2RfYnJhbmRcIik7XG5jbGFzcyBab2RCcmFuZGVkIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBjb25zdCBkYXRhID0gY3R4LmRhdGE7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudHlwZS5fcGFyc2Uoe1xuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB1bndyYXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudHlwZTtcbiAgICB9XG59XG5leHBvcnRzLlpvZEJyYW5kZWQgPSBab2RCcmFuZGVkO1xuY2xhc3MgWm9kUGlwZWxpbmUgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZUFzeW5jID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluUmVzdWx0ID0gYXdhaXQgdGhpcy5fZGVmLmluLl9wYXJzZUFzeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoaW5SZXN1bHQuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlVXRpbF9qc18xLklOVkFMSUQ7XG4gICAgICAgICAgICAgICAgaWYgKGluUmVzdWx0LnN0YXR1cyA9PT0gXCJkaXJ0eVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKDAsIHBhcnNlVXRpbF9qc18xLkRJUlRZKShpblJlc3VsdC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVmLm91dC5fcGFyc2VBc3luYyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBpblJlc3VsdC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlQXN5bmMoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGluUmVzdWx0ID0gdGhpcy5fZGVmLmluLl9wYXJzZVN5bmMoe1xuICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoaW5SZXN1bHQuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VVdGlsX2pzXzEuSU5WQUxJRDtcbiAgICAgICAgICAgIGlmIChpblJlc3VsdC5zdGF0dXMgPT09IFwiZGlydHlcIikge1xuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1czogXCJkaXJ0eVwiLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaW5SZXN1bHQudmFsdWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWYub3V0Ll9wYXJzZVN5bmMoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBpblJlc3VsdC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGUoYSwgYikge1xuICAgICAgICByZXR1cm4gbmV3IFpvZFBpcGVsaW5lKHtcbiAgICAgICAgICAgIGluOiBhLFxuICAgICAgICAgICAgb3V0OiBiLFxuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RQaXBlbGluZSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5ab2RQaXBlbGluZSA9IFpvZFBpcGVsaW5lO1xuY2xhc3MgWm9kUmVhZG9ubHkgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fZGVmLmlubmVyVHlwZS5fcGFyc2UoaW5wdXQpO1xuICAgICAgICBjb25zdCBmcmVlemUgPSAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgaWYgKCgwLCBwYXJzZVV0aWxfanNfMS5pc1ZhbGlkKShkYXRhKSkge1xuICAgICAgICAgICAgICAgIGRhdGEudmFsdWUgPSBPYmplY3QuZnJlZXplKGRhdGEudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiAoMCwgcGFyc2VVdGlsX2pzXzEuaXNBc3luYykocmVzdWx0KSA/IHJlc3VsdC50aGVuKChkYXRhKSA9PiBmcmVlemUoZGF0YSkpIDogZnJlZXplKHJlc3VsdCk7XG4gICAgfVxuICAgIHVud3JhcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGU7XG4gICAgfVxufVxuZXhwb3J0cy5ab2RSZWFkb25seSA9IFpvZFJlYWRvbmx5O1xuWm9kUmVhZG9ubHkuY3JlYXRlID0gKHR5cGUsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kUmVhZG9ubHkoe1xuICAgICAgICBpbm5lclR5cGU6IHR5cGUsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kUmVhZG9ubHksXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8vLy8vLy8vICAgICAgICAgICAgICAgICAgICAvLy8vLy8vLy8vXG4vLy8vLy8vLy8vICAgICAgei5jdXN0b20gICAgICAvLy8vLy8vLy8vXG4vLy8vLy8vLy8vICAgICAgICAgICAgICAgICAgICAvLy8vLy8vLy8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5mdW5jdGlvbiBjbGVhblBhcmFtcyhwYXJhbXMsIGRhdGEpIHtcbiAgICBjb25zdCBwID0gdHlwZW9mIHBhcmFtcyA9PT0gXCJmdW5jdGlvblwiID8gcGFyYW1zKGRhdGEpIDogdHlwZW9mIHBhcmFtcyA9PT0gXCJzdHJpbmdcIiA/IHsgbWVzc2FnZTogcGFyYW1zIH0gOiBwYXJhbXM7XG4gICAgY29uc3QgcDIgPSB0eXBlb2YgcCA9PT0gXCJzdHJpbmdcIiA/IHsgbWVzc2FnZTogcCB9IDogcDtcbiAgICByZXR1cm4gcDI7XG59XG5mdW5jdGlvbiBjdXN0b20oY2hlY2ssIF9wYXJhbXMgPSB7fSwgXG4vKipcbiAqIEBkZXByZWNhdGVkXG4gKlxuICogUGFzcyBgZmF0YWxgIGludG8gdGhlIHBhcmFtcyBvYmplY3QgaW5zdGVhZDpcbiAqXG4gKiBgYGB0c1xuICogei5zdHJpbmcoKS5jdXN0b20oKHZhbCkgPT4gdmFsLmxlbmd0aCA+IDUsIHsgZmF0YWw6IGZhbHNlIH0pXG4gKiBgYGBcbiAqXG4gKi9cbmZhdGFsKSB7XG4gICAgaWYgKGNoZWNrKVxuICAgICAgICByZXR1cm4gWm9kQW55LmNyZWF0ZSgpLnN1cGVyUmVmaW5lKChkYXRhLCBjdHgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHIgPSBjaGVjayhkYXRhKTtcbiAgICAgICAgICAgIGlmIChyIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByLnRoZW4oKHIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJhbXMgPSBjbGVhblBhcmFtcyhfcGFyYW1zLCBkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IF9mYXRhbCA9IHBhcmFtcy5mYXRhbCA/PyBmYXRhbCA/PyB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmFkZElzc3VlKHsgY29kZTogXCJjdXN0b21cIiwgLi4ucGFyYW1zLCBmYXRhbDogX2ZhdGFsIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJhbXMgPSBjbGVhblBhcmFtcyhfcGFyYW1zLCBkYXRhKTtcbiAgICAgICAgICAgICAgICBjb25zdCBfZmF0YWwgPSBwYXJhbXMuZmF0YWwgPz8gZmF0YWwgPz8gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjdHguYWRkSXNzdWUoeyBjb2RlOiBcImN1c3RvbVwiLCAuLi5wYXJhbXMsIGZhdGFsOiBfZmF0YWwgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0pO1xuICAgIHJldHVybiBab2RBbnkuY3JlYXRlKCk7XG59XG5leHBvcnRzLmxhdGUgPSB7XG4gICAgb2JqZWN0OiBab2RPYmplY3QubGF6eWNyZWF0ZSxcbn07XG52YXIgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kO1xuKGZ1bmN0aW9uIChab2RGaXJzdFBhcnR5VHlwZUtpbmQpIHtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RTdHJpbmdcIl0gPSBcIlpvZFN0cmluZ1wiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZE51bWJlclwiXSA9IFwiWm9kTnVtYmVyXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kTmFOXCJdID0gXCJab2ROYU5cIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RCaWdJbnRcIl0gPSBcIlpvZEJpZ0ludFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZEJvb2xlYW5cIl0gPSBcIlpvZEJvb2xlYW5cIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2REYXRlXCJdID0gXCJab2REYXRlXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kU3ltYm9sXCJdID0gXCJab2RTeW1ib2xcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RVbmRlZmluZWRcIl0gPSBcIlpvZFVuZGVmaW5lZFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZE51bGxcIl0gPSBcIlpvZE51bGxcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RBbnlcIl0gPSBcIlpvZEFueVwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFVua25vd25cIl0gPSBcIlpvZFVua25vd25cIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2ROZXZlclwiXSA9IFwiWm9kTmV2ZXJcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RWb2lkXCJdID0gXCJab2RWb2lkXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kQXJyYXlcIl0gPSBcIlpvZEFycmF5XCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kT2JqZWN0XCJdID0gXCJab2RPYmplY3RcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RVbmlvblwiXSA9IFwiWm9kVW5pb25cIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2REaXNjcmltaW5hdGVkVW5pb25cIl0gPSBcIlpvZERpc2NyaW1pbmF0ZWRVbmlvblwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZEludGVyc2VjdGlvblwiXSA9IFwiWm9kSW50ZXJzZWN0aW9uXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kVHVwbGVcIl0gPSBcIlpvZFR1cGxlXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kUmVjb3JkXCJdID0gXCJab2RSZWNvcmRcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RNYXBcIl0gPSBcIlpvZE1hcFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFNldFwiXSA9IFwiWm9kU2V0XCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kRnVuY3Rpb25cIl0gPSBcIlpvZEZ1bmN0aW9uXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kTGF6eVwiXSA9IFwiWm9kTGF6eVwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZExpdGVyYWxcIl0gPSBcIlpvZExpdGVyYWxcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RFbnVtXCJdID0gXCJab2RFbnVtXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kRWZmZWN0c1wiXSA9IFwiWm9kRWZmZWN0c1wiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZE5hdGl2ZUVudW1cIl0gPSBcIlpvZE5hdGl2ZUVudW1cIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RPcHRpb25hbFwiXSA9IFwiWm9kT3B0aW9uYWxcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2ROdWxsYWJsZVwiXSA9IFwiWm9kTnVsbGFibGVcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2REZWZhdWx0XCJdID0gXCJab2REZWZhdWx0XCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kQ2F0Y2hcIl0gPSBcIlpvZENhdGNoXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kUHJvbWlzZVwiXSA9IFwiWm9kUHJvbWlzZVwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZEJyYW5kZWRcIl0gPSBcIlpvZEJyYW5kZWRcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RQaXBlbGluZVwiXSA9IFwiWm9kUGlwZWxpbmVcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RSZWFkb25seVwiXSA9IFwiWm9kUmVhZG9ubHlcIjtcbn0pKFpvZEZpcnN0UGFydHlUeXBlS2luZCB8fCAoZXhwb3J0cy5ab2RGaXJzdFBhcnR5VHlwZUtpbmQgPSBab2RGaXJzdFBhcnR5VHlwZUtpbmQgPSB7fSkpO1xuLy8gcmVxdWlyZXMgVFMgNC40K1xuY2xhc3MgQ2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKC4uLl8pIHsgfVxufVxuY29uc3QgaW5zdGFuY2VPZlR5cGUgPSAoXG4vLyBjb25zdCBpbnN0YW5jZU9mVHlwZSA9IDxUIGV4dGVuZHMgbmV3ICguLi5hcmdzOiBhbnlbXSkgPT4gYW55PihcbmNscywgcGFyYW1zID0ge1xuICAgIG1lc3NhZ2U6IGBJbnB1dCBub3QgaW5zdGFuY2Ugb2YgJHtjbHMubmFtZX1gLFxufSkgPT4gY3VzdG9tKChkYXRhKSA9PiBkYXRhIGluc3RhbmNlb2YgY2xzLCBwYXJhbXMpO1xuZXhwb3J0cy5pbnN0YW5jZW9mID0gaW5zdGFuY2VPZlR5cGU7XG5jb25zdCBzdHJpbmdUeXBlID0gWm9kU3RyaW5nLmNyZWF0ZTtcbmV4cG9ydHMuc3RyaW5nID0gc3RyaW5nVHlwZTtcbmNvbnN0IG51bWJlclR5cGUgPSBab2ROdW1iZXIuY3JlYXRlO1xuZXhwb3J0cy5udW1iZXIgPSBudW1iZXJUeXBlO1xuY29uc3QgbmFuVHlwZSA9IFpvZE5hTi5jcmVhdGU7XG5leHBvcnRzLm5hbiA9IG5hblR5cGU7XG5jb25zdCBiaWdJbnRUeXBlID0gWm9kQmlnSW50LmNyZWF0ZTtcbmV4cG9ydHMuYmlnaW50ID0gYmlnSW50VHlwZTtcbmNvbnN0IGJvb2xlYW5UeXBlID0gWm9kQm9vbGVhbi5jcmVhdGU7XG5leHBvcnRzLmJvb2xlYW4gPSBib29sZWFuVHlwZTtcbmNvbnN0IGRhdGVUeXBlID0gWm9kRGF0ZS5jcmVhdGU7XG5leHBvcnRzLmRhdGUgPSBkYXRlVHlwZTtcbmNvbnN0IHN5bWJvbFR5cGUgPSBab2RTeW1ib2wuY3JlYXRlO1xuZXhwb3J0cy5zeW1ib2wgPSBzeW1ib2xUeXBlO1xuY29uc3QgdW5kZWZpbmVkVHlwZSA9IFpvZFVuZGVmaW5lZC5jcmVhdGU7XG5leHBvcnRzLnVuZGVmaW5lZCA9IHVuZGVmaW5lZFR5cGU7XG5jb25zdCBudWxsVHlwZSA9IFpvZE51bGwuY3JlYXRlO1xuZXhwb3J0cy5udWxsID0gbnVsbFR5cGU7XG5jb25zdCBhbnlUeXBlID0gWm9kQW55LmNyZWF0ZTtcbmV4cG9ydHMuYW55ID0gYW55VHlwZTtcbmNvbnN0IHVua25vd25UeXBlID0gWm9kVW5rbm93bi5jcmVhdGU7XG5leHBvcnRzLnVua25vd24gPSB1bmtub3duVHlwZTtcbmNvbnN0IG5ldmVyVHlwZSA9IFpvZE5ldmVyLmNyZWF0ZTtcbmV4cG9ydHMubmV2ZXIgPSBuZXZlclR5cGU7XG5jb25zdCB2b2lkVHlwZSA9IFpvZFZvaWQuY3JlYXRlO1xuZXhwb3J0cy52b2lkID0gdm9pZFR5cGU7XG5jb25zdCBhcnJheVR5cGUgPSBab2RBcnJheS5jcmVhdGU7XG5leHBvcnRzLmFycmF5ID0gYXJyYXlUeXBlO1xuY29uc3Qgb2JqZWN0VHlwZSA9IFpvZE9iamVjdC5jcmVhdGU7XG5leHBvcnRzLm9iamVjdCA9IG9iamVjdFR5cGU7XG5jb25zdCBzdHJpY3RPYmplY3RUeXBlID0gWm9kT2JqZWN0LnN0cmljdENyZWF0ZTtcbmV4cG9ydHMuc3RyaWN0T2JqZWN0ID0gc3RyaWN0T2JqZWN0VHlwZTtcbmNvbnN0IHVuaW9uVHlwZSA9IFpvZFVuaW9uLmNyZWF0ZTtcbmV4cG9ydHMudW5pb24gPSB1bmlvblR5cGU7XG5jb25zdCBkaXNjcmltaW5hdGVkVW5pb25UeXBlID0gWm9kRGlzY3JpbWluYXRlZFVuaW9uLmNyZWF0ZTtcbmV4cG9ydHMuZGlzY3JpbWluYXRlZFVuaW9uID0gZGlzY3JpbWluYXRlZFVuaW9uVHlwZTtcbmNvbnN0IGludGVyc2VjdGlvblR5cGUgPSBab2RJbnRlcnNlY3Rpb24uY3JlYXRlO1xuZXhwb3J0cy5pbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3Rpb25UeXBlO1xuY29uc3QgdHVwbGVUeXBlID0gWm9kVHVwbGUuY3JlYXRlO1xuZXhwb3J0cy50dXBsZSA9IHR1cGxlVHlwZTtcbmNvbnN0IHJlY29yZFR5cGUgPSBab2RSZWNvcmQuY3JlYXRlO1xuZXhwb3J0cy5yZWNvcmQgPSByZWNvcmRUeXBlO1xuY29uc3QgbWFwVHlwZSA9IFpvZE1hcC5jcmVhdGU7XG5leHBvcnRzLm1hcCA9IG1hcFR5cGU7XG5jb25zdCBzZXRUeXBlID0gWm9kU2V0LmNyZWF0ZTtcbmV4cG9ydHMuc2V0ID0gc2V0VHlwZTtcbmNvbnN0IGZ1bmN0aW9uVHlwZSA9IFpvZEZ1bmN0aW9uLmNyZWF0ZTtcbmV4cG9ydHMuZnVuY3Rpb24gPSBmdW5jdGlvblR5cGU7XG5jb25zdCBsYXp5VHlwZSA9IFpvZExhenkuY3JlYXRlO1xuZXhwb3J0cy5sYXp5ID0gbGF6eVR5cGU7XG5jb25zdCBsaXRlcmFsVHlwZSA9IFpvZExpdGVyYWwuY3JlYXRlO1xuZXhwb3J0cy5saXRlcmFsID0gbGl0ZXJhbFR5cGU7XG5jb25zdCBlbnVtVHlwZSA9IFpvZEVudW0uY3JlYXRlO1xuZXhwb3J0cy5lbnVtID0gZW51bVR5cGU7XG5jb25zdCBuYXRpdmVFbnVtVHlwZSA9IFpvZE5hdGl2ZUVudW0uY3JlYXRlO1xuZXhwb3J0cy5uYXRpdmVFbnVtID0gbmF0aXZlRW51bVR5cGU7XG5jb25zdCBwcm9taXNlVHlwZSA9IFpvZFByb21pc2UuY3JlYXRlO1xuZXhwb3J0cy5wcm9taXNlID0gcHJvbWlzZVR5cGU7XG5jb25zdCBlZmZlY3RzVHlwZSA9IFpvZEVmZmVjdHMuY3JlYXRlO1xuZXhwb3J0cy5lZmZlY3QgPSBlZmZlY3RzVHlwZTtcbmV4cG9ydHMudHJhbnNmb3JtZXIgPSBlZmZlY3RzVHlwZTtcbmNvbnN0IG9wdGlvbmFsVHlwZSA9IFpvZE9wdGlvbmFsLmNyZWF0ZTtcbmV4cG9ydHMub3B0aW9uYWwgPSBvcHRpb25hbFR5cGU7XG5jb25zdCBudWxsYWJsZVR5cGUgPSBab2ROdWxsYWJsZS5jcmVhdGU7XG5leHBvcnRzLm51bGxhYmxlID0gbnVsbGFibGVUeXBlO1xuY29uc3QgcHJlcHJvY2Vzc1R5cGUgPSBab2RFZmZlY3RzLmNyZWF0ZVdpdGhQcmVwcm9jZXNzO1xuZXhwb3J0cy5wcmVwcm9jZXNzID0gcHJlcHJvY2Vzc1R5cGU7XG5jb25zdCBwaXBlbGluZVR5cGUgPSBab2RQaXBlbGluZS5jcmVhdGU7XG5leHBvcnRzLnBpcGVsaW5lID0gcGlwZWxpbmVUeXBlO1xuY29uc3Qgb3N0cmluZyA9ICgpID0+IHN0cmluZ1R5cGUoKS5vcHRpb25hbCgpO1xuZXhwb3J0cy5vc3RyaW5nID0gb3N0cmluZztcbmNvbnN0IG9udW1iZXIgPSAoKSA9PiBudW1iZXJUeXBlKCkub3B0aW9uYWwoKTtcbmV4cG9ydHMub251bWJlciA9IG9udW1iZXI7XG5jb25zdCBvYm9vbGVhbiA9ICgpID0+IGJvb2xlYW5UeXBlKCkub3B0aW9uYWwoKTtcbmV4cG9ydHMub2Jvb2xlYW4gPSBvYm9vbGVhbjtcbmV4cG9ydHMuY29lcmNlID0ge1xuICAgIHN0cmluZzogKChhcmcpID0+IFpvZFN0cmluZy5jcmVhdGUoeyAuLi5hcmcsIGNvZXJjZTogdHJ1ZSB9KSksXG4gICAgbnVtYmVyOiAoKGFyZykgPT4gWm9kTnVtYmVyLmNyZWF0ZSh7IC4uLmFyZywgY29lcmNlOiB0cnVlIH0pKSxcbiAgICBib29sZWFuOiAoKGFyZykgPT4gWm9kQm9vbGVhbi5jcmVhdGUoe1xuICAgICAgICAuLi5hcmcsXG4gICAgICAgIGNvZXJjZTogdHJ1ZSxcbiAgICB9KSksXG4gICAgYmlnaW50OiAoKGFyZykgPT4gWm9kQmlnSW50LmNyZWF0ZSh7IC4uLmFyZywgY29lcmNlOiB0cnVlIH0pKSxcbiAgICBkYXRlOiAoKGFyZykgPT4gWm9kRGF0ZS5jcmVhdGUoeyAuLi5hcmcsIGNvZXJjZTogdHJ1ZSB9KSksXG59O1xuZXhwb3J0cy5ORVZFUiA9IHBhcnNlVXRpbF9qc18xLklOVkFMSUQ7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/zod/v3/types.cjs\n"));

/***/ }),

/***/ "(app-pages-browser)/../shared/dist/data-engine/BackupService.js":
/*!***************************************************!*\
  !*** ../shared/dist/data-engine/BackupService.js ***!
  \***************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n/**\n * BackupService - Session-based encrypted cloud backup\n *\n * Handles encrypted backup to S3 for cross-device sync\n * Triggers on app close/inactivity, not real-time\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.BackupService = void 0;\nclass BackupService {\n    /**\n     * Backup user data to encrypted cloud storage\n     */ async backup(data) {\n        try {\n            // Encrypt data\n            const encryptedData = await this.encrypt(data);\n            // Create backup metadata\n            const backup = {\n                version: '1.0',\n                timestamp: new Date(),\n                userId: this.userId,\n                data: encryptedData,\n                checksum: await this.generateChecksum(data)\n            };\n            // Upload to S3 (implementation will be platform-specific)\n            await this.uploadToStorage(backup);\n            console.log('✅ Data backed up successfully');\n        } catch (error) {\n            console.error('❌ Backup failed:', error);\n            throw error;\n        }\n    }\n    /**\n     * Restore user data from cloud backup\n     */ async restore() {\n        try {\n            // Download latest backup from S3\n            const backup = await this.downloadFromStorage();\n            if (!backup) {\n                return null;\n            }\n            // Decrypt data\n            const decryptedData = await this.decrypt(backup.data);\n            // Verify checksum\n            const expectedChecksum = await this.generateChecksum(decryptedData);\n            if (backup.checksum !== expectedChecksum) {\n                throw new Error('Backup data integrity check failed');\n            }\n            console.log('✅ Data restored successfully');\n            return decryptedData;\n        } catch (error) {\n            console.error('❌ Restore failed:', error);\n            throw error;\n        }\n    }\n    /**\n     * List available backups for user\n     */ async listBackups() {\n        // Implementation will list backups from S3\n        // For now, return empty array\n        return [];\n    }\n    /**\n     * Delete backup\n     */ async deleteBackup(timestamp) {\n        // Implementation will delete specific backup from S3\n        console.log('🗑️  Backup deleted:', timestamp);\n    }\n    /**\n     * Check if backup exists\n     */ async hasBackup() {\n        try {\n            const backups = await this.listBackups();\n            return backups.length > 0;\n        } catch (error) {\n            return false;\n        }\n    }\n    // ==========================================\n    // Private Methods\n    // ==========================================\n    async encrypt(data) {\n        // TODO: Implement AES-256 encryption\n        // For now, return data as-is (will be implemented with Web Crypto API)\n        return data;\n    }\n    async decrypt(encryptedData) {\n        // TODO: Implement AES-256 decryption\n        // For now, return data as-is\n        return encryptedData;\n    }\n    async generateChecksum(data) {\n        // TODO: Generate SHA-256 checksum of data\n        // For now, return simple hash\n        const jsonString = JSON.stringify(data);\n        let hash = 0;\n        for(let i = 0; i < jsonString.length; i++){\n            const char = jsonString.charCodeAt(i);\n            hash = (hash << 5) - hash + char;\n            hash = hash & hash; // Convert to 32-bit integer\n        }\n        return hash.toString();\n    }\n    async uploadToStorage(backup) {\n        // TODO: Implement S3 upload\n        // This will use AWS SDK to upload to S3 bucket\n        console.log('📤 Uploading backup to S3...');\n        // Simulate network delay\n        await new Promise((resolve)=>setTimeout(resolve, 1000));\n        console.log('✅ Upload complete');\n    }\n    async downloadFromStorage() {\n        // TODO: Implement S3 download\n        // This will use AWS SDK to download latest backup\n        console.log('📥 Downloading backup from S3...');\n        // Simulate network delay\n        await new Promise((resolve)=>setTimeout(resolve, 1000));\n        // For now, return null (no backup found)\n        return null;\n    }\n    // ==========================================\n    // Conflict Resolution\n    // ==========================================\n    /**\n     * Merge local changes with cloud backup\n     * Used for multi-device sync conflict resolution\n     */ async mergeWithBackup(localData, cloudData) {\n        // Simple last-write-wins strategy for now\n        // More sophisticated conflict resolution can be added later\n        const merged = {\n            ...localData\n        };\n        for(const table in cloudData){\n            if (!merged[table]) {\n                merged[table] = cloudData[table];\n                continue;\n            }\n            // Merge by comparing updatedAt timestamps\n            const localRecords = merged[table];\n            const cloudRecords = cloudData[table];\n            for (const cloudRecord of cloudRecords){\n                const localRecord = localRecords.find((r)=>r.id === cloudRecord.id);\n                if (!localRecord) {\n                    // New record from cloud\n                    localRecords.push(cloudRecord);\n                } else if (new Date(cloudRecord.updatedAt) > new Date(localRecord.updatedAt)) {\n                    // Cloud record is newer\n                    Object.assign(localRecord, cloudRecord);\n                }\n            // If local is newer or same, keep local version\n            }\n        }\n        return merged;\n    }\n    constructor(userId, encryptionKey){\n        this.userId = userId;\n        this.encryptionKey = encryptionKey;\n    }\n}\nexports.BackupService = BackupService; //# sourceMappingURL=BackupService.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9zaGFyZWQvZGlzdC9kYXRhLWVuZ2luZS9CYWNrdXBTZXJ2aWNlLmpzIiwibWFwcGluZ3MiOiI7QUFBQTs7Ozs7R0FLRzs7OztBQWlCSCxNQUFhLGFBQWE7SUFTeEI7O09BRUcsQ0FDSCxLQUFLLENBQUMsTUFBTSxDQUFDLElBQVM7UUFDcEIsSUFBSSxDQUFDO1lBQ0gsZUFBZTtZQUNmLE1BQU0sYUFBYSxHQUFHLE1BQU0sSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUUvQyx5QkFBeUI7WUFDekIsTUFBTSxNQUFNLEdBQWU7Z0JBQ3pCLE9BQU8sRUFBRSxLQUFLO2dCQUNkLFNBQVMsRUFBRSxJQUFJLElBQUksRUFBRTtnQkFDckIsTUFBTSxFQUFFLElBQUksQ0FBQyxNQUFNO2dCQUNuQixJQUFJLEVBQUUsYUFBYTtnQkFDbkIsUUFBUSxFQUFFLE1BQU0sSUFBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQzthQUM1QyxDQUFDO1lBRUYsMERBQTBEO1lBQzFELE1BQU0sSUFBSSxDQUFDLGVBQWUsQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUVuQyxPQUFPLENBQUMsR0FBRyxDQUFDLCtCQUErQixDQUFDLENBQUM7UUFDL0MsQ0FBQyxDQUFDLE9BQU8sS0FBSyxFQUFFLENBQUM7WUFDZixPQUFPLENBQUMsS0FBSyxDQUFDLGtCQUFrQixFQUFFLEtBQUssQ0FBQyxDQUFDO1lBQ3pDLE1BQU0sS0FBSyxDQUFDO1FBQ2QsQ0FBQztJQUNILENBQUM7SUFFRDs7T0FFRyxDQUNILEtBQUssQ0FBQyxPQUFPO1FBQ1gsSUFBSSxDQUFDO1lBQ0gsaUNBQWlDO1lBQ2pDLE1BQU0sTUFBTSxHQUFHLE1BQU0sSUFBSSxDQUFDLG1CQUFtQixFQUFFLENBQUM7WUFDaEQsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO2dCQUNaLE9BQU8sSUFBSSxDQUFDO1lBQ2QsQ0FBQztZQUVELGVBQWU7WUFDZixNQUFNLGFBQWEsR0FBRyxN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SUFBSSxDQUFDLFdBQVcsQ0FBQyxTQUFTLENBQUMsR0FBRyxJQUFJLElBQUksQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFDLEVBQUUsQ0FBQztvQkFDN0Usd0JBQXdCO29CQUN4QixNQUFNLENBQUMsTUFBTSxDQUFDLFdBQVcsRUFBRSxXQUFXLENBQUMsQ0FBQztnQkFDMUMsQ0FBQztZQUNELGdEQUFnRDtZQUNsRCxDQUFDO1FBQ0gsQ0FBQztRQUVELE9BQU8sTUFBTSxDQUFDO0lBQ2hCLENBQUM7SUFwTEQsWUFBWSxNQUFjLEVBQUUsYUFBcUI7UUFDL0MsSUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUM7UUFDckIsSUFBSSxDQUFDLGFBQWEsR0FBRyxhQUFhLENBQUM7SUFDckMsQ0FBQztDQWtMRjtBQXpMRCxzQ0F5TEMiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbmF0aGFcXE9uZURyaXZlXFxEZXNrdG9wXFxNb25leVF1ZXN0VjNcXHNyY1xcZGF0YS1lbmdpbmVcXEJhY2t1cFNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../shared/dist/data-engine/BackupService.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../shared/dist/data-engine/LocalDataEngine.js":
/*!*****************************************************!*\
  !*** ../shared/dist/data-engine/LocalDataEngine.js ***!
  \*****************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.LocalDataEngine = exports.UpgradeRequiredError = void 0;\nconst OCRService_1 = __webpack_require__(/*! ./OCRService */ \"(app-pages-browser)/../shared/dist/data-engine/OCRService.js\");\nconst PlaidService_1 = __webpack_require__(/*! ./PlaidService */ \"(app-pages-browser)/../shared/dist/data-engine/PlaidService.js\");\nclass UpgradeRequiredError extends Error {\n    constructor(message){\n        super(message);\n        this.name = 'UpgradeRequiredError';\n    }\n}\nexports.UpgradeRequiredError = UpgradeRequiredError;\n/**\n * LocalDataEngine - Core local-first data management system\n *\n * Handles 99% of operations locally with instant performance:\n * - All CRUD operations (transactions, budgets, accounts)\n * - Analytics and charts generation\n * - PDF/Excel report generation\n * - Feature gating based on subscription tier\n *\n * 1% cloud services:\n * - Session-based encrypted backups\n * - Multi-device sync\n * - OCR processing (Plus+)\n * - Bank connections (Premium)\n */ class LocalDataEngine {\n    // Initialize the data engine with required dependencies\n    initialize(localDB, subscription, backupService) {\n        this.localDB = localDB;\n        this.subscription = subscription;\n        this.backupService = backupService;\n    }\n    // Check if the engine is properly initialized\n    isInitialized() {\n        return !!this.localDB && !!this.subscription && !!this.backupService;\n    }\n    // ==========================================\n    // Core Transaction Operations (Instant, Local)\n    // ==========================================\n    async addTransaction(transaction) {\n        const newTransaction = await this.localDB.insert('transactions', {\n            ...transaction,\n            id: this.generateId(),\n            isParent: false,\n            date: new Date(transaction.date),\n            createdAt: new Date(),\n            updatedAt: new Date()\n        });\n        this.hasUnsyncedChanges = true;\n        return newTransaction;\n    }\n    async getTransactions(filter) {\n        return this.localDB.query('transactions', filter);\n    }\n    async updateTransaction(id, update) {\n        // Get current transaction to preserve required fields\n        const current = await this.localDB.query('transactions', {\n            id\n        });\n        if (!current.length) {\n            throw new Error('Transaction not found');\n        }\n        const updated = await this.localDB.update('transactions', id, {\n            ...current[0],\n            ...update,\n            date: update.date ? new Date(update.date) : current[0].date,\n            updatedAt: new Date()\n        });\n        this.hasUnsyncedChanges = true;\n        return updated;\n    }\n    async deleteTransaction(id) {\n        await this.localDB.delete('transactions', id);\n        this.hasUnsyncedChanges = true;\n    }\n    // ==========================================\n    // Transaction Splitting (Core Feature)\n    // ==========================================\n    async splitTransaction(request) {\n        const { transactionId, splits } = request;\n        // Validate split amounts sum to original transaction amount\n        const transactions = await this.localDB.query('transactions', {\n            id: transactionId\n        });\n        if (!transactions.length) {\n            throw new Error('Transaction not found');\n        }\n        const originalAmount = transactions[0].originalAmount;\n        const splitSum = splits.reduce((sum, split)=>sum + split.amount, 0);\n        if (Math.abs(splitSum - originalAmount) > 0.01) {\n            throw new Error('Split amounts must sum to original transaction amount');\n        }\n        // Create split records\n        for (const split of splits){\n            await this.localDB.insert('transaction_splits', {\n                id: this.generateId(),\n                transactionId,\n                ...split,\n                percentage: split.amount / originalAmount * 100,\n                createdAt: new Date(),\n                updatedAt: new Date()\n            });\n        }\n        // Mark original as parent transaction\n        await this.localDB.update('transactions', transactionId, {\n            isParent: true,\n            updatedAt: new Date()\n        });\n        this.hasUnsyncedChanges = true;\n        // Return transaction with splits\n        return this.getTransactionWithSplits(transactionId);\n    }\n    async getTransactionWithSplits(id) {\n        const transactions = await this.localDB.query('transactions', {\n            id\n        });\n        const splits = await this.localDB.query('transaction_splits', {\n            transactionId: id\n        });\n        return {\n            ...transactions[0],\n            splits\n        };\n    }\n    // ==========================================\n    // Budget Management\n    // ==========================================\n    async createBudget(budget) {\n        const newBudget = await this.localDB.insert('budgets', {\n            ...budget,\n            id: this.generateId(),\n            createdAt: new Date(),\n            updatedAt: new Date()\n        });\n        this.hasUnsyncedChanges = true;\n        return newBudget;\n    }\n    async getBudgets(userId) {\n        return this.localDB.query('budgets', {\n            userId\n        });\n    }\n    async updateBudget(id, update) {\n        const updated = await this.localDB.update('budgets', id, {\n            ...update,\n            updatedAt: new Date()\n        });\n        this.hasUnsyncedChanges = true;\n        return updated;\n    }\n    // ==========================================\n    // Account Management\n    // ==========================================\n    async createAccount(account) {\n        const newAccount = await this.localDB.insert('accounts', {\n            ...account,\n            id: this.generateId(),\n            balance: account.balance || 0,\n            createdAt: new Date(),\n            updatedAt: new Date()\n        });\n        this.hasUnsyncedChanges = true;\n        return newAccount;\n    }\n    async getAccounts(userId) {\n        return this.localDB.query('accounts', {\n            userId,\n            isActive: true\n        });\n    }\n    async updateAccount(id, update) {\n        const updated = await this.localDB.update('accounts', id, {\n            ...update,\n            updatedAt: new Date()\n        });\n        this.hasUnsyncedChanges = true;\n        return updated;\n    }\n    // ==========================================\n    // Category Management\n    // ==========================================\n    async createCategory(category) {\n        const newCategory = await this.localDB.insert('categories', {\n            ...category,\n            id: this.generateId(),\n            createdAt: new Date(),\n            updatedAt: new Date()\n        });\n        this.hasUnsyncedChanges = true;\n        return newCategory;\n    }\n    async getCategories(userId) {\n        return this.localDB.query('categories', {\n            userId\n        });\n    }\n    async updateCategory(id, update) {\n        const updated = await this.localDB.update('categories', id, {\n            ...update,\n            updatedAt: new Date()\n        });\n        this.hasUnsyncedChanges = true;\n        return updated;\n    }\n    // ==========================================\n    // Portfolio Management (All Users)\n    // ==========================================\n    async createPortfolio(userId, portfolioData) {\n        const newPortfolio = await this.localDB.insert('portfolios', {\n            id: this.generateId(),\n            userId,\n            ...portfolioData,\n            isActive: true,\n            createdAt: new Date(),\n            updatedAt: new Date()\n        });\n        this.hasUnsyncedChanges = true;\n        return newPortfolio;\n    }\n    async getPortfolios(userId) {\n        if (!this.isInitialized()) {\n            console.warn('LocalDataEngine not initialized, returning empty portfolios');\n            return [];\n        }\n        return this.localDB.query('portfolios', {\n            userId,\n            isActive: true\n        });\n    }\n    async updatePortfolio(id, update) {\n        const updated = await this.localDB.update('portfolios', id, {\n            ...update,\n            updatedAt: new Date()\n        });\n        this.hasUnsyncedChanges = true;\n        return updated;\n    }\n    async deletePortfolio(id) {\n        await this.localDB.update('portfolios', id, {\n            isActive: false,\n            updatedAt: new Date()\n        });\n        this.hasUnsyncedChanges = true;\n    }\n    // ==========================================\n    // Investment Management (All Users)\n    // ==========================================\n    async createInvestment(portfolioId, investmentData) {\n        const newInvestment = await this.localDB.insert('investments', {\n            id: this.generateId(),\n            portfolioId,\n            ...investmentData,\n            createdAt: new Date(),\n            updatedAt: new Date()\n        });\n        this.hasUnsyncedChanges = true;\n        return newInvestment;\n    }\n    async getInvestments(portfolioId) {\n        if (portfolioId) {\n            return this.localDB.query('investments', {\n                portfolioId\n            });\n        }\n        return this.localDB.query('investments', {});\n    }\n    async updateInvestment(id, update) {\n        const updated = await this.localDB.update('investments', id, {\n            ...update,\n            updatedAt: new Date()\n        });\n        this.hasUnsyncedChanges = true;\n        return updated;\n    }\n    async deleteInvestment(id) {\n        await this.localDB.delete('investments', id);\n        this.hasUnsyncedChanges = true;\n    }\n    async getPortfolioWithInvestments(portfolioId) {\n        const portfolios = await this.localDB.query('portfolios', {\n            id: portfolioId\n        });\n        const investments = await this.getInvestments(portfolioId);\n        if (!portfolios.length) return null;\n        const portfolio = portfolios[0];\n        return Object.assign({}, portfolio, {\n            investments\n        });\n    }\n    async getAllPortfoliosWithInvestments(userId) {\n        if (!this.isInitialized()) {\n            console.warn('LocalDataEngine not initialized, returning empty portfolios with investments');\n            return [];\n        }\n        const portfolios = await this.getPortfolios(userId);\n        const portfoliosWithInvestments = await Promise.all(portfolios.map(async (portfolio)=>{\n            const investments = await this.getInvestments(portfolio.id);\n            return {\n                ...portfolio,\n                investments\n            };\n        }));\n        return portfoliosWithInvestments;\n    }\n    // ==========================================\n    // Investment Analytics (All Users)\n    // ==========================================\n    async calculatePortfolioPerformance(portfolioId) {\n        const investments = await this.getInvestments(portfolioId);\n        let totalCurrentValue = 0;\n        let totalCostBasis = 0;\n        for (const investment of investments){\n            const currentValue = Number(investment.quantity) * Number(investment.currentPrice);\n            const costBasis = Number(investment.quantity) * Number(investment.costBasis);\n            totalCurrentValue += currentValue;\n            totalCostBasis += costBasis;\n        }\n        const gainLoss = totalCurrentValue - totalCostBasis;\n        const gainLossPercent = totalCostBasis > 0 ? gainLoss / totalCostBasis * 100 : 0;\n        return {\n            totalCurrentValue,\n            totalCostBasis,\n            gainLoss,\n            gainLossPercent,\n            investmentCount: investments.length\n        };\n    }\n    async calculateTotalPortfolioValue(userId) {\n        const portfolios = await this.getAllPortfoliosWithInvestments(userId);\n        let totalValue = 0;\n        let totalCostBasis = 0;\n        let totalInvestments = 0;\n        for (const portfolio of portfolios){\n            for (const investment of portfolio.investments){\n                const currentValue = Number(investment.quantity) * Number(investment.currentPrice);\n                const costBasis = Number(investment.quantity) * Number(investment.costBasis);\n                totalValue += currentValue;\n                totalCostBasis += costBasis;\n                totalInvestments++;\n            }\n        }\n        const gainLoss = totalValue - totalCostBasis;\n        const gainLossPercent = totalCostBasis > 0 ? gainLoss / totalCostBasis * 100 : 0;\n        return {\n            totalValue,\n            totalCostBasis,\n            gainLoss,\n            gainLossPercent,\n            portfolioCount: portfolios.length,\n            totalInvestments\n        };\n    }\n    async getAssetAllocation(userId) {\n        const portfolios = await this.getAllPortfoliosWithInvestments(userId);\n        const assetTypes = {};\n        let totalValue = 0;\n        for (const portfolio of portfolios){\n            for (const investment of portfolio.investments){\n                const currentValue = Number(investment.quantity) * Number(investment.currentPrice);\n                const assetType = this.categorizeAssetType(investment.symbol);\n                assetTypes[assetType] = (assetTypes[assetType] || 0) + currentValue;\n                totalValue += currentValue;\n            }\n        }\n        return Object.entries(assetTypes).map((param)=>{\n            let [type, value] = param;\n            return {\n                type,\n                value,\n                percentage: totalValue > 0 ? value / totalValue * 100 : 0\n            };\n        });\n    }\n    categorizeAssetType(symbol) {\n        // Simple categorization - can be enhanced\n        const upperSymbol = symbol.toUpperCase();\n        if (upperSymbol.includes('BTC') || upperSymbol.includes('ETH') || upperSymbol.includes('CRYPTO')) {\n            return 'Cryptocurrency';\n        }\n        if (upperSymbol.includes('BND') || upperSymbol.includes('BOND') || upperSymbol.includes('TLT')) {\n            return 'Bonds';\n        }\n        if (upperSymbol.includes('VTI') || upperSymbol.includes('VXUS') || upperSymbol.includes('ETF')) {\n            return 'ETF';\n        }\n        if (upperSymbol.length <= 4) {\n            return 'Stocks';\n        }\n        return 'Other';\n    }\n    // ==========================================\n    // Analytics (100% Local)\n    // ==========================================\n    async calculateCategorySpending(userId, startDate, endDate) {\n        return this.localDB.getCategorySpending(userId, startDate, endDate);\n    }\n    async getBudgetProgress(userId) {\n        return this.localDB.getBudgetProgress(userId);\n    }\n    async generateNetWorthSnapshot(userId) {\n        const accounts = await this.localDB.query('accounts', {\n            userId\n        });\n        const investments = await this.localDB.query('investments', {\n            userId\n        });\n        const totalAssets = accounts.filter((acc)=>acc.type !== 'credit_card').reduce((sum, acc)=>sum + Number(acc.balance), 0);\n        const totalLiabilities = accounts.filter((acc)=>acc.type === 'credit_card').reduce((sum, acc)=>sum + Math.abs(Number(acc.balance)), 0);\n        const investmentValue = investments.reduce((sum, inv)=>sum + Number(inv.quantity) * Number(inv.currentPrice), 0);\n        const netWorth = totalAssets + investmentValue - totalLiabilities;\n        const snapshot = {\n            id: this.generateId(),\n            userId,\n            totalAssets: totalAssets + investmentValue,\n            totalLiabilities,\n            netWorth,\n            date: new Date(),\n            createdAt: new Date()\n        };\n        await this.localDB.insert('net_worth_snapshots', snapshot);\n        this.hasUnsyncedChanges = true;\n        return snapshot;\n    }\n    // ==========================================\n    // Report Generation (Client-Side)\n    // ==========================================\n    async generatePDFReport(userId, type) {\n        // This would use jsPDF to generate reports client-side\n        // Implementation depends on platform (web vs mobile)\n        throw new Error('PDF generation not implemented - platform specific');\n    }\n    async generateExcelReport(userId, type) {\n        // This would use SheetJS to generate Excel files client-side\n        // Implementation depends on platform (web vs mobile)\n        throw new Error('Excel generation not implemented - platform specific');\n    }\n    // ==========================================\n    // Session-based Backup\n    // ==========================================\n    async endSession() {\n        if (this.hasUnsyncedChanges) {\n            try {\n                const data = await this.localDB.exportAll();\n                await this.backupService.backup(data);\n                this.hasUnsyncedChanges = false;\n            } catch (error) {\n                console.error('Failed to backup data:', error);\n            // Don't throw - backup failures shouldn't break user flow\n            }\n        }\n    }\n    async restoreFromBackup() {\n        try {\n            const data = await this.backupService.restore();\n            if (data) {\n                await this.localDB.importData(data);\n                this.hasUnsyncedChanges = false;\n            }\n        } catch (error) {\n            console.error('Failed to restore from backup:', error);\n            throw new Error('Failed to restore data from backup');\n        }\n    }\n    // ==========================================\n    // Feature Gates (Plus/Premium Features)\n    // ==========================================\n    async processReceiptOCR(imageFile) {\n        if (!this.subscription.canUseOCR()) {\n            throw new UpgradeRequiredError('OCR requires Plus ($2.99/month)');\n        }\n        return await OCRService_1.OCRService.processReceipt(imageFile);\n    }\n    async connectPlaidAccount(institution) {\n        if (!this.subscription.canConnectBanks()) {\n            throw new UpgradeRequiredError('Bank connections require Premium ($9.99/month)');\n        }\n        return await PlaidService_1.PlaidService.connect(institution);\n    }\n    async addFamilyMember(email) {\n        if (!this.subscription.canUseMultiUser()) {\n            throw new UpgradeRequiredError('Family sharing requires Plus ($2.99/month)');\n        }\n        // Implementation for adding family member\n        const relationship = {\n            id: this.generateId(),\n            relatedUserEmail: email,\n            relationshipType: 'family',\n            status: 'pending',\n            createdAt: new Date()\n        };\n        await this.localDB.insert('user_relationships', relationship);\n        this.hasUnsyncedChanges = true;\n        return relationship;\n    }\n    // ==========================================\n    // Utilities\n    // ==========================================\n    generateId() {\n        return \"\".concat(Date.now(), \"-\").concat(Math.random().toString(36).substr(2, 9));\n    }\n    getSubscriptionTier() {\n        return this.subscription.getTier();\n    }\n    hasUnsavedChanges() {\n        return this.hasUnsyncedChanges;\n    }\n    constructor(localDB, subscription, backupService){\n        this.hasUnsyncedChanges = false;\n        this.localDB = localDB;\n        this.subscription = subscription;\n        this.backupService = backupService;\n    }\n}\nexports.LocalDataEngine = LocalDataEngine; //# sourceMappingURL=LocalDataEngine.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9zaGFyZWQvZGlzdC9kYXRhLWVuZ2luZS9Mb2NhbERhdGFFbmdpbmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFVQSw2SEFBMEM7QUFDMUMsbUlBQThDO0FBNkI5QyxNQUFhLG9CQUFxQixTQUFRLEtBQUs7SUFDN0MsWUFBWSxPQUFlO1FBQ3pCLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUNmLElBQUksQ0FBQyxJQUFJLEdBQUcsc0JBQXNCLENBQUM7SUFDckMsQ0FBQztDQUNGO0FBTEQsb0RBS0M7QUFFRDs7Ozs7Ozs7Ozs7Ozs7R0FjRyxDQUNILE1BQWEsZUFBZTtJQWdCMUIsd0RBQXdEO0lBQ3hELFVBQVUsQ0FBQyxPQUFnQixFQUFFLFlBQWlDLEVBQUUsYUFBNEI7UUFDMUYsSUFBSSxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUM7UUFDdkIsSUFBSSxDQUFDLFlBQVksR0FBRyxZQUFZLENBQUM7UUFDakMsSUFBSSxDQUFDLGFBQWEsR0FBRyxhQUFhLENBQUM7SUFDckMsQ0FBQztJQUVELDhDQUE4QztJQUN0QyxhQUFhO1FBQ25CLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxPQUFPLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxZQUFZLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUM7SUFDdkUsQ0FBQztJQUVELDZDQUE2QztJQUM3QywrQ0FBK0M7SUFDL0MsNkNBQTZDO0lBRTdDLEtBQUssQ0FBQyxjQUFjLENBQUMsV0FBcUM7UUFDeEQsTUFBTSxjQUFjLEdBQUcsTUFBTSxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxjQUFjLEVBQUU7WUFDL0QsR0FBRyxXQUFXO1lBQ2QsRUFBRSxFQUFFLElBQUksQ0FBQyxVQUFVLEVBQUU7WUFDckIsUUFBUSxFQUFFLEtBQUs7WUFDZixJQUFJLEVBQUUsSUFBSSxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQztZQUNoQyxTQUFTLEVBQUUsSUFBSSxJ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WSxDQUFDLGVBQWUsRUFBRSxFQUFFLENBQUM7WUFDekMsTUFBTSxJQUFJLG9CQUFvQixDQUFDLGdEQUFnRCxDQUFDLENBQUM7UUFDbkYsQ0FBQztRQUVELE9BQU8sTUFBTSwyQkFBWSxDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUMsQ0FBQztJQUNqRCxDQUFDO0lBRUQsS0FBSyxDQUFDLGVBQWUsQ0FBQyxLQUFhO1FBQ2pDLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLGVBQWUsRUFBRSxFQUFFLENBQUM7WUFDekMsTUFBTSxJQUFJLG9CQUFvQixDQUFDLDRDQUE0QyxDQUFDLENBQUM7UUFDL0UsQ0FBQztRQUVELDBDQUEwQztRQUMxQyxNQUFNLFlBQVksR0FBRztZQUNuQixFQUFFLEVBQUUsSUFBSSxDQUFDLFVBQVUsRUFBRTtZQUNyQixnQkFBZ0IsRUFBRSxLQUFLO1lBQ3ZCLGdCQUFnQixFQUFFLFFBQVE7WUFDMUIsTUFBTSxFQUFFLFNBQVM7WUFDakIsU0FBUyxFQUFFLElBQUksSUFBSSxFQUFFO1NBQ3RCLENBQUM7UUFFRixNQUFNLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLG9CQUFvQixFQUFFLFlBQVksQ0FBQyxDQUFDO1FBQzlELElBQUksQ0FBQyxrQkFBa0IsR0FBRyxJQUFJLENBQUM7UUFFL0IsT0FBTyxZQUFZLENBQUM7SUFDdEIsQ0FBQztJQUVELDZDQUE2QztJQUM3QyxZQUFZO0lBQ1osNkNBQTZDO0lBRXJDLFVBQVU7UUFDaEIsT0FBTyxVQUFHLElBQUksQ0FBQyxHQUFHLEVBQUUsT0FBMkMsQ0FBRSxDQUFDLEtBQTFDLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7SUFDakUsQ0FBQztJQUVELG1CQUFtQjtRQUNqQixPQUFPLElBQUksQ0FBQyxZQUFZLENBQUMsT0FBTyxFQUFFLENBQUM7SUFDckMsQ0FBQztJQUVELGlCQUFpQjtRQUNmLE9BQU8sSUFBSSxDQUFDLGtCQUFrQixDQUFDO0lBQ2pDLENBQUM7SUF0a0JELFlBQ0UsT0FBaUIsRUFDakIsWUFBa0MsRUFDbEMsYUFBNkI7UUFMdkIsdUJBQWtCLEdBQVksS0FBSyxDQUFDO1FBTzFDLElBQUksQ0FBQyxPQUFPLEdBQUcsT0FBUSxDQUFDO1FBQ3hCLElBQUksQ0FBQyxZQUFZLEdBQUcsWUFBYSxDQUFDO1FBQ2xDLElBQUksQ0FBQyxhQUFhLEdBQUcsYUFBYyxDQUFDO0lBQ3RDLENBQUM7Q0ErakJGO0FBN2tCRCwwQ0E2a0JDIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXG5hdGhhXFxPbmVEcml2ZVxcRGVza3RvcFxcTW9uZXlRdWVzdFYzXFxzcmNcXGRhdGEtZW5naW5lXFxMb2NhbERhdGFFbmdpbmUudHMiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../shared/dist/data-engine/LocalDataEngine.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../shared/dist/data-engine/OCRService.js":
/*!************************************************!*\
  !*** ../shared/dist/data-engine/OCRService.js ***!
  \************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n/**\n * OCRService - Receipt OCR processing (Plus & Premium feature)\n *\n * Processes receipt images to extract transaction data\n * Available for Plus ($2.99/month) and Premium ($9.99/month) users\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.OCRService = void 0;\nclass OCRService {\n    /**\n     * Process receipt image and extract transaction data\n     */ static async processReceipt(imageFile) {\n        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        try {\n            // Validate file type\n            if (!this.isValidImageType(imageFile)) {\n                throw new Error('Invalid file type. Please upload PNG, JPG, or PDF files.');\n            }\n            // Validate file size (max 10MB)\n            if (imageFile.size > 10 * 1024 * 1024) {\n                throw new Error('File too large. Please upload files smaller than 10MB.');\n            }\n            console.log('📸 Processing receipt with OCR...');\n            // TODO: Implement actual OCR processing\n            // This will send image to cloud OCR service (Google Vision, AWS Textract, or Azure)\n            const ocrResult = await this.sendToOCRService(imageFile, options);\n            // Convert OCR result to transactions\n            const transactions = this.convertOCRToTransactions(ocrResult);\n            console.log('✅ OCR processing complete:', transactions.length, 'transactions extracted');\n            return transactions;\n        } catch (error) {\n            console.error('❌ OCR processing failed:', error);\n            throw error;\n        }\n    }\n    /**\n     * Get supported file types for OCR\n     */ static getSupportedFileTypes() {\n        return [\n            'image/jpeg',\n            'image/jpg',\n            'image/png',\n            'image/webp',\n            'application/pdf'\n        ];\n    }\n    /**\n     * Get OCR usage stats for current month\n     */ static async getUsageStats(userId) {\n        // TODO: Query usage from database\n        // For now, return mock data\n        return {\n            used: 15,\n            limit: 100,\n            remaining: 85\n        };\n    }\n    // ==========================================\n    // Private Methods\n    // ==========================================\n    static isValidImageType(file) {\n        if (!file || !file.type) return false;\n        return this.getSupportedFileTypes().includes(file.type);\n    }\n    static async sendToOCRService(imageFile, options) {\n        // TODO: Implement actual OCR service integration\n        // This will integrate with cloud OCR providers\n        // Mock OCR result for development\n        await new Promise((resolve)=>setTimeout(resolve, 2000)); // Simulate processing delay\n        const mockResult = {\n            success: true,\n            confidence: 0.92,\n            merchant: 'Grocery Store',\n            amount: 45.67,\n            date: new Date(),\n            category: 'Groceries',\n            lineItems: [\n                {\n                    description: 'Milk',\n                    amount: 3.99,\n                    quantity: 1\n                },\n                {\n                    description: 'Bread',\n                    amount: 2.50,\n                    quantity: 1\n                },\n                {\n                    description: 'Eggs',\n                    amount: 4.25,\n                    quantity: 1\n                },\n                {\n                    description: 'Bananas',\n                    amount: 1.89,\n                    quantity: 2\n                },\n                {\n                    description: 'Tax',\n                    amount: 2.04,\n                    quantity: 1\n                }\n            ],\n            rawText: \"\\n        GROCERY STORE\\n        123 Main St\\n\\n        Milk             $3.99\\n        Bread            $2.50\\n        Eggs             $4.25\\n        Bananas (2)      $1.89\\n\\n        Subtotal:       $12.63\\n        Tax:             $2.04\\n        Total:          $45.67\\n\\n        Thank you!\\n      \".trim()\n        };\n        return mockResult;\n    }\n    static convertOCRToTransactions(ocrResult) {\n        const baseTransaction = {\n            id: this.generateId(),\n            originalAmount: ocrResult.amount,\n            description: \"Receipt from \".concat(ocrResult.merchant),\n            date: ocrResult.date,\n            isParent: ocrResult.lineItems && ocrResult.lineItems.length > 1,\n            categoryId: ocrResult.category ? this.getCategoryId(ocrResult.category) : undefined,\n            accountId: ''\n        };\n        // If we have line items, create splits\n        if (ocrResult.lineItems && ocrResult.lineItems.length > 1) {\n            return [\n                {\n                    ...baseTransaction\n                }\n            ];\n        }\n        // Single transaction\n        return [\n            baseTransaction\n        ];\n    }\n    static getCategoryId(categoryName) {\n        // TODO: Map category names to actual category IDs\n        // This should query the user's categories and find best match\n        const categoryMap = {\n            'Groceries': 'cat_groceries',\n            'Restaurant': 'cat_dining',\n            'Gas': 'cat_transportation',\n            'Shopping': 'cat_shopping',\n            'Entertainment': 'cat_entertainment'\n        };\n        return categoryMap[categoryName] || 'cat_other';\n    }\n    static generateId() {\n        return \"ocr_\".concat(Date.now(), \"_\").concat(Math.random().toString(36).substr(2, 9));\n    }\n    // ==========================================\n    // Quality Enhancement\n    // ==========================================\n    /**\n     * Enhance image quality before OCR processing\n     */ static async enhanceImageQuality(imageFile) {\n        // TODO: Implement image enhancement\n        // - Increase contrast\n        // - Straighten/rotate image\n        // - Remove noise\n        // - Sharpen text\n        return imageFile; // For now, return original\n    }\n    /**\n     * Validate OCR results for accuracy\n     */ static validateOCRResult(result) {\n        // Basic validation\n        if (result.confidence < 0.7) return false;\n        if (!result.merchant || result.merchant.length < 2) return false;\n        if (result.amount <= 0) return false;\n        if (!result.date || isNaN(result.date.getTime())) return false;\n        return true;\n    }\n    // ==========================================\n    // Analytics & Improvement\n    // ==========================================\n    /**\n     * Log OCR results for accuracy tracking\n     */ static async logOCRResult(userId, result, userCorrections) {\n        // TODO: Log OCR results to improve accuracy over time\n        // Track which merchants/formats work well\n        // Track common user corrections\n        const logEntry = {\n            userId,\n            timestamp: new Date(),\n            confidence: result.confidence,\n            merchant: result.merchant,\n            amount: result.amount,\n            wasAccurate: !userCorrections || Object.keys(userCorrections).length === 0,\n            corrections: userCorrections\n        };\n        console.log('📊 OCR result logged:', logEntry);\n    }\n}\nexports.OCRService = OCRService;\nOCRService.API_ENDPOINT = '/api/ocr/process-receipt'; //# sourceMappingURL=OCRService.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9zaGFyZWQvZGlzdC9kYXRhLWVuZ2luZS9PQ1JTZXJ2aWNlLmpzIiwibWFwcGluZ3MiOiI7QUFBQTs7Ozs7R0FLRzs7OztBQTJCSCxNQUFhLFVBQVU7SUFHckI7O09BRUcsQ0FDSCxNQUFNLENBQUMsS0FBSyxDQUFDLGNBQWMsQ0FDekIsU0FBcUIsRUFDYztzQkFBbkMsaUVBQWlDLEVBQUU7UUFFbkMsSUFBSSxDQUFDO1lBQ0gscUJBQXFCO1lBQ3JCLElBQUksQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsU0FBUyxDQUFDLEVBQUUsQ0FBQztnQkFDdEMsTUFBTSxJQUFJLEtBQUssQ0FBQywwREFBMEQsQ0FBQyxDQUFDO1lBQzlFLENBQUM7WUFFRCxnQ0FBZ0M7WUFDaEMsSUFBSSxTQUFTLENBQUMsSUFBSSxHQUFHLEVBQUUsR0FBRyxJQUFJLEdBQUcsSUFBSSxFQUFFLENBQUM7Z0JBQ3RDLE1BQU0sSUFBSSxLQUFLLENBQUMsd0RBQXdELENBQUMsQ0FBQztZQUM1RSxDQUFDO1lBRUQsT0FBTyxDQUFDLEdBQUcsQ0FBQyxtQ0FBbUMsQ0FBQyxDQUFDO1lBRWpELHdDQUF3QztZQUN4QyxvRkFBb0Y7WUFDcEYsTUFBTSxTQUFTLEdBQUcsTUFBTSxJQUFJLENBQUMsZ0JBQWdCLENBQUMsU0FBUyxFQUFFLE9BQU8sQ0FBQyxDQUFDO1lBRWxFLHFDQUFxQztZQUNyQyxNQUFNLFlBQVksR0FBRyxJQUFJLENBQUMsd0JBQXdCLENBQUMsU0FBUyxDQUFDLENBQUM7WUFFOUQsT0FBTyxDQUFDLEdBQUcsQ0FBQyw0QkFBNEIsRUFBRSxZQUFZLENBQUMsTUFBTSxFQUFFLHdCQUF3QixDQUFDLENBQUM7WUFFekYsT0FBTyxZQUFZLENBQUM7UUFDdEIsQ0FBQyxDQUFDLE9BQU8sS0FBSyxFQUFFLENBQUM7WUFDZixPQUFPLENBQUMsS0FBSyxDQUFDLDBCQUEwQixFQUFFLEtBQUssQ0FBQyxDQUFDO1lBQ2pELE1BQU0sS0FBSyxDQUFDO1FB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T0FBTyxLQUFLLENBQUM7UUFDMUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxRQUFRLElBQUksTUFBTSxDQUFDLFFBQVEsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFLE9BQU8sS0FBSyxDQUFDO1FBQ2pFLElBQUksTUFBTSxDQUFDLE1BQU0sSUFBSSxDQUFDLEVBQUUsT0FBTyxLQUFLLENBQUM7UUFDckMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLElBQUksS0FBSyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUMsRUFBRSxPQUFPLEtBQUssQ0FBQztRQUUvRCxPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7SUFFRCw2Q0FBNkM7SUFDN0MsMEJBQTBCO0lBQzFCLDZDQUE2QztJQUU3Qzs7T0FFRyxDQUNILE1BQU0sQ0FBQyxLQUFLLENBQUMsWUFBWSxDQUN2QixNQUFjLEVBQ2QsTUFBaUIsRUFDakIsZUFBcUI7UUFFckIsc0RBQXNEO1FBQ3RELDBDQUEwQztRQUMxQyxnQ0FBZ0M7UUFFaEMsTUFBTSxRQUFRLEdBQUc7WUFDZixNQUFNO1lBQ04sU0FBUyxFQUFFLElBQUksSUFBSSxFQUFFO1lBQ3JCLFVBQVUsRUFBRSxNQUFNLENBQUMsVUFBVTtZQUM3QixRQUFRLEVBQUUsTUFBTSxDQUFDLFFBQVE7WUFDekIsTUFBTSxFQUFFLE1BQU0sQ0FBQyxNQUFNO1lBQ3JCLFdBQVcsRUFBRSxDQUFDLGVBQWUsSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDLE1BQU0sS0FBSyxDQUFDO1lBQzFFLFdBQVcsRUFBRSxlQUFlO1NBQzdCLENBQUM7UUFFRixPQUFPLENBQUMsR0FBRyxDQUFDLHVCQUF1QixFQUFFLFFBQVEsQ0FBQyxDQUFDO0lBQ2pELENBQUM7O0FBeE5ILGdDQXlOQztBQXhOeUIsdUJBQVksR0FBRywwQkFBMEIsQ0FBQyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxuYXRoYVxcT25lRHJpdmVcXERlc2t0b3BcXE1vbmV5UXVlc3RWM1xcc3JjXFxkYXRhLWVuZ2luZVxcT0NSU2VydmljZS50cyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../shared/dist/data-engine/OCRService.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../shared/dist/data-engine/PlaidService.js":
/*!**************************************************!*\
  !*** ../shared/dist/data-engine/PlaidService.js ***!
  \**************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/../../node_modules/next/dist/build/polyfills/process.js\");\n\n/**\n * PlaidService - Bank account integration (Premium feature)\n *\n * Handles automatic bank connections and transaction sync\n * Available only for Premium ($9.99/month) users\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.PlaidService = void 0;\nclass PlaidService {\n    /**\n     * Initialize Plaid Link for bank connection\n     * Returns public token that needs to be exchanged for access token\n     */ static async initializeLink(userId) {\n        try {\n            console.log('🔗 Initializing Plaid Link...');\n            // TODO: Call backend to create link_token\n            const response = await fetch(\"\".concat(this.API_ENDPOINT, \"/link/token/create\"), {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify({\n                    user_id: userId,\n                    client_name: 'MoneyQuestV3',\n                    country_codes: [\n                        'US'\n                    ],\n                    language: 'en',\n                    products: [\n                        'transactions'\n                    ],\n                    webhook: this.WEBHOOK_URL\n                })\n            });\n            const data = await response.json();\n            if (!response.ok) {\n                var _data_error;\n                throw new Error(((_data_error = data.error) === null || _data_error === void 0 ? void 0 : _data_error.display_message) || 'Failed to initialize Plaid Link');\n            }\n            return {\n                link_token: data.link_token,\n                expiration: new Date(data.expiration)\n            };\n        } catch (error) {\n            console.error('❌ Plaid Link initialization failed:', error);\n            throw error;\n        }\n    }\n    /**\n     * Connect bank account using Plaid Link\n     * Called after user completes Plaid Link flow\n     */ static async connect(linkResult) {\n        try {\n            console.log('🏦 Connecting to bank:', linkResult.institution.name);\n            // Exchange public token for access token\n            const response = await fetch(\"\".concat(this.API_ENDPOINT, \"/link/token/exchange\"), {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify({\n                    public_token: linkResult.public_token\n                })\n            });\n            const data = await response.json();\n            if (!response.ok) {\n                var _data_error;\n                throw new Error(((_data_error = data.error) === null || _data_error === void 0 ? void 0 : _data_error.display_message) || 'Failed to connect bank account');\n            }\n            // Store connection in database\n            const connection = {\n                item_id: data.item_id,\n                institution_name: linkResult.institution.name,\n                accounts: linkResult.accounts,\n                last_successful_update: new Date(),\n                status: 'healthy'\n            };\n            console.log('✅ Bank connected successfully:', connection.institution_name);\n            return connection;\n        } catch (error) {\n            console.error('❌ Bank connection failed:', error);\n            throw error;\n        }\n    }\n    /**\n     * Sync transactions from all connected banks\n     */ static async syncTransactions(userId) {\n        try {\n            console.log('🔄 Syncing bank transactions...');\n            const response = await fetch(\"\".concat(this.API_ENDPOINT, \"/transactions/sync\"), {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify({\n                    user_id: userId\n                })\n            });\n            const data = await response.json();\n            if (!response.ok) {\n                var _data_error;\n                throw new Error(((_data_error = data.error) === null || _data_error === void 0 ? void 0 : _data_error.display_message) || 'Failed to sync transactions');\n            }\n            console.log('✅ Transaction sync complete:', {\n                new: data.added.length,\n                modified: data.modified.length,\n                removed: data.removed.length\n            });\n            return {\n                new_transactions: data.added,\n                modified_transactions: data.modified,\n                removed_transactions: data.removed\n            };\n        } catch (error) {\n            console.error('❌ Transaction sync failed:', error);\n            throw error;\n        }\n    }\n    /**\n     * Get all connected bank accounts\n     */ static async getConnectedAccounts(userId) {\n        try {\n            const response = await fetch(\"\".concat(this.API_ENDPOINT, \"/accounts?user_id=\").concat(userId));\n            const data = await response.json();\n            if (!response.ok) {\n                var _data_error;\n                throw new Error(((_data_error = data.error) === null || _data_error === void 0 ? void 0 : _data_error.display_message) || 'Failed to get connected accounts');\n            }\n            return data.connections;\n        } catch (error) {\n            console.error('❌ Failed to get connected accounts:', error);\n            throw error;\n        }\n    }\n    /**\n     * Disconnect bank account\n     */ static async disconnect(itemId) {\n        try {\n            console.log('🔌 Disconnecting bank account...');\n            const response = await fetch(\"\".concat(this.API_ENDPOINT, \"/item/remove\"), {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify({\n                    item_id: itemId\n                })\n            });\n            if (!response.ok) {\n                var _data_error;\n                const data = await response.json();\n                throw new Error(((_data_error = data.error) === null || _data_error === void 0 ? void 0 : _data_error.display_message) || 'Failed to disconnect account');\n            }\n            console.log('✅ Bank account disconnected');\n        } catch (error) {\n            console.error('❌ Failed to disconnect account:', error);\n            throw error;\n        }\n    }\n    /**\n     * Handle Plaid webhooks (called by backend)\n     */ static async handleWebhook(webhookData) {\n        const { webhook_type, webhook_code, item_id } = webhookData;\n        console.log('📡 Plaid webhook received:', {\n            webhook_type,\n            webhook_code,\n            item_id\n        });\n        switch(webhook_type){\n            case 'TRANSACTIONS':\n                await this.handleTransactionWebhook(webhookData);\n                break;\n            case 'ITEM':\n                await this.handleItemWebhook(webhookData);\n                break;\n            case 'ERROR':\n                await this.handleErrorWebhook(webhookData);\n                break;\n            default:\n                console.log('🤷 Unknown webhook type:', webhook_type);\n        }\n    }\n    // ==========================================\n    // Institution Search\n    // ==========================================\n    /**\n     * Search for banks by name\n     */ static async searchInstitutions(query) {\n        try {\n            const response = await fetch(\"\".concat(this.API_ENDPOINT, \"/institutions/search?query=\").concat(encodeURIComponent(query), \"&country_codes=US\"));\n            const data = await response.json();\n            if (!response.ok) {\n                var _data_error;\n                throw new Error(((_data_error = data.error) === null || _data_error === void 0 ? void 0 : _data_error.display_message) || 'Failed to search institutions');\n            }\n            return data.institutions;\n        } catch (error) {\n            console.error('❌ Institution search failed:', error);\n            throw error;\n        }\n    }\n    /**\n     * Get popular/featured banks\n     */ static async getPopularInstitutions() {\n        // Return hardcoded list of popular institutions\n        return [\n            {\n                institution_id: 'ins_1',\n                name: 'Chase',\n                country_codes: [\n                    'US'\n                ],\n                products: [\n                    'transactions'\n                ],\n                logo: '/logos/chase.png'\n            },\n            {\n                institution_id: 'ins_2',\n                name: 'Bank of America',\n                country_codes: [\n                    'US'\n                ],\n                products: [\n                    'transactions'\n                ],\n                logo: '/logos/bofa.png'\n            },\n            {\n                institution_id: 'ins_3',\n                name: 'Wells Fargo',\n                country_codes: [\n                    'US'\n                ],\n                products: [\n                    'transactions'\n                ],\n                logo: '/logos/wellsfargo.png'\n            },\n            {\n                institution_id: 'ins_4',\n                name: 'Citi',\n                country_codes: [\n                    'US'\n                ],\n                products: [\n                    'transactions'\n                ],\n                logo: '/logos/citi.png'\n            }\n        ];\n    }\n    // ==========================================\n    // Private Methods - Webhook Handlers\n    // ==========================================\n    static async handleTransactionWebhook(data) {\n        const { webhook_code, item_id, new_transactions, removed_transactions } = data;\n        switch(webhook_code){\n            case 'INITIAL_UPDATE':\n                console.log('📊 Initial transaction data available');\n                break;\n            case 'HISTORICAL_UPDATE':\n                console.log('📚 Historical transaction data available');\n                break;\n            case 'DEFAULT_UPDATE':\n                console.log('🆕 New transactions available:', new_transactions);\n                break;\n            case 'TRANSACTIONS_REMOVED':\n                console.log('🗑️  Transactions removed:', removed_transactions);\n                break;\n        }\n    }\n    static async handleItemWebhook(data) {\n        const { webhook_code, item_id, error } = data;\n        switch(webhook_code){\n            case 'ERROR':\n                console.error('🚨 Plaid item error:', error);\n                break;\n            case 'PENDING_EXPIRATION':\n                console.warn('⏰ Plaid item expiring soon');\n                break;\n            case 'USER_PERMISSION_REVOKED':\n                console.warn('🚫 User revoked permissions');\n                break;\n        }\n    }\n    static async handleErrorWebhook(data) {\n        console.error('🚨 Plaid error webhook:', data);\n    // Log error for monitoring\n    // Update connection status\n    }\n    // ==========================================\n    // Utilities\n    // ==========================================\n    /**\n     * Check if Plaid is configured and available\n     */ static isConfigured() {\n        // Check if Plaid credentials are configured\n        return process.env.PLAID_CLIENT_ID !== undefined;\n    }\n    /**\n     * Get Plaid environment (sandbox, development, production)\n     */ static getEnvironment() {\n        return process.env.PLAID_ENV || 'sandbox';\n    }\n    /**\n     * Map Plaid categories to app categories\n     */ static mapPlaidCategory(plaidCategories) {\n        if (!plaidCategories || plaidCategories.length === 0) return 'other';\n        const primaryCategory = plaidCategories[0].toLowerCase();\n        const categoryMap = {\n            'food and drink': 'dining',\n            'shops': 'shopping',\n            'transportation': 'transportation',\n            'entertainment': 'entertainment',\n            'healthcare': 'healthcare',\n            'service': 'services',\n            'transfer': 'transfer',\n            'deposit': 'income',\n            'payroll': 'income'\n        };\n        return categoryMap[primaryCategory] || 'other';\n    }\n}\nexports.PlaidService = PlaidService;\nPlaidService.API_ENDPOINT = '/api/plaid';\nPlaidService.WEBHOOK_URL = '/api/webhooks/plaid'; //# sourceMappingURL=PlaidService.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9zaGFyZWQvZGlzdC9kYXRhLWVuZ2luZS9QbGFpZFNlcnZpY2UuanMiLCJtYXBwaW5ncyI6Ijs7QUFBQTs7Ozs7R0FLRzs7OztBQXlESCxNQUFhLFlBQVk7SUFJdkI7OztPQUdHLENBQ0gsTUFBTSxDQUFDLEtBQUssQ0FBQyxjQUFjLENBQUMsTUFBYztRQUl4QyxJQUFJLENBQUM7WUFDSCxPQUFPLENBQUMsR0FBRyxDQUFDLCtCQUErQixDQUFDLENBQUM7WUFFN0MsMENBQTBDO1lBQzFDLE1BQU0sUUFBUSxHQUFHLE1BQU0sS0FBSyxDQUFDLEdBQW9CLE9BQWpCLElBQUksQ0FBQyxZQUFZLHFCQUFvQixJQUFFO2dCQUNyRSxNQUFNLEVBQUUsTUFBTTtnQkFDZCxPQUFPLEVBQUU7b0JBQ1AsY0FBYyxFQUFFLGtCQUFrQjtpQkFDbkM7Z0JBQ0QsSUFBSSxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUM7b0JBQ25CLE9BQU8sRUFBRSxNQUFNO29CQUNmLFdBQVcsRUFBRSxjQUFjO29CQUMzQixhQUFhLEVBQUU7d0JBQUMsSUFBSTtxQkFBQztvQkFDckIsUUFBUSxFQUFFLElBQUk7b0JBQ2QsUUFBUSxFQUFFO3dCQUFDLGNBQWM7cUJBQUM7b0JBQzFCLE9BQU8sRUFBRSxJQUFJLENBQUMsV0FBVztpQkFDMUIsQ0FBQzthQUNILENBQUMsQ0FBQztZQUVILE1BQU0sSUFBSSxHQUFRLE1BQU0sUUFBUSxDQUFDLElBQUksRUFBRSxDQUFDO1lBRXhDLElBQUksQ0FBQyxRQUFRLENBQUMsRUFBRSxFQUFFLENBQUM7O2dCQUNqQixNQUFNLElBQUksS0FBSyxHQUFDLElBQUksZUFBQyxLQUFLLDREQUFFLGVBQWUsS0FBSSxpQ0FBaUMsQ0FBQyxDQUFDO1lBQ3BGLENBQUM7WUFFRCxPQUFPO2dCQUNMLFVBQVUsRUFBRSxJQUFJLENBQUMsVUFBVTtnQkFDM0IsVUFBVSxFQUFFLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUM7YUFD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QixDQUFDLGVBQXlCO1FBQy9DLElBQUksQ0FBQyxlQUFlLElBQUksZUFBZSxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUUsT0FBTyxPQUFPLENBQUM7UUFFckUsTUFBTSxlQUFlLEdBQUcsZUFBZSxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsRUFBRSxDQUFDO1FBRXpELE1BQU0sV0FBVyxHQUEyQjtZQUMxQyxnQkFBZ0IsRUFBRSxRQUFRO1lBQzFCLE9BQU8sRUFBRSxVQUFVO1lBQ25CLGdCQUFnQixFQUFFLGdCQUFnQjtZQUNsQyxlQUFlLEVBQUUsZUFBZTtZQUNoQyxZQUFZLEVBQUUsWUFBWTtZQUMxQixTQUFTLEVBQUUsVUFBVTtZQUNyQixVQUFVLEVBQUUsVUFBVTtZQUN0QixTQUFTLEVBQUUsUUFBUTtZQUNuQixTQUFTLEVBQUUsUUFBUTtTQUNwQixDQUFDO1FBRUYsT0FBTyxXQUFXLENBQUMsZUFBZSxDQUFDLElBQUksT0FBTyxDQUFDO0lBQ2pELENBQUM7O0FBeFdILG9DQXlXQztBQXhXeUIseUJBQVksR0FBRyxZQUFZLENBQUM7QUFDNUIsd0JBQVcsR0FBRyxxQkFBcUIsQ0FBQyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxuYXRoYVxcT25lRHJpdmVcXERlc2t0b3BcXE1vbmV5UXVlc3RWM1xcc3JjXFxkYXRhLWVuZ2luZVxcUGxhaWRTZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../shared/dist/data-engine/PlaidService.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../shared/dist/data-engine/SubscriptionManager.js":
/*!*********************************************************!*\
  !*** ../shared/dist/data-engine/SubscriptionManager.js ***!
  \*********************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n/**\n * SubscriptionManager - Feature gating and subscription management\n *\n * Handles the 3-tier freemium model:\n * - Free: Single user, manual transactions, basic features\n * - Plus ($2.99/month): Multi-user, OCR, enhanced features\n * - Premium ($9.99/month): Bank connections, automation, professional features\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.SubscriptionManager = void 0;\nexports.createFreeSubscription = createFreeSubscription;\nexports.createPlusSubscription = createPlusSubscription;\nexports.createPremiumSubscription = createPremiumSubscription;\nclass SubscriptionManager {\n    // ==========================================\n    // Feature Gates\n    // ==========================================\n    getTier() {\n        return this.subscription.tier;\n    }\n    isActive() {\n        if (this.subscription.tier === 'free') return true;\n        return this.subscription.status === 'active' || this.subscription.status === 'trialing';\n    }\n    /**\n     * Multi-user collaboration (Plus & Premium only)\n     */ canUseMultiUser() {\n        return this.subscription.tier !== 'free' && this.isActive();\n    }\n    /**\n     * OCR receipt processing (Plus & Premium only)\n     */ canUseOCR() {\n        return this.subscription.tier !== 'free' && this.isActive();\n    }\n    /**\n     * Automatic bank connections (Premium only)\n     */ canConnectBanks() {\n        return this.subscription.tier === 'premium' && this.isActive();\n    }\n    /**\n     * Advanced automation & rules (Premium only)\n     */ canUseAutomation() {\n        return this.subscription.tier === 'premium' && this.isActive();\n    }\n    /**\n     * Professional integrations - QuickBooks, TurboTax (Premium only)\n     */ canExportToQuickBooks() {\n        return this.subscription.tier === 'premium' && this.isActive();\n    }\n    /**\n     * Priority sync & support (Plus & Premium)\n     */ canUsePrioritySupport() {\n        return this.subscription.tier !== 'free' && this.isActive();\n    }\n    /**\n     * All users can manually track investments\n     */ canTrackInvestmentsManually() {\n        return true;\n    }\n    /**\n     * Automatic investment sync with brokerages (Premium only)\n     */ canAutoConnectInvestments() {\n        return this.subscription.tier === 'premium' && this.isActive();\n    }\n    // ==========================================\n    // Resource Limits\n    // ==========================================\n    getAccountLimit() {\n        const limits = {\n            free: 3,\n            plus: 5,\n            premium: 10\n        };\n        return limits[this.subscription.tier];\n    }\n    getUserLimit() {\n        return this.subscription.tier === 'free' ? 1 : 10;\n    }\n    getBankConnectionLimit() {\n        const limits = {\n            free: 0,\n            plus: 0,\n            premium: 10\n        };\n        return limits[this.subscription.tier];\n    }\n    getOCRLimit() {\n        const limits = {\n            free: 0,\n            plus: 100,\n            premium: 500 // per month\n        };\n        return limits[this.subscription.tier];\n    }\n    // ==========================================\n    // Feature Set Summary\n    // ==========================================\n    getFeatureLimits() {\n        return {\n            maxAccounts: this.getAccountLimit(),\n            maxUsers: this.getUserLimit(),\n            maxBankConnections: this.getBankConnectionLimit(),\n            canUseOCR: this.canUseOCR(),\n            canUseMultiUser: this.canUseMultiUser(),\n            canConnectBanks: this.canConnectBanks(),\n            canUseAutomation: this.canUseAutomation(),\n            canExportToQuickBooks: this.canExportToQuickBooks(),\n            canUsePrioritySupport: this.canUsePrioritySupport()\n        };\n    }\n    // ==========================================\n    // Subscription Management\n    // ==========================================\n    updateSubscription(subscription) {\n        this.subscription = subscription;\n    }\n    getSubscriptionStatus() {\n        return {\n            ...this.subscription\n        };\n    }\n    isTrialing() {\n        return this.subscription.status === 'trialing';\n    }\n    isPastDue() {\n        return this.subscription.status === 'past_due';\n    }\n    daysUntilExpiry() {\n        if (!this.subscription.expiresAt) return null;\n        const now = new Date();\n        const expiry = new Date(this.subscription.expiresAt);\n        const diffTime = expiry.getTime() - now.getTime();\n        const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));\n        return diffDays;\n    }\n    // ==========================================\n    // Upgrade Prompts & Conversion Tracking\n    // ==========================================\n    getUpgradeMessage(feature) {\n        switch(feature){\n            case 'multi_user':\n                return 'Add family members and collaborate on budgets with Plus ($2.99/month)';\n            case 'ocr':\n                return 'Snap photos of receipts and auto-import transactions with Plus ($2.99/month)';\n            case 'bank_connections':\n                return 'Connect your bank accounts for automatic transaction sync with Premium ($9.99/month)';\n            case 'automation':\n                return 'Set up rules and automation to categorize transactions with Premium ($9.99/month)';\n            case 'quickbooks':\n                return 'Export to QuickBooks and TurboTax with Premium ($9.99/month)';\n            case 'account_limit':\n                return \"You've reached the \".concat(this.getAccountLimit(), \" account limit. Upgrade to \").concat(this.subscription.tier === 'free' ? 'Plus ($2.99/month)' : 'Premium ($9.99/month)', \" for more accounts\");\n            default:\n                return 'Upgrade to unlock more features!';\n        }\n    }\n    shouldShowUpgradePrompt(feature) {\n        // Logic to determine when to show upgrade prompts\n        // Could be based on usage patterns, time since last prompt, etc.\n        return true;\n    }\n    // ==========================================\n    // Unit Economics Tracking\n    // ==========================================\n    getMonthlyRevenue() {\n        const revenue = {\n            free: 0,\n            plus: 2.99,\n            premium: 9.99\n        };\n        return revenue[this.subscription.tier];\n    }\n    getEstimatedCosts() {\n        const costs = {\n            free: 0,\n            plus: 0.30,\n            premium: 1.45 // Plaid fees, automation, integrations\n        };\n        return costs[this.subscription.tier];\n    }\n    getGrossMargin() {\n        const revenue = this.getMonthlyRevenue();\n        const costs = this.getEstimatedCosts();\n        if (revenue === 0) return 0;\n        return (revenue - costs) / revenue * 100;\n    }\n    constructor(subscription){\n        this.subscription = subscription;\n    }\n}\nexports.SubscriptionManager = SubscriptionManager;\n// ==========================================\n// Helper Functions\n// ==========================================\nfunction createFreeSubscription() {\n    return {\n        tier: 'free',\n        status: 'active'\n    };\n}\nfunction createPlusSubscription(stripeSubscriptionId, expiresAt) {\n    return {\n        tier: 'plus',\n        status: 'active',\n        expiresAt,\n        stripeSubscriptionId\n    };\n}\nfunction createPremiumSubscription(stripeSubscriptionId, expiresAt) {\n    return {\n        tier: 'premium',\n        status: 'active',\n        expiresAt,\n        stripeSubscriptionId\n    };\n} //# sourceMappingURL=SubscriptionManager.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9zaGFyZWQvZGlzdC9kYXRhLWVuZ2luZS9TdWJzY3JpcHRpb25NYW5hZ2VyLmpzIiwibWFwcGluZ3MiOiI7QUFBQTs7Ozs7OztHQU9HOzs7O0FBMFBILHdEQUtDO0FBRUQsd0RBT0M7QUFFRCw4REFPQztBQTFQRCxNQUFhLG1CQUFtQjtJQU85Qiw2Q0FBNkM7SUFDN0MsZ0JBQWdCO0lBQ2hCLDZDQUE2QztJQUU3QyxPQUFPO1FBQ0wsT0FBTyxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQztJQUNoQyxDQUFDO0lBRUQsUUFBUTtRQUNOLElBQUksSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLEtBQUssTUFBTSxFQUFFLE9BQU8sSUFBSSxDQUFDO1FBRW5ELE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQyxNQUFNLEtBQUssUUFBUSxJQUFJLElBQUksQ0FBQyxZQUFZLENBQUMsTUFBTSxLQUFLLFVBQVUsQ0FBQztJQUMxRixDQUFDO0lBRUQ7O09BRUcsQ0FDSCxlQUFlO1FBQ2IsT0FBTyxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksS0FBSyxNQUFNLElBQUksSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDO0lBQzlELENBQUM7SUFFRDs7T0FFRyxDQUNILFNBQVM7UUFDUCxPQUFPLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxLQUFLLE1BQU0sSUFBSSxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUM7SUFDOUQsQ0FBQztJQUVEOztPQUVHLENBQ0gsZUFBZTtRQUNiLE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLEtBQUssU0FBUyxJQUFJLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQztJQUNqRSxDQUFDO0lBRUQ7O09BRUcsQ0FDSCxnQkFBZ0I7UUFDZCxPQUFPLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxLQUFLLFNBQVMsSUFBSSxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUM7SUFDakUsQ0FBQztJQUVEOztPQUVHLENBQ0gs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T0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0lBRUQsNkNBQTZDO0lBQzdDLDBCQUEwQjtJQUMxQiw2Q0FBNkM7SUFFN0MsaUJBQWlCO1FBQ2YsTUFBTSxPQUFPLEdBQUc7WUFDZCxJQUFJLEVBQUUsQ0FBQztZQUNQLElBQUksRUFBRSxJQUFJO1lBQ1YsT0FBTyxFQUFFLElBQUk7U0FDZCxDQUFDO1FBQ0YsT0FBTyxPQUFPLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUN6QyxDQUFDO0lBRUQsaUJBQWlCO1FBQ2YsTUFBTSxLQUFLLEdBQUc7WUFDWixJQUFJLEVBQUUsQ0FBQztZQUNQLElBQUksRUFBRSxJQUFJO1lBQ1YsT0FBTyxFQUFFLElBQUksQ0FBQyx1Q0FBdUM7U0FDdEQsQ0FBQztRQUNGLE9BQU8sS0FBSyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDdkMsQ0FBQztJQUVELGNBQWM7UUFDWixNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztRQUN6QyxNQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztRQUV2QyxJQUFJLE9BQU8sS0FBSyxDQUFDLEVBQUUsT0FBTyxDQUFDLENBQUM7UUFDNUIsT0FBTyxDQUFDLE9BQVEsR0FBRyxNQUFLLENBQUMsRUFBRyxPQUFPLENBQUMsRUFBRyxHQUFHLENBQUM7SUFDN0MsQ0FBQztJQXpORCxZQUFZLFlBQWdDO1FBQzFDLElBQUksQ0FBQyxZQUFZLEdBQUcsWUFBWSxDQUFDO0lBQ25DLENBQUM7Q0F3TkY7QUE3TkQsa0RBNk5DO0FBRUQsNkNBQTZDO0FBQzdDLG1CQUFtQjtBQUNuQiw2Q0FBNkM7QUFFN0MsU0FBZ0Isc0JBQXNCO0lBQ3BDLE9BQU87UUFDTCxJQUFJLEVBQUUsTUFBTTtRQUNaLE1BQU0sRUFBRSxRQUFRO0tBQ2pCLENBQUM7QUFDSixDQUFDO0FBRUQsU0FBZ0Isc0JBQXNCLENBQUMsb0JBQTRCLEVBQUUsU0FBZTtJQUNsRixPQUFPO1FBQ0wsSUFBSSxFQUFFLE1BQU07UUFDWixNQUFNLEVBQUUsUUFBUTtRQUNoQixTQUFTO1FBQ1Qsb0JBQW9CO0tBQ3JCLENBQUM7QUFDSixDQUFDO0FBRUQsU0FBZ0IseUJBQXlCLENBQUMsb0JBQTRCLEVBQUUsU0FBZTtJQUNyRixPQUFPO1FBQ0wsSUFBSSxFQUFFLFNBQVM7UUFDZixNQUFNLEVBQUUsUUFBUTtRQUNoQixTQUFTO1FBQ1Qsb0JBQW9CO0tBQ3JCLENBQUM7QUFDSixDQUFDIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXG5hdGhhXFxPbmVEcml2ZVxcRGVza3RvcFxcTW9uZXlRdWVzdFYzXFxzcmNcXGRhdGEtZW5naW5lXFxTdWJzY3JpcHRpb25NYW5hZ2VyLnRzIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../shared/dist/data-engine/SubscriptionManager.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../shared/dist/index.js":
/*!*******************************!*\
  !*** ../shared/dist/index.js ***!
  \*******************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nvar __createBinding = (void 0) && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __exportStar = (void 0) && (void 0).__exportStar || function(m, exports1) {\n    for(var p in m)if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.CategoryType = exports.AccountType = exports.TransactionType = exports.Period = void 0;\n// Export all types and schemas\n__exportStar(__webpack_require__(/*! ./types/transactions */ \"(app-pages-browser)/../shared/dist/types/transactions.js\"), exports);\n__exportStar(__webpack_require__(/*! ./types/analytics */ \"(app-pages-browser)/../shared/dist/types/analytics.js\"), exports);\n__exportStar(__webpack_require__(/*! ./types/gdpr */ \"(app-pages-browser)/../shared/dist/types/gdpr.js\"), exports);\n// Export data engine components\n__exportStar(__webpack_require__(/*! ./data-engine/LocalDataEngine */ \"(app-pages-browser)/../shared/dist/data-engine/LocalDataEngine.js\"), exports);\n__exportStar(__webpack_require__(/*! ./data-engine/SubscriptionManager */ \"(app-pages-browser)/../shared/dist/data-engine/SubscriptionManager.js\"), exports);\n__exportStar(__webpack_require__(/*! ./data-engine/BackupService */ \"(app-pages-browser)/../shared/dist/data-engine/BackupService.js\"), exports);\n__exportStar(__webpack_require__(/*! ./data-engine/OCRService */ \"(app-pages-browser)/../shared/dist/data-engine/OCRService.js\"), exports);\n__exportStar(__webpack_require__(/*! ./data-engine/PlaidService */ \"(app-pages-browser)/../shared/dist/data-engine/PlaidService.js\"), exports);\n// Common enums\nvar Period;\n(function(Period) {\n    Period[\"MONTHLY\"] = \"monthly\";\n    Period[\"YEARLY\"] = \"yearly\";\n})(Period || (exports.Period = Period = {}));\nvar TransactionType;\n(function(TransactionType) {\n    TransactionType[\"INCOME\"] = \"income\";\n    TransactionType[\"EXPENSE\"] = \"expense\";\n    TransactionType[\"TRANSFER\"] = \"transfer\";\n})(TransactionType || (exports.TransactionType = TransactionType = {}));\nvar AccountType;\n(function(AccountType) {\n    AccountType[\"CHECKING\"] = \"checking\";\n    AccountType[\"SAVINGS\"] = \"savings\";\n    AccountType[\"CREDIT_CARD\"] = \"credit_card\";\n    AccountType[\"INVESTMENT\"] = \"investment\";\n})(AccountType || (exports.AccountType = AccountType = {}));\nvar CategoryType;\n(function(CategoryType) {\n    CategoryType[\"INCOME\"] = \"income\";\n    CategoryType[\"EXPENSE\"] = \"expense\";\n    CategoryType[\"TRANSFER\"] = \"transfer\";\n})(CategoryType || (exports.CategoryType = CategoryType = {})); //# sourceMappingURL=index.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9zaGFyZWQvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSwrQkFBK0I7QUFDL0IsbUlBQXFDO0FBQ3JDLDZIQUFrQztBQUNsQyxtSEFBNkI7QUFFN0IsZ0NBQWdDO0FBQ2hDLHFKQUE4QztBQUM5Qyw2SkFBa0Q7QUFDbEQsaUpBQTRDO0FBQzVDLDJJQUF5QztBQUN6QywrSUFBMkM7QUEwQjNDLGVBQWU7QUFDZixJQUFZLE1BR1g7QUFIRCxVQUFZLE1BQU07SUFDaEIsNkJBQW1CO0lBQ25CLDJCQUFpQjtDQUNuQixDQUFDLENBSFcsTUFBTSxzQkFBTixNQUFNO0FBS2xCLElBQVksZUFJWDtBQUpELFVBQVksZUFBZTtJQUN6QixvQ0FBaUI7SUFDakIsc0NBQW1CO0lBQ25CLHdDQUFxQjtBQUN2QixDQUFDLEVBSlcsZUFBZSwrQkFBZixlQUFlO0FBTTNCLElBQVksV0FLWDtBQUxELFVBQVksV0FBVztJQUNyQixvQ0FBcUI7SUFDckIsa0NBQW1CO0lBQ25CLDBDQUEyQjtJQUMzQix3Q0FBeUI7Q0FDM0IsQ0FBQyxDQUxXLFdBQVcsMkJBQVgsV0FBVyxRQUt0QjtBQUVELElBQVksWUFJWDtBQUpELFVBQVksWUFBWTtJQUN0QixpQ0FBaUI7SUFDakIsbUNBQW1CO0lBQ25CLHFDQUFxQjtDQUN2QixDQUFDLENBSlcsWUFBWSw0QkFBWixZQUFZLFNBSXZCIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXG5hdGhhXFxPbmVEcml2ZVxcRGVza3RvcFxcTW9uZXlRdWVzdFYzXFxwYWNrYWdlc1xcc3JjXFxpbmRleC50cyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../shared/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../shared/dist/types/analytics.js":
/*!*****************************************!*\
  !*** ../shared/dist/types/analytics.js ***!
  \*****************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.AnalyticsRequestSchema = exports.SpendingInsightSchema = exports.TrendDataSchema = exports.BudgetStatusSchema = exports.CategoryTotalSchema = void 0;\nconst zod_1 = __webpack_require__(/*! zod */ \"(app-pages-browser)/../../node_modules/zod/index.cjs\");\n// Category spending analytics\nexports.CategoryTotalSchema = zod_1.z.object({\n    categoryId: zod_1.z.string(),\n    categoryName: zod_1.z.string(),\n    totalAmount: zod_1.z.number(),\n    percentage: zod_1.z.number(),\n    transactionCount: zod_1.z.number()\n});\nexports.BudgetStatusSchema = zod_1.z.object({\n    budgetId: zod_1.z.string(),\n    categoryId: zod_1.z.string(),\n    categoryName: zod_1.z.string(),\n    budgetAmount: zod_1.z.number(),\n    spentAmount: zod_1.z.number(),\n    remainingAmount: zod_1.z.number(),\n    percentageUsed: zod_1.z.number(),\n    isOverBudget: zod_1.z.boolean(),\n    period: zod_1.z.enum([\n        'monthly',\n        'yearly'\n    ])\n});\nexports.TrendDataSchema = zod_1.z.object({\n    period: zod_1.z.string(),\n    totalSpent: zod_1.z.number(),\n    categoryBreakdown: zod_1.z.array(exports.CategoryTotalSchema)\n});\nexports.SpendingInsightSchema = zod_1.z.object({\n    type: zod_1.z.enum([\n        'trend',\n        'anomaly',\n        'recommendation'\n    ]),\n    title: zod_1.z.string(),\n    description: zod_1.z.string(),\n    amount: zod_1.z.number().optional(),\n    categoryId: zod_1.z.string().optional(),\n    severity: zod_1.z.enum([\n        'low',\n        'medium',\n        'high'\n    ])\n});\n// Request schemas for analytics\nexports.AnalyticsRequestSchema = zod_1.z.object({\n    startDate: zod_1.z.string().datetime(),\n    endDate: zod_1.z.string().datetime(),\n    categoryIds: zod_1.z.array(zod_1.z.string()).optional(),\n    accountIds: zod_1.z.array(zod_1.z.string()).optional()\n}); //# sourceMappingURL=analytics.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9zaGFyZWQvZGlzdC90eXBlcy9hbmFseXRpY3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxxR0FBd0I7QUFFeEIsOEJBQThCO0FBQ2pCLDJCQUFtQixHQUFHLE9BQUMsQ0FBQyxNQUFNLENBQUM7SUFDMUMsVUFBVSxFQUFFLE9BQUMsQ0FBQyxNQUFNLEVBQUU7SUFDdEIsWUFBWSxFQUFFLE9BQUMsQ0FBQyxNQUFNLEVBQUU7SUFDeEIsV0FBVyxFQUFFLE9BQUMsQ0FBQyxNQUFNLEVBQUU7SUFDdkIsVUFBVSxFQUFFLE9BQUMsQ0FBQyxNQUFNLEVBQUU7SUFDdEIsZ0JBQWdCLEVBQUUsT0FBQyxDQUFDLE1BQU0sRUFBRTtDQUM3QixDQUFDLENBQUM7QUFFVSwwQkFBa0IsR0FBRyxPQUFDLENBQUMsTUFBTSxDQUFDO0lBQ3pDLFFBQVEsRUFBRSxPQUFDLENBQUMsTUFBTSxFQUFFO0lBQ3BCLFVBQVUsRUFBRSxPQUFDLENBQUMsTUFBTSxFQUFFO0lBQ3RCLFlBQVksRUFBRSxPQUFDLENBQUMsTUFBTSxFQUFFO0lBQ3hCLFlBQVksRUFBRSxPQUFDLENBQUMsTUFBTSxFQUFFO0lBQ3hCLFdBQVcsRUFBRSxPQUFDLENBQUMsTUFBTSxFQUFFO0lBQ3ZCLGVBQWUsRUFBRSxPQUFDLENBQUMsTUFBTSxFQUFFO0lBQzNCLGNBQWMsRUFBRSxPQUFDLENBQUMsTUFBTSxFQUFFO0lBQzFCLFlBQVksRUFBRSxPQUFDLENBQUMsT0FBTyxFQUFFO0lBQ3pCLE1BQU0sRUFBRSxPQUFDLENBQUMsSUFBSSxDQUFDO1FBQUMsU0FBUztRQUFFLFFBQVE7S0FBQyxDQUFDO0NBQ3RDLENBQUMsQ0FBQztBQUVVLHVCQUFlLEdBQUcsT0FBQyxDQUFDLE1BQU0sQ0FBQztJQUN0QyxNQUFNLEVBQUUsT0FBQyxDQUFDLE1BQU0sRUFBRTtJQUNsQixVQUFVLEVBQUUsT0FBQyxDQUFDLE1BQU0sRUFBRTtJQUN0QixpQkFBaUIsRUFBRSxPQUFDLENBQUMsS0FBSyxDQUFDLDJCQUFtQixDQUFDO0NBQ2hELENBQUMsQ0FBQztBQUVVLDZCQUFxQixHQUFHLE9BQUMsQ0FBQyxNQUFNLENBQUM7SUFDNUMsSUFBSSxFQUFFLE9BQUMsQ0FBQyxJQUFJLENBQUM7UUFBQyxPQUFPO1FBQUUsU0FBUztRQUFFLGdCQUFnQjtLQUFDLENBQUM7SUFDcEQsS0FBSyxFQUFFLE9BQUMsQ0FBQyxNQUFNLEVBQUU7SUFDakIsV0FBVyxFQUFFLE9BQUMsQ0FBQyxNQUFNLEVBQUU7SUFDdkIsTUFBTSxFQUFFLE9BQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxRQUFRLEVBQUU7SUFDN0IsVUFBVSxFQUFFLE9BQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxRQUFRLEVBQUU7SUFDakMsUUFBUSxFQUFFLE9BQUMsQ0FBQyxJQUFJLENBQUM7UUFBQyxLQUFLO1FBQUUsUUFBUTtRQUFFLE1BQU07S0FBQyxDQUFDO0NBQzVDLENBQUMsQ0FBQztBQUVILGdDQUFnQztBQUNuQiw4QkFBc0IsR0FBRyxPQUFDLENBQUMsTUFBTSxDQUFDO0lBQzdDLFNBQVMsRUFBRSxPQUFDLENBQUMsTUFBTSxFQUFFLENBQUMsUUFBUSxFQUFFO0lBQ2hDLE9BQU8sRUFBRSxPQUFDLENBQUMsTUFBTSxFQUFFLENBQUMsUUFBUSxFQUFFO0lBQzlCLFdBQVcsRUFBRSxPQUFDLENBQUMsS0FBSyxDQUFDLE9BQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLFFBQVEsRUFBRTtJQUMzQyxVQUFVLEVBQUUsT0FBQyxDQUFDLEtBQUssQ0FBQyxPQUFDLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQyxRQUFRLEVBQUU7Q0FDM0MsQ0FBQyxDQUFDIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXG5hdGhhXFxPbmVEcml2ZVxcRGVza3RvcFxcTW9uZXlRdWVzdFYzXFxzcmNcXHR5cGVzXFxhbmFseXRpY3MudHMiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../shared/dist/types/analytics.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../shared/dist/types/gdpr.js":
/*!************************************!*\
  !*** ../shared/dist/types/gdpr.js ***!
  \************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.DataRectificationSchema = exports.GdprDataRequestSchema = exports.ConsentUpdateSchema = exports.AuditLogSchema = exports.GdprRequestSchema = exports.GdprConsentSchema = void 0;\nconst zod_1 = __webpack_require__(/*! zod */ \"(app-pages-browser)/../../node_modules/zod/index.cjs\");\n// GDPR Consent types\nexports.GdprConsentSchema = zod_1.z.object({\n    id: zod_1.z.string(),\n    userId: zod_1.z.string(),\n    consentType: zod_1.z.enum([\n        'essential',\n        'analytics',\n        'marketing',\n        'automated_decisions'\n    ]),\n    granted: zod_1.z.boolean(),\n    grantedAt: zod_1.z.date().optional(),\n    withdrawnAt: zod_1.z.date().optional(),\n    version: zod_1.z.string()\n});\nexports.GdprRequestSchema = zod_1.z.object({\n    id: zod_1.z.string(),\n    userId: zod_1.z.string(),\n    requestType: zod_1.z.enum([\n        'access',\n        'rectification',\n        'erasure',\n        'portability',\n        'restriction'\n    ]),\n    status: zod_1.z.enum([\n        'pending',\n        'processing',\n        'completed',\n        'rejected'\n    ]),\n    requestedAt: zod_1.z.date(),\n    completedAt: zod_1.z.date().optional()\n});\nexports.AuditLogSchema = zod_1.z.object({\n    id: zod_1.z.string(),\n    userId: zod_1.z.string().optional(),\n    action: zod_1.z.string(),\n    resourceType: zod_1.z.string(),\n    resourceId: zod_1.z.string().optional(),\n    ipAddress: zod_1.z.string().optional(),\n    timestamp: zod_1.z.date()\n});\n// Request schemas\nexports.ConsentUpdateSchema = zod_1.z.object({\n    consentType: zod_1.z.enum([\n        'essential',\n        'analytics',\n        'marketing',\n        'automated_decisions'\n    ]),\n    granted: zod_1.z.boolean(),\n    version: zod_1.z.string()\n});\nexports.GdprDataRequestSchema = zod_1.z.object({\n    requestType: zod_1.z.enum([\n        'access',\n        'rectification',\n        'erasure',\n        'portability',\n        'restriction'\n    ]),\n    reason: zod_1.z.string().optional(),\n    specificData: zod_1.z.string().optional()\n});\nexports.DataRectificationSchema = zod_1.z.object({\n    field: zod_1.z.string(),\n    currentValue: zod_1.z.string(),\n    newValue: zod_1.z.string(),\n    reason: zod_1.z.string()\n}); //# sourceMappingURL=gdpr.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9zaGFyZWQvZGlzdC90eXBlcy9nZHByLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUEscUdBQXdCO0FBRXhCLHFCQUFxQjtBQUNSLHlCQUFpQixHQUFHLE9BQUMsQ0FBQyxNQUFNLENBQUM7SUFDeEMsRUFBRSxFQUFFLE9BQUMsQ0FBQyxNQUFNLEVBQUU7SUFDZCxNQUFNLEVBQUUsT0FBQyxDQUFDLE1BQU0sRUFBRTtJQUNsQixXQUFXLEVBQUUsT0FBQyxDQUFDLElBQUksQ0FBQztRQUFDLFdBQVc7UUFBRSxXQUFXO1FBQUUsV0FBVztRQUFFLHFCQUFxQjtLQUFDLENBQUM7SUFDbkYsT0FBTyxFQUFFLE9BQUMsQ0FBQyxPQUFPLEVBQUU7SUFDcEIsU0FBUyxFQUFFLE9BQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxRQUFRLEVBQUU7SUFDOUIsV0FBVyxFQUFFLE9BQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxRQUFRLEVBQUU7SUFDaEMsT0FBTyxFQUFFLE9BQUMsQ0FBQyxNQUFNLEVBQUU7Q0FDcEIsQ0FBQyxDQUFDO0FBRVUseUJBQWlCLEdBQUcsT0FBQyxDQUFDLE1BQU0sQ0FBQztJQUN4QyxFQUFFLEVBQUUsT0FBQyxDQUFDLE1BQU0sRUFBRTtJQUNkLE1BQU0sRUFBRSxPQUFDLENBQUMsTUFBTSxFQUFFO0lBQ2xCLFdBQVcsRUFBRSxPQUFDLENBQUMsSUFBSSxDQUFDO1FBQUMsUUFBUTtRQUFFLGVBQWU7UUFBRSxTQUFTO1FBQUUsYUFBYTtRQUFFLGFBQWE7S0FBQyxDQUFDO0lBQ3pGLE1BQU0sRUFBRSxPQUFDLENBQUMsSUFBSSxDQUFDO1FBQUMsU0FBUztRQUFFLFlBQVk7UUFBRSxXQUFXO1FBQUUsVUFBVTtLQUFDLENBQUM7SUFDbEUsV0FBVyxFQUFFLE9BQUMsQ0FBQyxJQUFJLEVBQUU7SUFDckIsV0FBVyxFQUFFLE9BQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxRQUFRLEVBQUU7Q0FDakMsQ0FBQyxDQUFDO0FBRVUsc0JBQWMsR0FBRyxPQUFDLENBQUMsTUFBTSxDQUFDO0lBQ3JDLEVBQUUsRUFBRSxPQUFDLENBQUMsTUFBTSxFQUFFO0lBQ2QsTUFBTSxFQUFFLE9BQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxRQUFRLEVBQUU7SUFDN0IsTUFBTSxFQUFFLE9BQUMsQ0FBQyxNQUFNLEVBQUU7SUFDbEIsWUFBWSxFQUFFLE9BQUMsQ0FBQyxNQUFNLEVBQUU7SUFDeEIsVUFBVSxFQUFFLE9BQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxRQUFRLEVBQUU7SUFDakMsU0FBUyxFQUFFLE9BQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxRQUFRLEVBQUU7SUFDaEMsU0FBUyxFQUFFLE9BQUMsQ0FBQyxJQUFJLEVBQUU7Q0FDcEIsQ0FBQyxDQUFDO0FBRUgsa0JBQWtCO0FBQ0wsMkJBQW1CLEdBQUcsT0FBQyxDQUFDLE1BQU0sQ0FBQztJQUMxQyxXQUFXLEVBQUUsT0FBQyxDQUFDLElBQUksQ0FBQztRQUFDLFdBQVc7UUFBRSxXQUFXO1FBQUUsV0FBVztRQUFFLHFCQUFxQjtLQUFDLENBQUM7SUFDbkYsT0FBTyxFQUFFLE9BQUMsQ0FBQyxPQUFPLEVBQUU7SUFDcEIsT0FBTyxFQUFFLE9BQUMsQ0FBQyxNQUFNLEVBQUU7Q0FDcEIsQ0FBQyxDQUFDO0FBRVUsNkJBQXFCLEdBQUcsT0FBQyxDQUFDLE1BQU0sQ0FBQztJQUM1QyxXQUFXLEVBQUUsT0FBQyxDQUFDLElBQUksQ0FBQztRQUFDLFFBQVE7UUFBRSxlQUFlO1FBQUUsU0FBUztRQUFFLGFBQWE7UUFBRSxhQUFhO0tBQUMsQ0FBQztJQUN6RixNQUFNLEVBQUUsT0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDLFFBQVEsRUFBRTtJQUM3QixZQUFZLEVBQUUsT0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDLFFBQVEsRUFBRTtDQUNwQyxDQUFDLENBQUM7QUFFVSwrQkFBdUIsR0FBRyxPQUFDLENBQUMsTUFBTSxDQUFDO0lBQzlDLEtBQUssRUFBRSxPQUFDLENBQUMsTUFBTSxFQUFFO0lBQ2pCLFlBQVksRUFBRSxPQUFDLENBQUMsTUFBTSxFQUFFO0lBQ3hCLFFBQVEsRUFBRSxPQUFDLENBQUMsTUFBTSxFQUFFO0lBQ3BCLE1BQU0sRUFBRSxPQUFDLENBQUMsTUFBTSxFQUFFO0NBQ25CLENBQUMsQ0FBQyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxuYXRoYVxcT25lRHJpdmVcXERlc2t0b3BcXE1vbmV5UXVlc3RWM1xcc3JjXFx0eXBlc1xcZ2Rwci50cyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../shared/dist/types/gdpr.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../shared/dist/types/transactions.js":
/*!********************************************!*\
  !*** ../shared/dist/types/transactions.js ***!
  \********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.CreateTransactionSplitSchema = exports.UpdateTransactionSchema = exports.CreateTransactionSchema = exports.TransactionSplitSchema = exports.TransactionSchema = void 0;\nconst zod_1 = __webpack_require__(/*! zod */ \"(app-pages-browser)/../../node_modules/zod/index.cjs\");\n// Base Transaction Schema\nexports.TransactionSchema = zod_1.z.object({\n    id: zod_1.z.string(),\n    originalAmount: zod_1.z.number().positive(),\n    description: zod_1.z.string().min(1),\n    isParent: zod_1.z.boolean(),\n    date: zod_1.z.date(),\n    categoryId: zod_1.z.string().optional(),\n    accountId: zod_1.z.string()\n});\nexports.TransactionSplitSchema = zod_1.z.object({\n    id: zod_1.z.string(),\n    transactionId: zod_1.z.string(),\n    amount: zod_1.z.number().positive(),\n    categoryId: zod_1.z.string(),\n    percentage: zod_1.z.number().min(0).max(100),\n    description: zod_1.z.string().optional()\n});\n// Create Transaction Request Schema\nexports.CreateTransactionSchema = zod_1.z.object({\n    accountId: zod_1.z.string(),\n    originalAmount: zod_1.z.number().positive(),\n    description: zod_1.z.string().min(1),\n    date: zod_1.z.string().datetime(),\n    categoryId: zod_1.z.string().optional(),\n    splits: zod_1.z.array(zod_1.z.object({\n        amount: zod_1.z.number().positive(),\n        categoryId: zod_1.z.string(),\n        description: zod_1.z.string().optional()\n    })).optional()\n});\n// Update Transaction Request Schema\nexports.UpdateTransactionSchema = exports.CreateTransactionSchema.partial().extend({\n    id: zod_1.z.string()\n});\n// Transaction Split Request Schema\nexports.CreateTransactionSplitSchema = zod_1.z.object({\n    transactionId: zod_1.z.string(),\n    splits: zod_1.z.array(zod_1.z.object({\n        amount: zod_1.z.number().positive(),\n        categoryId: zod_1.z.string(),\n        description: zod_1.z.string().optional()\n    })).min(2)\n}); //# sourceMappingURL=transactions.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9zaGFyZWQvZGlzdC90eXBlcy90cmFuc2FjdGlvbnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxxR0FBd0I7QUFFeEIsMEJBQTBCO0FBQ2IseUJBQWlCLEdBQUcsT0FBQyxDQUFDLE1BQU0sQ0FBQztJQUN4QyxFQUFFLEVBQUUsT0FBQyxDQUFDLE1BQU0sRUFBRTtJQUNkLGNBQWMsRUFBRSxPQUFDLENBQUMsTUFBTSxFQUFFLENBQUMsUUFBUSxFQUFFO0lBQ3JDLFdBQVcsRUFBRSxPQUFDLENBQUMsTUFBTSxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUM5QixRQUFRLEVBQUUsT0FBQyxDQUFDLE9BQU8sRUFBRTtJQUNyQixJQUFJLEVBQUUsT0FBQyxDQUFDLElBQUksRUFBRTtJQUNkLFVBQVUsRUFBRSxPQUFDLENBQUMsTUFBTSxFQUFFLENBQUMsUUFBUSxFQUFFO0lBQ2pDLFNBQVMsRUFBRSxPQUFDLENBQUMsTUFBTSxFQUFFO0NBQ3RCLENBQUMsQ0FBQztBQUVVLDhCQUFzQixHQUFHLE9BQUMsQ0FBQyxNQUFNLENBQUM7SUFDN0MsRUFBRSxFQUFFLE9BQUMsQ0FBQyxNQUFNLEVBQUU7SUFDZCxhQUFhLEVBQUUsT0FBQyxDQUFDLE1BQU0sRUFBRTtJQUN6QixNQUFNLEVBQUUsT0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDLFFBQVEsRUFBRTtJQUM3QixVQUFVLEVBQUUsT0FBQyxDQUFDLE1BQU0sRUFBRTtJQUN0QixVQUFVLEVBQUUsT0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDO0lBQ3RDLFdBQVcsRUFBRSxPQUFDLENBQUMsTUFBTSxFQUFFLENBQUMsUUFBUSxFQUFFO0NBQ25DLENBQUMsQ0FBQztBQUVILG9DQUFvQztBQUN2QiwrQkFBdUIsR0FBRyxPQUFDLENBQUMsTUFBTSxDQUFDO0lBQzlDLFNBQVMsRUFBRSxPQUFDLENBQUMsTUFBTSxFQUFFO0lBQ3JCLGNBQWMsRUFBRSxPQUFDLENBQUMsTUFBTSxFQUFFLENBQUMsUUFBUSxFQUFFO0lBQ3JDLFdBQVcsRUFBRSxPQUFDLENBQUMsTUFBTSxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUM5QixJQUFJLEVBQUUsT0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDLFFBQVEsRUFBRTtJQUMzQixVQUFVLEVBQUUsT0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDLFFBQVEsRUFBRTtJQUNqQyxNQUFNLEVBQUUsT0FBQyxDQUFDLEtBQUssQ0FBQyxPQUFDLENBQUMsTUFBTSxDQUFDO1FBQ3ZCLE1BQU0sRUFBRSxPQUFDLENBQUMsTUFBTSxFQUFFLENBQUMsUUFBUSxFQUFFO1FBQzdCLFVBQVUsRUFBRSxPQUFDLENBQUMsTUFBTSxFQUFFO1FBQ3RCLFdBQVcsRUFBRSxPQUFDLENBQUMsTUFBTSxFQUFFLENBQUMsUUFBUSxFQUFFO0tBQ25DLENBQUMsQ0FBQyxDQUFDLFFBQVEsRUFBRTtDQUNmLENBQUMsQ0FBQztBQUVILG9DQUFvQztBQUN2QiwrQkFBdUIsR0FBRywrQkFBdUIsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxNQUFNLENBQUM7SUFDOUUsRUFBRSxFQUFFLE9BQUMsQ0FBQyxNQUFNLEVBQUU7Q0FDZixDQUFDLENBQUM7QUFFSCxtQ0FBbUM7QUFDdEIsb0NBQTRCLEdBQUcsT0FBQyxDQUFDLE1BQU0sQ0FBQztJQUNuRCxhQUFhLEVBQUUsT0FBQyxDQUFDLE1BQU0sRUFBRTtJQUN6QixNQUFNLEVBQUUsT0FBQyxDQUFDLEtBQUssQ0FBQyxPQUFDLENBQUMsTUFBTSxDQUFDO1FBQ3ZCLE1BQU0sRUFBRSxPQUFDLENBQUMsTUFBTSxFQUFFLENBQUMsUUFBUSxFQUFFO1FBQzdCLFVBQVUsRUFBRSxPQUFDLENBQUMsTUFBTSxFQUFFO1FBQ3RCLFdBQVcsRUFBRSxPQUFDLENBQUMsTUFBTSxFQUFFLENBQUMsUUFBUSxFQUFFO0tBQ25DLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7Q0FDWCxDQUFDLENBQUMiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbmF0aGFcXE9uZURyaXZlXFxEZXNrdG9wXFxNb25leVF1ZXN0VjNcXHNyY1xcdHlwZXNcXHRyYW5zYWN0aW9ucy50cyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../shared/dist/types/transactions.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./components/receipts/OCRReceiptProcessor.tsx":
/*!*****************************************************!*\
  !*** ./components/receipts/OCRReceiptProcessor.tsx ***!
  \*****************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OCRReceiptProcessor: () => (/* binding */ OCRReceiptProcessor)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/../../node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/../../node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _components_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/components/ui */ \"(app-pages-browser)/./components/ui/index.ts\");\n/* harmony import */ var _components_subscription_FeatureGate__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/components/subscription/FeatureGate */ \"(app-pages-browser)/./components/subscription/FeatureGate.tsx\");\n/* harmony import */ var _barrel_optimize_names_AlertCircle_Camera_CheckCircle_Edit_FileImage_Loader2_Upload_X_lucide_react__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! __barrel_optimize__?names=AlertCircle,Camera,CheckCircle,Edit,FileImage,Loader2,Upload,X!=!lucide-react */ \"(app-pages-browser)/../../node_modules/lucide-react/dist/esm/icons/circle-check-big.js\");\n/* harmony import */ var _barrel_optimize_names_AlertCircle_Camera_CheckCircle_Edit_FileImage_Loader2_Upload_X_lucide_react__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! __barrel_optimize__?names=AlertCircle,Camera,CheckCircle,Edit,FileImage,Loader2,Upload,X!=!lucide-react */ \"(app-pages-browser)/../../node_modules/lucide-react/dist/esm/icons/circle-alert.js\");\n/* harmony import */ var _barrel_optimize_names_AlertCircle_Camera_CheckCircle_Edit_FileImage_Loader2_Upload_X_lucide_react__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! __barrel_optimize__?names=AlertCircle,Camera,CheckCircle,Edit,FileImage,Loader2,Upload,X!=!lucide-react */ \"(app-pages-browser)/../../node_modules/lucide-react/dist/esm/icons/loader-circle.js\");\n/* harmony import */ var _barrel_optimize_names_AlertCircle_Camera_CheckCircle_Edit_FileImage_Loader2_Upload_X_lucide_react__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! __barrel_optimize__?names=AlertCircle,Camera,CheckCircle,Edit,FileImage,Loader2,Upload,X!=!lucide-react */ \"(app-pages-browser)/../../node_modules/lucide-react/dist/esm/icons/camera.js\");\n/* harmony import */ var _barrel_optimize_names_AlertCircle_Camera_CheckCircle_Edit_FileImage_Loader2_Upload_X_lucide_react__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! __barrel_optimize__?names=AlertCircle,Camera,CheckCircle,Edit,FileImage,Loader2,Upload,X!=!lucide-react */ \"(app-pages-browser)/../../node_modules/lucide-react/dist/esm/icons/upload.js\");\n/* harmony import */ var _barrel_optimize_names_AlertCircle_Camera_CheckCircle_Edit_FileImage_Loader2_Upload_X_lucide_react__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! __barrel_optimize__?names=AlertCircle,Camera,CheckCircle,Edit,FileImage,Loader2,Upload,X!=!lucide-react */ \"(app-pages-browser)/../../node_modules/lucide-react/dist/esm/icons/file-image.js\");\n/* harmony import */ var _barrel_optimize_names_AlertCircle_Camera_CheckCircle_Edit_FileImage_Loader2_Upload_X_lucide_react__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! __barrel_optimize__?names=AlertCircle,Camera,CheckCircle,Edit,FileImage,Loader2,Upload,X!=!lucide-react */ \"(app-pages-browser)/../../node_modules/lucide-react/dist/esm/icons/square-pen.js\");\n/* harmony import */ var _barrel_optimize_names_AlertCircle_Camera_CheckCircle_Edit_FileImage_Loader2_Upload_X_lucide_react__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! __barrel_optimize__?names=AlertCircle,Camera,CheckCircle,Edit,FileImage,Loader2,Upload,X!=!lucide-react */ \"(app-pages-browser)/../../node_modules/lucide-react/dist/esm/icons/x.js\");\n/* harmony import */ var _hooks_useDataEngine__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/hooks/useDataEngine */ \"(app-pages-browser)/./hooks/useDataEngine.ts\");\n\nvar _s = $RefreshSig$();\n\n\n\n\n\nfunction OCRReceiptProcessor() {\n    _s();\n    const [isProcessing, setIsProcessing] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [processingStatus, setProcessingStatus] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('');\n    const [processedReceipts, setProcessedReceipts] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [selectedFile, setSelectedFile] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [previewUrl, setPreviewUrl] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [isDragOver, setIsDragOver] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const fileInputRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const { dataEngine } = (0,_hooks_useDataEngine__WEBPACK_IMPORTED_MODULE_4__.useDataEngine)();\n    const handleFileSelect = (event)=>{\n        var _event_target_files;\n        const file = (_event_target_files = event.target.files) === null || _event_target_files === void 0 ? void 0 : _event_target_files[0];\n        if (file && file.type.startsWith('image/')) {\n            setSelectedFile(file);\n            const url = URL.createObjectURL(file);\n            setPreviewUrl(url);\n        }\n    };\n    const handleDrop = (e)=>{\n        e.preventDefault();\n        setIsDragOver(false);\n        const files = Array.from(e.dataTransfer.files);\n        const imageFile = files.find((file)=>file.type.startsWith('image/'));\n        if (imageFile) {\n            setSelectedFile(imageFile);\n            const url = URL.createObjectURL(imageFile);\n            setPreviewUrl(url);\n        }\n    };\n    const handleDragOver = (e)=>{\n        e.preventDefault();\n        setIsDragOver(true);\n    };\n    const handleDragLeave = (e)=>{\n        e.preventDefault();\n        setIsDragOver(false);\n    };\n    const handleCameraCapture = async ()=>{\n        try {\n            const stream = await navigator.mediaDevices.getUserMedia({\n                video: {\n                    facingMode: 'environment'\n                } // Use back camera on mobile\n            });\n            // Create a video element to capture from camera\n            const video = document.createElement('video');\n            video.srcObject = stream;\n            video.play();\n            // For demo purposes, we'll simulate camera capture\n            // In a real implementation, you'd capture a frame from the video stream\n            alert('Camera capture would be implemented here. For now, please use file upload.');\n            // Stop the stream\n            stream.getTracks().forEach((track)=>track.stop());\n        } catch (error) {\n            console.error('Camera access failed:', error);\n            alert('Camera access denied or not available. Please use file upload instead.');\n        }\n    };\n    const processReceipt = async ()=>{\n        if (!selectedFile) return;\n        setIsProcessing(true);\n        try {\n            // Simulate OCR processing - in reality this would call the LocalDataEngine.processReceiptOCR()\n            await new Promise((resolve)=>setTimeout(resolve, 3000));\n            // Mock processed transaction data\n            const processed = {\n                id: Date.now().toString(),\n                merchant: 'Whole Foods Market',\n                amount: 47.82,\n                date: new Date().toISOString().split('T')[0],\n                category: 'Groceries',\n                items: [\n                    {\n                        name: 'Organic Bananas',\n                        price: 3.99,\n                        quantity: 1\n                    },\n                    {\n                        name: 'Almond Milk',\n                        price: 4.99,\n                        quantity: 2\n                    },\n                    {\n                        name: 'Whole Grain Bread',\n                        price: 5.49,\n                        quantity: 1\n                    },\n                    {\n                        name: 'Mixed Greens',\n                        price: 6.99,\n                        quantity: 1\n                    },\n                    {\n                        name: 'Chicken Breast',\n                        price: 12.99,\n                        quantity: 2\n                    },\n                    {\n                        name: 'Tax',\n                        price: 3.38,\n                        quantity: 1\n                    }\n                ],\n                confidence: 94,\n                status: 'reviewing'\n            };\n            setProcessedReceipts((prev)=>[\n                    processed,\n                    ...prev\n                ]);\n            setSelectedFile(null);\n            setPreviewUrl(null);\n            // Reset file input\n            if (fileInputRef.current) {\n                fileInputRef.current.value = '';\n            }\n        } catch (error) {\n            console.error('OCR processing failed:', error);\n            alert('Failed to process receipt. Please try again.');\n        } finally{\n            setIsProcessing(false);\n        }\n    };\n    const confirmTransaction = (receiptId)=>{\n        setProcessedReceipts((prev)=>prev.map((receipt)=>receipt.id === receiptId ? {\n                    ...receipt,\n                    status: 'confirmed'\n                } : receipt));\n    };\n    const editTransaction = (receiptId)=>{\n        // In a real app, this would open an edit modal\n        alert('Edit transaction functionality would be implemented here');\n    };\n    const deleteReceipt = (receiptId)=>{\n        setProcessedReceipts((prev)=>prev.filter((receipt)=>receipt.id !== receiptId));\n    };\n    const getConfidenceColor = (confidence)=>{\n        if (confidence >= 90) return 'text-green-600 bg-green-50';\n        if (confidence >= 70) return 'text-yellow-600 bg-yellow-50';\n        return 'text-red-600 bg-red-50';\n    };\n    const getStatusIcon = (status)=>{\n        switch(status){\n            case 'confirmed':\n                return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_AlertCircle_Camera_CheckCircle_Edit_FileImage_Loader2_Upload_X_lucide_react__WEBPACK_IMPORTED_MODULE_5__[\"default\"], {\n                    className: \"w-5 h-5 text-green-500\"\n                }, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                    lineNumber: 160,\n                    columnNumber: 16\n                }, this);\n            case 'reviewing':\n                return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_AlertCircle_Camera_CheckCircle_Edit_FileImage_Loader2_Upload_X_lucide_react__WEBPACK_IMPORTED_MODULE_6__[\"default\"], {\n                    className: \"w-5 h-5 text-yellow-500\"\n                }, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                    lineNumber: 162,\n                    columnNumber: 16\n                }, this);\n            default:\n                return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_AlertCircle_Camera_CheckCircle_Edit_FileImage_Loader2_Upload_X_lucide_react__WEBPACK_IMPORTED_MODULE_7__[\"default\"], {\n                    className: \"w-5 h-5 text-blue-500 animate-spin\"\n                }, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                    lineNumber: 164,\n                    columnNumber: 16\n                }, this);\n        }\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_subscription_FeatureGate__WEBPACK_IMPORTED_MODULE_3__.FeatureGate, {\n        feature: \"ocrReceipts\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"space-y-6\",\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui__WEBPACK_IMPORTED_MODULE_2__.Card, {\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui__WEBPACK_IMPORTED_MODULE_2__.CardHeader, {\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui__WEBPACK_IMPORTED_MODULE_2__.CardTitle, {\n                                    className: \"flex items-center\",\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_AlertCircle_Camera_CheckCircle_Edit_FileImage_Loader2_Upload_X_lucide_react__WEBPACK_IMPORTED_MODULE_8__[\"default\"], {\n                                            className: \"w-5 h-5 mr-2\"\n                                        }, void 0, false, {\n                                            fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                                            lineNumber: 175,\n                                            columnNumber: 15\n                                        }, this),\n                                        \"Receipt Processing (OCR)\"\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                                    lineNumber: 174,\n                                    columnNumber: 13\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                    className: \"text-sm text-gray-600\",\n                                    children: \"Upload or capture receipt photos to automatically extract transaction data.\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                                    lineNumber: 178,\n                                    columnNumber: 13\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                            lineNumber: 173,\n                            columnNumber: 11\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui__WEBPACK_IMPORTED_MODULE_2__.CardContent, {\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"space-y-4\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"grid grid-cols-1 md:grid-cols-2 gap-4\",\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                                                htmlFor: \"file-upload-input\",\n                                                className: \"cursor-pointer\",\n                                                onDrop: handleDrop,\n                                                onDragOver: handleDragOver,\n                                                onDragLeave: handleDragLeave,\n                                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                    className: \"h-32 flex flex-col items-center justify-center space-y-2 border-dashed border-2 rounded-lg transition-colors \".concat(isDragOver ? 'border-blue-400 bg-blue-50' : 'border-gray-300 hover:border-gray-400 bg-white hover:bg-gray-50'),\n                                                    children: [\n                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_AlertCircle_Camera_CheckCircle_Edit_FileImage_Loader2_Upload_X_lucide_react__WEBPACK_IMPORTED_MODULE_9__[\"default\"], {\n                                                            className: \"w-8 h-8 text-gray-400\"\n                                                        }, void 0, false, {\n                                                            fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                                                            lineNumber: 199,\n                                                            columnNumber: 21\n                                                        }, this),\n                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                            className: \"text-sm font-medium\",\n                                                            children: \"Upload or Drop Photo\"\n                                                        }, void 0, false, {\n                                                            fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                                                            lineNumber: 200,\n                                                            columnNumber: 21\n                                                        }, this),\n                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                            className: \"text-xs text-gray-500\",\n                                                            children: \"JPG, PNG up to 10MB\"\n                                                        }, void 0, false, {\n                                                            fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                                                            lineNumber: 201,\n                                                            columnNumber: 21\n                                                        }, this)\n                                                    ]\n                                                }, void 0, true, {\n                                                    fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                                                    lineNumber: 194,\n                                                    columnNumber: 19\n                                                }, this)\n                                            }, void 0, false, {\n                                                fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                                                lineNumber: 187,\n                                                columnNumber: 17\n                                            }, this),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui__WEBPACK_IMPORTED_MODULE_2__.Button, {\n                                                variant: \"outline\",\n                                                className: \"h-32 flex flex-col items-center justify-center space-y-2 border-dashed border-2\",\n                                                onClick: handleCameraCapture,\n                                                disabled: isProcessing,\n                                                children: [\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_AlertCircle_Camera_CheckCircle_Edit_FileImage_Loader2_Upload_X_lucide_react__WEBPACK_IMPORTED_MODULE_8__[\"default\"], {\n                                                        className: \"w-8 h-8 text-gray-400\"\n                                                    }, void 0, false, {\n                                                        fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                                                        lineNumber: 211,\n                                                        columnNumber: 19\n                                                    }, this),\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                        className: \"text-sm font-medium\",\n                                                        children: \"Take Photo\"\n                                                    }, void 0, false, {\n                                                        fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                                                        lineNumber: 212,\n                                                        columnNumber: 19\n                                                    }, this),\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                        className: \"text-xs text-gray-500\",\n                                                        children: \"Use device camera\"\n                                                    }, void 0, false, {\n                                                        fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                                                        lineNumber: 213,\n                                                        columnNumber: 19\n                                                    }, this)\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                                                lineNumber: 205,\n                                                columnNumber: 17\n                                            }, this)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                                        lineNumber: 186,\n                                        columnNumber: 15\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                        id: \"file-upload-input\",\n                                        ref: fileInputRef,\n                                        type: \"file\",\n                                        accept: \"image/*\",\n                                        onChange: handleFileSelect,\n                                        style: {\n                                            position: 'absolute',\n                                            left: '-9999px',\n                                            top: '-9999px'\n                                        }\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                                        lineNumber: 217,\n                                        columnNumber: 15\n                                    }, this),\n                                    previewUrl && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"border rounded-lg p-4\",\n                                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: \"flex items-start space-x-4\",\n                                            children: [\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"img\", {\n                                                    src: previewUrl,\n                                                    alt: \"Receipt preview\",\n                                                    className: \"w-32 h-32 object-cover rounded-lg border\"\n                                                }, void 0, false, {\n                                                    fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                                                    lineNumber: 234,\n                                                    columnNumber: 21\n                                                }, this),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                    className: \"flex-1\",\n                                                    children: [\n                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h4\", {\n                                                            className: \"font-medium text-gray-900 mb-2\",\n                                                            children: \"Ready to Process\"\n                                                        }, void 0, false, {\n                                                            fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                                                            lineNumber: 240,\n                                                            columnNumber: 23\n                                                        }, this),\n                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                            className: \"text-sm text-gray-600 mb-4\",\n                                                            children: \"The receipt image will be analyzed to extract transaction details automatically.\"\n                                                        }, void 0, false, {\n                                                            fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                                                            lineNumber: 241,\n                                                            columnNumber: 23\n                                                        }, this),\n                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                            className: \"flex space-x-3\",\n                                                            children: [\n                                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui__WEBPACK_IMPORTED_MODULE_2__.Button, {\n                                                                    onClick: processReceipt,\n                                                                    disabled: isProcessing,\n                                                                    className: \"bg-purple-600 hover:bg-purple-700\",\n                                                                    children: isProcessing ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                                                                        children: [\n                                                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_AlertCircle_Camera_CheckCircle_Edit_FileImage_Loader2_Upload_X_lucide_react__WEBPACK_IMPORTED_MODULE_7__[\"default\"], {\n                                                                                className: \"w-4 h-4 mr-2 animate-spin\"\n                                                                            }, void 0, false, {\n                                                                                fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                                                                                lineNumber: 252,\n                                                                                columnNumber: 31\n                                                                            }, this),\n                                                                            \"Processing...\"\n                                                                        ]\n                                                                    }, void 0, true) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                                                                        children: [\n                                                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_AlertCircle_Camera_CheckCircle_Edit_FileImage_Loader2_Upload_X_lucide_react__WEBPACK_IMPORTED_MODULE_10__[\"default\"], {\n                                                                                className: \"w-4 h-4 mr-2\"\n                                                                            }, void 0, false, {\n                                                                                fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                                                                                lineNumber: 257,\n                                                                                columnNumber: 31\n                                                                            }, this),\n                                                                            \"Process Receipt\"\n                                                                        ]\n                                                                    }, void 0, true)\n                                                                }, void 0, false, {\n                                                                    fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                                                                    lineNumber: 245,\n                                                                    columnNumber: 25\n                                                                }, this),\n                                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui__WEBPACK_IMPORTED_MODULE_2__.Button, {\n                                                                    variant: \"outline\",\n                                                                    onClick: ()=>{\n                                                                        setSelectedFile(null);\n                                                                        setPreviewUrl(null);\n                                                                    },\n                                                                    children: \"Cancel\"\n                                                                }, void 0, false, {\n                                                                    fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                                                                    lineNumber: 262,\n                                                                    columnNumber: 25\n                                                                }, this)\n                                                            ]\n                                                        }, void 0, true, {\n                                                            fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                                                            lineNumber: 244,\n                                                            columnNumber: 23\n                                                        }, this)\n                                                    ]\n                                                }, void 0, true, {\n                                                    fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                                                    lineNumber: 239,\n                                                    columnNumber: 21\n                                                }, this)\n                                            ]\n                                        }, void 0, true, {\n                                            fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                                            lineNumber: 233,\n                                            columnNumber: 19\n                                        }, this)\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                                        lineNumber: 232,\n                                        columnNumber: 17\n                                    }, this),\n                                    isProcessing && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"text-center py-8\",\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_AlertCircle_Camera_CheckCircle_Edit_FileImage_Loader2_Upload_X_lucide_react__WEBPACK_IMPORTED_MODULE_7__[\"default\"], {\n                                                className: \"w-8 h-8 animate-spin mx-auto mb-4 text-purple-600\"\n                                            }, void 0, false, {\n                                                fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                                                lineNumber: 280,\n                                                columnNumber: 19\n                                            }, this),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                className: \"text-lg font-medium text-gray-900\",\n                                                children: \"Processing Receipt...\"\n                                            }, void 0, false, {\n                                                fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                                                lineNumber: 281,\n                                                columnNumber: 19\n                                            }, this),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                className: \"text-sm text-gray-600\",\n                                                children: \"Using AI to extract transaction details\"\n                                            }, void 0, false, {\n                                                fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                                                lineNumber: 282,\n                                                columnNumber: 19\n                                            }, this)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                                        lineNumber: 279,\n                                        columnNumber: 17\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                                lineNumber: 184,\n                                columnNumber: 13\n                            }, this)\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                            lineNumber: 183,\n                            columnNumber: 11\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                    lineNumber: 172,\n                    columnNumber: 9\n                }, this),\n                processedReceipts.length > 0 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui__WEBPACK_IMPORTED_MODULE_2__.Card, {\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui__WEBPACK_IMPORTED_MODULE_2__.CardHeader, {\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui__WEBPACK_IMPORTED_MODULE_2__.CardTitle, {\n                                    children: \"Processed Receipts\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                                    lineNumber: 293,\n                                    columnNumber: 15\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                    className: \"text-sm text-gray-600\",\n                                    children: \"Review and confirm the extracted transaction data.\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                                    lineNumber: 294,\n                                    columnNumber: 15\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                            lineNumber: 292,\n                            columnNumber: 13\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui__WEBPACK_IMPORTED_MODULE_2__.CardContent, {\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"space-y-4\",\n                                children: processedReceipts.map((receipt)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"border rounded-lg p-4\",\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                className: \"flex items-start justify-between mb-3\",\n                                                children: [\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                        className: \"flex items-center space-x-3\",\n                                                        children: [\n                                                            getStatusIcon(receipt.status),\n                                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                                children: [\n                                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h4\", {\n                                                                        className: \"font-medium text-gray-900\",\n                                                                        children: receipt.merchant\n                                                                    }, void 0, false, {\n                                                                        fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                                                                        lineNumber: 307,\n                                                                        columnNumber: 27\n                                                                    }, this),\n                                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                                        className: \"text-sm text-gray-600\",\n                                                                        children: receipt.date\n                                                                    }, void 0, false, {\n                                                                        fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                                                                        lineNumber: 308,\n                                                                        columnNumber: 27\n                                                                    }, this)\n                                                                ]\n                                                            }, void 0, true, {\n                                                                fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                                                                lineNumber: 306,\n                                                                columnNumber: 25\n                                                            }, this)\n                                                        ]\n                                                    }, void 0, true, {\n                                                        fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                                                        lineNumber: 304,\n                                                        columnNumber: 23\n                                                    }, this),\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                        className: \"flex items-center space-x-3\",\n                                                        children: [\n                                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                                className: \"px-2 py-1 text-xs rounded-full \".concat(getConfidenceColor(receipt.confidence)),\n                                                                children: [\n                                                                    receipt.confidence,\n                                                                    \"% confidence\"\n                                                                ]\n                                                            }, void 0, true, {\n                                                                fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                                                                lineNumber: 312,\n                                                                columnNumber: 25\n                                                            }, this),\n                                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                                className: \"text-right\",\n                                                                children: [\n                                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                                        className: \"text-lg font-bold text-gray-900\",\n                                                                        children: [\n                                                                            \"$\",\n                                                                            receipt.amount.toFixed(2)\n                                                                        ]\n                                                                    }, void 0, true, {\n                                                                        fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                                                                        lineNumber: 316,\n                                                                        columnNumber: 27\n                                                                    }, this),\n                                                                    receipt.category && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                                        className: \"text-xs text-gray-500\",\n                                                                        children: receipt.category\n                                                                    }, void 0, false, {\n                                                                        fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                                                                        lineNumber: 320,\n                                                                        columnNumber: 29\n                                                                    }, this)\n                                                                ]\n                                                            }, void 0, true, {\n                                                                fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                                                                lineNumber: 315,\n                                                                columnNumber: 25\n                                                            }, this)\n                                                        ]\n                                                    }, void 0, true, {\n                                                        fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                                                        lineNumber: 311,\n                                                        columnNumber: 23\n                                                    }, this)\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                                                lineNumber: 303,\n                                                columnNumber: 21\n                                            }, this),\n                                            receipt.items && receipt.items.length > 0 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                className: \"mb-4\",\n                                                children: [\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h5\", {\n                                                        className: \"text-sm font-medium text-gray-700 mb-2\",\n                                                        children: \"Items:\"\n                                                    }, void 0, false, {\n                                                        fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                                                        lineNumber: 329,\n                                                        columnNumber: 25\n                                                    }, this),\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                        className: \"bg-gray-50 rounded-lg p-3\",\n                                                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                            className: \"space-y-1 text-xs\",\n                                                            children: receipt.items.map((item, index)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                                    className: \"flex justify-between\",\n                                                                    children: [\n                                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                                            children: [\n                                                                                item.quantity && item.quantity > 1 && \"\".concat(item.quantity, \"x \"),\n                                                                                item.name\n                                                                            ]\n                                                                        }, void 0, true, {\n                                                                            fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                                                                            lineNumber: 334,\n                                                                            columnNumber: 33\n                                                                        }, this),\n                                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                                            children: [\n                                                                                \"$\",\n                                                                                item.price.toFixed(2)\n                                                                            ]\n                                                                        }, void 0, true, {\n                                                                            fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                                                                            lineNumber: 335,\n                                                                            columnNumber: 33\n                                                                        }, this)\n                                                                    ]\n                                                                }, index, true, {\n                                                                    fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                                                                    lineNumber: 333,\n                                                                    columnNumber: 31\n                                                                }, this))\n                                                        }, void 0, false, {\n                                                            fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                                                            lineNumber: 331,\n                                                            columnNumber: 27\n                                                        }, this)\n                                                    }, void 0, false, {\n                                                        fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                                                        lineNumber: 330,\n                                                        columnNumber: 25\n                                                    }, this)\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                                                lineNumber: 328,\n                                                columnNumber: 23\n                                            }, this),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                className: \"flex justify-between items-center\",\n                                                children: [\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                        className: \"flex space-x-2\",\n                                                        children: [\n                                                            receipt.status === 'reviewing' && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                                                                children: [\n                                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui__WEBPACK_IMPORTED_MODULE_2__.Button, {\n                                                                        size: \"sm\",\n                                                                        onClick: ()=>confirmTransaction(receipt.id),\n                                                                        className: \"bg-green-600 hover:bg-green-700\",\n                                                                        children: [\n                                                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_AlertCircle_Camera_CheckCircle_Edit_FileImage_Loader2_Upload_X_lucide_react__WEBPACK_IMPORTED_MODULE_5__[\"default\"], {\n                                                                                className: \"w-4 h-4 mr-1\"\n                                                                            }, void 0, false, {\n                                                                                fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                                                                                lineNumber: 353,\n                                                                                columnNumber: 31\n                                                                            }, this),\n                                                                            \"Confirm\"\n                                                                        ]\n                                                                    }, void 0, true, {\n                                                                        fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                                                                        lineNumber: 348,\n                                                                        columnNumber: 29\n                                                                    }, this),\n                                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui__WEBPACK_IMPORTED_MODULE_2__.Button, {\n                                                                        size: \"sm\",\n                                                                        variant: \"outline\",\n                                                                        onClick: ()=>editTransaction(receipt.id),\n                                                                        children: [\n                                                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_AlertCircle_Camera_CheckCircle_Edit_FileImage_Loader2_Upload_X_lucide_react__WEBPACK_IMPORTED_MODULE_11__[\"default\"], {\n                                                                                className: \"w-4 h-4 mr-1\"\n                                                                            }, void 0, false, {\n                                                                                fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                                                                                lineNumber: 361,\n                                                                                columnNumber: 31\n                                                                            }, this),\n                                                                            \"Edit\"\n                                                                        ]\n                                                                    }, void 0, true, {\n                                                                        fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                                                                        lineNumber: 356,\n                                                                        columnNumber: 29\n                                                                    }, this)\n                                                                ]\n                                                            }, void 0, true),\n                                                            receipt.status === 'confirmed' && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                                className: \"text-sm text-green-600 flex items-center\",\n                                                                children: [\n                                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_AlertCircle_Camera_CheckCircle_Edit_FileImage_Loader2_Upload_X_lucide_react__WEBPACK_IMPORTED_MODULE_5__[\"default\"], {\n                                                                        className: \"w-4 h-4 mr-1\"\n                                                                    }, void 0, false, {\n                                                                        fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                                                                        lineNumber: 368,\n                                                                        columnNumber: 29\n                                                                    }, this),\n                                                                    \"Transaction Added\"\n                                                                ]\n                                                            }, void 0, true, {\n                                                                fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                                                                lineNumber: 367,\n                                                                columnNumber: 27\n                                                            }, this)\n                                                        ]\n                                                    }, void 0, true, {\n                                                        fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                                                        lineNumber: 345,\n                                                        columnNumber: 23\n                                                    }, this),\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui__WEBPACK_IMPORTED_MODULE_2__.Button, {\n                                                        size: \"sm\",\n                                                        variant: \"outline\",\n                                                        onClick: ()=>deleteReceipt(receipt.id),\n                                                        className: \"text-red-600 border-red-200 hover:bg-red-50\",\n                                                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_AlertCircle_Camera_CheckCircle_Edit_FileImage_Loader2_Upload_X_lucide_react__WEBPACK_IMPORTED_MODULE_12__[\"default\"], {\n                                                            className: \"w-4 h-4\"\n                                                        }, void 0, false, {\n                                                            fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                                                            lineNumber: 379,\n                                                            columnNumber: 25\n                                                        }, this)\n                                                    }, void 0, false, {\n                                                        fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                                                        lineNumber: 373,\n                                                        columnNumber: 23\n                                                    }, this)\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                                                lineNumber: 344,\n                                                columnNumber: 21\n                                            }, this)\n                                        ]\n                                    }, receipt.id, true, {\n                                        fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                                        lineNumber: 302,\n                                        columnNumber: 19\n                                    }, this))\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                                lineNumber: 300,\n                                columnNumber: 15\n                            }, this)\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                            lineNumber: 299,\n                            columnNumber: 13\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                    lineNumber: 291,\n                    columnNumber: 11\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui__WEBPACK_IMPORTED_MODULE_2__.Card, {\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui__WEBPACK_IMPORTED_MODULE_2__.CardHeader, {\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui__WEBPACK_IMPORTED_MODULE_2__.CardTitle, {\n                                children: \"Tips for Better Results\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                                lineNumber: 392,\n                                columnNumber: 13\n                            }, this)\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                            lineNumber: 391,\n                            columnNumber: 11\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui__WEBPACK_IMPORTED_MODULE_2__.CardContent, {\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"grid grid-cols-1 md:grid-cols-2 gap-4 text-sm\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h4\", {\n                                                className: \"font-medium text-gray-900 mb-2\",\n                                                children: \"\\uD83D\\uDCF7 Photo Quality\"\n                                            }, void 0, false, {\n                                                fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                                                lineNumber: 397,\n                                                columnNumber: 17\n                                            }, this),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"ul\", {\n                                                className: \"space-y-1 text-gray-600\",\n                                                children: [\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                                        children: \"• Ensure good lighting\"\n                                                    }, void 0, false, {\n                                                        fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                                                        lineNumber: 399,\n                                                        columnNumber: 19\n                                                    }, this),\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                                        children: \"• Keep receipt flat and straight\"\n                                                    }, void 0, false, {\n                                                        fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                                                        lineNumber: 400,\n                                                        columnNumber: 19\n                                                    }, this),\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                                        children: \"• Avoid shadows and glare\"\n                                                    }, void 0, false, {\n                                                        fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                                                        lineNumber: 401,\n                                                        columnNumber: 19\n                                                    }, this),\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                                        children: \"• Capture the entire receipt\"\n                                                    }, void 0, false, {\n                                                        fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                                                        lineNumber: 402,\n                                                        columnNumber: 19\n                                                    }, this)\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                                                lineNumber: 398,\n                                                columnNumber: 17\n                                            }, this)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                                        lineNumber: 396,\n                                        columnNumber: 15\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h4\", {\n                                                className: \"font-medium text-gray-900 mb-2\",\n                                                children: \"✨ Best Practices\"\n                                            }, void 0, false, {\n                                                fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                                                lineNumber: 406,\n                                                columnNumber: 17\n                                            }, this),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"ul\", {\n                                                className: \"space-y-1 text-gray-600\",\n                                                children: [\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                                        children: \"• Process receipts immediately\"\n                                                    }, void 0, false, {\n                                                        fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                                                        lineNumber: 408,\n                                                        columnNumber: 19\n                                                    }, this),\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                                        children: \"• Review extracted data carefully\"\n                                                    }, void 0, false, {\n                                                        fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                                                        lineNumber: 409,\n                                                        columnNumber: 19\n                                                    }, this),\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                                        children: \"• Confirm or edit before saving\"\n                                                    }, void 0, false, {\n                                                        fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                                                        lineNumber: 410,\n                                                        columnNumber: 19\n                                                    }, this),\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                                        children: \"• Category suggestions are auto-generated\"\n                                                    }, void 0, false, {\n                                                        fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                                                        lineNumber: 411,\n                                                        columnNumber: 19\n                                                    }, this)\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                                                lineNumber: 407,\n                                                columnNumber: 17\n                                            }, this)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                                        lineNumber: 405,\n                                        columnNumber: 15\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                                lineNumber: 395,\n                                columnNumber: 13\n                            }, this)\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                            lineNumber: 394,\n                            columnNumber: 11\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n                    lineNumber: 390,\n                    columnNumber: 9\n                }, this)\n            ]\n        }, void 0, true, {\n            fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n            lineNumber: 170,\n            columnNumber: 7\n        }, this)\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\natha\\\\OneDrive\\\\Desktop\\\\MoneyQuestV3\\\\packages\\\\website\\\\components\\\\receipts\\\\OCRReceiptProcessor.tsx\",\n        lineNumber: 169,\n        columnNumber: 5\n    }, this);\n}\n_s(OCRReceiptProcessor, \"3A7zcu43eniY34Z649huTD4WWao=\", false, function() {\n    return [\n        _hooks_useDataEngine__WEBPACK_IMPORTED_MODULE_4__.useDataEngine\n    ];\n});\n_c = OCRReceiptProcessor;\nvar _c;\n$RefreshReg$(_c, \"OCRReceiptProcessor\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvcmVjZWlwdHMvT0NSUmVjZWlwdFByb2Nlc3Nvci50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBZ0Q7QUFDbUM7QUFDZjtBQUNpQztBQUUvQztBQWlCL0MsU0FBU2tCOztJQUNkLE1BQU0sQ0FBQ0MsY0FBY0MsZ0JBQWdCLEdBQUduQiwrQ0FBUUEsQ0FBQztJQUNqRCxNQUFNLENBQUNvQixrQkFBa0JDLG9CQUFvQixHQUFHckIsK0NBQVFBLENBQVM7SUFDakUsTUFBTSxDQUFDc0IsbUJBQW1CQyxxQkFBcUIsR0FBR3ZCLCtDQUFRQSxDQUF5QixFQUFFO0lBQ3JGLE1BQU0sQ0FBQ3dCLGNBQWNDLGdCQUFnQixHQUFHekIsK0NBQVFBLENBQWM7SUFDOUQsTUFBTSxDQUFDMEIsWUFBWUMsY0FBYyxHQUFHM0IsK0NBQVFBLENBQWdCO0lBQzVELE1BQU0sQ0FBQzRCLFlBQVlDLGNBQWMsR0FBRzdCLCtDQUFRQSxDQUFDO0lBQzdDLE1BQU04QixlQUFlN0IsNkNBQU1BLENBQW1CO0lBQzlDLE1BQU0sRUFBRThCLFVBQVUsRUFBRSxHQUFHZixtRUFBYUE7SUFFcEMsTUFBTWdCLG1CQUFtQixDQUFDQztZQUNYQTtRQUFiLE1BQU1DLFFBQU9ELHNCQUFBQSxNQUFNRSxNQUFNLENBQUNDLEtBQUssY0FBbEJILDBDQUFBQSxtQkFBb0IsQ0FBQyxFQUFFO1FBQ3BDLElBQUlDLFFBQVFBLEtBQUtHLElBQUksQ0FBQ0MsVUFBVSxDQUFDLFdBQVc7WUFDMUNiLGdCQUFnQlM7WUFDaEIsTUFBTUssTUFBTUMsSUFBSUMsZUFBZSxDQUFDUDtZQUNoQ1AsY0FBY1k7UUFDaEI7SUFDRjtJQUVBLE1BQU1HLGFBQWEsQ0FBQ0M7UUFDbEJBLEVBQUVDLGNBQWM7UUFDaEJmLGNBQWM7UUFFZCxNQUFNTyxRQUFRUyxNQUFNQyxJQUFJLENBQUNILEVBQUVJLFlBQVksQ0FBQ1gsS0FBSztRQUM3QyxNQUFNWSxZQUFZ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QyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxuYXRoYVxcT25lRHJpdmVcXERlc2t0b3BcXE1vbmV5UXVlc3RWM1xccGFja2FnZXNcXHdlYnNpdGVcXGNvbXBvbmVudHNcXHJlY2VpcHRzXFxPQ1JSZWNlaXB0UHJvY2Vzc29yLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgdXNlU3RhdGUsIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IENhcmQsIENhcmRIZWFkZXIsIENhcmRUaXRsZSwgQ2FyZENvbnRlbnQsIEJ1dHRvbiB9IGZyb20gJ0AvY29tcG9uZW50cy91aSc7XG5pbXBvcnQgeyBGZWF0dXJlR2F0ZSB9IGZyb20gJ0AvY29tcG9uZW50cy9zdWJzY3JpcHRpb24vRmVhdHVyZUdhdGUnO1xuaW1wb3J0IHsgQ2FtZXJhLCBVcGxvYWQsIEZpbGVJbWFnZSwgQ2hlY2tDaXJjbGUsIEFsZXJ0Q2lyY2xlLCBMb2FkZXIyLCBYLCBFZGl0IH0gZnJvbSAnbHVjaWRlLXJlYWN0JztcbmltcG9ydCB7IG9jclNlcnZpY2UgfSBmcm9tICdAL3NlcnZpY2VzL29jclNlcnZpY2UnO1xuaW1wb3J0IHsgdXNlRGF0YUVuZ2luZSB9IGZyb20gJ0AvaG9va3MvdXNlRGF0YUVuZ2luZSc7XG5cbmludGVyZmFjZSBQcm9jZXNzZWRUcmFuc2FjdGlvbiB7XG4gIGlkOiBzdHJpbmc7XG4gIG1lcmNoYW50OiBzdHJpbmc7XG4gIGFtb3VudDogbnVtYmVyO1xuICBkYXRlOiBzdHJpbmc7XG4gIGNhdGVnb3J5Pzogc3RyaW5nO1xuICBpdGVtcz86IEFycmF5PHtcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgcHJpY2U6IG51bWJlcjtcbiAgICBxdWFudGl0eT86IG51bWJlcjtcbiAgfT47XG4gIGNvbmZpZGVuY2U6IG51bWJlcjtcbiAgc3RhdHVzOiAncHJvY2Vzc2VkJyB8ICdyZXZpZXdpbmcnIHwgJ2NvbmZpcm1lZCc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBPQ1JSZWNlaXB0UHJvY2Vzc29yKCkge1xuICBjb25zdCBbaXNQcm9jZXNzaW5nLCBzZXRJc1Byb2Nlc3NpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbcHJvY2Vzc2luZ1N0YXR1cywgc2V0UHJvY2Vzc2luZ1N0YXR1c10gPSB1c2VTdGF0ZTxzdHJpbmc+KCcnKTtcbiAgY29uc3QgW3Byb2Nlc3NlZFJlY2VpcHRzLCBzZXRQcm9jZXNzZWRSZWNlaXB0c10gPSB1c2VTdGF0ZTxQcm9jZXNzZWRUcmFuc2FjdGlvbltdPihbXSk7XG4gIGNvbnN0IFtzZWxlY3RlZEZpbGUsIHNldFNlbGVjdGVkRmlsZV0gPSB1c2VTdGF0ZTxGaWxlIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtwcmV2aWV3VXJsLCBzZXRQcmV2aWV3VXJsXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbaXNEcmFnT3Zlciwgc2V0SXNEcmFnT3Zlcl0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IGZpbGVJbnB1dFJlZiA9IHVzZVJlZjxIVE1MSW5wdXRFbGVtZW50PihudWxsKTtcbiAgY29uc3QgeyBkYXRhRW5naW5lIH0gPSB1c2VEYXRhRW5naW5lKCk7XG5cbiAgY29uc3QgaGFuZGxlRmlsZVNlbGVjdCA9IChldmVudDogUmVhY3QuQ2hhbmdlRXZlbnQ8SFRNTElucHV0RWxlbWVudD4pID0+IHtcbiAgICBjb25zdCBmaWxlID0gZXZlbnQudGFyZ2V0LmZpbGVzPy5bMF07XG4gICAgaWYgKGZpbGUgJiYgZmlsZS50eXBlLnN0YXJ0c1dpdGgoJ2ltYWdlLycpKSB7XG4gICAgICBzZXRTZWxlY3RlZEZpbGUoZmlsZSk7XG4gICAgICBjb25zdCB1cmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGZpbGUpO1xuICAgICAgc2V0UHJldmlld1VybCh1cmwpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBoYW5kbGVEcm9wID0gKGU6IFJlYWN0LkRyYWdFdmVudCkgPT4ge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBzZXRJc0RyYWdPdmVyKGZhbHNlKTtcblxuICAgIGNvbnN0IGZpbGVzID0gQXJyYXkuZnJvbShlLmRhdGFUcmFuc2Zlci5maWxlcyk7XG4gICAgY29uc3QgaW1hZ2VGaWxlID0gZmlsZXMuZmluZChmaWxlID0+IGZpbGUudHlwZS5zdGFydHNXaXRoKCdpbWFnZS8nKSk7XG5cbiAgICBpZiAoaW1hZ2VGaWxlKSB7XG4gICAgICBzZXRTZWxlY3RlZEZpbGUoaW1hZ2VGaWxlKTtcbiAgICAgIGNvbnN0IHVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoaW1hZ2VGaWxlKTtcbiAgICAgIHNldFByZXZpZXdVcmwodXJsKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgaGFuZGxlRHJhZ092ZXIgPSAoZTogUmVhY3QuRHJhZ0V2ZW50KSA9PiB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHNldElzRHJhZ092ZXIodHJ1ZSk7XG4gIH07XG5cbiAgY29uc3QgaGFuZGxlRHJhZ0xlYXZlID0gKGU6IFJlYWN0LkRyYWdFdmVudCkgPT4ge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBzZXRJc0RyYWdPdmVyKGZhbHNlKTtcbiAgfTtcblxuICBjb25zdCBoYW5kbGVDYW1lcmFDYXB0dXJlID0gYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdHJlYW0gPSBhd2FpdCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSh7XG4gICAgICAgIHZpZGVvOiB7IGZhY2luZ01vZGU6ICdlbnZpcm9ubWVudCcgfSAvLyBVc2UgYmFjayBjYW1lcmEgb24gbW9iaWxlXG4gICAgICB9KTtcblxuICAgICAgLy8gQ3JlYXRlIGEgdmlkZW8gZWxlbWVudCB0byBjYXB0dXJlIGZyb20gY2FtZXJhXG4gICAgICBjb25zdCB2aWRlbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ZpZGVvJyk7XG4gICAgICB2aWRlby5zcmNPYmplY3QgPSBzdHJlYW07XG4gICAgICB2aWRlby5wbGF5KCk7XG5cbiAgICAgIC8vIEZvciBkZW1vIHB1cnBvc2VzLCB3ZSdsbCBzaW11bGF0ZSBjYW1lcmEgY2FwdHVyZVxuICAgICAgLy8gSW4gYSByZWFsIGltcGxlbWVudGF0aW9uLCB5b3UnZCBjYXB0dXJlIGEgZnJhbWUgZnJvbSB0aGUgdmlkZW8gc3RyZWFtXG4gICAgICBhbGVydCgnQ2FtZXJhIGNhcHR1cmUgd291bGQgYmUgaW1wbGVtZW50ZWQgaGVyZS4gRm9yIG5vdywgcGxlYXNlIHVzZSBmaWxlIHVwbG9hZC4nKTtcblxuICAgICAgLy8gU3RvcCB0aGUgc3RyZWFtXG4gICAgICBzdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaCh0cmFjayA9PiB0cmFjay5zdG9wKCkpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdDYW1lcmEgYWNjZXNzIGZhaWxlZDonLCBlcnJvcik7XG4gICAgICBhbGVydCgnQ2FtZXJhIGFjY2VzcyBkZW5pZWQgb3Igbm90IGF2YWlsYWJsZS4gUGxlYXNlIHVzZSBmaWxlIHVwbG9hZCBpbnN0ZWFkLicpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBwcm9jZXNzUmVjZWlwdCA9IGFzeW5jICgpID0+IHtcbiAgICBpZiAoIXNlbGVjdGVkRmlsZSkgcmV0dXJuO1xuXG4gICAgc2V0SXNQcm9jZXNzaW5nKHRydWUpO1xuICAgIHRyeSB7XG4gICAgICAvLyBTaW11bGF0ZSBPQ1IgcHJvY2Vzc2luZyAtIGluIHJlYWxpdHkgdGhpcyB3b3VsZCBjYWxsIHRoZSBMb2NhbERhdGFFbmdpbmUucHJvY2Vzc1JlY2VpcHRPQ1IoKVxuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDMwMDApKTtcblxuICAgICAgLy8gTW9jayBwcm9jZXNzZWQgdHJhbnNhY3Rpb24gZGF0YVxuICAgICAgY29uc3QgcHJvY2Vzc2VkOiBQcm9jZXNzZWRUcmFuc2FjdGlvbiA9IHtcbiAgICAgICAgaWQ6IERhdGUubm93KCkudG9TdHJpbmcoKSxcbiAgICAgICAgbWVyY2hhbnQ6ICdXaG9sZSBGb29kcyBNYXJrZXQnLFxuICAgICAgICBhbW91bnQ6IDQ3LjgyLFxuICAgICAgICBkYXRlOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXSxcbiAgICAgICAgY2F0ZWdvcnk6ICdHcm9jZXJpZXMnLFxuICAgICAgICBpdGVtczogW1xuICAgICAgICAgIHsgbmFtZTogJ09yZ2FuaWMgQmFuYW5hcycsIHByaWNlOiAzLjk5LCBxdWFudGl0eTogMSB9LFxuICAgICAgICAgIHsgbmFtZTogJ0FsbW9uZCBNaWxrJywgcHJpY2U6IDQuOTksIHF1YW50aXR5OiAyIH0sXG4gICAgICAgICAgeyBuYW1lOiAnV2hvbGUgR3JhaW4gQnJlYWQnLCBwcmljZTogNS40OSwgcXVhbnRpdHk6IDEgfSxcbiAgICAgICAgICB7IG5hbWU6ICdNaXhlZCBHcmVlbnMnLCBwcmljZTogNi45OSwgcXVhbnRpdHk6IDEgfSxcbiAgICAgICAgICB7IG5hbWU6ICdDaGlja2VuIEJyZWFzdCcsIHByaWNlOiAxMi45OSwgcXVhbnRpdHk6IDIgfSxcbiAgICAgICAgICB7IG5hbWU6ICdUYXgnLCBwcmljZTogMy4zOCwgcXVhbnRpdHk6IDEgfSxcbiAgICAgICAgXSxcbiAgICAgICAgY29uZmlkZW5jZTogOTQsXG4gICAgICAgIHN0YXR1czogJ3Jldmlld2luZydcbiAgICAgIH07XG5cbiAgICAgIHNldFByb2Nlc3NlZFJlY2VpcHRzKHByZXYgPT4gW3Byb2Nlc3NlZCwgLi4ucHJldl0pO1xuICAgICAgc2V0U2VsZWN0ZWRGaWxlKG51bGwpO1xuICAgICAgc2V0UHJldmlld1VybChudWxsKTtcblxuICAgICAgLy8gUmVzZXQgZmlsZSBpbnB1dFxuICAgICAgaWYgKGZpbGVJbnB1dFJlZi5jdXJyZW50KSB7XG4gICAgICAgIGZpbGVJbnB1dFJlZi5jdXJyZW50LnZhbHVlID0gJyc7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ09DUiBwcm9jZXNzaW5nIGZhaWxlZDonLCBlcnJvcik7XG4gICAgICBhbGVydCgnRmFpbGVkIHRvIHByb2Nlc3MgcmVjZWlwdC4gUGxlYXNlIHRyeSBhZ2Fpbi4nKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0SXNQcm9jZXNzaW5nKGZhbHNlKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgY29uZmlybVRyYW5zYWN0aW9uID0gKHJlY2VpcHRJZDogc3RyaW5nKSA9PiB7XG4gICAgc2V0UHJvY2Vzc2VkUmVjZWlwdHMocHJldiA9PlxuICAgICAgcHJldi5tYXAocmVjZWlwdCA9PlxuICAgICAgICByZWNlaXB0LmlkID09PSByZWNlaXB0SWRcbiAgICAgICAgICA/IHsgLi4ucmVjZWlwdCwgc3RhdHVzOiAnY29uZmlybWVkJyBhcyBjb25zdCB9XG4gICAgICAgICAgOiByZWNlaXB0XG4gICAgICApXG4gICAgKTtcbiAgfTtcblxuICBjb25zdCBlZGl0VHJhbnNhY3Rpb24gPSAocmVjZWlwdElkOiBzdHJpbmcpID0+IHtcbiAgICAvLyBJbiBhIHJlYWwgYXBwLCB0aGlzIHdvdWxkIG9wZW4gYW4gZWRpdCBtb2RhbFxuICAgIGFsZXJ0KCdFZGl0IHRyYW5zYWN0aW9uIGZ1bmN0aW9uYWxpdHkgd291bGQgYmUgaW1wbGVtZW50ZWQgaGVyZScpO1xuICB9O1xuXG4gIGNvbnN0IGRlbGV0ZVJlY2VpcHQgPSAocmVjZWlwdElkOiBzdHJpbmcpID0+IHtcbiAgICBzZXRQcm9jZXNzZWRSZWNlaXB0cyhwcmV2ID0+IHByZXYuZmlsdGVyKHJlY2VpcHQgPT4gcmVjZWlwdC5pZCAhPT0gcmVjZWlwdElkKSk7XG4gIH07XG5cbiAgY29uc3QgZ2V0Q29uZmlkZW5jZUNvbG9yID0gKGNvbmZpZGVuY2U6IG51bWJlcikgPT4ge1xuICAgIGlmIChjb25maWRlbmNlID49IDkwKSByZXR1cm4gJ3RleHQtZ3JlZW4tNjAwIGJnLWdyZWVuLTUwJztcbiAgICBpZiAoY29uZmlkZW5jZSA+PSA3MCkgcmV0dXJuICd0ZXh0LXllbGxvdy02MDAgYmcteWVsbG93LTUwJztcbiAgICByZXR1cm4gJ3RleHQtcmVkLTYwMCBiZy1yZWQtNTAnO1xuICB9O1xuXG4gIGNvbnN0IGdldFN0YXR1c0ljb24gPSAoc3RhdHVzOiBzdHJpbmcpID0+IHtcbiAgICBzd2l0Y2ggKHN0YXR1cykge1xuICAgICAgY2FzZSAnY29uZmlybWVkJzpcbiAgICAgICAgcmV0dXJuIDxDaGVja0NpcmNsZSBjbGFzc05hbWU9XCJ3LTUgaC01IHRleHQtZ3JlZW4tNTAwXCIgLz47XG4gICAgICBjYXNlICdyZXZpZXdpbmcnOlxuICAgICAgICByZXR1cm4gPEFsZXJ0Q2lyY2xlIGNsYXNzTmFtZT1cInctNSBoLTUgdGV4dC15ZWxsb3ctNTAwXCIgLz47XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gPExvYWRlcjIgY2xhc3NOYW1lPVwidy01IGgtNSB0ZXh0LWJsdWUtNTAwIGFuaW1hdGUtc3BpblwiIC8+O1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gKFxuICAgIDxGZWF0dXJlR2F0ZSBmZWF0dXJlPVwib2NyUmVjZWlwdHNcIj5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwic3BhY2UteS02XCI+XG4gICAgICAgIHsvKiBVcGxvYWQgU2VjdGlvbiAqL31cbiAgICAgICAgPENhcmQ+XG4gICAgICAgICAgPENhcmRIZWFkZXI+XG4gICAgICAgICAgICA8Q2FyZFRpdGxlIGNsYXNzTmFtZT1cImZsZXggaXRlbXMtY2VudGVyXCI+XG4gICAgICAgICAgICAgIDxDYW1lcmEgY2xhc3NOYW1lPVwidy01IGgtNSBtci0yXCIgLz5cbiAgICAgICAgICAgICAgUmVjZWlwdCBQcm9jZXNzaW5nIChPQ1IpXG4gICAgICAgICAgICA8L0NhcmRUaXRsZT5cbiAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQtc20gdGV4dC1ncmF5LTYwMFwiPlxuICAgICAgICAgICAgICBVcGxvYWQgb3IgY2FwdHVyZSByZWNlaXB0IHBob3RvcyB0byBhdXRvbWF0aWNhbGx5IGV4dHJhY3QgdHJhbnNhY3Rpb24gZGF0YS5cbiAgICAgICAgICAgIDwvcD5cbiAgICAgICAgICA8L0NhcmRIZWFkZXI+XG5cbiAgICAgICAgICA8Q2FyZENvbnRlbnQ+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInNwYWNlLXktNFwiPlxuICAgICAgICAgICAgICB7LyogVXBsb2FkIE9wdGlvbnMgKi99XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZ3JpZCBncmlkLWNvbHMtMSBtZDpncmlkLWNvbHMtMiBnYXAtNFwiPlxuICAgICAgICAgICAgICAgIDxsYWJlbFxuICAgICAgICAgICAgICAgICAgaHRtbEZvcj1cImZpbGUtdXBsb2FkLWlucHV0XCJcbiAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImN1cnNvci1wb2ludGVyXCJcbiAgICAgICAgICAgICAgICAgIG9uRHJvcD17aGFuZGxlRHJvcH1cbiAgICAgICAgICAgICAgICAgIG9uRHJhZ092ZXI9e2hhbmRsZURyYWdPdmVyfVxuICAgICAgICAgICAgICAgICAgb25EcmFnTGVhdmU9e2hhbmRsZURyYWdMZWF2ZX1cbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17YGgtMzIgZmxleCBmbGV4LWNvbCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgc3BhY2UteS0yIGJvcmRlci1kYXNoZWQgYm9yZGVyLTIgcm91bmRlZC1sZyB0cmFuc2l0aW9uLWNvbG9ycyAke1xuICAgICAgICAgICAgICAgICAgICBpc0RyYWdPdmVyXG4gICAgICAgICAgICAgICAgICAgICAgPyAnYm9yZGVyLWJsdWUtNDAwIGJnLWJsdWUtNTAnXG4gICAgICAgICAgICAgICAgICAgICAgOiAnYm9yZGVyLWdyYXktMzAwIGhvdmVyOmJvcmRlci1ncmF5LTQwMCBiZy13aGl0ZSBob3ZlcjpiZy1ncmF5LTUwJ1xuICAgICAgICAgICAgICAgICAgfWB9PlxuICAgICAgICAgICAgICAgICAgICA8VXBsb2FkIGNsYXNzTmFtZT1cInctOCBoLTggdGV4dC1ncmF5LTQwMFwiIC8+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInRleHQtc20gZm9udC1tZWRpdW1cIj5VcGxvYWQgb3IgRHJvcCBQaG90bzwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwidGV4dC14cyB0ZXh0LWdyYXktNTAwXCI+SlBHLCBQTkcgdXAgdG8gMTBNQjwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDwvbGFiZWw+XG5cbiAgICAgICAgICAgICAgICA8QnV0dG9uXG4gICAgICAgICAgICAgICAgICB2YXJpYW50PVwib3V0bGluZVwiXG4gICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJoLTMyIGZsZXggZmxleC1jb2wgaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIHNwYWNlLXktMiBib3JkZXItZGFzaGVkIGJvcmRlci0yXCJcbiAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9e2hhbmRsZUNhbWVyYUNhcHR1cmV9XG4gICAgICAgICAgICAgICAgICBkaXNhYmxlZD17aXNQcm9jZXNzaW5nfVxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgIDxDYW1lcmEgY2xhc3NOYW1lPVwidy04IGgtOCB0ZXh0LWdyYXktNDAwXCIgLz5cbiAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInRleHQtc20gZm9udC1tZWRpdW1cIj5UYWtlIFBob3RvPC9zcGFuPlxuICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwidGV4dC14cyB0ZXh0LWdyYXktNTAwXCI+VXNlIGRldmljZSBjYW1lcmE8L3NwYW4+XG4gICAgICAgICAgICAgICAgPC9CdXR0b24+XG4gICAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgICAgIGlkPVwiZmlsZS11cGxvYWQtaW5wdXRcIlxuICAgICAgICAgICAgICAgIHJlZj17ZmlsZUlucHV0UmVmfVxuICAgICAgICAgICAgICAgIHR5cGU9XCJmaWxlXCJcbiAgICAgICAgICAgICAgICBhY2NlcHQ9XCJpbWFnZS8qXCJcbiAgICAgICAgICAgICAgICBvbkNoYW5nZT17aGFuZGxlRmlsZVNlbGVjdH1cbiAgICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICAgICAgICBsZWZ0OiAnLTk5OTlweCcsXG4gICAgICAgICAgICAgICAgICB0b3A6ICctOTk5OXB4J1xuICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgIC8+XG5cbiAgICAgICAgICAgICAgey8qIEltYWdlIFByZXZpZXcgJiBQcm9jZXNzaW5nICovfVxuICAgICAgICAgICAgICB7cHJldmlld1VybCAmJiAoXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJib3JkZXIgcm91bmRlZC1sZyBwLTRcIj5cbiAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBpdGVtcy1zdGFydCBzcGFjZS14LTRcIj5cbiAgICAgICAgICAgICAgICAgICAgPGltZ1xuICAgICAgICAgICAgICAgICAgICAgIHNyYz17cHJldmlld1VybH1cbiAgICAgICAgICAgICAgICAgICAgICBhbHQ9XCJSZWNlaXB0IHByZXZpZXdcIlxuICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInctMzIgaC0zMiBvYmplY3QtY292ZXIgcm91bmRlZC1sZyBib3JkZXJcIlxuICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXgtMVwiPlxuICAgICAgICAgICAgICAgICAgICAgIDxoNCBjbGFzc05hbWU9XCJmb250LW1lZGl1bSB0ZXh0LWdyYXktOTAwIG1iLTJcIj5SZWFkeSB0byBQcm9jZXNzPC9oND5cbiAgICAgICAgICAgICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJ0ZXh0LXNtIHRleHQtZ3JheS02MDAgbWItNFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgVGhlIHJlY2VpcHQgaW1hZ2Ugd2lsbCBiZSBhbmFseXplZCB0byBleHRyYWN0IHRyYW5zYWN0aW9uIGRldGFpbHMgYXV0b21hdGljYWxseS5cbiAgICAgICAgICAgICAgICAgICAgICA8L3A+XG4gICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IHNwYWNlLXgtM1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPEJ1dHRvblxuICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXtwcm9jZXNzUmVjZWlwdH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ9e2lzUHJvY2Vzc2luZ31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiYmctcHVycGxlLTYwMCBob3ZlcjpiZy1wdXJwbGUtNzAwXCJcbiAgICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgICAge2lzUHJvY2Vzc2luZyA/IChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPExvYWRlcjIgY2xhc3NOYW1lPVwidy00IGgtNCBtci0yIGFuaW1hdGUtc3BpblwiIC8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQcm9jZXNzaW5nLi4uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICkgOiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxGaWxlSW1hZ2UgY2xhc3NOYW1lPVwidy00IGgtNCBtci0yXCIgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFByb2Nlc3MgUmVjZWlwdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICAgICAgICAgICAgPC9CdXR0b24+XG4gICAgICAgICAgICAgICAgICAgICAgICA8QnV0dG9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhbnQ9XCJvdXRsaW5lXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFNlbGVjdGVkRmlsZShudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRQcmV2aWV3VXJsKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAgICBDYW5jZWxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvQnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICApfVxuXG4gICAgICAgICAgICAgIHsvKiBQcm9jZXNzaW5nIFN0YXR1cyAqL31cbiAgICAgICAgICAgICAge2lzUHJvY2Vzc2luZyAmJiAoXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0ZXh0LWNlbnRlciBweS04XCI+XG4gICAgICAgICAgICAgICAgICA8TG9hZGVyMiBjbGFzc05hbWU9XCJ3LTggaC04IGFuaW1hdGUtc3BpbiBteC1hdXRvIG1iLTQgdGV4dC1wdXJwbGUtNjAwXCIgLz5cbiAgICAgICAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQtbGcgZm9udC1tZWRpdW0gdGV4dC1ncmF5LTkwMFwiPlByb2Nlc3NpbmcgUmVjZWlwdC4uLjwvcD5cbiAgICAgICAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQtc20gdGV4dC1ncmF5LTYwMFwiPlVzaW5nIEFJIHRvIGV4dHJhY3QgdHJhbnNhY3Rpb24gZGV0YWlsczwvcD5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvQ2FyZENvbnRlbnQ+XG4gICAgICAgIDwvQ2FyZD5cblxuICAgICAgICB7LyogUHJvY2Vzc2VkIFJlY2VpcHRzICovfVxuICAgICAgICB7cHJvY2Vzc2VkUmVjZWlwdHMubGVuZ3RoID4gMCAmJiAoXG4gICAgICAgICAgPENhcmQ+XG4gICAgICAgICAgICA8Q2FyZEhlYWRlcj5cbiAgICAgICAgICAgICAgPENhcmRUaXRsZT5Qcm9jZXNzZWQgUmVjZWlwdHM8L0NhcmRUaXRsZT5cbiAgICAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC1zbSB0ZXh0LWdyYXktNjAwXCI+XG4gICAgICAgICAgICAgICAgUmV2aWV3IGFuZCBjb25maXJtIHRoZSBleHRyYWN0ZWQgdHJhbnNhY3Rpb24gZGF0YS5cbiAgICAgICAgICAgICAgPC9wPlxuICAgICAgICAgICAgPC9DYXJkSGVhZGVyPlxuXG4gICAgICAgICAgICA8Q2FyZENvbnRlbnQ+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwic3BhY2UteS00XCI+XG4gICAgICAgICAgICAgICAge3Byb2Nlc3NlZFJlY2VpcHRzLm1hcCgocmVjZWlwdCkgPT4gKFxuICAgICAgICAgICAgICAgICAgPGRpdiBrZXk9e3JlY2VpcHQuaWR9IGNsYXNzTmFtZT1cImJvcmRlciByb3VuZGVkLWxnIHAtNFwiPlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggaXRlbXMtc3RhcnQganVzdGlmeS1iZXR3ZWVuIG1iLTNcIj5cbiAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggaXRlbXMtY2VudGVyIHNwYWNlLXgtM1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAge2dldFN0YXR1c0ljb24ocmVjZWlwdC5zdGF0dXMpfVxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgPGg0IGNsYXNzTmFtZT1cImZvbnQtbWVkaXVtIHRleHQtZ3JheS05MDBcIj57cmVjZWlwdC5tZXJjaGFudH08L2g0PlxuICAgICAgICAgICAgICAgICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJ0ZXh0LXNtIHRleHQtZ3JheS02MDBcIj57cmVjZWlwdC5kYXRlfTwvcD5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBpdGVtcy1jZW50ZXIgc3BhY2UteC0zXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9e2BweC0yIHB5LTEgdGV4dC14cyByb3VuZGVkLWZ1bGwgJHtnZXRDb25maWRlbmNlQ29sb3IocmVjZWlwdC5jb25maWRlbmNlKX1gfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAge3JlY2VpcHQuY29uZmlkZW5jZX0lIGNvbmZpZGVuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidGV4dC1yaWdodFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJ0ZXh0LWxnIGZvbnQtYm9sZCB0ZXh0LWdyYXktOTAwXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHtyZWNlaXB0LmFtb3VudC50b0ZpeGVkKDIpfVxuICAgICAgICAgICAgICAgICAgICAgICAgICA8L3A+XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHtyZWNlaXB0LmNhdGVnb3J5ICYmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJ0ZXh0LXhzIHRleHQtZ3JheS01MDBcIj57cmVjZWlwdC5jYXRlZ29yeX08L3A+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgICAgICAgICAgey8qIEl0ZW1zIExpc3QgKi99XG4gICAgICAgICAgICAgICAgICAgIHtyZWNlaXB0Lml0ZW1zICYmIHJlY2VpcHQuaXRlbXMubGVuZ3RoID4gMCAmJiAoXG4gICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtYi00XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8aDUgY2xhc3NOYW1lPVwidGV4dC1zbSBmb250LW1lZGl1bSB0ZXh0LWdyYXktNzAwIG1iLTJcIj5JdGVtczo8L2g1PlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJiZy1ncmF5LTUwIHJvdW5kZWQtbGcgcC0zXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwic3BhY2UteS0xIHRleHQteHNcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7cmVjZWlwdC5pdGVtcy5tYXAoKGl0ZW0sIGluZGV4KSA9PiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGtleT17aW5kZXh9IGNsYXNzTmFtZT1cImZsZXgganVzdGlmeS1iZXR3ZWVuXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuPntpdGVtLnF1YW50aXR5ICYmIGl0ZW0ucXVhbnRpdHkgPiAxICYmIGAke2l0ZW0ucXVhbnRpdHl9eCBgfXtpdGVtLm5hbWV9PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3Bhbj4ke2l0ZW0ucHJpY2UudG9GaXhlZCgyKX08L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApKX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgKX1cblxuICAgICAgICAgICAgICAgICAgICB7LyogQWN0aW9ucyAqL31cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGp1c3RpZnktYmV0d2VlbiBpdGVtcy1jZW50ZXJcIj5cbiAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggc3BhY2UteC0yXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICB7cmVjZWlwdC5zdGF0dXMgPT09ICdyZXZpZXdpbmcnICYmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8QnV0dG9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaXplPVwic21cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gY29uZmlybVRyYW5zYWN0aW9uKHJlY2VpcHQuaWQpfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiYmctZ3JlZW4tNjAwIGhvdmVyOmJnLWdyZWVuLTcwMFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPENoZWNrQ2lyY2xlIGNsYXNzTmFtZT1cInctNCBoLTQgbXItMVwiIC8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDb25maXJtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9CdXR0b24+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPEJ1dHRvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZT1cInNtXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhbnQ9XCJvdXRsaW5lXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IGVkaXRUcmFuc2FjdGlvbihyZWNlaXB0LmlkKX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8RWRpdCBjbGFzc05hbWU9XCJ3LTQgaC00IG1yLTFcIiAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRWRpdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvQnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgICA8Lz5cbiAgICAgICAgICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAgICAgICAgICB7cmVjZWlwdC5zdGF0dXMgPT09ICdjb25maXJtZWQnICYmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwidGV4dC1zbSB0ZXh0LWdyZWVuLTYwMCBmbGV4IGl0ZW1zLWNlbnRlclwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxDaGVja0NpcmNsZSBjbGFzc05hbWU9XCJ3LTQgaC00IG1yLTFcIiAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRyYW5zYWN0aW9uIEFkZGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgPEJ1dHRvblxuICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZT1cInNtXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhbnQ9XCJvdXRsaW5lXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IGRlbGV0ZVJlY2VpcHQocmVjZWlwdC5pZCl9XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJ0ZXh0LXJlZC02MDAgYm9yZGVyLXJlZC0yMDAgaG92ZXI6YmctcmVkLTUwXCJcbiAgICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICA8WCBjbGFzc05hbWU9XCJ3LTQgaC00XCIgLz5cbiAgICAgICAgICAgICAgICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICApKX1cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L0NhcmRDb250ZW50PlxuICAgICAgICAgIDwvQ2FyZD5cbiAgICAgICAgKX1cblxuICAgICAgICB7LyogVXNhZ2UgVGlwcyAqL31cbiAgICAgICAgPENhcmQ+XG4gICAgICAgICAgPENhcmRIZWFkZXI+XG4gICAgICAgICAgICA8Q2FyZFRpdGxlPlRpcHMgZm9yIEJldHRlciBSZXN1bHRzPC9DYXJkVGl0bGU+XG4gICAgICAgICAgPC9DYXJkSGVhZGVyPlxuICAgICAgICAgIDxDYXJkQ29udGVudD5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZ3JpZCBncmlkLWNvbHMtMSBtZDpncmlkLWNvbHMtMiBnYXAtNCB0ZXh0LXNtXCI+XG4gICAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAgPGg0IGNsYXNzTmFtZT1cImZvbnQtbWVkaXVtIHRleHQtZ3JheS05MDAgbWItMlwiPvCfk7cgUGhvdG8gUXVhbGl0eTwvaDQ+XG4gICAgICAgICAgICAgICAgPHVsIGNsYXNzTmFtZT1cInNwYWNlLXktMSB0ZXh0LWdyYXktNjAwXCI+XG4gICAgICAgICAgICAgICAgICA8bGk+4oCiIEVuc3VyZSBnb29kIGxpZ2h0aW5nPC9saT5cbiAgICAgICAgICAgICAgICAgIDxsaT7igKIgS2VlcCByZWNlaXB0IGZsYXQgYW5kIHN0cmFpZ2h0PC9saT5cbiAgICAgICAgICAgICAgICAgIDxsaT7igKIgQXZvaWQgc2hhZG93cyBhbmQgZ2xhcmU8L2xpPlxuICAgICAgICAgICAgICAgICAgPGxpPuKAoiBDYXB0dXJlIHRoZSBlbnRpcmUgcmVjZWlwdDwvbGk+XG4gICAgICAgICAgICAgICAgPC91bD5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAgPGg0IGNsYXNzTmFtZT1cImZvbnQtbWVkaXVtIHRleHQtZ3JheS05MDAgbWItMlwiPuKcqCBCZXN0IFByYWN0aWNlczwvaDQ+XG4gICAgICAgICAgICAgICAgPHVsIGNsYXNzTmFtZT1cInNwYWNlLXktMSB0ZXh0LWdyYXktNjAwXCI+XG4gICAgICAgICAgICAgICAgICA8bGk+4oCiIFByb2Nlc3MgcmVjZWlwdHMgaW1tZWRpYXRlbHk8L2xpPlxuICAgICAgICAgICAgICAgICAgPGxpPuKAoiBSZXZpZXcgZXh0cmFjdGVkIGRhdGEgY2FyZWZ1bGx5PC9saT5cbiAgICAgICAgICAgICAgICAgIDxsaT7igKIgQ29uZmlybSBvciBlZGl0IGJlZm9yZSBzYXZpbmc8L2xpPlxuICAgICAgICAgICAgICAgICAgPGxpPuKAoiBDYXRlZ29yeSBzdWdnZXN0aW9ucyBhcmUgYXV0by1nZW5lcmF0ZWQ8L2xpPlxuICAgICAgICAgICAgICAgIDwvdWw+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC9DYXJkQ29udGVudD5cbiAgICAgICAgPC9DYXJkPlxuICAgICAgPC9kaXY+XG4gICAgPC9GZWF0dXJlR2F0ZT5cbiAgKTtcbn0iXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VTdGF0ZSIsInVzZVJlZiIsIkNhcmQiLCJDYXJkSGVhZGVyIiwiQ2FyZFRpdGxlIiwiQ2FyZENvbnRlbnQiLCJCdXR0b24iLCJGZWF0dXJlR2F0ZSIsIkNhbWVyYSIsIlVwbG9hZCIsIkZpbGVJbWFnZSIsIkNoZWNrQ2lyY2xlIiwiQWxlcnRDaXJjbGUiLCJMb2FkZXIyIiwiWCIsIkVkaXQiLCJ1c2VEYXRhRW5naW5lIiwiT0NSUmVjZWlwdFByb2Nlc3NvciIsImlzUHJvY2Vzc2luZyIsInNldElzUHJvY2Vzc2luZyIsInByb2Nlc3NpbmdTdGF0dXMiLCJzZXRQcm9jZXNzaW5nU3RhdHVzIiwicHJvY2Vzc2VkUmVjZWlwdHMiLCJzZXRQcm9jZXNzZWRSZWNlaXB0cyIsInNlbGVjdGVkRmlsZSIsInNldFNlbGVjdGVkRmlsZSIsInByZXZpZXdVcmwiLCJzZXRQcmV2aWV3VXJsIiwiaXNEcmFnT3ZlciIsInNldElzRHJhZ092ZXIiLCJmaWxlSW5wdXRSZWYiLCJkYXRhRW5naW5lIiwiaGFuZGxlRmlsZVNlbGVjdCIsImV2ZW50IiwiZmlsZSIsInRhcmdldCIsImZpbGVzIiwidHlwZSIsInN0YXJ0c1dpdGgiLCJ1cmwiLCJVUkwiLCJjcmVhdGVPYmplY3RVUkwiLCJoYW5kbGVEcm9wIiwiZSIsInByZXZlbnREZWZhdWx0IiwiQXJyYXkiLCJmcm9tIiwiZGF0YVRyYW5zZmVyIiwiaW1hZ2VGaWxlIiwiZmluZCIsImhhbmRsZURyYWdPdmVyIiwiaGFuZGxlRHJhZ0xlYXZlIiwiaGFuZGxlQ2FtZXJhQ2FwdHVyZSIsInN0cmVhbSIsIm5hdmlnYXRvciIsIm1lZGlhRGV2aWNlcyIsImdldFVzZXJNZWRpYSIsInZpZGVvIiwiZmFjaW5nTW9kZSIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsInNyY09iamVjdCIsInBsYXkiLCJhbGVydCIsImdldFRyYWNrcyIsImZvckVhY2giLCJ0cmFjayIsInN0b3AiLCJlcnJvciIsImNvbnNvbGUiLCJwcm9jZXNzUmVjZWlwdCIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsInByb2Nlc3NlZCIsImlkIiwiRGF0ZSIsIm5vdyIsInRvU3RyaW5nIiwibWVyY2hhbnQiLCJhbW91bnQiLCJkYXRlIiwidG9JU09TdHJpbmciLCJzcGxpdCIsImNhdGVnb3J5IiwiaXRlbXMiLCJuYW1lIiwicHJpY2UiLCJxdWFudGl0eSIsImNvbmZpZGVuY2UiLCJzdGF0dXMiLCJwcmV2IiwiY3VycmVudCIsInZhbHVlIiwiY29uZmlybVRyYW5zYWN0aW9uIiwicmVjZWlwdElkIiwibWFwIiwicmVjZWlwdCIsImVkaXRUcmFuc2FjdGlvbiIsImRlbGV0ZVJlY2VpcHQiLCJmaWx0ZXIiLCJnZXRDb25maWRlbmNlQ29sb3IiLCJnZXRTdGF0dXNJY29uIiwiY2xhc3NOYW1lIiwiZmVhdHVyZSIsImRpdiIsInAiLCJsYWJlbCIsImh0bWxGb3IiLCJvbkRyb3AiLCJvbkRyYWdPdmVyIiwib25EcmFnTGVhdmUiLCJzcGFuIiwidmFyaWFudCIsIm9uQ2xpY2siLCJkaXNhYmxlZCIsImlucHV0IiwicmVmIiwiYWNjZXB0Iiwib25DaGFuZ2UiLCJzdHlsZSIsInBvc2l0aW9uIiwibGVmdCIsInRvcCIsImltZyIsInNyYyIsImFsdCIsImg0IiwibGVuZ3RoIiwidG9GaXhlZCIsImg1IiwiaXRlbSIsImluZGV4Iiwic2l6ZSIsInVsIiwibGkiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/receipts/OCRReceiptProcessor.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./hooks/useDataEngine.ts":
/*!********************************!*\
  !*** ./hooks/useDataEngine.ts ***!
  \********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useDataEngine: () => (/* binding */ useDataEngine)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/../../node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_auth_react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next-auth/react */ \"(app-pages-browser)/../../node_modules/next-auth/react/index.js\");\n/* harmony import */ var next_auth_react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(next_auth_react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _lib_database_DataEngineFactory__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/database/DataEngineFactory */ \"(app-pages-browser)/./lib/database/DataEngineFactory.ts\");\n/* __next_internal_client_entry_do_not_use__ useDataEngine auto */ \n\n\nfunction useDataEngine() {\n    var _session_user, _session_user1, _session_user2;\n    const { data: session } = (0,next_auth_react__WEBPACK_IMPORTED_MODULE_1__.useSession)();\n    const [dataEngine, setDataEngine] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [isInitializing, setIsInitializing] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    const [stats, setStats] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        totalBalance: 0,\n        transactionCount: 0,\n        categoryCount: 0,\n        budgetCount: 0,\n        recentTransactions: [],\n        categories: [],\n        accounts: []\n    });\n    // Initialize data engine when session is available\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useDataEngine.useEffect\": ()=>{\n            var _session_user, _session_user1, _session_user2, _session_user3;\n            console.log('🔄 useDataEngine effect triggered');\n            console.log('📊 Session status:', {\n                hasSession: !!session,\n                hasUser: !!(session === null || session === void 0 ? void 0 : session.user),\n                userId: session === null || session === void 0 ? void 0 : (_session_user = session.user) === null || _session_user === void 0 ? void 0 : _session_user.id,\n                userEmail: session === null || session === void 0 ? void 0 : (_session_user1 = session.user) === null || _session_user1 === void 0 ? void 0 : _session_user1.email,\n                subscription: session === null || session === void 0 ? void 0 : (_session_user2 = session.user) === null || _session_user2 === void 0 ? void 0 : _session_user2.subscription\n            });\n            if (!(session === null || session === void 0 ? void 0 : (_session_user3 = session.user) === null || _session_user3 === void 0 ? void 0 : _session_user3.id)) {\n                console.log('⚠️ No session user ID, skipping initialization');\n                return;\n            }\n            const initEngine = {\n                \"useDataEngine.useEffect.initEngine\": async ()=>{\n                    try {\n                        var _session_user;\n                        console.log('🚀 Starting data engine initialization for user:', session.user.id);\n                        setIsInitializing(true);\n                        const subscriptionStatus = {\n                            tier: ((_session_user = session.user) === null || _session_user === void 0 ? void 0 : _session_user.subscription) || 'free',\n                            status: 'active'\n                        };\n                        console.log('🎯 Initializing with subscription:', subscriptionStatus);\n                        const engine = await (0,_lib_database_DataEngineFactory__WEBPACK_IMPORTED_MODULE_2__.initializeDataEngine)(session.user.id, subscriptionStatus);\n                        setDataEngine(engine);\n                        console.log('✅ Data engine initialized successfully:', engine.getSubscriptionTier());\n                        // Load initial stats\n                        console.log('📈 Loading initial stats...');\n                        await refreshStats(engine);\n                        console.log('✅ Initial stats loaded');\n                    } catch (error) {\n                        console.error('❌ Failed to initialize data engine:', error);\n                    } finally{\n                        console.log('🏁 Data engine initialization complete, setting isInitializing to false');\n                        setIsInitializing(false);\n                    }\n                }\n            }[\"useDataEngine.useEffect.initEngine\"];\n            initEngine();\n        }\n    }[\"useDataEngine.useEffect\"], [\n        session === null || session === void 0 ? void 0 : (_session_user = session.user) === null || _session_user === void 0 ? void 0 : _session_user.id,\n        session === null || session === void 0 ? void 0 : (_session_user1 = session.user) === null || _session_user1 === void 0 ? void 0 : _session_user1.subscription\n    ]);\n    // Refresh dashboard statistics\n    const refreshStats = async (engine)=>{\n        var _session_user;\n        if (!(session === null || session === void 0 ? void 0 : (_session_user = session.user) === null || _session_user === void 0 ? void 0 : _session_user.id)) return;\n        const activeEngine = engine || dataEngine;\n        if (!activeEngine) return;\n        try {\n            var _activeEngine_getAccounts, _activeEngine_getCategories, _activeEngine_getBudgets;\n            // Get accounts and calculate total balance\n            const accounts = await ((_activeEngine_getAccounts = activeEngine.getAccounts) === null || _activeEngine_getAccounts === void 0 ? void 0 : _activeEngine_getAccounts.call(activeEngine, session.user.id)) || [];\n            const totalBalance = accounts.reduce((sum, account)=>sum + Number(account.balance), 0);\n            // Get transactions\n            const transactions = await activeEngine.getTransactions() || [];\n            const recentTransactions = transactions.slice(0, 5); // Get 5 most recent\n            // Get categories\n            const categories = await ((_activeEngine_getCategories = activeEngine.getCategories) === null || _activeEngine_getCategories === void 0 ? void 0 : _activeEngine_getCategories.call(activeEngine, session.user.id)) || [];\n            // Get budgets\n            const budgets = await ((_activeEngine_getBudgets = activeEngine.getBudgets) === null || _activeEngine_getBudgets === void 0 ? void 0 : _activeEngine_getBudgets.call(activeEngine, session.user.id)) || [];\n            setStats({\n                totalBalance,\n                transactionCount: transactions.length,\n                categoryCount: categories.length,\n                budgetCount: budgets.length,\n                recentTransactions,\n                categories,\n                accounts\n            });\n            console.log('Stats updated:', {\n                totalBalance,\n                transactionCount: transactions.length,\n                categoryCount: categories.length,\n                accounts: accounts.length\n            });\n        } catch (error) {\n            console.error('Failed to refresh stats:', error);\n        }\n    };\n    // Add a new transaction\n    const addTransaction = async (transactionData)=>{\n        var _session_user;\n        if (!dataEngine || !(session === null || session === void 0 ? void 0 : (_session_user = session.user) === null || _session_user === void 0 ? void 0 : _session_user.id)) return null;\n        try {\n            const transaction = await dataEngine.addTransaction({\n                ...transactionData,\n                userId: session.user.id,\n                date: transactionData.date || new Date()\n            });\n            // Refresh stats after adding transaction\n            await refreshStats();\n            return transaction;\n        } catch (error) {\n            console.error('Failed to add transaction:', error);\n            throw error;\n        }\n    };\n    // Add a new budget\n    const addBudget = async (budgetData)=>{\n        var _session_user;\n        if (!dataEngine || !(session === null || session === void 0 ? void 0 : (_session_user = session.user) === null || _session_user === void 0 ? void 0 : _session_user.id)) return null;\n        try {\n            const budget = await dataEngine.createBudget({\n                ...budgetData,\n                userId: session.user.id\n            });\n            // Refresh stats after adding budget\n            await refreshStats();\n            return budget;\n        } catch (error) {\n            console.error('Failed to add budget:', error);\n            throw error;\n        }\n    };\n    // Get analytics data\n    const getCategorySpending = async (startDate, endDate)=>{\n        var _session_user;\n        if (!dataEngine || !(session === null || session === void 0 ? void 0 : (_session_user = session.user) === null || _session_user === void 0 ? void 0 : _session_user.id)) return [];\n        try {\n            return await dataEngine.calculateCategorySpending(session.user.id, startDate, endDate);\n        } catch (error) {\n            console.error('Failed to get category spending:', error);\n            return [];\n        }\n    };\n    // Get budget progress\n    const getBudgetProgress = async ()=>{\n        var _session_user;\n        if (!dataEngine || !(session === null || session === void 0 ? void 0 : (_session_user = session.user) === null || _session_user === void 0 ? void 0 : _session_user.id)) return [];\n        try {\n            return await dataEngine.getBudgetProgress(session.user.id);\n        } catch (error) {\n            console.error('Failed to get budget progress:', error);\n            return [];\n        }\n    };\n    return {\n        dataEngine,\n        isInitializing,\n        stats,\n        refreshStats: ()=>refreshStats(),\n        addTransaction,\n        addBudget,\n        getCategorySpending,\n        getBudgetProgress,\n        subscriptionTier: (session === null || session === void 0 ? void 0 : (_session_user2 = session.user) === null || _session_user2 === void 0 ? void 0 : _session_user2.subscription) || 'free',\n        hasUnsavedChanges: (dataEngine === null || dataEngine === void 0 ? void 0 : dataEngine.hasUnsavedChanges()) || false\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2hvb2tzL3VzZURhdGFFbmdpbmUudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O21FQUU0QztBQUNDO0FBRTJCO0FBWWpFLFNBQVNJO1FBK0RWQyxlQUFtQkEsZ0JBMkhIQTtJQXpMcEIsTUFBTSxFQUFFQyxNQUFNRCxPQUFPLEVBQUUsR0FBR0gsMkRBQVVBO0lBQ3BDLE1BQU0sQ0FBQ0ssWUFBWUMsY0FBYyxHQUFHUiwrQ0FBUUEsQ0FBeUI7SUFDckUsTUFBTSxDQUFDUyxnQkFBZ0JDLGtCQUFrQixHQUFHViwrQ0FBUUEsQ0FBQztJQUNyRCxNQUFNLENBQUNXLE9BQU9DLFNBQVMsR0FBR1osK0NBQVFBLENBQWlCO1FBQ2pEYSxjQUFjO1FBQ2RDLGtCQUFrQjtRQUNsQkMsZUFBZTtRQUNmQyxhQUFhO1FBQ2JDLG9CQUFvQixFQUFFO1FBQ3RCQyxZQUFZLEVBQUU7UUFDZEMsVUFBVSxFQUFFO0lBQ2Q7SUFFQSxtREFBbUQ7SUFDbkRsQixnREFBU0E7bUNBQUM7Z0JBS0VJLGVBQ0dBLGdCQUNHQSxnQkFHWEE7WUFUTGUsUUFBUUMsR0FBRyxDQUFDO1lBQ1pELFFBQVFDLEdBQUcsQ0FBQyxzQkFBc0I7Z0JBQ2hDQyxZQUFZLENBQUMsQ0FBQ2pCO2dCQUNka0IsU0FBUyxDQUFDLEVBQUNsQixvQkFBQUEsOEJBQUFBLFFBQVNtQixJQUFJO2dCQUN4QkMsTUFBTSxFQUFFcEIsb0JBQUFBLCtCQUFBQSxnQkFBQUEsUUFBU21CLElBQUksY0FBYm5CLG9DQUFBQSxjQUFlcUIsRUFBRTtnQkFDekJDLFNBQVMsRUFBRXRCLG9CQUFBQSwrQkFBQUEsaUJBQUFBLFFBQVNtQixJQUFJLGNBQWJuQixxQ0FBQUEsZUFBZXVCLEtBQUs7Z0JBQy9CQyxZQUFZLEVBQUV4QixvQkFBQUEsK0JBQUFBLGlCQUFBQSxRQUFTbUIsSUFBSSxjQUFibkIscUNBQUFBLGVBQWV3QixZQUFZO1lBQzNDO1lBRUEsSUFBSSxFQUFDeEIsb0JBQUFBLCtCQUFBQSxpQkFB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QzlCMUQ7UUFBcEIsSUFBSSxDQUFDRSxjQUFjLEVBQUNGLG9CQUFBQSwrQkFBQUEsZ0JBQUFBLFFBQVNtQixJQUFJLGNBQWJuQixvQ0FBQUEsY0FBZXFCLEVBQUUsR0FBRSxPQUFPLEVBQUU7UUFFaEQsSUFBSTtZQUNGLE9BQU8sTUFBTW5CLFdBQVd5RCx5QkFBeUIsQ0FDL0MzRCxRQUFRbUIsSUFBSSxDQUFDRSxFQUFFLEVBQ2ZvQyxXQUNBQztRQUVKLEVBQUUsT0FBTzFCLE9BQU87WUFDZGpCLFFBQVFpQixLQUFLLENBQUMsb0NBQW9DQTtZQUNsRCxPQUFPLEVBQUU7UUFDWDtJQUNGO0lBRUEsc0JBQXNCO0lBQ3RCLE1BQU00QixvQkFBb0I7WUFDSjVEO1FBQXBCLElBQUksQ0FBQ0UsY0FBYyxFQUFDRixvQkFBQUEsK0JBQUFBLGdCQUFBQSxRQUFTbUIsSUFBSSxjQUFibkIsb0NBQUFBLGNBQWVxQixFQUFFLEdBQUUsT0FBTyxFQUFFO1FBRWhELElBQUk7WUFDRixPQUFPLE1BQU1uQixXQUFXMEQsaUJBQWlCLENBQUM1RCxRQUFRbUIsSUFBSSxDQUFDRSxFQUFFO1FBQzNELEVBQUUsT0FBT1csT0FBTztZQUNkakIsUUFBUWlCLEtBQUssQ0FBQyxrQ0FBa0NBO1lBQ2hELE9BQU8sRUFBRTtRQUNYO0lBQ0Y7SUFFQSxPQUFPO1FBQ0w5QjtRQUNBRTtRQUNBRTtRQUNBeUIsY0FBYyxJQUFNQTtRQUNwQmdCO1FBQ0FLO1FBQ0FJO1FBQ0FJO1FBQ0FDLGtCQUFrQjdELENBQUFBLG9CQUFBQSwrQkFBQUEsaUJBQUFBLFFBQVNtQixJQUFJLGNBQWJuQixxQ0FBQUEsZUFBZXdCLFlBQVksS0FBSTtRQUNqRHNDLG1CQUFtQjVELENBQUFBLHVCQUFBQSxpQ0FBQUEsV0FBWTRELGlCQUFpQixPQUFNO0lBQ3hEO0FBQ0YiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbmF0aGFcXE9uZURyaXZlXFxEZXNrdG9wXFxNb25leVF1ZXN0VjNcXHBhY2thZ2VzXFx3ZWJzaXRlXFxob29rc1xcdXNlRGF0YUVuZ2luZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG5cbmltcG9ydCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VTZXNzaW9uIH0gZnJvbSAnbmV4dC1hdXRoL3JlYWN0JztcbmltcG9ydCB7IExvY2FsRGF0YUVuZ2luZSwgU3Vic2NyaXB0aW9uU3RhdHVzIH0gZnJvbSAnQG1vbmV5cXVlc3Qvc2hhcmVkJztcbmltcG9ydCB7IGluaXRpYWxpemVEYXRhRW5naW5lIH0gZnJvbSAnQC9saWIvZGF0YWJhc2UvRGF0YUVuZ2luZUZhY3RvcnknO1xuXG5leHBvcnQgaW50ZXJmYWNlIERhc2hib2FyZFN0YXRzIHtcbiAgdG90YWxCYWxhbmNlOiBudW1iZXI7XG4gIHRyYW5zYWN0aW9uQ291bnQ6IG51bWJlcjtcbiAgY2F0ZWdvcnlDb3VudDogbnVtYmVyO1xuICBidWRnZXRDb3VudDogbnVtYmVyO1xuICByZWNlbnRUcmFuc2FjdGlvbnM6IGFueVtdO1xuICBjYXRlZ29yaWVzOiBhbnlbXTtcbiAgYWNjb3VudHM6IGFueVtdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlRGF0YUVuZ2luZSgpIHtcbiAgY29uc3QgeyBkYXRhOiBzZXNzaW9uIH0gPSB1c2VTZXNzaW9uKCk7XG4gIGNvbnN0IFtkYXRhRW5naW5lLCBzZXREYXRhRW5naW5lXSA9IHVzZVN0YXRlPExvY2FsRGF0YUVuZ2luZSB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbaXNJbml0aWFsaXppbmcsIHNldElzSW5pdGlhbGl6aW5nXSA9IHVzZVN0YXRlKHRydWUpO1xuICBjb25zdCBbc3RhdHMsIHNldFN0YXRzXSA9IHVzZVN0YXRlPERhc2hib2FyZFN0YXRzPih7XG4gICAgdG90YWxCYWxhbmNlOiAwLFxuICAgIHRyYW5zYWN0aW9uQ291bnQ6IDAsXG4gICAgY2F0ZWdvcnlDb3VudDogMCxcbiAgICBidWRnZXRDb3VudDogMCxcbiAgICByZWNlbnRUcmFuc2FjdGlvbnM6IFtdLFxuICAgIGNhdGVnb3JpZXM6IFtdLFxuICAgIGFjY291bnRzOiBbXVxuICB9KTtcblxuICAvLyBJbml0aWFsaXplIGRhdGEgZW5naW5lIHdoZW4gc2Vzc2lvbiBpcyBhdmFpbGFibGVcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zb2xlLmxvZygn8J+UhCB1c2VEYXRhRW5naW5lIGVmZmVjdCB0cmlnZ2VyZWQnKTtcbiAgICBjb25zb2xlLmxvZygn8J+TiiBTZXNzaW9uIHN0YXR1czonLCB7XG4gICAgICBoYXNTZXNzaW9uOiAhIXNlc3Npb24sXG4gICAgICBoYXNVc2VyOiAhIXNlc3Npb24/LnVzZXIsXG4gICAgICB1c2VySWQ6IHNlc3Npb24/LnVzZXI/LmlkLFxuICAgICAgdXNlckVtYWlsOiBzZXNzaW9uPy51c2VyPy5lbWFpbCxcbiAgICAgIHN1YnNjcmlwdGlvbjogc2Vzc2lvbj8udXNlcj8uc3Vic2NyaXB0aW9uXG4gICAgfSk7XG5cbiAgICBpZiAoIXNlc3Npb24/LnVzZXI/LmlkKSB7XG4gICAgICBjb25zb2xlLmxvZygn4pqg77iPIE5vIHNlc3Npb24gdXNlciBJRCwgc2tpcHBpbmcgaW5pdGlhbGl6YXRpb24nKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBpbml0RW5naW5lID0gYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc29sZS5sb2coJ/CfmoAgU3RhcnRpbmcgZGF0YSBlbmdpbmUgaW5pdGlhbGl6YXRpb24gZm9yIHVzZXI6Jywgc2Vzc2lvbi51c2VyLmlkKTtcbiAgICAgICAgc2V0SXNJbml0aWFsaXppbmcodHJ1ZSk7XG5cbiAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uU3RhdHVzOiBTdWJzY3JpcHRpb25TdGF0dXMgPSB7XG4gICAgICAgICAgdGllcjogc2Vzc2lvbi51c2VyPy5zdWJzY3JpcHRpb24gfHwgJ2ZyZWUnLFxuICAgICAgICAgIHN0YXR1czogJ2FjdGl2ZScsXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc29sZS5sb2coJ/Cfjq8gSW5pdGlhbGl6aW5nIHdpdGggc3Vic2NyaXB0aW9uOicsIHN1YnNjcmlwdGlvblN0YXR1cyk7XG5cbiAgICAgICAgY29uc3QgZW5naW5lID0gYXdhaXQgaW5pdGlhbGl6ZURhdGFFbmdpbmUoXG4gICAgICAgICAgc2Vzc2lvbi51c2VyLmlkLFxuICAgICAgICAgIHN1YnNjcmlwdGlvblN0YXR1c1xuICAgICAgICApO1xuXG4gICAgICAgIHNldERhdGFFbmdpbmUoZW5naW5lKTtcbiAgICAgICAgY29uc29sZS5sb2coJ+KchSBEYXRhIGVuZ2luZSBpbml0aWFsaXplZCBzdWNjZXNzZnVsbHk6JywgZW5naW5lLmdldFN1YnNjcmlwdGlvblRpZXIoKSk7XG5cbiAgICAgICAgLy8gTG9hZCBpbml0aWFsIHN0YXRzXG4gICAgICAgIGNvbnNvbGUubG9nKCfwn5OIIExvYWRpbmcgaW5pdGlhbCBzdGF0cy4uLicpO1xuICAgICAgICBhd2FpdCByZWZyZXNoU3RhdHMoZW5naW5lKTtcbiAgICAgICAgY29uc29sZS5sb2coJ+KchSBJbml0aWFsIHN0YXRzIGxvYWRlZCcpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcign4p2MIEZhaWxlZCB0byBpbml0aWFsaXplIGRhdGEgZW5naW5lOicsIGVycm9yKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCfwn4+BIERhdGEgZW5naW5lIGluaXRpYWxpemF0aW9uIGNvbXBsZXRlLCBzZXR0aW5nIGlzSW5pdGlhbGl6aW5nIHRvIGZhbHNlJyk7XG4gICAgICAgIHNldElzSW5pdGlhbGl6aW5nKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaW5pdEVuZ2luZSgpO1xuICB9LCBbc2Vzc2lvbj8udXNlcj8uaWQsIHNlc3Npb24/LnVzZXI/LnN1YnNjcmlwdGlvbl0pO1xuXG4gIC8vIFJlZnJlc2ggZGFzaGJvYXJkIHN0YXRpc3RpY3NcbiAgY29uc3QgcmVmcmVzaFN0YXRzID0gYXN5bmMgKGVuZ2luZT86IExvY2FsRGF0YUVuZ2luZSkgPT4ge1xuICAgIGlmICghc2Vzc2lvbj8udXNlcj8uaWQpIHJldHVybjtcblxuICAgIGNvbnN0IGFjdGl2ZUVuZ2luZSA9IGVuZ2luZSB8fCBkYXRhRW5naW5lO1xuICAgIGlmICghYWN0aXZlRW5naW5lKSByZXR1cm47XG5cbiAgICB0cnkge1xuICAgICAgLy8gR2V0IGFjY291bnRzIGFuZCBjYWxjdWxhdGUgdG90YWwgYmFsYW5jZVxuICAgICAgY29uc3QgYWNjb3VudHMgPSBhd2FpdCBhY3RpdmVFbmdpbmUuZ2V0QWNjb3VudHM/LihzZXNzaW9uLnVzZXIuaWQpIHx8IFtdO1xuICAgICAgY29uc3QgdG90YWxCYWxhbmNlID0gYWNjb3VudHMucmVkdWNlKChzdW06IG51bWJlciwgYWNjb3VudDogYW55KSA9PiBzdW0gKyBOdW1iZXIoYWNjb3VudC5iYWxhbmNlKSwgMCk7XG5cbiAgICAgIC8vIEdldCB0cmFuc2FjdGlvbnNcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9ucyA9IGF3YWl0IGFjdGl2ZUVuZ2luZS5nZXRUcmFuc2FjdGlvbnMoKSB8fCBbXTtcbiAgICAgIGNvbnN0IHJlY2VudFRyYW5zYWN0aW9ucyA9IHRyYW5zYWN0aW9ucy5zbGljZSgwLCA1KTsgLy8gR2V0IDUgbW9zdCByZWNlbnRcblxuICAgICAgLy8gR2V0IGNhdGVnb3JpZXNcbiAgICAgIGNvbnN0IGNhdGVnb3JpZXMgPSBhd2FpdCBhY3RpdmVFbmdpbmUuZ2V0Q2F0ZWdvcmllcz8uKHNlc3Npb24udXNlci5pZCkgfHwgW107XG5cbiAgICAgIC8vIEdldCBidWRnZXRzXG4gICAgICBjb25zdCBidWRnZXRzID0gYXdhaXQgYWN0aXZlRW5naW5lLmdldEJ1ZGdldHM/LihzZXNzaW9uLnVzZXIuaWQpIHx8IFtdO1xuXG4gICAgICBzZXRTdGF0cyh7XG4gICAgICAgIHRvdGFsQmFsYW5jZSxcbiAgICAgICAgdHJhbnNhY3Rpb25Db3VudDogdHJhbnNhY3Rpb25zLmxlbmd0aCxcbiAgICAgICAgY2F0ZWdvcnlDb3VudDogY2F0ZWdvcmllcy5sZW5ndGgsXG4gICAgICAgIGJ1ZGdldENvdW50OiBidWRnZXRzLmxlbmd0aCxcbiAgICAgICAgcmVjZW50VHJhbnNhY3Rpb25zLFxuICAgICAgICBjYXRlZ29yaWVzLFxuICAgICAgICBhY2NvdW50c1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnNvbGUubG9nKCdTdGF0cyB1cGRhdGVkOicsIHtcbiAgICAgICAgdG90YWxCYWxhbmNlLFxuICAgICAgICB0cmFuc2FjdGlvbkNvdW50OiB0cmFuc2FjdGlvbnMubGVuZ3RoLFxuICAgICAgICBjYXRlZ29yeUNvdW50OiBjYXRlZ29yaWVzLmxlbmd0aCxcbiAgICAgICAgYWNjb3VudHM6IGFjY291bnRzLmxlbmd0aFxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byByZWZyZXNoIHN0YXRzOicsIGVycm9yKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gQWRkIGEgbmV3IHRyYW5zYWN0aW9uXG4gIGNvbnN0IGFkZFRyYW5zYWN0aW9uID0gYXN5bmMgKHRyYW5zYWN0aW9uRGF0YTogYW55KSA9PiB7XG4gICAgaWYgKCFkYXRhRW5naW5lIHx8ICFzZXNzaW9uPy51c2VyPy5pZCkgcmV0dXJuIG51bGw7XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBhd2FpdCBkYXRhRW5naW5lLmFkZFRyYW5zYWN0aW9uKHtcbiAgICAgICAgLi4udHJhbnNhY3Rpb25EYXRhLFxuICAgICAgICB1c2VySWQ6IHNlc3Npb24udXNlci5pZCxcbiAgICAgICAgZGF0ZTogdHJhbnNhY3Rpb25EYXRhLmRhdGUgfHwgbmV3IERhdGUoKSxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBSZWZyZXNoIHN0YXRzIGFmdGVyIGFkZGluZyB0cmFuc2FjdGlvblxuICAgICAgYXdhaXQgcmVmcmVzaFN0YXRzKCk7XG5cbiAgICAgIHJldHVybiB0cmFuc2FjdGlvbjtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGFkZCB0cmFuc2FjdGlvbjonLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH07XG5cbiAgLy8gQWRkIGEgbmV3IGJ1ZGdldFxuICBjb25zdCBhZGRCdWRnZXQgPSBhc3luYyAoYnVkZ2V0RGF0YTogYW55KSA9PiB7XG4gICAgaWYgKCFkYXRhRW5naW5lIHx8ICFzZXNzaW9uPy51c2VyPy5pZCkgcmV0dXJuIG51bGw7XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgYnVkZ2V0ID0gYXdhaXQgZGF0YUVuZ2luZS5jcmVhdGVCdWRnZXQoe1xuICAgICAgICAuLi5idWRnZXREYXRhLFxuICAgICAgICB1c2VySWQ6IHNlc3Npb24udXNlci5pZCxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBSZWZyZXNoIHN0YXRzIGFmdGVyIGFkZGluZyBidWRnZXRcbiAgICAgIGF3YWl0IHJlZnJlc2hTdGF0cygpO1xuXG4gICAgICByZXR1cm4gYnVkZ2V0O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gYWRkIGJ1ZGdldDonLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH07XG5cbiAgLy8gR2V0IGFuYWx5dGljcyBkYXRhXG4gIGNvbnN0IGdldENhdGVnb3J5U3BlbmRpbmcgPSBhc3luYyAoc3RhcnREYXRlOiBEYXRlLCBlbmREYXRlOiBEYXRlKSA9PiB7XG4gICAgaWYgKCFkYXRhRW5naW5lIHx8ICFzZXNzaW9uPy51c2VyPy5pZCkgcmV0dXJuIFtdO1xuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCBkYXRhRW5naW5lLmNhbGN1bGF0ZUNhdGVnb3J5U3BlbmRpbmcoXG4gICAgICAgIHNlc3Npb24udXNlci5pZCxcbiAgICAgICAgc3RhcnREYXRlLFxuICAgICAgICBlbmREYXRlXG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZ2V0IGNhdGVnb3J5IHNwZW5kaW5nOicsIGVycm9yKTtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH07XG5cbiAgLy8gR2V0IGJ1ZGdldCBwcm9ncmVzc1xuICBjb25zdCBnZXRCdWRnZXRQcm9ncmVzcyA9IGFzeW5jICgpID0+IHtcbiAgICBpZiAoIWRhdGFFbmdpbmUgfHwgIXNlc3Npb24/LnVzZXI/LmlkKSByZXR1cm4gW107XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IGRhdGFFbmdpbmUuZ2V0QnVkZ2V0UHJvZ3Jlc3Moc2Vzc2lvbi51c2VyLmlkKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGdldCBidWRnZXQgcHJvZ3Jlc3M6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4ge1xuICAgIGRhdGFFbmdpbmUsXG4gICAgaXNJbml0aWFsaXppbmcsXG4gICAgc3RhdHMsXG4gICAgcmVmcmVzaFN0YXRzOiAoKSA9PiByZWZyZXNoU3RhdHMoKSxcbiAgICBhZGRUcmFuc2FjdGlvbixcbiAgICBhZGRCdWRnZXQsXG4gICAgZ2V0Q2F0ZWdvcnlTcGVuZGluZyxcbiAgICBnZXRCdWRnZXRQcm9ncmVzcyxcbiAgICBzdWJzY3JpcHRpb25UaWVyOiBzZXNzaW9uPy51c2VyPy5zdWJzY3JpcHRpb24gfHwgJ2ZyZWUnLFxuICAgIGhhc1Vuc2F2ZWRDaGFuZ2VzOiBkYXRhRW5naW5lPy5oYXNVbnNhdmVkQ2hhbmdlcygpIHx8IGZhbHNlXG4gIH07XG59Il0sIm5hbWVzIjpbInVzZVN0YXRlIiwidXNlRWZmZWN0IiwidXNlU2Vzc2lvbiIsImluaXRpYWxpemVEYXRhRW5naW5lIiwidXNlRGF0YUVuZ2luZSIsInNlc3Npb24iLCJkYXRhIiwiZGF0YUVuZ2luZSIsInNldERhdGFFbmdpbmUiLCJpc0luaXRpYWxpemluZyIsInNldElzSW5pdGlhbGl6aW5nIiwic3RhdHMiLCJzZXRTdGF0cyIsInRvdGFsQmFsYW5jZSIsInRyYW5zYWN0aW9uQ291bnQiLCJjYXRlZ29yeUNvdW50IiwiYnVkZ2V0Q291bnQiLCJyZWNlbnRUcmFuc2FjdGlvbnMiLCJjYXRlZ29yaWVzIiwiYWNjb3VudHMiLCJjb25zb2xlIiwibG9nIiwiaGFzU2Vzc2lvbiIsImhhc1VzZXIiLCJ1c2VyIiwidXNlcklkIiwiaWQiLCJ1c2VyRW1haWwiLCJlbWFpbCIsInN1YnNjcmlwdGlvbiIsImluaXRFbmdpbmUiLCJzdWJzY3JpcHRpb25TdGF0dXMiLCJ0aWVyIiwic3RhdHVzIiwiZW5naW5lIiwiZ2V0U3Vic2NyaXB0aW9uVGllciIsInJlZnJlc2hTdGF0cyIsImVycm9yIiwiYWN0aXZlRW5naW5lIiwiZ2V0QWNjb3VudHMiLCJyZWR1Y2UiLCJzdW0iLCJhY2NvdW50IiwiTnVtYmVyIiwiYmFsYW5jZSIsInRyYW5zYWN0aW9ucyIsImdldFRyYW5zYWN0aW9ucyIsInNsaWNlIiwiZ2V0Q2F0ZWdvcmllcyIsImJ1ZGdldHMiLCJnZXRCdWRnZXRzIiwibGVuZ3RoIiwiYWRkVHJhbnNhY3Rpb24iLCJ0cmFuc2FjdGlvbkRhdGEiLCJ0cmFuc2FjdGlvbiIsImRhdGUiLCJEYXRlIiwiYWRkQnVkZ2V0IiwiYnVkZ2V0RGF0YSIsImJ1ZGdldCIsImNyZWF0ZUJ1ZGdldCIsImdldENhdGVnb3J5U3BlbmRpbmciLCJzdGFydERhdGUiLCJlbmREYXRlIiwiY2FsY3VsYXRlQ2F0ZWdvcnlTcGVuZGluZyIsImdldEJ1ZGdldFByb2dyZXNzIiwic3Vic2NyaXB0aW9uVGllciIsImhhc1Vuc2F2ZWRDaGFuZ2VzIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/useDataEngine.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./lib/database/DataEngineFactory.ts":
/*!*******************************************!*\
  !*** ./lib/database/DataEngineFactory.ts ***!
  \*******************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DataEngineFactory: () => (/* binding */ DataEngineFactory),\n/* harmony export */   initializeDataEngine: () => (/* binding */ initializeDataEngine),\n/* harmony export */   useDataEngine: () => (/* binding */ useDataEngine)\n/* harmony export */ });\n/* harmony import */ var _moneyquest_shared__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @moneyquest/shared */ \"(app-pages-browser)/../shared/dist/index.js\");\n/* harmony import */ var _moneyquest_shared__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_moneyquest_shared__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _IndexedDBWrapper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./IndexedDBWrapper */ \"(app-pages-browser)/./lib/database/IndexedDBWrapper.ts\");\n\n\n/**\n * Factory for creating LocalDataEngine instances for the web app\n */ class DataEngineFactory {\n    /**\n   * Get or create a singleton LocalDataEngine instance\n   */ static async getInstance(userId, subscriptionStatus) {\n        if (!this.instance) {\n            this.instance = await this.createEngine(userId, subscriptionStatus);\n        }\n        return this.instance;\n    }\n    /**\n   * Create a new LocalDataEngine instance\n   */ static async createEngine(userId, subscriptionStatus) {\n        // Initialize IndexedDB wrapper\n        if (!this.dbWrapper) {\n            this.dbWrapper = new _IndexedDBWrapper__WEBPACK_IMPORTED_MODULE_1__.IndexedDBWrapper();\n            // Initialize with default data if userId provided\n            if (userId) {\n                await this.dbWrapper.initialize(userId);\n            }\n        }\n        // Create subscription manager\n        const subscription = new _moneyquest_shared__WEBPACK_IMPORTED_MODULE_0__.SubscriptionManager(subscriptionStatus || (0,_moneyquest_shared__WEBPACK_IMPORTED_MODULE_0__.createFreeSubscription)());\n        // Create backup service (minimal implementation for now)\n        const backupService = new WebBackupService(userId || 'anonymous', 'temp-key');\n        // Create and return LocalDataEngine\n        return new _moneyquest_shared__WEBPACK_IMPORTED_MODULE_0__.LocalDataEngine(this.dbWrapper, subscription, backupService);\n    }\n    /**\n   * Reset the singleton instance (useful for testing or user logout)\n   */ static reset() {\n        this.instance = null;\n        this.dbWrapper = null;\n    }\n    /**\n   * Get the database wrapper directly (for advanced operations)\n   */ static getDBWrapper() {\n        return this.dbWrapper;\n    }\n}\nDataEngineFactory.instance = null;\nDataEngineFactory.dbWrapper = null;\n/**\n * Web implementation of BackupService\n * Uses localStorage for simple backup/restore for now\n * In production, this would use encrypted cloud storage\n */ class WebBackupService extends _moneyquest_shared__WEBPACK_IMPORTED_MODULE_0__.BackupService {\n    async backup(data) {\n        try {\n            // Encrypt data in production\n            const backupData = {\n                data,\n                timestamp: new Date().toISOString(),\n                version: 1\n            };\n            // For now, store in localStorage (limited to ~5MB)\n            // In production, this would be encrypted and stored in S3\n            localStorage.setItem(WebBackupService.BACKUP_KEY, JSON.stringify(backupData));\n            console.log('Data backed up locally');\n        } catch (error) {\n            console.error('Failed to backup data:', error);\n            throw new Error(\"Backup failed: \".concat(error));\n        }\n    }\n    async restore() {\n        try {\n            const backupString = localStorage.getItem(WebBackupService.BACKUP_KEY);\n            if (!backupString) {\n                console.log('No backup data found');\n                return null;\n            }\n            const backupData = JSON.parse(backupString);\n            // Validate backup data structure\n            if (!backupData.data || !backupData.timestamp) {\n                throw new Error('Invalid backup data format');\n            }\n            console.log(\"Restored backup from \".concat(backupData.timestamp));\n            return backupData.data;\n        } catch (error) {\n            console.error('Failed to restore data:', error);\n            throw new Error(\"Restore failed: \".concat(error));\n        }\n    }\n    async hasBackup() {\n        return localStorage.getItem(WebBackupService.BACKUP_KEY) !== null;\n    }\n    async clearBackup() {\n        localStorage.removeItem(WebBackupService.BACKUP_KEY);\n        console.log('Backup data cleared');\n    }\n    constructor(userId, encryptionKey){\n        super(userId, encryptionKey);\n    }\n}\nWebBackupService.BACKUP_KEY = 'moneyquest_backup';\n/**\n * Hook for React components to get the data engine\n */ async function useDataEngine(userId, subscriptionStatus) {\n    return DataEngineFactory.getInstance(userId, subscriptionStatus);\n}\n/**\n * Initialize the data engine for the app\n */ async function initializeDataEngine(userId, subscriptionStatus) {\n    console.log(\"Initializing data engine for user: \".concat(userId));\n    const engine = await DataEngineFactory.createEngine(userId, subscriptionStatus);\n    // Check if we can restore from backup\n    const backupService = new WebBackupService(userId, 'temp-key');\n    const hasBackup = await backupService.hasBackup();\n    if (hasBackup) {\n        console.log('Backup found, attempting to restore...');\n        try {\n            await engine.restoreFromBackup();\n            console.log('Successfully restored from backup');\n        } catch (error) {\n            console.warn('Failed to restore from backup, continuing with fresh data:', error);\n        }\n    }\n    return engine;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9kYXRhYmFzZS9EYXRhRW5naW5lRmFjdG9yeS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFNNEI7QUFDMEI7QUFFdEQ7O0NBRUMsR0FDTSxNQUFNSztJQUlYOztHQUVDLEdBQ0QsYUFBYUMsWUFDWEMsTUFBZSxFQUNmQyxrQkFBdUMsRUFDYjtRQUMxQixJQUFJLENBQUMsSUFBSSxDQUFDQyxRQUFRLEVBQUU7WUFDbEIsSUFBSSxDQUFDQSxRQUFRLEdBQUcsTUFBTSxJQUFJLENBQUNDLFlBQVksQ0FBQ0gsUUFBUUM7UUFDbEQ7UUFDQSxPQUFPLElBQUksQ0FBQ0MsUUFBUTtJQUN0QjtJQUVBOztHQUVDLEdBQ0QsYUFBYUMsYUFDWEgsTUFBZSxFQUNmQyxrQkFBdUMsRUFDYjtRQUMxQiwrQkFBK0I7UUFDL0IsSUFBSSxDQUFDLElBQUksQ0FBQ0csU0FBUyxFQUFFO1lBQ25CLElBQUksQ0FBQ0EsU0FBUyxHQUFHLElBQUlQLCtEQUFnQkE7WUFFckMsa0RBQWtEO1lBQ2xELElBQUlHLFFBQVE7Z0JBQ1YsTUFBTSxJQUFJLENBQUNJLFNBQVMsQ0FBQ0MsVUFBVSxDQUFDTDtZQUNsQztRQUNGO1FBRUEsOEJBQThCO1FBQzlCLE1BQU1NLGVBQWUsSUFBSVosbUVBQW1CQSxDQUMxQ08sc0JBQXNCTCwwRUFBc0JBO1FBRzlDLHlEQUF5RDtRQUN6RCxNQUFNVyxnQkFBZ0IsSUFBSUMsaUJBQWlCUixVQUFVLGFBQWE7UUFFbEUsb0NBQW9DO1FBQ3BDLE9BQU8sSUFBSVAsK0RBQWVBLENBQ3hCLElBQUksQ0FBQ1csU0FBUyxFQUNkRSxjQUNBQztJQUVKO0lBRUE7O0dBRUMsR0FDRCxPQUFPRSxRQUFjO1FBQ25CLElBQUksQ0FBQ1AsUUFBUSxHQUFHO1FBQ2hCLElBQUksQ0FBQ0UsU0FBUyxHQUFHO0lBQ25CO0lBRUE7O0dBRUMsR0FDRCxPQUFPTSxlQUF3QztRQUM3QyxPQUFPLElBQUksQ0FBQ04sU0FBUztJQUN2QjtBQUNGO0FBaEVhTixrQkFDSUksV0FBbUM7QUFEdkNKLGtCQUVJTSxZQUFxQztBQWdFdEQ7Ozs7Q0FJQyxHQUNELE1BQU1JLHlCQUF5QmIsNkRBQWFBO0lBTzFDLE1BQU1nQixPQUFPQyxJQUFTLEVBQWlCO1FBQ3JDLElBQUk7WUFDRiw2QkFBNkI7WUFDN0IsTUFBTUMsYUFBYTtnQkFDakJEO2dCQUNBRSxXQUFXLElBQUlDLE9BQU9DLFdBQVc7Z0JBQ2pDQyxTQUFTO1lBQ1g7WUFFQSxtREFBbUQ7WUFDbkQsMERBQTBEO1lBQzFEQyxhQUFhQyxPQUFPLENBQ2xCWCxpQkFBaUJZLFVBQVUsRUFDM0JDLEtBQUtDLFNBQVMsQ0FBQ1Q7WUFHakJVLFFBQVFDLEdBQUcsQ0FBQztRQUNkLEVBQUUsT0FBT0MsT0FBTztZQUNkRixRQUFRRSxLQUFLLENBQUMsMEJBQTBCQTtZQUN4QyxNQUFNLElBQUlDLE1BQU0sa0JBQXdCLE9BQU5EO1FBQ3BDO0lBQ0Y7SUFFQSxNQUFNRSxVQUF3QjtRQUM1QixJQUFJO1lBQ0YsTUFBTUMsZUFBZVYsYUFBYVcsT0FBTyxDQUFDckIsaUJBQWlCWSxVQUFVO1lBRXJFLElBQUksQ0FBQ1EsY0FBYztnQkFDakJMLFFBQVFDLEdBQUcsQ0FBQztnQkFDWixPQUFPO1lBQ1Q7WUFFQSxNQUFNWCxhQUFhUSxLQUFLUyxLQUFLLENBQUNGO1lBRTlCLGlDQUFpQztZQUNqQyxJQUFJLENBQUNmLFdBQVdELElBQUksSUFBSSxDQUFDQyxXQUFXQyxTQUFTLEVBQUU7Z0JBQzdDLE1BQU0sSUFBSVksTUFBTTtZQUNsQjtZQUVBSCxRQUFRQyxHQUFHLENBQUMsd0JBQTZDLE9BQXJCWCxXQUFXQyxTQUFTO1lBQ3hELE9BQU9ELFdBQVdELElBQUk7UUFDeEIsRUFBRSxPQUFPYSxPQUFPO1lBQ2RGLFFBQVFFLEtBQUssQ0FBQywyQkFBMkJBO1lBQ3pDLE1BQU0sSUFBSUMsTUFBTSxtQkFBeUIsT0FBTkQ7UUFDckM7SUFDRjtJQUVBLE1BQU1NLFlBQThCO1FBQ2xDLE9BQU9iLGFBQWFXLE9BQU8sQ0FBQ3JCLGlCQUFpQlksVUFBVSxNQUFNO0lBQy9EO0lBRUEsTUFBTVksY0FBNkI7UUFDakNkLGFBQWFlLFVBQVUsQ0FBQ3pCLGlCQUFpQlksVUFBVTtRQUNuREcsUUFBUUMsR0FBRyxDQUFDO0lBQ2Q7SUExREEsWUFBWXhCLE1BQWMsRUFBRWtDLGFBQXFCLENBQUU7UUFDakQsS0FBSyxDQUFDbEMsUUFBUWtDO0lBQ2hCO0FBeURGO0FBOURNMUIsaUJBQ29CWSxhQUFhO0FBK0R2Qzs7Q0FFQyxHQUNNLGVBQWVlLGNBQ3BCbkMsTUFBZSxFQUNmQyxrQkFBdUM7SUFFdkMsT0FBT0gsa0JBQWtCQyxXQUFXLENBQUNDLFFBQVFDO0FBQy9DO0FBRUE7O0NBRUMsR0FDTSxlQUFlbUMscUJBQ3BCcEMsTUFBYyxFQUNkQyxrQkFBdUM7SUFFdkNzQixRQUFRQyxHQUFHLENBQUMsc0NBQTZDLE9BQVB4QjtJQUVsRCxNQUFNcUMsU0FBUyxNQUFNdkMsa0JBQWtCSyxZQUFZLENBQUNILFFBQVFDO0lBRTVELHNDQUFzQztJQUN0QyxNQUFNTSxnQkFBZ0IsSUFBSUMsaUJBQWlCUixRQUFRO0lBQ25ELE1BQU0rQixZQUFZLE1BQU14QixjQUFjd0IsU0FBUztJQUUvQyxJQUFJQSxXQUFXO1FBQ2JSLFFBQVFDLEdBQUcsQ0FBQztRQUNaLElBQUk7WUFDRixNQUFNYSxPQUFPQyxpQkFBaUI7WUFDOUJmLFFBQVFDLEdBQUcsQ0FBQztRQUNkLEVBQUUsT0FBT0MsT0FBTztZQUNkRixRQUFRZ0IsSUFBSSxDQUFDLDhEQUE4RGQ7UUFDN0U7SUFDRjtJQUVBLE9BQU9ZO0FBQ1QiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbmF0aGFcXE9uZURyaXZlXFxEZXNrdG9wXFxNb25leVF1ZXN0VjNcXHBhY2thZ2VzXFx3ZWJzaXRlXFxsaWJcXGRhdGFiYXNlXFxEYXRhRW5naW5lRmFjdG9yeS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBMb2NhbERhdGFFbmdpbmUsXG4gIFN1YnNjcmlwdGlvbk1hbmFnZXIsXG4gIEJhY2t1cFNlcnZpY2UsXG4gIGNyZWF0ZUZyZWVTdWJzY3JpcHRpb24sXG4gIFN1YnNjcmlwdGlvblN0YXR1c1xufSBmcm9tICdAbW9uZXlxdWVzdC9zaGFyZWQnO1xuaW1wb3J0IHsgSW5kZXhlZERCV3JhcHBlciB9IGZyb20gJy4vSW5kZXhlZERCV3JhcHBlcic7XG5cbi8qKlxuICogRmFjdG9yeSBmb3IgY3JlYXRpbmcgTG9jYWxEYXRhRW5naW5lIGluc3RhbmNlcyBmb3IgdGhlIHdlYiBhcHBcbiAqL1xuZXhwb3J0IGNsYXNzIERhdGFFbmdpbmVGYWN0b3J5IHtcbiAgcHJpdmF0ZSBzdGF0aWMgaW5zdGFuY2U6IExvY2FsRGF0YUVuZ2luZSB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIHN0YXRpYyBkYldyYXBwZXI6IEluZGV4ZWREQldyYXBwZXIgfCBudWxsID0gbnVsbDtcblxuICAvKipcbiAgICogR2V0IG9yIGNyZWF0ZSBhIHNpbmdsZXRvbiBMb2NhbERhdGFFbmdpbmUgaW5zdGFuY2VcbiAgICovXG4gIHN0YXRpYyBhc3luYyBnZXRJbnN0YW5jZShcbiAgICB1c2VySWQ/OiBzdHJpbmcsXG4gICAgc3Vic2NyaXB0aW9uU3RhdHVzPzogU3Vic2NyaXB0aW9uU3RhdHVzXG4gICk6IFByb21pc2U8TG9jYWxEYXRhRW5naW5lPiB7XG4gICAgaWYgKCF0aGlzLmluc3RhbmNlKSB7XG4gICAgICB0aGlzLmluc3RhbmNlID0gYXdhaXQgdGhpcy5jcmVhdGVFbmdpbmUodXNlcklkLCBzdWJzY3JpcHRpb25TdGF0dXMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5pbnN0YW5jZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgTG9jYWxEYXRhRW5naW5lIGluc3RhbmNlXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgY3JlYXRlRW5naW5lKFxuICAgIHVzZXJJZD86IHN0cmluZyxcbiAgICBzdWJzY3JpcHRpb25TdGF0dXM/OiBTdWJzY3JpcHRpb25TdGF0dXNcbiAgKTogUHJvbWlzZTxMb2NhbERhdGFFbmdpbmU+IHtcbiAgICAvLyBJbml0aWFsaXplIEluZGV4ZWREQiB3cmFwcGVyXG4gICAgaWYgKCF0aGlzLmRiV3JhcHBlcikge1xuICAgICAgdGhpcy5kYldyYXBwZXIgPSBuZXcgSW5kZXhlZERCV3JhcHBlcigpO1xuXG4gICAgICAvLyBJbml0aWFsaXplIHdpdGggZGVmYXVsdCBkYXRhIGlmIHVzZXJJZCBwcm92aWRlZFxuICAgICAgaWYgKHVzZXJJZCkge1xuICAgICAgICBhd2FpdCB0aGlzLmRiV3JhcHBlci5pbml0aWFsaXplKHVzZXJJZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIHN1YnNjcmlwdGlvbiBtYW5hZ2VyXG4gICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gbmV3IFN1YnNjcmlwdGlvbk1hbmFnZXIoXG4gICAgICBzdWJzY3JpcHRpb25TdGF0dXMgfHwgY3JlYXRlRnJlZVN1YnNjcmlwdGlvbigpXG4gICAgKTtcblxuICAgIC8vIENyZWF0ZSBiYWNrdXAgc2VydmljZSAobWluaW1hbCBpbXBsZW1lbnRhdGlvbiBmb3Igbm93KVxuICAgIGNvbnN0IGJhY2t1cFNlcnZpY2UgPSBuZXcgV2ViQmFja3VwU2VydmljZSh1c2VySWQgfHwgJ2Fub255bW91cycsICd0ZW1wLWtleScpO1xuXG4gICAgLy8gQ3JlYXRlIGFuZCByZXR1cm4gTG9jYWxEYXRhRW5naW5lXG4gICAgcmV0dXJuIG5ldyBMb2NhbERhdGFFbmdpbmUoXG4gICAgICB0aGlzLmRiV3JhcHBlcixcbiAgICAgIHN1YnNjcmlwdGlvbixcbiAgICAgIGJhY2t1cFNlcnZpY2VcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2V0IHRoZSBzaW5nbGV0b24gaW5zdGFuY2UgKHVzZWZ1bCBmb3IgdGVzdGluZyBvciB1c2VyIGxvZ291dClcbiAgICovXG4gIHN0YXRpYyByZXNldCgpOiB2b2lkIHtcbiAgICB0aGlzLmluc3RhbmNlID0gbnVsbDtcbiAgICB0aGlzLmRiV3JhcHBlciA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBkYXRhYmFzZSB3cmFwcGVyIGRpcmVjdGx5IChmb3IgYWR2YW5jZWQgb3BlcmF0aW9ucylcbiAgICovXG4gIHN0YXRpYyBnZXREQldyYXBwZXIoKTogSW5kZXhlZERCV3JhcHBlciB8IG51bGwge1xuICAgIHJldHVybiB0aGlzLmRiV3JhcHBlcjtcbiAgfVxufVxuXG4vKipcbiAqIFdlYiBpbXBsZW1lbnRhdGlvbiBvZiBCYWNrdXBTZXJ2aWNlXG4gKiBVc2VzIGxvY2FsU3RvcmFnZSBmb3Igc2ltcGxlIGJhY2t1cC9yZXN0b3JlIGZvciBub3dcbiAqIEluIHByb2R1Y3Rpb24sIHRoaXMgd291bGQgdXNlIGVuY3J5cHRlZCBjbG91ZCBzdG9yYWdlXG4gKi9cbmNsYXNzIFdlYkJhY2t1cFNlcnZpY2UgZXh0ZW5kcyBCYWNrdXBTZXJ2aWNlIHtcbiAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgQkFDS1VQX0tFWSA9ICdtb25leXF1ZXN0X2JhY2t1cCc7XG5cbiAgY29uc3RydWN0b3IodXNlcklkOiBzdHJpbmcsIGVuY3J5cHRpb25LZXk6IHN0cmluZykge1xuICAgIHN1cGVyKHVzZXJJZCwgZW5jcnlwdGlvbktleSk7XG4gIH1cblxuICBhc3luYyBiYWNrdXAoZGF0YTogYW55KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIEVuY3J5cHQgZGF0YSBpbiBwcm9kdWN0aW9uXG4gICAgICBjb25zdCBiYWNrdXBEYXRhID0ge1xuICAgICAgICBkYXRhLFxuICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgdmVyc2lvbjogMVxuICAgICAgfTtcblxuICAgICAgLy8gRm9yIG5vdywgc3RvcmUgaW4gbG9jYWxTdG9yYWdlIChsaW1pdGVkIHRvIH41TUIpXG4gICAgICAvLyBJbiBwcm9kdWN0aW9uLCB0aGlzIHdvdWxkIGJlIGVuY3J5cHRlZCBhbmQgc3RvcmVkIGluIFMzXG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShcbiAgICAgICAgV2ViQmFja3VwU2VydmljZS5CQUNLVVBfS0VZLFxuICAgICAgICBKU09OLnN0cmluZ2lmeShiYWNrdXBEYXRhKVxuICAgICAgKTtcblxuICAgICAgY29uc29sZS5sb2coJ0RhdGEgYmFja2VkIHVwIGxvY2FsbHknKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGJhY2t1cCBkYXRhOicsIGVycm9yKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQmFja3VwIGZhaWxlZDogJHtlcnJvcn1gKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyByZXN0b3JlKCk6IFByb21pc2U8YW55PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGJhY2t1cFN0cmluZyA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFdlYkJhY2t1cFNlcnZpY2UuQkFDS1VQX0tFWSk7XG5cbiAgICAgIGlmICghYmFja3VwU3RyaW5nKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdObyBiYWNrdXAgZGF0YSBmb3VuZCcpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYmFja3VwRGF0YSA9IEpTT04ucGFyc2UoYmFja3VwU3RyaW5nKTtcblxuICAgICAgLy8gVmFsaWRhdGUgYmFja3VwIGRhdGEgc3RydWN0dXJlXG4gICAgICBpZiAoIWJhY2t1cERhdGEuZGF0YSB8fCAhYmFja3VwRGF0YS50aW1lc3RhbXApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGJhY2t1cCBkYXRhIGZvcm1hdCcpO1xuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmxvZyhgUmVzdG9yZWQgYmFja3VwIGZyb20gJHtiYWNrdXBEYXRhLnRpbWVzdGFtcH1gKTtcbiAgICAgIHJldHVybiBiYWNrdXBEYXRhLmRhdGE7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byByZXN0b3JlIGRhdGE6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZXN0b3JlIGZhaWxlZDogJHtlcnJvcn1gKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBoYXNCYWNrdXAoKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgcmV0dXJuIGxvY2FsU3RvcmFnZS5nZXRJdGVtKFdlYkJhY2t1cFNlcnZpY2UuQkFDS1VQX0tFWSkgIT09IG51bGw7XG4gIH1cblxuICBhc3luYyBjbGVhckJhY2t1cCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShXZWJCYWNrdXBTZXJ2aWNlLkJBQ0tVUF9LRVkpO1xuICAgIGNvbnNvbGUubG9nKCdCYWNrdXAgZGF0YSBjbGVhcmVkJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBIb29rIGZvciBSZWFjdCBjb21wb25lbnRzIHRvIGdldCB0aGUgZGF0YSBlbmdpbmVcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHVzZURhdGFFbmdpbmUoXG4gIHVzZXJJZD86IHN0cmluZyxcbiAgc3Vic2NyaXB0aW9uU3RhdHVzPzogU3Vic2NyaXB0aW9uU3RhdHVzXG4pOiBQcm9taXNlPExvY2FsRGF0YUVuZ2luZT4ge1xuICByZXR1cm4gRGF0YUVuZ2luZUZhY3RvcnkuZ2V0SW5zdGFuY2UodXNlcklkLCBzdWJzY3JpcHRpb25TdGF0dXMpO1xufVxuXG4vKipcbiAqIEluaXRpYWxpemUgdGhlIGRhdGEgZW5naW5lIGZvciB0aGUgYXBwXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBpbml0aWFsaXplRGF0YUVuZ2luZShcbiAgdXNlcklkOiBzdHJpbmcsXG4gIHN1YnNjcmlwdGlvblN0YXR1cz86IFN1YnNjcmlwdGlvblN0YXR1c1xuKTogUHJvbWlzZTxMb2NhbERhdGFFbmdpbmU+IHtcbiAgY29uc29sZS5sb2coYEluaXRpYWxpemluZyBkYXRhIGVuZ2luZSBmb3IgdXNlcjogJHt1c2VySWR9YCk7XG5cbiAgY29uc3QgZW5naW5lID0gYXdhaXQgRGF0YUVuZ2luZUZhY3RvcnkuY3JlYXRlRW5naW5lKHVzZXJJZCwgc3Vic2NyaXB0aW9uU3RhdHVzKTtcblxuICAvLyBDaGVjayBpZiB3ZSBjYW4gcmVzdG9yZSBmcm9tIGJhY2t1cFxuICBjb25zdCBiYWNrdXBTZXJ2aWNlID0gbmV3IFdlYkJhY2t1cFNlcnZpY2UodXNlcklkLCAndGVtcC1rZXknKTtcbiAgY29uc3QgaGFzQmFja3VwID0gYXdhaXQgYmFja3VwU2VydmljZS5oYXNCYWNrdXAoKTtcblxuICBpZiAoaGFzQmFja3VwKSB7XG4gICAgY29uc29sZS5sb2coJ0JhY2t1cCBmb3VuZCwgYXR0ZW1wdGluZyB0byByZXN0b3JlLi4uJyk7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGVuZ2luZS5yZXN0b3JlRnJvbUJhY2t1cCgpO1xuICAgICAgY29uc29sZS5sb2coJ1N1Y2Nlc3NmdWxseSByZXN0b3JlZCBmcm9tIGJhY2t1cCcpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byByZXN0b3JlIGZyb20gYmFja3VwLCBjb250aW51aW5nIHdpdGggZnJlc2ggZGF0YTonLCBlcnJvcik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVuZ2luZTtcbn0iXSwibmFtZXMiOlsiTG9jYWxEYXRhRW5naW5lIiwiU3Vic2NyaXB0aW9uTWFuYWdlciIsIkJhY2t1cFNlcnZpY2UiLCJjcmVhdGVGcmVlU3Vic2NyaXB0aW9uIiwiSW5kZXhlZERCV3JhcHBlciIsIkRhdGFFbmdpbmVGYWN0b3J5IiwiZ2V0SW5zdGFuY2UiLCJ1c2VySWQiLCJzdWJzY3JpcHRpb25TdGF0dXMiLCJpbnN0YW5jZSIsImNyZWF0ZUVuZ2luZSIsImRiV3JhcHBlciIsImluaXRpYWxpemUiLCJzdWJzY3JpcHRpb24iLCJiYWNrdXBTZXJ2aWNlIiwiV2ViQmFja3VwU2VydmljZSIsInJlc2V0IiwiZ2V0REJXcmFwcGVyIiwiYmFja3VwIiwiZGF0YSIsImJhY2t1cERhdGEiLCJ0aW1lc3RhbXAiLCJEYXRlIiwidG9JU09TdHJpbmciLCJ2ZXJzaW9uIiwibG9jYWxTdG9yYWdlIiwic2V0SXRlbSIsIkJBQ0tVUF9LRVkiLCJKU09OIiwic3RyaW5naWZ5IiwiY29uc29sZSIsImxvZyIsImVycm9yIiwiRXJyb3IiLCJyZXN0b3JlIiwiYmFja3VwU3RyaW5nIiwiZ2V0SXRlbSIsInBhcnNlIiwiaGFzQmFja3VwIiwiY2xlYXJCYWNrdXAiLCJyZW1vdmVJdGVtIiwiZW5jcnlwdGlvbktleSIsInVzZURhdGFFbmdpbmUiLCJpbml0aWFsaXplRGF0YUVuZ2luZSIsImVuZ2luZSIsInJlc3RvcmVGcm9tQmFja3VwIiwid2FybiJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/database/DataEngineFactory.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./lib/database/IndexedDBWrapper.ts":
/*!******************************************!*\
  !*** ./lib/database/IndexedDBWrapper.ts ***!
  \******************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IndexedDBWrapper: () => (/* binding */ IndexedDBWrapper)\n/* harmony export */ });\n/* harmony import */ var dexie__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! dexie */ \"(app-pages-browser)/../../node_modules/dexie/import-wrapper.mjs\");\n\nclass MoneyQuestDB extends dexie__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    constructor(){\n        super('MoneyQuestDB');\n        this.version(1).stores({\n            users: 'id, cognitoId, email, createdAt',\n            accounts: 'id, userId, name, type, isActive, createdAt',\n            categories: 'id, userId, name, type, isDefault, createdAt',\n            transactions: 'id, accountId, date, categoryId, isParent, parentTransactionId, createdAt',\n            transaction_splits: 'id, transactionId, categoryId, createdAt',\n            budgets: 'id, userId, categoryId, period, startDate, isActive, createdAt',\n            currencies: 'id, code, name, isActive, createdAt',\n            investments: 'id, portfolioId, symbol, createdAt',\n            portfolios: 'id, userId, name, isActive, createdAt',\n            net_worth_snapshots: 'id, userId, date, createdAt'\n        });\n    }\n}\nclass IndexedDBWrapper {\n    // ==========================================\n    // Core CRUD Operations\n    // ==========================================\n    async insert(table, data) {\n        try {\n            const dbTable = this.getTable(table);\n            const id = await dbTable.add(data);\n            // Return the inserted data with the generated ID if needed\n            if (typeof id === 'string' && data.id === undefined) {\n                return {\n                    ...data,\n                    id\n                };\n            }\n            return data;\n        } catch (error) {\n            console.error(\"Failed to insert into \".concat(table, \":\"), error);\n            throw new Error(\"Database insert failed: \".concat(error));\n        }\n    }\n    async query(table, filter) {\n        try {\n            const dbTable = this.getTable(table);\n            let collection = dbTable.toCollection();\n            if (filter) {\n                // Apply filters based on the filter object\n                if (filter.id) {\n                    return [\n                        await dbTable.get(filter.id)\n                    ];\n                }\n                // Apply common filters\n                Object.keys(filter).forEach((key)=>{\n                    if (filter[key] !== undefined && filter[key] !== null) {\n                        collection = collection.filter((item)=>{\n                            const value = item[key];\n                            const filterValue = filter[key];\n                            // Handle date range filters\n                            if (key === 'startDate' && value instanceof Date) {\n                                return value >= filterValue;\n                            }\n                            if (key === 'endDate' && value instanceof Date) {\n                                return value <= filterValue;\n                            }\n                            // Handle exact matches\n                            return value === filterValue;\n                        });\n                    }\n                });\n            }\n            const results = await collection.toArray();\n            return results;\n        } catch (error) {\n            console.error(\"Failed to query \".concat(table, \":\"), error);\n            throw new Error(\"Database query failed: \".concat(error));\n        }\n    }\n    async update(table, id, data) {\n        try {\n            const dbTable = this.getTable(table);\n            // Get existing record\n            const existing = await dbTable.get(id);\n            if (!existing) {\n                throw new Error(\"Record with id \".concat(id, \" not found in \").concat(table));\n            }\n            // Merge updates\n            const updated = {\n                ...existing,\n                ...data,\n                updatedAt: new Date()\n            };\n            // Update in database\n            await dbTable.update(id, updated);\n            return updated;\n        } catch (error) {\n            console.error(\"Failed to update \".concat(table, \":\"), error);\n            throw new Error(\"Database update failed: \".concat(error));\n        }\n    }\n    async delete(table, id) {\n        try {\n            const dbTable = this.getTable(table);\n            await dbTable.delete(id);\n        } catch (error) {\n            console.error(\"Failed to delete from \".concat(table, \":\"), error);\n            throw new Error(\"Database delete failed: \".concat(error));\n        }\n    }\n    // ==========================================\n    // Analytics Queries\n    // ==========================================\n    async getCategorySpending(userId, startDate, endDate) {\n        try {\n            // Get user's transactions in date range\n            const transactions = await this.db.transactions.where('date').between(startDate, endDate, true, true).filter((t)=>{\n                // We need to check if the account belongs to the user\n                // This would normally be a JOIN operation\n                return true; // Simplified for now\n            }).toArray();\n            // Get user's categories\n            const categories = await this.db.categories.where('userId').equals(userId).toArray();\n            // Calculate spending by category\n            const categoryMap = new Map();\n            // Initialize categories\n            categories.forEach((cat)=>{\n                categoryMap.set(cat.id, {\n                    categoryId: cat.id,\n                    categoryName: cat.name,\n                    totalAmount: 0,\n                    transactionCount: 0,\n                    percentage: 0\n                });\n            });\n            // Aggregate transaction amounts\n            let totalSpending = 0;\n            for (const transaction of transactions){\n                if (transaction.categoryId) {\n                    const category = categoryMap.get(transaction.categoryId);\n                    if (category) {\n                        category.totalAmount += Math.abs(transaction.originalAmount);\n                        category.transactionCount += 1;\n                        totalSpending += Math.abs(transaction.originalAmount);\n                    }\n                }\n                // Handle splits\n                const splits = await this.db.transaction_splits.where('transactionId').equals(transaction.id).toArray();\n                splits.forEach((split)=>{\n                    const category = categoryMap.get(split.categoryId);\n                    if (category) {\n                        category.totalAmount += Math.abs(split.amount);\n                        totalSpending += Math.abs(split.amount);\n                    }\n                });\n            }\n            // Calculate percentages\n            categoryMap.forEach((category)=>{\n                if (totalSpending > 0) {\n                    category.percentage = category.totalAmount / totalSpending * 100;\n                }\n            });\n            return Array.from(categoryMap.values()).filter((cat)=>cat.totalAmount > 0).sort((a, b)=>b.totalAmount - a.totalAmount);\n        } catch (error) {\n            console.error('Failed to get category spending:', error);\n            throw new Error(\"Analytics query failed: \".concat(error));\n        }\n    }\n    async getBudgetProgress(userId) {\n        try {\n            const budgets = await this.db.budgets.where('userId').equals(userId).filter((b)=>b.isActive).toArray();\n            const budgetStatus = [];\n            for (const budget of budgets){\n                var _categorySpending_find;\n                // Calculate period start/end dates\n                const now = new Date();\n                let periodStart = new Date(budget.startDate);\n                let periodEnd = new Date(budget.startDate);\n                if (budget.period === 'monthly') {\n                    periodStart = new Date(now.getFullYear(), now.getMonth(), 1);\n                    periodEnd = new Date(now.getFullYear(), now.getMonth() + 1, 0);\n                } else if (budget.period === 'yearly') {\n                    periodStart = new Date(now.getFullYear(), 0, 1);\n                    periodEnd = new Date(now.getFullYear(), 11, 31);\n                }\n                // Calculate spending for this category in the period\n                const categorySpending = await this.getCategorySpending(userId, periodStart, periodEnd);\n                const spent = ((_categorySpending_find = categorySpending.find((c)=>c.categoryId === budget.categoryId)) === null || _categorySpending_find === void 0 ? void 0 : _categorySpending_find.totalAmount) || 0;\n                // Get category details\n                const category = await this.db.categories.get(budget.categoryId);\n                budgetStatus.push({\n                    budgetId: budget.id,\n                    categoryId: budget.categoryId,\n                    categoryName: (category === null || category === void 0 ? void 0 : category.name) || 'Unknown Category',\n                    budgetAmount: budget.amount,\n                    spentAmount: spent,\n                    remainingAmount: budget.amount - spent,\n                    percentageUsed: spent / budget.amount * 100,\n                    period: budget.period,\n                    isOverBudget: spent > budget.amount\n                });\n            }\n            return budgetStatus;\n        } catch (error) {\n            console.error('Failed to get budget progress:', error);\n            throw new Error(\"Budget progress query failed: \".concat(error));\n        }\n    }\n    // ==========================================\n    // Export/Import Operations\n    // ==========================================\n    async exportAll() {\n        try {\n            const data = {};\n            // Export all tables\n            const tables = [\n                'users',\n                'accounts',\n                'categories',\n                'transactions',\n                'transaction_splits',\n                'budgets',\n                'currencies',\n                'investments',\n                'portfolios',\n                'net_worth_snapshots'\n            ];\n            for (const tableName of tables){\n                const table = this.getTable(tableName);\n                data[tableName] = await table.toArray();\n            }\n            return {\n                version: 1,\n                exportedAt: new Date(),\n                data\n            };\n        } catch (error) {\n            console.error('Failed to export data:', error);\n            throw new Error(\"Data export failed: \".concat(error));\n        }\n    }\n    async importData(importData) {\n        try {\n            if (!importData.data) {\n                throw new Error('Invalid import data format');\n            }\n            // Clear existing data (optional - might want to merge instead)\n            await this.db.transaction('rw', [\n                this.db.users,\n                this.db.accounts,\n                this.db.categories,\n                this.db.transactions,\n                this.db.transaction_splits,\n                this.db.budgets,\n                this.db.currencies,\n                this.db.investments,\n                this.db.portfolios,\n                this.db.net_worth_snapshots\n            ], async ()=>{\n                // Import data table by table\n                const tables = [\n                    'users',\n                    'accounts',\n                    'categories',\n                    'transactions',\n                    'transaction_splits',\n                    'budgets',\n                    'currencies',\n                    'investments',\n                    'portfolios',\n                    'net_worth_snapshots'\n                ];\n                for (const tableName of tables){\n                    if (importData.data[tableName]) {\n                        const table = this.getTable(tableName);\n                        await table.bulkAdd(importData.data[tableName]);\n                    }\n                }\n            });\n        } catch (error) {\n            console.error('Failed to import data:', error);\n            throw new Error(\"Data import failed: \".concat(error));\n        }\n    }\n    // ==========================================\n    // Utility Methods\n    // ==========================================\n    getTable(tableName) {\n        const table = this.db[tableName];\n        if (!table) {\n            throw new Error(\"Table \".concat(tableName, \" not found\"));\n        }\n        return table;\n    }\n    // Initialize with default data\n    async initialize(userId) {\n        try {\n            console.log(\"Starting IndexedDB initialization for user: \".concat(userId));\n            // Check if already initialized\n            const user = await this.db.users.get(userId);\n            if (user) {\n                console.log(\"User \".concat(userId, \" already initialized\"));\n                return; // Already initialized\n            }\n            console.log(\"Creating new user profile for: \".concat(userId));\n            // Create user record\n            const newUser = {\n                id: userId,\n                cognitoId: userId,\n                email: \"\".concat(userId, \"@moneyquest.com\"),\n                preferences: JSON.stringify({\n                    theme: 'light',\n                    currency: 'USD'\n                }),\n                createdAt: new Date(),\n                updatedAt: new Date()\n            };\n            // Create default currencies\n            const defaultCurrencies = [\n                {\n                    id: 'usd',\n                    code: 'USD',\n                    name: 'US Dollar',\n                    symbol: '$',\n                    isActive: true,\n                    createdAt: new Date(),\n                    updatedAt: new Date()\n                },\n                {\n                    id: 'eur',\n                    code: 'EUR',\n                    name: 'Euro',\n                    symbol: '€',\n                    isActive: true,\n                    createdAt: new Date(),\n                    updatedAt: new Date()\n                }\n            ];\n            // Create default categories\n            const defaultCategories = [\n                {\n                    name: 'Groceries',\n                    type: 'expense',\n                    color: '#10B981'\n                },\n                {\n                    name: 'Transportation',\n                    type: 'expense',\n                    color: '#3B82F6'\n                },\n                {\n                    name: 'Housing',\n                    type: 'expense',\n                    color: '#8B5CF6'\n                },\n                {\n                    name: 'Utilities',\n                    type: 'expense',\n                    color: '#F59E0B'\n                },\n                {\n                    name: 'Entertainment',\n                    type: 'expense',\n                    color: '#EF4444'\n                },\n                {\n                    name: 'Healthcare',\n                    type: 'expense',\n                    color: '#EC4899'\n                },\n                {\n                    name: 'Salary',\n                    type: 'income',\n                    color: '#059669'\n                },\n                {\n                    name: 'Investment',\n                    type: 'income',\n                    color: '#0891B2'\n                }\n            ].map((cat)=>({\n                    id: \"\".concat(userId, \"-\").concat(cat.name.toLowerCase().replace(/\\s+/g, '-')),\n                    userId,\n                    ...cat,\n                    isDefault: true,\n                    createdAt: new Date(),\n                    updatedAt: new Date()\n                }));\n            // Create some demo accounts for new users\n            const defaultAccounts = [\n                {\n                    id: \"\".concat(userId, \"-checking\"),\n                    userId,\n                    name: 'Checking Account',\n                    type: 'checking',\n                    balance: 2500.00,\n                    currencyId: 'usd',\n                    isActive: true,\n                    createdAt: new Date(),\n                    updatedAt: new Date()\n                },\n                {\n                    id: \"\".concat(userId, \"-savings\"),\n                    userId,\n                    name: 'Savings Account',\n                    type: 'savings',\n                    balance: 12500.00,\n                    currencyId: 'usd',\n                    isActive: true,\n                    createdAt: new Date(),\n                    updatedAt: new Date()\n                }\n            ];\n            // Initialize database with transaction\n            await this.db.transaction('rw', [\n                this.db.users,\n                this.db.currencies,\n                this.db.categories,\n                this.db.accounts\n            ], async ()=>{\n                console.log('Creating user record...');\n                await this.db.users.add(newUser);\n                console.log('Adding default currencies...');\n                // Add currencies (only if not exist)\n                for (const currency of defaultCurrencies){\n                    const existing = await this.db.currencies.get(currency.id);\n                    if (!existing) {\n                        await this.db.currencies.add(currency);\n                    }\n                }\n                console.log('Adding default categories...');\n                await this.db.categories.bulkAdd(defaultCategories);\n                console.log('Adding default accounts...');\n                await this.db.accounts.bulkAdd(defaultAccounts);\n            });\n            console.log(\"Successfully initialized database for user: \".concat(userId));\n        } catch (error) {\n            console.error('Failed to initialize database:', error);\n            throw new Error(\"Database initialization failed: \".concat(error));\n        }\n    }\n    constructor(){\n        this.db = new MoneyQuestDB();\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9kYXRhYmFzZS9JbmRleGVkREJXcmFwcGVyLnRzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXFDO0FBeUhyQyxNQUFNQyxxQkFBcUJELDZDQUFLQTtJQVk5QixhQUFjO1FBQ1osS0FBSyxDQUFDO1FBRU4sSUFBSSxDQUFDRSxPQUFPLENBQUMsR0FBR0MsTUFBTSxDQUFDO1lBQ3JCQyxPQUFPO1lBQ1BDLFVBQVU7WUFDVkMsWUFBWTtZQUNaQyxjQUFjO1lBQ2RDLG9CQUFvQjtZQUNwQkMsU0FBUztZQUNUQyxZQUFZO1lBQ1pDLGFBQWE7WUFDYkMsWUFBWTtZQUNaQyxxQkFBcUI7UUFDdkI7SUFDRjtBQUNGO0FBRU8sTUFBTUM7SUFPWCw2Q0FBNkM7SUFDN0MsdUJBQXVCO0lBQ3ZCLDZDQUE2QztJQUU3QyxNQUFNQyxPQUFVQyxLQUFhLEVBQUVDLElBQU8sRUFBYztRQUNsRCxJQUFJO1lBQ0YsTUFBTUMsVUFBVSxJQUFJLENBQUNDLFFBQVEsQ0FBQ0g7WUFDOUIsTUFBTUksS0FBSyxNQUFNRixRQUFRRyxHQUFHLENBQUNKO1lBRTdCLDJEQUEyRDtZQUMzRCxJQUFJLE9BQU9HLE9BQU8sWUFBWSxLQUFjQSxFQUFFLEtBQUtFLFdBQVc7Z0JBQzVELE9BQU87b0JBQUUsR0FBR0wsSUFBSTtvQkFBRUc7Z0JBQUc7WUFDdkI7WUFFQSxPQUFPSDtRQUNULEVBQUUsT0FBT00sT0FBTztZQUNkQyxRQUFRRCxLQUFLLENBQUMseUJBQStCLE9BQU5QLE9BQU0sTUFBSU87WUFDakQsTUFBTSxJQUFJRSxNQUFNLDJCQUFpQyxPQUFORjtRQUM3QztJQUNGO0lBRUEsTUFBTUcsTUFBU1YsS0FBYSxFQUFFVyxNQUFZLEVBQWdCO1FBQ3hELElBQUk7WUFDRixNQUFNVCxVQUFVLElBQUksQ0FBQ0MsUUFBUSxDQUFDSDtZQUM5QixJQUFJWSxhQUFhVixRQUFRVyxZQUFZO1lBRXJDLElBQUlGLFFBQVE7Z0JBQ1YsMkNBQTJDO2dCQUMzQyxJQUFJQSxP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eUY7Z0JBRXhCdEYsUUFBUW9GLEdBQUcsQ0FBQztnQkFDWixxQ0FBcUM7Z0JBQ3JDLEtBQUssTUFBTVMsWUFBWUUsa0JBQW1CO29CQUN4QyxNQUFNN0UsV0FBVyxNQUFNLElBQUksQ0FBQ1EsRUFBRSxDQUFDeEMsVUFBVSxDQUFDb0IsR0FBRyxDQUFDdUYsU0FBU2pHLEVBQUU7b0JBQ3pELElBQUksQ0FBQ3NCLFVBQVU7d0JBQ2IsTUFBTSxJQUFJLENBQUNRLEVBQUUsQ0FBQ3hDLFVBQVUsQ0FBQ1csR0FBRyxDQUFDZ0c7b0JBQy9CO2dCQUNGO2dCQUVBN0YsUUFBUW9GLEdBQUcsQ0FBQztnQkFDWixNQUFNLElBQUksQ0FBQzFELEVBQUUsQ0FBQzVDLFVBQVUsQ0FBQ29HLE9BQU8sQ0FBQ2dCO2dCQUVqQ2xHLFFBQVFvRixHQUFHLENBQUM7Z0JBQ1osTUFBTSxJQUFJLENBQUMxRCxFQUFFLENBQUM3QyxRQUFRLENBQUNxRyxPQUFPLENBQUN1QjtZQUNqQztZQUVBekcsUUFBUW9GLEdBQUcsQ0FBQywrQ0FBc0QsT0FBUDdEO1FBRTdELEVBQUUsT0FBT3hCLE9BQU87WUFDZEMsUUFBUUQsS0FBSyxDQUFDLGtDQUFrQ0E7WUFDaEQsTUFBTSxJQUFJRSxNQUFNLG1DQUF5QyxPQUFORjtRQUNyRDtJQUNGO0lBaGJBLGFBQWM7UUFDWixJQUFJLENBQUMyQixFQUFFLEdBQUcsSUFBSWpEO0lBQ2hCO0FBK2FGIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXG5hdGhhXFxPbmVEcml2ZVxcRGVza3RvcFxcTW9uZXlRdWVzdFYzXFxwYWNrYWdlc1xcd2Vic2l0ZVxcbGliXFxkYXRhYmFzZVxcSW5kZXhlZERCV3JhcHBlci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgRGV4aWUsIHsgVGFibGUgfSBmcm9tICdkZXhpZSc7XG5pbXBvcnQge1xuICBMb2NhbERCLFxuICBGaWx0ZXJcbn0gZnJvbSAnQG1vbmV5cXVlc3Qvc2hhcmVkJztcbmltcG9ydCB7IENhdGVnb3J5VG90YWwsIEJ1ZGdldFN0YXR1cyB9IGZyb20gJ0Btb25leXF1ZXN0L3NoYXJlZCc7XG5cbi8vIERlZmluZSBkYXRhYmFzZSBzY2hlbWEgbWF0Y2hpbmcgUHJpc21hIHNjaGVtYVxuaW50ZXJmYWNlIFVzZXIge1xuICBpZDogc3RyaW5nO1xuICBjb2duaXRvSWQ6IHN0cmluZztcbiAgZW1haWw6IHN0cmluZztcbiAgcHJlZmVyZW5jZXM6IHN0cmluZztcbiAgY3JlYXRlZEF0OiBEYXRlO1xuICB1cGRhdGVkQXQ6IERhdGU7XG59XG5cbmludGVyZmFjZSBBY2NvdW50IHtcbiAgaWQ6IHN0cmluZztcbiAgdXNlcklkOiBzdHJpbmc7XG4gIG5hbWU6IHN0cmluZztcbiAgdHlwZTogc3RyaW5nO1xuICBiYWxhbmNlOiBudW1iZXI7XG4gIGN1cnJlbmN5SWQ6IHN0cmluZztcbiAgaXNBY3RpdmU6IGJvb2xlYW47XG4gIGNyZWF0ZWRBdDogRGF0ZTtcbiAgdXBkYXRlZEF0OiBEYXRlO1xufVxuXG5pbnRlcmZhY2UgQ2F0ZWdvcnkge1xuICBpZDogc3RyaW5nO1xuICB1c2VySWQ6IHN0cmluZztcbiAgbmFtZTogc3RyaW5nO1xuICB0eXBlOiBzdHJpbmc7XG4gIGNvbG9yOiBzdHJpbmc7XG4gIGlzRGVmYXVsdDogYm9vbGVhbjtcbiAgY3JlYXRlZEF0OiBEYXRlO1xuICB1cGRhdGVkQXQ6IERhdGU7XG59XG5cbmludGVyZmFjZSBUcmFuc2FjdGlvbiB7XG4gIGlkOiBzdHJpbmc7XG4gIGFjY291bnRJZDogc3RyaW5nO1xuICBvcmlnaW5hbEFtb3VudDogbnVtYmVyO1xuICBkZXNjcmlwdGlvbjogc3RyaW5nO1xuICBkYXRlOiBEYXRlO1xuICBjdXJyZW5jeUlkOiBzdHJpbmc7XG4gIGlzUGFyZW50OiBib29sZWFuO1xuICBwYXJlbnRUcmFuc2FjdGlvbklkPzogc3RyaW5nO1xuICBjYXRlZ29yeUlkPzogc3RyaW5nO1xuICBjcmVhdGVkQXQ6IERhdGU7XG4gIHVwZGF0ZWRBdDogRGF0ZTtcbn1cblxuaW50ZXJmYWNlIFRyYW5zYWN0aW9uU3BsaXQge1xuICBpZDogc3RyaW5nO1xuICB0cmFuc2FjdGlvbklkOiBzdHJpbmc7XG4gIGFtb3VudDogbnVtYmVyO1xuICBjYXRlZ29yeUlkOiBzdHJpbmc7XG4gIGRlc2NyaXB0aW9uPzogc3RyaW5nO1xuICBwZXJjZW50YWdlOiBudW1iZXI7XG4gIGNyZWF0ZWRBdDogRGF0ZTtcbiAgdXBkYXRlZEF0OiBEYXRlO1xufVxuXG5pbnRlcmZhY2UgQnVkZ2V0IHtcbiAgaWQ6IHN0cmluZztcbiAgdXNlcklkOiBzdHJpbmc7XG4gIGNhdGVnb3J5SWQ6IHN0cmluZztcbiAgYW1vdW50OiBudW1iZXI7XG4gIGN1cnJlbmN5SWQ6IHN0cmluZztcbiAgcGVyaW9kOiBzdHJpbmc7XG4gIHN0YXJ0RGF0ZTogRGF0ZTtcbiAgaXNBY3RpdmU6IGJvb2xlYW47XG4gIGNyZWF0ZWRBdDogRGF0ZTtcbiAgdXBkYXRlZEF0OiBEYXRlO1xufVxuXG5pbnRlcmZhY2UgQ3VycmVuY3kge1xuICBpZDogc3RyaW5nO1xuICBjb2RlOiBzdHJpbmc7XG4gIG5hbWU6IHN0cmluZztcbiAgc3ltYm9sOiBzdHJpbmc7XG4gIGlzQWN0aXZlOiBib29sZWFuO1xuICBjcmVhdGVkQXQ6IERhdGU7XG4gIHVwZGF0ZWRBdDogRGF0ZTtcbn1cblxuaW50ZXJmYWNlIEludmVzdG1lbnQge1xuICBpZDogc3RyaW5nO1xuICBwb3J0Zm9saW9JZDogc3RyaW5nO1xuICBzeW1ib2w6IHN0cmluZztcbiAgbmFtZTogc3RyaW5nO1xuICBxdWFudGl0eTogbnVtYmVyO1xuICBjb3N0QmFzaXM6IG51bWJlcjtcbiAgY3VycmVudFByaWNlOiBudW1iZXI7XG4gIGNyZWF0ZWRBdDogRGF0ZTtcbiAgdXBkYXRlZEF0OiBEYXRlO1xufVxuXG5pbnRlcmZhY2UgUG9ydGZvbGlvIHtcbiAgaWQ6IHN0cmluZztcbiAgdXNlcklkOiBzdHJpbmc7XG4gIG5hbWU6IHN0cmluZztcbiAgcHJvdmlkZXI/OiBzdHJpbmc7XG4gIGFjY291bnROdW1iZXI/OiBzdHJpbmc7XG4gIGlzQWN0aXZlOiBib29sZWFuO1xuICBjcmVhdGVkQXQ6IERhdGU7XG4gIHVwZGF0ZWRBdDogRGF0ZTtcbn1cblxuaW50ZXJmYWNlIE5ldFdvcnRoU25hcHNob3Qge1xuICBpZDogc3RyaW5nO1xuICB1c2VySWQ6IHN0cmluZztcbiAgdG90YWxBc3NldHM6IG51bWJlcjtcbiAgdG90YWxMaWFiaWxpdGllczogbnVtYmVyO1xuICBuZXRXb3J0aDogbnVtYmVyO1xuICBkYXRlOiBEYXRlO1xuICBjcmVhdGVkQXQ6IERhdGU7XG59XG5cbmNsYXNzIE1vbmV5UXVlc3REQiBleHRlbmRzIERleGllIHtcbiAgdXNlcnMhOiBUYWJsZTxVc2VyPjtcbiAgYWNjb3VudHMhOiBUYWJsZTxBY2NvdW50PjtcbiAgY2F0ZWdvcmllcyE6IFRhYmxlPENhdGVnb3J5PjtcbiAgdHJhbnNhY3Rpb25zITogVGFibGU8VHJhbnNhY3Rpb24+O1xuICB0cmFuc2FjdGlvbl9zcGxpdHMhOiBUYWJsZTxUcmFuc2FjdGlvblNwbGl0PjtcbiAgYnVkZ2V0cyE6IFRhYmxlPEJ1ZGdldD47XG4gIGN1cnJlbmNpZXMhOiBUYWJsZTxDdXJyZW5jeT47XG4gIGludmVzdG1lbnRzITogVGFibGU8SW52ZXN0bWVudD47XG4gIHBvcnRmb2xpb3MhOiBUYWJsZTxQb3J0Zm9saW8+O1xuICBuZXRfd29ydGhfc25hcHNob3RzITogVGFibGU8TmV0V29ydGhTbmFwc2hvdD47XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoJ01vbmV5UXVlc3REQicpO1xuXG4gICAgdGhpcy52ZXJzaW9uKDEpLnN0b3Jlcyh7XG4gICAgICB1c2VyczogJ2lkLCBjb2duaXRvSWQsIGVtYWlsLCBjcmVhdGVkQXQnLFxuICAgICAgYWNjb3VudHM6ICdpZCwgdXNlcklkLCBuYW1lLCB0eXBlLCBpc0FjdGl2ZSwgY3JlYXRlZEF0JyxcbiAgICAgIGNhdGVnb3JpZXM6ICdpZCwgdXNlcklkLCBuYW1lLCB0eXBlLCBpc0RlZmF1bHQsIGNyZWF0ZWRBdCcsXG4gICAgICB0cmFuc2FjdGlvbnM6ICdpZCwgYWNjb3VudElkLCBkYXRlLCBjYXRlZ29yeUlkLCBpc1BhcmVudCwgcGFyZW50VHJhbnNhY3Rpb25JZCwgY3JlYXRlZEF0JyxcbiAgICAgIHRyYW5zYWN0aW9uX3NwbGl0czogJ2lkLCB0cmFuc2FjdGlvbklkLCBjYXRlZ29yeUlkLCBjcmVhdGVkQXQnLFxuICAgICAgYnVkZ2V0czogJ2lkLCB1c2VySWQsIGNhdGVnb3J5SWQsIHBlcmlvZCwgc3RhcnREYXRlLCBpc0FjdGl2ZSwgY3JlYXRlZEF0JyxcbiAgICAgIGN1cnJlbmNpZXM6ICdpZCwgY29kZSwgbmFtZSwgaXNBY3RpdmUsIGNyZWF0ZWRBdCcsXG4gICAgICBpbnZlc3RtZW50czogJ2lkLCBwb3J0Zm9saW9JZCwgc3ltYm9sLCBjcmVhdGVkQXQnLFxuICAgICAgcG9ydGZvbGlvczogJ2lkLCB1c2VySWQsIG5hbWUsIGlzQWN0aXZlLCBjcmVhdGVkQXQnLFxuICAgICAgbmV0X3dvcnRoX3NuYXBzaG90czogJ2lkLCB1c2VySWQsIGRhdGUsIGNyZWF0ZWRBdCdcbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgSW5kZXhlZERCV3JhcHBlciBpbXBsZW1lbnRzIExvY2FsREIge1xuICBwcml2YXRlIGRiOiBNb25leVF1ZXN0REI7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5kYiA9IG5ldyBNb25leVF1ZXN0REIoKTtcbiAgfVxuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBDb3JlIENSVUQgT3BlcmF0aW9uc1xuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICBhc3luYyBpbnNlcnQ8VD4odGFibGU6IHN0cmluZywgZGF0YTogVCk6IFByb21pc2U8VD4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkYlRhYmxlID0gdGhpcy5nZXRUYWJsZSh0YWJsZSk7XG4gICAgICBjb25zdCBpZCA9IGF3YWl0IGRiVGFibGUuYWRkKGRhdGEgYXMgYW55KTtcblxuICAgICAgLy8gUmV0dXJuIHRoZSBpbnNlcnRlZCBkYXRhIHdpdGggdGhlIGdlbmVyYXRlZCBJRCBpZiBuZWVkZWRcbiAgICAgIGlmICh0eXBlb2YgaWQgPT09ICdzdHJpbmcnICYmIChkYXRhIGFzIGFueSkuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4geyAuLi5kYXRhLCBpZCB9IGFzIFQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gaW5zZXJ0IGludG8gJHt0YWJsZX06YCwgZXJyb3IpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBEYXRhYmFzZSBpbnNlcnQgZmFpbGVkOiAke2Vycm9yfWApO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIHF1ZXJ5PFQ+KHRhYmxlOiBzdHJpbmcsIGZpbHRlcj86IGFueSk6IFByb21pc2U8VFtdPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRiVGFibGUgPSB0aGlzLmdldFRhYmxlKHRhYmxlKTtcbiAgICAgIGxldCBjb2xsZWN0aW9uID0gZGJUYWJsZS50b0NvbGxlY3Rpb24oKTtcblxuICAgICAgaWYgKGZpbHRlcikge1xuICAgICAgICAvLyBBcHBseSBmaWx0ZXJzIGJhc2VkIG9uIHRoZSBmaWx0ZXIgb2JqZWN0XG4gICAgICAgIGlmIChmaWx0ZXIuaWQpIHtcbiAgICAgICAgICByZXR1cm4gWyhhd2FpdCBkYlRhYmxlLmdldChmaWx0ZXIuaWQpKV0gYXMgVFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXBwbHkgY29tbW9uIGZpbHRlcnNcbiAgICAgICAgT2JqZWN0LmtleXMoZmlsdGVyKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgaWYgKGZpbHRlcltrZXldICE9PSB1bmRlZmluZWQgJiYgZmlsdGVyW2tleV0gIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbGxlY3Rpb24gPSBjb2xsZWN0aW9uLmZpbHRlcihpdGVtID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSAoaXRlbSBhcyBhbnkpW2tleV07XG4gICAgICAgICAgICAgIGNvbnN0IGZpbHRlclZhbHVlID0gZmlsdGVyW2tleV07XG5cbiAgICAgICAgICAgICAgLy8gSGFuZGxlIGRhdGUgcmFuZ2UgZmlsdGVyc1xuICAgICAgICAgICAgICBpZiAoa2V5ID09PSAnc3RhcnREYXRlJyAmJiB2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgPj0gZmlsdGVyVmFsdWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGtleSA9PT0gJ2VuZERhdGUnICYmIHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSA8PSBmaWx0ZXJWYWx1ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIEhhbmRsZSBleGFjdCBtYXRjaGVzXG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZSA9PT0gZmlsdGVyVmFsdWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgY29sbGVjdGlvbi50b0FycmF5KCk7XG4gICAgICByZXR1cm4gcmVzdWx0cyBhcyBUW107XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBxdWVyeSAke3RhYmxlfTpgLCBlcnJvcik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYERhdGFiYXNlIHF1ZXJ5IGZhaWxlZDogJHtlcnJvcn1gKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyB1cGRhdGU8VD4odGFibGU6IHN0cmluZywgaWQ6IHN0cmluZywgZGF0YTogUGFydGlhbDxUPik6IFByb21pc2U8VD4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkYlRhYmxlID0gdGhpcy5nZXRUYWJsZSh0YWJsZSk7XG5cbiAgICAgIC8vIEdldCBleGlzdGluZyByZWNvcmRcbiAgICAgIGNvbnN0IGV4aXN0aW5nID0gYXdhaXQgZGJUYWJsZS5nZXQoaWQpO1xuICAgICAgaWYgKCFleGlzdGluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFJlY29yZCB3aXRoIGlkICR7aWR9IG5vdCBmb3VuZCBpbiAke3RhYmxlfWApO1xuICAgICAgfVxuXG4gICAgICAvLyBNZXJnZSB1cGRhdGVzXG4gICAgICBjb25zdCB1cGRhdGVkID0geyAuLi5leGlzdGluZywgLi4uZGF0YSwgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpIH07XG5cbiAgICAgIC8vIFVwZGF0ZSBpbiBkYXRhYmFzZVxuICAgICAgYXdhaXQgZGJUYWJsZS51cGRhdGUoaWQsIHVwZGF0ZWQpO1xuXG4gICAgICByZXR1cm4gdXBkYXRlZCBhcyBUO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gdXBkYXRlICR7dGFibGV9OmAsIGVycm9yKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRGF0YWJhc2UgdXBkYXRlIGZhaWxlZDogJHtlcnJvcn1gKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBkZWxldGUodGFibGU6IHN0cmluZywgaWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkYlRhYmxlID0gdGhpcy5nZXRUYWJsZSh0YWJsZSk7XG4gICAgICBhd2FpdCBkYlRhYmxlLmRlbGV0ZShpZCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBkZWxldGUgZnJvbSAke3RhYmxlfTpgLCBlcnJvcik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYERhdGFiYXNlIGRlbGV0ZSBmYWlsZWQ6ICR7ZXJyb3J9YCk7XG4gICAgfVxuICB9XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIEFuYWx5dGljcyBRdWVyaWVzXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIGFzeW5jIGdldENhdGVnb3J5U3BlbmRpbmcodXNlcklkOiBzdHJpbmcsIHN0YXJ0RGF0ZTogRGF0ZSwgZW5kRGF0ZTogRGF0ZSk6IFByb21pc2U8Q2F0ZWdvcnlUb3RhbFtdPiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIEdldCB1c2VyJ3MgdHJhbnNhY3Rpb25zIGluIGRhdGUgcmFuZ2VcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9ucyA9IGF3YWl0IHRoaXMuZGIudHJhbnNhY3Rpb25zXG4gICAgICAgIC53aGVyZSgnZGF0ZScpXG4gICAgICAgIC5iZXR3ZWVuKHN0YXJ0RGF0ZSwgZW5kRGF0ZSwgdHJ1ZSwgdHJ1ZSlcbiAgICAgICAgLmZpbHRlcih0ID0+IHtcbiAgICAgICAgICAvLyBXZSBuZWVkIHRvIGNoZWNrIGlmIHRoZSBhY2NvdW50IGJlbG9uZ3MgdG8gdGhlIHVzZXJcbiAgICAgICAgICAvLyBUaGlzIHdvdWxkIG5vcm1hbGx5IGJlIGEgSk9JTiBvcGVyYXRpb25cbiAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gU2ltcGxpZmllZCBmb3Igbm93XG4gICAgICAgIH0pXG4gICAgICAgIC50b0FycmF5KCk7XG5cbiAgICAgIC8vIEdldCB1c2VyJ3MgY2F0ZWdvcmllc1xuICAgICAgY29uc3QgY2F0ZWdvcmllcyA9IGF3YWl0IHRoaXMuZGIuY2F0ZWdvcmllc1xuICAgICAgICAud2hlcmUoJ3VzZXJJZCcpXG4gICAgICAgIC5lcXVhbHModXNlcklkKVxuICAgICAgICAudG9BcnJheSgpO1xuXG4gICAgICAvLyBDYWxjdWxhdGUgc3BlbmRpbmcgYnkgY2F0ZWdvcnlcbiAgICAgIGNvbnN0IGNhdGVnb3J5TWFwID0gbmV3IE1hcDxzdHJpbmcsIENhdGVnb3J5VG90YWw+KCk7XG5cbiAgICAgIC8vIEluaXRpYWxpemUgY2F0ZWdvcmllc1xuICAgICAgY2F0ZWdvcmllcy5mb3JFYWNoKGNhdCA9PiB7XG4gICAgICAgIGNhdGVnb3J5TWFwLnNldChjYXQuaWQsIHtcbiAgICAgICAgICBjYXRlZ29yeUlkOiBjYXQuaWQsXG4gICAgICAgICAgY2F0ZWdvcnlOYW1lOiBjYXQubmFtZSxcbiAgICAgICAgICB0b3RhbEFtb3VudDogMCxcbiAgICAgICAgICB0cmFuc2FjdGlvbkNvdW50OiAwLFxuICAgICAgICAgIHBlcmNlbnRhZ2U6IDBcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gQWdncmVnYXRlIHRyYW5zYWN0aW9uIGFtb3VudHNcbiAgICAgIGxldCB0b3RhbFNwZW5kaW5nID0gMDtcblxuICAgICAgZm9yIChjb25zdCB0cmFuc2FjdGlvbiBvZiB0cmFuc2FjdGlvbnMpIHtcbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uLmNhdGVnb3J5SWQpIHtcbiAgICAgICAgICBjb25zdCBjYXRlZ29yeSA9IGNhdGVnb3J5TWFwLmdldCh0cmFuc2FjdGlvbi5jYXRlZ29yeUlkKTtcbiAgICAgICAgICBpZiAoY2F0ZWdvcnkpIHtcbiAgICAgICAgICAgIGNhdGVnb3J5LnRvdGFsQW1vdW50ICs9IE1hdGguYWJzKHRyYW5zYWN0aW9uLm9yaWdpbmFsQW1vdW50KTtcbiAgICAgICAgICAgIGNhdGVnb3J5LnRyYW5zYWN0aW9uQ291bnQgKz0gMTtcbiAgICAgICAgICAgIHRvdGFsU3BlbmRpbmcgKz0gTWF0aC5hYnModHJhbnNhY3Rpb24ub3JpZ2luYWxBbW91bnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhhbmRsZSBzcGxpdHNcbiAgICAgICAgY29uc3Qgc3BsaXRzID0gYXdhaXQgdGhpcy5kYi50cmFuc2FjdGlvbl9zcGxpdHNcbiAgICAgICAgICAud2hlcmUoJ3RyYW5zYWN0aW9uSWQnKVxuICAgICAgICAgIC5lcXVhbHModHJhbnNhY3Rpb24uaWQpXG4gICAgICAgICAgLnRvQXJyYXkoKTtcblxuICAgICAgICBzcGxpdHMuZm9yRWFjaChzcGxpdCA9PiB7XG4gICAgICAgICAgY29uc3QgY2F0ZWdvcnkgPSBjYXRlZ29yeU1hcC5nZXQoc3BsaXQuY2F0ZWdvcnlJZCk7XG4gICAgICAgICAgaWYgKGNhdGVnb3J5KSB7XG4gICAgICAgICAgICBjYXRlZ29yeS50b3RhbEFtb3VudCArPSBNYXRoLmFicyhzcGxpdC5hbW91bnQpO1xuICAgICAgICAgICAgdG90YWxTcGVuZGluZyArPSBNYXRoLmFicyhzcGxpdC5hbW91bnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIENhbGN1bGF0ZSBwZXJjZW50YWdlc1xuICAgICAgY2F0ZWdvcnlNYXAuZm9yRWFjaChjYXRlZ29yeSA9PiB7XG4gICAgICAgIGlmICh0b3RhbFNwZW5kaW5nID4gMCkge1xuICAgICAgICAgIGNhdGVnb3J5LnBlcmNlbnRhZ2UgPSAoY2F0ZWdvcnkudG90YWxBbW91bnQgLyB0b3RhbFNwZW5kaW5nKSAqIDEwMDtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBBcnJheS5mcm9tKGNhdGVnb3J5TWFwLnZhbHVlcygpKVxuICAgICAgICAuZmlsdGVyKGNhdCA9PiBjYXQudG90YWxBbW91bnQgPiAwKVxuICAgICAgICAuc29ydCgoYSwgYikgPT4gYi50b3RhbEFtb3VudCAtIGEudG90YWxBbW91bnQpO1xuXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBnZXQgY2F0ZWdvcnkgc3BlbmRpbmc6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBbmFseXRpY3MgcXVlcnkgZmFpbGVkOiAke2Vycm9yfWApO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGdldEJ1ZGdldFByb2dyZXNzKHVzZXJJZDogc3RyaW5nKTogUHJvbWlzZTxCdWRnZXRTdGF0dXNbXT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBidWRnZXRzID0gYXdhaXQgdGhpcy5kYi5idWRnZXRzXG4gICAgICAgIC53aGVyZSgndXNlcklkJylcbiAgICAgICAgLmVxdWFscyh1c2VySWQpXG4gICAgICAgIC5maWx0ZXIoYiA9PiBiLmlzQWN0aXZlKVxuICAgICAgICAudG9BcnJheSgpO1xuXG4gICAgICBjb25zdCBidWRnZXRTdGF0dXM6IEJ1ZGdldFN0YXR1c1tdID0gW107XG5cbiAgICAgIGZvciAoY29uc3QgYnVkZ2V0IG9mIGJ1ZGdldHMpIHtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHBlcmlvZCBzdGFydC9lbmQgZGF0ZXNcbiAgICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcbiAgICAgICAgbGV0IHBlcmlvZFN0YXJ0ID0gbmV3IERhdGUoYnVkZ2V0LnN0YXJ0RGF0ZSk7XG4gICAgICAgIGxldCBwZXJpb2RFbmQgPSBuZXcgRGF0ZShidWRnZXQuc3RhcnREYXRlKTtcblxuICAgICAgICBpZiAoYnVkZ2V0LnBlcmlvZCA9PT0gJ21vbnRobHknKSB7XG4gICAgICAgICAgcGVyaW9kU3RhcnQgPSBuZXcgRGF0ZShub3cuZ2V0RnVsbFllYXIoKSwgbm93LmdldE1vbnRoKCksIDEpO1xuICAgICAgICAgIHBlcmlvZEVuZCA9IG5ldyBEYXRlKG5vdy5nZXRGdWxsWWVhcigpLCBub3cuZ2V0TW9udGgoKSArIDEsIDApO1xuICAgICAgICB9IGVsc2UgaWYgKGJ1ZGdldC5wZXJpb2QgPT09ICd5ZWFybHknKSB7XG4gICAgICAgICAgcGVyaW9kU3RhcnQgPSBuZXcgRGF0ZShub3cuZ2V0RnVsbFllYXIoKSwgMCwgMSk7XG4gICAgICAgICAgcGVyaW9kRW5kID0gbmV3IERhdGUobm93LmdldEZ1bGxZZWFyKCksIDExLCAzMSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDYWxjdWxhdGUgc3BlbmRpbmcgZm9yIHRoaXMgY2F0ZWdvcnkgaW4gdGhlIHBlcmlvZFxuICAgICAgICBjb25zdCBjYXRlZ29yeVNwZW5kaW5nID0gYXdhaXQgdGhpcy5nZXRDYXRlZ29yeVNwZW5kaW5nKHVzZXJJZCwgcGVyaW9kU3RhcnQsIHBlcmlvZEVuZCk7XG4gICAgICAgIGNvbnN0IHNwZW50ID0gY2F0ZWdvcnlTcGVuZGluZy5maW5kKGMgPT4gYy5jYXRlZ29yeUlkID09PSBidWRnZXQuY2F0ZWdvcnlJZCk/LnRvdGFsQW1vdW50IHx8IDA7XG5cbiAgICAgICAgLy8gR2V0IGNhdGVnb3J5IGRldGFpbHNcbiAgICAgICAgY29uc3QgY2F0ZWdvcnkgPSBhd2FpdCB0aGlzLmRiLmNhdGVnb3JpZXMuZ2V0KGJ1ZGdldC5jYXRlZ29yeUlkKTtcblxuICAgICAgICBidWRnZXRTdGF0dXMucHVzaCh7XG4gICAgICAgICAgYnVkZ2V0SWQ6IGJ1ZGdldC5pZCxcbiAgICAgICAgICBjYXRlZ29yeUlkOiBidWRnZXQuY2F0ZWdvcnlJZCxcbiAgICAgICAgICBjYXRlZ29yeU5hbWU6IGNhdGVnb3J5Py5uYW1lIHx8ICdVbmtub3duIENhdGVnb3J5JyxcbiAgICAgICAgICBidWRnZXRBbW91bnQ6IGJ1ZGdldC5hbW91bnQsXG4gICAgICAgICAgc3BlbnRBbW91bnQ6IHNwZW50LFxuICAgICAgICAgIHJlbWFpbmluZ0Ftb3VudDogYnVkZ2V0LmFtb3VudCAtIHNwZW50LFxuICAgICAgICAgIHBlcmNlbnRhZ2VVc2VkOiAoc3BlbnQgLyBidWRnZXQuYW1vdW50KSAqIDEwMCxcbiAgICAgICAgICBwZXJpb2Q6IGJ1ZGdldC5wZXJpb2QgYXMgJ21vbnRobHknIHwgJ3llYXJseScsXG4gICAgICAgICAgaXNPdmVyQnVkZ2V0OiBzcGVudCA+IGJ1ZGdldC5hbW91bnRcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBidWRnZXRTdGF0dXM7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBnZXQgYnVkZ2V0IHByb2dyZXNzOicsIGVycm9yKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQnVkZ2V0IHByb2dyZXNzIHF1ZXJ5IGZhaWxlZDogJHtlcnJvcn1gKTtcbiAgICB9XG4gIH1cblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gRXhwb3J0L0ltcG9ydCBPcGVyYXRpb25zXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIGFzeW5jIGV4cG9ydEFsbCgpOiBQcm9taXNlPGFueT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkYXRhOiBhbnkgPSB7fTtcblxuICAgICAgLy8gRXhwb3J0IGFsbCB0YWJsZXNcbiAgICAgIGNvbnN0IHRhYmxlcyA9IFtcbiAgICAgICAgJ3VzZXJzJywgJ2FjY291bnRzJywgJ2NhdGVnb3JpZXMnLCAndHJhbnNhY3Rpb25zJyxcbiAgICAgICAgJ3RyYW5zYWN0aW9uX3NwbGl0cycsICdidWRnZXRzJywgJ2N1cnJlbmNpZXMnLFxuICAgICAgICAnaW52ZXN0bWVudHMnLCAncG9ydGZvbGlvcycsICduZXRfd29ydGhfc25hcHNob3RzJ1xuICAgICAgXTtcblxuICAgICAgZm9yIChjb25zdCB0YWJsZU5hbWUgb2YgdGFibGVzKSB7XG4gICAgICAgIGNvbnN0IHRhYmxlID0gdGhpcy5nZXRUYWJsZSh0YWJsZU5hbWUpO1xuICAgICAgICBkYXRhW3RhYmxlTmFtZV0gPSBhd2FpdCB0YWJsZS50b0FycmF5KCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZlcnNpb246IDEsXG4gICAgICAgIGV4cG9ydGVkQXQ6IG5ldyBEYXRlKCksXG4gICAgICAgIGRhdGFcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBleHBvcnQgZGF0YTonLCBlcnJvcik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYERhdGEgZXhwb3J0IGZhaWxlZDogJHtlcnJvcn1gKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBpbXBvcnREYXRhKGltcG9ydERhdGE6IGFueSk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIWltcG9ydERhdGEuZGF0YSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW1wb3J0IGRhdGEgZm9ybWF0Jyk7XG4gICAgICB9XG5cbiAgICAgIC8vIENsZWFyIGV4aXN0aW5nIGRhdGEgKG9wdGlvbmFsIC0gbWlnaHQgd2FudCB0byBtZXJnZSBpbnN0ZWFkKVxuICAgICAgYXdhaXQgdGhpcy5kYi50cmFuc2FjdGlvbigncncnLCBbXG4gICAgICAgIHRoaXMuZGIudXNlcnMsIHRoaXMuZGIuYWNjb3VudHMsIHRoaXMuZGIuY2F0ZWdvcmllcyxcbiAgICAgICAgdGhpcy5kYi50cmFuc2FjdGlvbnMsIHRoaXMuZGIudHJhbnNhY3Rpb25fc3BsaXRzLFxuICAgICAgICB0aGlzLmRiLmJ1ZGdldHMsIHRoaXMuZGIuY3VycmVuY2llcywgdGhpcy5kYi5pbnZlc3RtZW50cyxcbiAgICAgICAgdGhpcy5kYi5wb3J0Zm9saW9zLCB0aGlzLmRiLm5ldF93b3J0aF9zbmFwc2hvdHNcbiAgICAgIF0sIGFzeW5jICgpID0+IHtcbiAgICAgICAgLy8gSW1wb3J0IGRhdGEgdGFibGUgYnkgdGFibGVcbiAgICAgICAgY29uc3QgdGFibGVzID0gW1xuICAgICAgICAgICd1c2VycycsICdhY2NvdW50cycsICdjYXRlZ29yaWVzJywgJ3RyYW5zYWN0aW9ucycsXG4gICAgICAgICAgJ3RyYW5zYWN0aW9uX3NwbGl0cycsICdidWRnZXRzJywgJ2N1cnJlbmNpZXMnLFxuICAgICAgICAgICdpbnZlc3RtZW50cycsICdwb3J0Zm9saW9zJywgJ25ldF93b3J0aF9zbmFwc2hvdHMnXG4gICAgICAgIF07XG5cbiAgICAgICAgZm9yIChjb25zdCB0YWJsZU5hbWUgb2YgdGFibGVzKSB7XG4gICAgICAgICAgaWYgKGltcG9ydERhdGEuZGF0YVt0YWJsZU5hbWVdKSB7XG4gICAgICAgICAgICBjb25zdCB0YWJsZSA9IHRoaXMuZ2V0VGFibGUodGFibGVOYW1lKTtcbiAgICAgICAgICAgIGF3YWl0IHRhYmxlLmJ1bGtBZGQoaW1wb3J0RGF0YS5kYXRhW3RhYmxlTmFtZV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGltcG9ydCBkYXRhOicsIGVycm9yKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRGF0YSBpbXBvcnQgZmFpbGVkOiAke2Vycm9yfWApO1xuICAgIH1cbiAgfVxuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBVdGlsaXR5IE1ldGhvZHNcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgcHJpdmF0ZSBnZXRUYWJsZSh0YWJsZU5hbWU6IHN0cmluZyk6IFRhYmxlIHtcbiAgICBjb25zdCB0YWJsZSA9ICh0aGlzLmRiIGFzIGFueSlbdGFibGVOYW1lXTtcbiAgICBpZiAoIXRhYmxlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRhYmxlICR7dGFibGVOYW1lfSBub3QgZm91bmRgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRhYmxlO1xuICB9XG5cbiAgLy8gSW5pdGlhbGl6ZSB3aXRoIGRlZmF1bHQgZGF0YVxuICBhc3luYyBpbml0aWFsaXplKHVzZXJJZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKGBTdGFydGluZyBJbmRleGVkREIgaW5pdGlhbGl6YXRpb24gZm9yIHVzZXI6ICR7dXNlcklkfWApO1xuXG4gICAgICAvLyBDaGVjayBpZiBhbHJlYWR5IGluaXRpYWxpemVkXG4gICAgICBjb25zdCB1c2VyID0gYXdhaXQgdGhpcy5kYi51c2Vycy5nZXQodXNlcklkKTtcbiAgICAgIGlmICh1c2VyKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBVc2VyICR7dXNlcklkfSBhbHJlYWR5IGluaXRpYWxpemVkYCk7XG4gICAgICAgIHJldHVybjsgLy8gQWxyZWFkeSBpbml0aWFsaXplZFxuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmxvZyhgQ3JlYXRpbmcgbmV3IHVzZXIgcHJvZmlsZSBmb3I6ICR7dXNlcklkfWApO1xuXG4gICAgICAvLyBDcmVhdGUgdXNlciByZWNvcmRcbiAgICAgIGNvbnN0IG5ld1VzZXIgPSB7XG4gICAgICAgIGlkOiB1c2VySWQsXG4gICAgICAgIGNvZ25pdG9JZDogdXNlcklkLCAvLyBVc2luZyB1c2VySWQgYXMgY29nbml0b0lkIGZvciBkZW1vIGFjY291bnRzXG4gICAgICAgIGVtYWlsOiBgJHt1c2VySWR9QG1vbmV5cXVlc3QuY29tYCxcbiAgICAgICAgcHJlZmVyZW5jZXM6IEpTT04uc3RyaW5naWZ5KHsgdGhlbWU6ICdsaWdodCcsIGN1cnJlbmN5OiAnVVNEJyB9KSxcbiAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLFxuICAgICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKClcbiAgICAgIH07XG5cbiAgICAgIC8vIENyZWF0ZSBkZWZhdWx0IGN1cnJlbmNpZXNcbiAgICAgIGNvbnN0IGRlZmF1bHRDdXJyZW5jaWVzID0gW1xuICAgICAgICB7XG4gICAgICAgICAgaWQ6ICd1c2QnLFxuICAgICAgICAgIGNvZGU6ICdVU0QnLFxuICAgICAgICAgIG5hbWU6ICdVUyBEb2xsYXInLFxuICAgICAgICAgIHN5bWJvbDogJyQnLFxuICAgICAgICAgIGlzQWN0aXZlOiB0cnVlLFxuICAgICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKSxcbiAgICAgICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKClcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGlkOiAnZXVyJyxcbiAgICAgICAgICBjb2RlOiAnRVVSJyxcbiAgICAgICAgICBuYW1lOiAnRXVybycsXG4gICAgICAgICAgc3ltYm9sOiAn4oKsJyxcbiAgICAgICAgICBpc0FjdGl2ZTogdHJ1ZSxcbiAgICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCksXG4gICAgICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpXG4gICAgICAgIH1cbiAgICAgIF07XG5cbiAgICAgIC8vIENyZWF0ZSBkZWZhdWx0IGNhdGVnb3JpZXNcbiAgICAgIGNvbnN0IGRlZmF1bHRDYXRlZ29yaWVzID0gW1xuICAgICAgICB7IG5hbWU6ICdHcm9jZXJpZXMnLCB0eXBlOiAnZXhwZW5zZScsIGNvbG9yOiAnIzEwQjk4MScgfSxcbiAgICAgICAgeyBuYW1lOiAnVHJhbnNwb3J0YXRpb24nLCB0eXBlOiAnZXhwZW5zZScsIGNvbG9yOiAnIzNCODJGNicgfSxcbiAgICAgICAgeyBuYW1lOiAnSG91c2luZycsIHR5cGU6ICdleHBlbnNlJywgY29sb3I6ICcjOEI1Q0Y2JyB9LFxuICAgICAgICB7IG5hbWU6ICdVdGlsaXRpZXMnLCB0eXBlOiAnZXhwZW5zZScsIGNvbG9yOiAnI0Y1OUUwQicgfSxcbiAgICAgICAgeyBuYW1lOiAnRW50ZXJ0YWlubWVudCcsIHR5cGU6ICdleHBlbnNlJywgY29sb3I6ICcjRUY0NDQ0JyB9LFxuICAgICAgICB7IG5hbWU6ICdIZWFsdGhjYXJlJywgdHlwZTogJ2V4cGVuc2UnLCBjb2xvcjogJyNFQzQ4OTknIH0sXG4gICAgICAgIHsgbmFtZTogJ1NhbGFyeScsIHR5cGU6ICdpbmNvbWUnLCBjb2xvcjogJyMwNTk2NjknIH0sXG4gICAgICAgIHsgbmFtZTogJ0ludmVzdG1lbnQnLCB0eXBlOiAnaW5jb21lJywgY29sb3I6ICcjMDg5MUIyJyB9XG4gICAgICBdLm1hcChjYXQgPT4gKHtcbiAgICAgICAgaWQ6IGAke3VzZXJJZH0tJHtjYXQubmFtZS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1xccysvZywgJy0nKX1gLFxuICAgICAgICB1c2VySWQsXG4gICAgICAgIC4uLmNhdCxcbiAgICAgICAgaXNEZWZhdWx0OiB0cnVlLFxuICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCksXG4gICAgICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKVxuICAgICAgfSkpO1xuXG4gICAgICAvLyBDcmVhdGUgc29tZSBkZW1vIGFjY291bnRzIGZvciBuZXcgdXNlcnNcbiAgICAgIGNvbnN0IGRlZmF1bHRBY2NvdW50cyA9IFtcbiAgICAgICAge1xuICAgICAgICAgIGlkOiBgJHt1c2VySWR9LWNoZWNraW5nYCxcbiAgICAgICAgICB1c2VySWQsXG4gICAgICAgICAgbmFtZTogJ0NoZWNraW5nIEFjY291bnQnLFxuICAgICAgICAgIHR5cGU6ICdjaGVja2luZycsXG4gICAgICAgICAgYmFsYW5jZTogMjUwMC4wMCxcbiAgICAgICAgICBjdXJyZW5jeUlkOiAndXNkJyxcbiAgICAgICAgICBpc0FjdGl2ZTogdHJ1ZSxcbiAgICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCksXG4gICAgICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBpZDogYCR7dXNlcklkfS1zYXZpbmdzYCxcbiAgICAgICAgICB1c2VySWQsXG4gICAgICAgICAgbmFtZTogJ1NhdmluZ3MgQWNjb3VudCcsXG4gICAgICAgICAgdHlwZTogJ3NhdmluZ3MnLFxuICAgICAgICAgIGJhbGFuY2U6IDEyNTAwLjAwLFxuICAgICAgICAgIGN1cnJlbmN5SWQ6ICd1c2QnLFxuICAgICAgICAgIGlzQWN0aXZlOiB0cnVlLFxuICAgICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKSxcbiAgICAgICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKClcbiAgICAgICAgfVxuICAgICAgXTtcblxuICAgICAgLy8gSW5pdGlhbGl6ZSBkYXRhYmFzZSB3aXRoIHRyYW5zYWN0aW9uXG4gICAgICBhd2FpdCB0aGlzLmRiLnRyYW5zYWN0aW9uKCdydycsIFtcbiAgICAgICAgdGhpcy5kYi51c2VycyxcbiAgICAgICAgdGhpcy5kYi5jdXJyZW5jaWVzLFxuICAgICAgICB0aGlzLmRiLmNhdGVnb3JpZXMsXG4gICAgICAgIHRoaXMuZGIuYWNjb3VudHNcbiAgICAgIF0sIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coJ0NyZWF0aW5nIHVzZXIgcmVjb3JkLi4uJyk7XG4gICAgICAgIGF3YWl0IHRoaXMuZGIudXNlcnMuYWRkKG5ld1VzZXIpO1xuXG4gICAgICAgIGNvbnNvbGUubG9nKCdBZGRpbmcgZGVmYXVsdCBjdXJyZW5jaWVzLi4uJyk7XG4gICAgICAgIC8vIEFkZCBjdXJyZW5jaWVzIChvbmx5IGlmIG5vdCBleGlzdClcbiAgICAgICAgZm9yIChjb25zdCBjdXJyZW5jeSBvZiBkZWZhdWx0Q3VycmVuY2llcykge1xuICAgICAgICAgIGNvbnN0IGV4aXN0aW5nID0gYXdhaXQgdGhpcy5kYi5jdXJyZW5jaWVzLmdldChjdXJyZW5jeS5pZCk7XG4gICAgICAgICAgaWYgKCFleGlzdGluZykge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5kYi5jdXJyZW5jaWVzLmFkZChjdXJyZW5jeSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc29sZS5sb2coJ0FkZGluZyBkZWZhdWx0IGNhdGVnb3JpZXMuLi4nKTtcbiAgICAgICAgYXdhaXQgdGhpcy5kYi5jYXRlZ29yaWVzLmJ1bGtBZGQoZGVmYXVsdENhdGVnb3JpZXMpO1xuXG4gICAgICAgIGNvbnNvbGUubG9nKCdBZGRpbmcgZGVmYXVsdCBhY2NvdW50cy4uLicpO1xuICAgICAgICBhd2FpdCB0aGlzLmRiLmFjY291bnRzLmJ1bGtBZGQoZGVmYXVsdEFjY291bnRzKTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zb2xlLmxvZyhgU3VjY2Vzc2Z1bGx5IGluaXRpYWxpemVkIGRhdGFiYXNlIGZvciB1c2VyOiAke3VzZXJJZH1gKTtcblxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gaW5pdGlhbGl6ZSBkYXRhYmFzZTonLCBlcnJvcik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYERhdGFiYXNlIGluaXRpYWxpemF0aW9uIGZhaWxlZDogJHtlcnJvcn1gKTtcbiAgICB9XG4gIH1cbn0iXSwibmFtZXMiOlsiRGV4aWUiLCJNb25leVF1ZXN0REIiLCJ2ZXJzaW9uIiwic3RvcmVzIiwidXNlcnMiLCJhY2NvdW50cyIsImNhdGVnb3JpZXMiLCJ0cmFuc2FjdGlvbnMiLCJ0cmFuc2FjdGlvbl9zcGxpdHMiLCJidWRnZXRzIiwiY3VycmVuY2llcyIsImludmVzdG1lbnRzIiwicG9ydGZvbGlvcyIsIm5ldF93b3J0aF9zbmFwc2hvdHMiLCJJbmRleGVkREJXcmFwcGVyIiwiaW5zZXJ0IiwidGFibGUiLCJkYXRhIiwiZGJUYWJsZSIsImdldFRhYmxlIiwiaWQiLCJhZGQiLCJ1bmRlZmluZWQiLCJlcnJvciIsImNvbnNvbGUiLCJFcnJvciIsInF1ZXJ5IiwiZmlsdGVyIiwiY29sbGVjdGlvbiIsInRvQ29sbGVjdGlvbiIsImdldCIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwia2V5IiwiaXRlbSIsInZhbHVlIiwiZmlsdGVyVmFsdWUiLCJEYXRlIiwicmVzdWx0cyIsInRvQXJyYXkiLCJ1cGRhdGUiLCJleGlzdGluZyIsInVwZGF0ZWQiLCJ1cGRhdGVkQXQiLCJkZWxldGUiLCJnZXRDYXRlZ29yeVNwZW5kaW5nIiwidXNlcklkIiwic3RhcnREYXRlIiwiZW5kRGF0ZSIsImRiIiwid2hlcmUiLCJiZXR3ZWVuIiwidCIsImVxdWFscyIsImNhdGVnb3J5TWFwIiwiTWFwIiwiY2F0Iiwic2V0IiwiY2F0ZWdvcnlJZCIsImNhdGVnb3J5TmFtZSIsIm5hbWUiLCJ0b3RhbEFtb3VudCIsInRyYW5zYWN0aW9uQ291bnQiLCJwZXJjZW50YWdlIiwidG90YWxTcGVuZGluZyIsInRyYW5zYWN0aW9uIiwiY2F0ZWdvcnkiLCJNYXRoIiwiYWJzIiwib3JpZ2luYWxBbW91bnQiLCJzcGxpdHMiLCJzcGxpdCIsImFtb3VudCIsIkFycmF5IiwiZnJvbSIsInZhbHVlcyIsInNvcnQiLCJhIiwiYiIsImdldEJ1ZGdldFByb2dyZXNzIiwiaXNBY3RpdmUiLCJidWRnZXRTdGF0dXMiLCJidWRnZXQiLCJjYXRlZ29yeVNwZW5kaW5nIiwibm93IiwicGVyaW9kU3RhcnQiLCJwZXJpb2RFbmQiLCJwZXJpb2QiLCJnZXRGdWxsWWVhciIsImdldE1vbnRoIiwic3BlbnQiLCJmaW5kIiwiYyIsInB1c2giLCJidWRnZXRJZCIsImJ1ZGdldEFtb3VudCIsInNwZW50QW1vdW50IiwicmVtYWluaW5nQW1vdW50IiwicGVyY2VudGFnZVVzZWQiLCJpc092ZXJCdWRnZXQiLCJleHBvcnRBbGwiLCJ0YWJsZXMiLCJ0YWJsZU5hbWUiLCJleHBvcnRlZEF0IiwiaW1wb3J0RGF0YSIsImJ1bGtBZGQiLCJpbml0aWFsaXplIiwibG9nIiwidXNlciIsIm5ld1VzZXIiLCJjb2duaXRvSWQiLCJlbWFpbCIsInByZWZlcmVuY2VzIiwiSlNPTiIsInN0cmluZ2lmeSIsInRoZW1lIiwiY3VycmVuY3kiLCJjcmVhdGVkQXQiLCJkZWZhdWx0Q3VycmVuY2llcyIsImNvZGUiLCJzeW1ib2wiLCJkZWZhdWx0Q2F0ZWdvcmllcyIsInR5cGUiLCJjb2xvciIsIm1hcCIsInRvTG93ZXJDYXNlIiwicmVwbGFjZSIsImlzRGVmYXVsdCIsImRlZmF1bHRBY2NvdW50cyIsImJhbGFuY2UiLCJjdXJyZW5jeUlkIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/database/IndexedDBWrapper.ts\n"));

/***/ })

});