"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/receipts/page",{

/***/ "(app-pages-browser)/./services/ocrService.ts":
/*!********************************!*\
  !*** ./services/ocrService.ts ***!
  \********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ocrService: () => (/* binding */ ocrService)\n/* harmony export */ });\n/* harmony import */ var tesseract_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tesseract.js */ \"(app-pages-browser)/../../node_modules/tesseract.js/src/index.js\");\n/* harmony import */ var tesseract_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(tesseract_js__WEBPACK_IMPORTED_MODULE_0__);\n\nclass OCRService {\n    async initialize() {\n        if (this.isInitialized) return;\n        try {\n            console.log('🔍 Initializing OCR engine...');\n            this.worker = await (0,tesseract_js__WEBPACK_IMPORTED_MODULE_0__.createWorker)('eng');\n            // Configure Tesseract for better receipt reading\n            await this.worker.setParameters({\n                'tessedit_char_whitelist': '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz.,$/:-# ',\n                'tessedit_pageseg_mode': '6',\n                'preserve_interword_spaces': '1'\n            });\n            this.isInitialized = true;\n            console.log('✅ OCR engine initialized successfully');\n        } catch (error) {\n            console.error('❌ Failed to initialize OCR engine:', error);\n            throw new Error('Failed to initialize OCR engine');\n        }\n    }\n    async preprocessImage(imageFile) {\n        return new Promise((resolve, reject)=>{\n            const canvas = document.createElement('canvas');\n            const ctx = canvas.getContext('2d');\n            const img = new Image();\n            img.onload = ()=>{\n                // Set canvas size\n                canvas.width = img.width;\n                canvas.height = img.height;\n                if (!ctx) {\n                    reject(new Error('Could not get canvas context'));\n                    return;\n                }\n                // Draw original image\n                ctx.drawImage(img, 0, 0);\n                // Get image data for processing\n                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n                const data = imageData.data;\n                // Convert to grayscale and increase contrast\n                for(let i = 0; i < data.length; i += 4){\n                    const gray = Math.round(0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2]);\n                    // Increase contrast\n                    const contrast = 1.5;\n                    const factor = 259 * (contrast + 255) / (255 * (259 - contrast));\n                    const enhanced = Math.min(255, Math.max(0, factor * (gray - 128) + 128));\n                    data[i] = enhanced; // Red\n                    data[i + 1] = enhanced; // Green\n                    data[i + 2] = enhanced; // Blue\n                // Alpha stays the same\n                }\n                // Put the processed image data back\n                ctx.putImageData(imageData, 0, 0);\n                // Convert to data URL\n                resolve(canvas.toDataURL('image/png'));\n            };\n            img.onerror = ()=>reject(new Error('Failed to load image'));\n            img.src = URL.createObjectURL(imageFile);\n        });\n    }\n    async processReceiptImage(imageFile) {\n        if (!this.worker || !this.isInitialized) {\n            await this.initialize();\n        }\n        try {\n            console.log('📄 Preprocessing receipt image...');\n            const preprocessedImage = await this.preprocessImage(imageFile);\n            console.log('🔍 Processing receipt image with OCR...');\n            const result = await this.worker.recognize(preprocessedImage);\n            console.log('✅ OCR completed', {\n                confidence: result.data.confidence,\n                textLength: result.data.text.length,\n                rawText: result.data.text.substring(0, 200) + '...'\n            });\n            return {\n                text: result.data.text,\n                confidence: result.data.confidence\n            };\n        } catch (error) {\n            console.error('❌ OCR processing failed:', error);\n            throw new Error('Failed to process image with OCR');\n        }\n    }\n    parseReceiptText(ocrText, confidence) {\n        console.log('🔍 Parsing receipt text...');\n        console.log('Raw OCR text:', ocrText);\n        const lines = ocrText.split('\\n').map((line)=>line.trim()).filter((line)=>line.length > 0);\n        // Extract merchant name (usually first or second line)\n        const merchant = this.extractMerchant(lines);\n        // Extract total amount\n        const amount = this.extractTotalAmount(lines);\n        // Extract date\n        const date = this.extractDate(lines);\n        // Extract line items\n        const items = this.extractItems(lines);\n        const parsed = {\n            merchant,\n            amount,\n            date,\n            items,\n            rawText: ocrText,\n            confidence: Math.max(confidence * 0.8, 60) // Adjust confidence for parsing uncertainty\n        };\n        console.log('✅ Receipt parsed successfully:', parsed);\n        return parsed;\n    }\n    extractMerchant(lines) {\n        // Common merchant patterns to look for\n        const merchantPatterns = [\n            /^([A-Za-z\\s&'.-]{3,40})$/,\n            /^([A-Z\\s&'.-]{3,40})\\s+STORE/,\n            /^([A-Z\\s&'.-]{3,40})\\s+MARKET/,\n            /^([A-Z\\s&'.-]{3,40})\\s+INC/\n        ];\n        // Look for merchant name in first 7 lines\n        for(let i = 0; i < Math.min(7, lines.length); i++){\n            const line = lines[i].trim();\n            // Skip obviously non-merchant lines\n            if (line.match(/^\\d+/) || line.includes('RECEIPT') || line.includes('INVOICE') || line.includes('#') || line.includes('TEL') || line.includes('WWW') || line.includes('@') || line.includes('.COM') || line.includes('STREET') || line.includes('AVE') || line.includes('BLVD') || line.includes('RD') || line.length < 3 || line.length > 50) {\n                continue;\n            }\n            // Try merchant patterns\n            for (const pattern of merchantPatterns){\n                const match = line.match(pattern);\n                if (match) {\n                    return match[1].trim().toUpperCase();\n                }\n            }\n            // If no pattern matches but line looks like merchant name\n            if (line.match(/^[A-Za-z\\s&'.-]+$/) && line.length >= 3 && line.length <= 40) {\n                // Check if it's not a common non-merchant word\n                const nonMerchantWords = [\n                    'THANK',\n                    'YOU',\n                    'VISIT',\n                    'AGAIN',\n                    'CUSTOMER',\n                    'COPY'\n                ];\n                if (!nonMerchantWords.some((word)=>line.includes(word))) {\n                    return line.toUpperCase();\n                }\n            }\n        }\n        return 'UNKNOWN MERCHANT';\n    }\n    extractTotalAmount(lines) {\n        // Enhanced total amount patterns\n        const totalPatterns = [\n            /TOTAL.*?[$]?(\\d+\\.?\\d{2})/i,\n            /AMOUNT\\s+DUE.*?[$]?(\\d+\\.?\\d{2})/i,\n            /BALANCE.*?[$]?(\\d+\\.?\\d{2})/i,\n            /GRAND\\s+TOTAL.*?[$]?(\\d+\\.?\\d{2})/i,\n            /FINAL\\s+TOTAL.*?[$]?(\\d+\\.?\\d{2})/i,\n            /[$](\\d+\\.\\d{2})\\s*$/,\n            /(\\d+\\.\\d{2})\\s*TOTAL/i,\n            /TOTAL\\s+[$]?(\\d+\\.\\d{2})/i,\n            /[$]\\s*(\\d+\\.\\d{2})\\s*TOTAL/i\n        ];\n        console.log('🔍 Looking for total amount in lines:', lines.slice(-10));\n        // Search from bottom up as totals are usually at the end\n        for(let i = lines.length - 1; i >= Math.max(0, lines.length - 15); i--){\n            const line = lines[i].trim();\n            if (line.length === 0) continue;\n            console.log(\"Checking line \".concat(i, ': \"').concat(line, '\"'));\n            for (const pattern of totalPatterns){\n                const match = line.match(pattern);\n                if (match) {\n                    const amount = parseFloat(match[1]);\n                    console.log(\"Found potential total: \".concat(amount, \" from pattern: \").concat(pattern));\n                    if (!isNaN(amount) && amount > 0 && amount < 10000) {\n                        console.log(\"✅ Using total amount: \".concat(amount));\n                        return amount;\n                    }\n                }\n            }\n        }\n        console.log('⚠️ No clear total found, looking for largest amount');\n        // If no clear total found, look for largest reasonable amount\n        const amounts = [];\n        lines.forEach((line, index)=>{\n            // Look for money amounts: $X.XX or X.XX\n            const matches = line.match(/[$]?(\\d+\\.\\d{2})/g) || [];\n            matches.forEach((match)=>{\n                const amount = parseFloat(match.replace('$', ''));\n                if (!isNaN(amount) && amount > 0 && amount < 10000) {\n                    console.log(\"Found amount \".concat(amount, \" on line \").concat(index, ': \"').concat(line, '\"'));\n                    amounts.push(amount);\n                }\n            });\n        });\n        const maxAmount = amounts.length > 0 ? Math.max(...amounts) : 0;\n        console.log(\"Using largest amount found: \".concat(maxAmount));\n        return maxAmount;\n    }\n    extractDate(lines) {\n        const datePatterns = [\n            /(\\d{1,2}\\/\\d{1,2}\\/\\d{2,4})/,\n            /(\\d{1,2}-\\d{1,2}-\\d{2,4})/,\n            /(\\d{4}-\\d{2}-\\d{2})/,\n            /(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec).*?(\\d{1,2}),?\\s*(\\d{4})/i\n        ];\n        for (const line of lines){\n            for (const pattern of datePatterns){\n                const match = line.match(pattern);\n                if (match) {\n                    try {\n                        // Try to parse and normalize the date\n                        const dateStr = match[0];\n                        const date = new Date(dateStr);\n                        if (!isNaN(date.getTime())) {\n                            return date.toISOString().split('T')[0]; // Return YYYY-MM-DD format\n                        }\n                    } catch (e) {\n                        continue;\n                    }\n                }\n            }\n        }\n        // Default to today if no date found\n        return new Date().toISOString().split('T')[0];\n    }\n    extractItems(lines) {\n        const items = [];\n        for (const line of lines){\n            // Look for lines with item name and price\n            // Pattern: \"ITEM NAME    $X.XX\" or \"QTY ITEM NAME $X.XX\"\n            const itemPatterns = [\n                /^(\\d+)\\s+(.+?)\\s+\\$?(\\d+\\.\\d{2})$/,\n                /^(.+?)\\s+\\$?(\\d+\\.\\d{2})$/,\n                /^(.+?)\\s+(\\d+\\.\\d{2})\\s*$/ // \"BANANAS 3.99\"\n            ];\n            for (const pattern of itemPatterns){\n                const match = line.match(pattern);\n                if (match) {\n                    let quantity;\n                    let name;\n                    let price;\n                    if (match.length === 4) {\n                        // Pattern with quantity\n                        quantity = parseInt(match[1]);\n                        name = match[2].trim();\n                        price = parseFloat(match[3]);\n                    } else {\n                        // Pattern without quantity\n                        name = match[1].trim();\n                        price = parseFloat(match[2]);\n                    }\n                    // Filter out obviously non-item lines\n                    if (name && !name.match(/TOTAL|TAX|SUBTOTAL|CHANGE|BALANCE|RECEIPT|STORE|THANK/i) && name.length > 2 && name.length < 50 && price > 0 && price < 1000) {\n                        items.push({\n                            name: name.toUpperCase(),\n                            price,\n                            quantity\n                        });\n                    }\n                    break;\n                }\n            }\n        }\n        return items;\n    }\n    async cleanup() {\n        if (this.worker) {\n            await this.worker.terminate();\n            this.worker = null;\n            this.isInitialized = false;\n            console.log('🧹 OCR engine cleaned up');\n        }\n    }\n    constructor(){\n        this.worker = null;\n        this.isInitialized = false;\n    }\n}\n// Export singleton instance\nconst ocrService = new OCRService();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NlcnZpY2VzL29jclNlcnZpY2UudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTRDO0FBb0I1QyxNQUFNQztJQUlKLE1BQU1DLGFBQTRCO1FBQ2hDLElBQUksSUFBSSxDQUFDQyxhQUFhLEVBQUU7UUFFeEIsSUFBSTtZQUNGQyxRQUFRQyxHQUFHLENBQUM7WUFDWixJQUFJLENBQUNDLE1BQU0sR0FBRyxNQUFNTiwwREFBWUEsQ0FBQztZQUVqQyxpREFBaUQ7WUFDakQsTUFBTSxJQUFJLENBQUNNLE1BQU0sQ0FBQ0MsYUFBYSxDQUFDO2dCQUM5QiwyQkFBMkI7Z0JBQzNCLHlCQUF5QjtnQkFDekIsNkJBQTZCO1lBQy9CO1lBRUEsSUFBSSxDQUFDSixhQUFhLEdBQUc7WUFDckJDLFFBQVFDLEdBQUcsQ0FBQztRQUNkLEVBQUUsT0FBT0csT0FBTztZQUNkSixRQUFRSSxLQUFLLENBQUMsc0NBQXNDQTtZQUNwRCxNQUFNLElBQUlDLE1BQU07UUFDbEI7SUFDRjtJQUVBLE1BQWNDLGdCQUFnQkMsU0FBZSxFQUFtQjtRQUM5RCxPQUFPLElBQUlDLFFBQVEsQ0FBQ0MsU0FBU0M7WUFDM0IsTUFBTUMsU0FBU0MsU0FBU0MsYUFBYSxDQUFDO1lBQ3RDLE1BQU1DLE1BQU1ILE9BQU9JLFVBQVUsQ0FBQztZQUM5QixNQUFNQyxNQUFNLElBQUlDO1lBRWhCRCxJQUFJRSxNQUFNLEdBQUc7Z0JBQ1gsa0JBQWtCO2dCQUNsQlAsT0FBT1EsS0FBSyxHQUFHSCxJQUFJRyxLQUFLO2dCQUN4QlIsT0FBT1MsTUFBTSxHQUFHSixJQUFJSSxNQUFNO2dCQUUxQixJQUFJLENBQUNOLEtBQUs7b0JBQ1JKLE9BQU8sSUFBSUwsTUFBTTtvQkFDakI7Z0JBQ0Y7Z0JBRUEsc0JBQXNCO2dCQUN0QlMsSUFBSU8sU0FBUyxDQUFDTCxLQUFLLEdBQUc7Z0JBRXRCLGdDQUFnQztnQkFDaEMsTUFBTU0sWUFBWVIsSUFBSVMsWUFBWSxDQUFDLEdBQUcsR0FBR1osT0FB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b0JBRUEsc0NBQXNDO29CQUN0QyxJQUFJMEIsUUFBUSxDQUFDQSxLQUFLMUIsS0FBSyxDQUFDLDZEQUNwQjBCLEtBQUtwRSxNQUFNLEdBQUcsS0FBS29FLEtBQUtwRSxNQUFNLEdBQUcsTUFBTXFFLFFBQVEsS0FBS0EsUUFBUSxNQUFNO3dCQUVwRS9CLE1BQU1vQixJQUFJLENBQUM7NEJBQ1RVLE1BQU1BLEtBQUt2QixXQUFXOzRCQUN0QndCOzRCQUNBRjt3QkFDRjtvQkFDRjtvQkFDQTtnQkFDRjtZQUNGO1FBQ0Y7UUFFQSxPQUFPN0I7SUFDVDtJQUVBLE1BQU1pQyxVQUF5QjtRQUM3QixJQUFJLElBQUksQ0FBQy9GLE1BQU0sRUFBRTtZQUNmLE1BQU0sSUFBSSxDQUFDQSxNQUFNLENBQUNnRyxTQUFTO1lBQzNCLElBQUksQ0FBQ2hHLE1BQU0sR0FBRztZQUNkLElBQUksQ0FBQ0gsYUFBYSxHQUFHO1lBQ3JCQyxRQUFRQyxHQUFHLENBQUM7UUFDZDtJQUNGOzthQWhVUUMsU0FBa0M7YUFDbENILGdCQUFnQjs7QUFnVTFCO0FBRUEsNEJBQTRCO0FBQ3JCLE1BQU1vRyxhQUFhLElBQUl0RyxhQUFhIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXG5hdGhhXFxPbmVEcml2ZVxcRGVza3RvcFxcTW9uZXlRdWVzdFYzXFxwYWNrYWdlc1xcd2Vic2l0ZVxcc2VydmljZXNcXG9jclNlcnZpY2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlV29ya2VyIH0gZnJvbSAndGVzc2VyYWN0LmpzJztcblxuZXhwb3J0IGludGVyZmFjZSBPQ1JSZXN1bHQge1xuICB0ZXh0OiBzdHJpbmc7XG4gIGNvbmZpZGVuY2U6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQYXJzZWRSZWNlaXB0IHtcbiAgbWVyY2hhbnQ6IHN0cmluZztcbiAgYW1vdW50OiBudW1iZXI7XG4gIGRhdGU6IHN0cmluZztcbiAgaXRlbXM6IEFycmF5PHtcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgcHJpY2U6IG51bWJlcjtcbiAgICBxdWFudGl0eT86IG51bWJlcjtcbiAgfT47XG4gIHJhd1RleHQ6IHN0cmluZztcbiAgY29uZmlkZW5jZTogbnVtYmVyO1xufVxuXG5jbGFzcyBPQ1JTZXJ2aWNlIHtcbiAgcHJpdmF0ZSB3b3JrZXI6IFRlc3NlcmFjdC5Xb3JrZXIgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBpc0luaXRpYWxpemVkID0gZmFsc2U7XG5cbiAgYXN5bmMgaW5pdGlhbGl6ZSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAodGhpcy5pc0luaXRpYWxpemVkKSByZXR1cm47XG5cbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coJ/CflI0gSW5pdGlhbGl6aW5nIE9DUiBlbmdpbmUuLi4nKTtcbiAgICAgIHRoaXMud29ya2VyID0gYXdhaXQgY3JlYXRlV29ya2VyKCdlbmcnKTtcblxuICAgICAgLy8gQ29uZmlndXJlIFRlc3NlcmFjdCBmb3IgYmV0dGVyIHJlY2VpcHQgcmVhZGluZ1xuICAgICAgYXdhaXQgdGhpcy53b3JrZXIuc2V0UGFyYW1ldGVycyh7XG4gICAgICAgICd0ZXNzZWRpdF9jaGFyX3doaXRlbGlzdCc6ICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ei4sJC86LSMgJyxcbiAgICAgICAgJ3Rlc3NlZGl0X3BhZ2VzZWdfbW9kZSc6ICc2JywgLy8gU2luZ2xlIHVuaWZvcm0gYmxvY2sgb2YgdGV4dFxuICAgICAgICAncHJlc2VydmVfaW50ZXJ3b3JkX3NwYWNlcyc6ICcxJ1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuaXNJbml0aWFsaXplZCA9IHRydWU7XG4gICAgICBjb25zb2xlLmxvZygn4pyFIE9DUiBlbmdpbmUgaW5pdGlhbGl6ZWQgc3VjY2Vzc2Z1bGx5Jyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBGYWlsZWQgdG8gaW5pdGlhbGl6ZSBPQ1IgZW5naW5lOicsIGVycm9yKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGluaXRpYWxpemUgT0NSIGVuZ2luZScpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgcHJlcHJvY2Vzc0ltYWdlKGltYWdlRmlsZTogRmlsZSk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICBjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKTtcblxuICAgICAgaW1nLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgLy8gU2V0IGNhbnZhcyBzaXplXG4gICAgICAgIGNhbnZhcy53aWR0aCA9IGltZy53aWR0aDtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IGltZy5oZWlnaHQ7XG5cbiAgICAgICAgaWYgKCFjdHgpIHtcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdDb3VsZCBub3QgZ2V0IGNhbnZhcyBjb250ZXh0JykpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERyYXcgb3JpZ2luYWwgaW1hZ2VcbiAgICAgICAgY3R4LmRyYXdJbWFnZShpbWcsIDAsIDApO1xuXG4gICAgICAgIC8vIEdldCBpbWFnZSBkYXRhIGZvciBwcm9jZXNzaW5nXG4gICAgICAgIGNvbnN0IGltYWdlRGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgY29uc3QgZGF0YSA9IGltYWdlRGF0YS5kYXRhO1xuXG4gICAgICAgIC8vIENvbnZlcnQgdG8gZ3JheXNjYWxlIGFuZCBpbmNyZWFzZSBjb250cmFzdFxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpICs9IDQpIHtcbiAgICAgICAgICBjb25zdCBncmF5ID0gTWF0aC5yb3VuZCgwLjI5OSAqIGRhdGFbaV0gKyAwLjU4NyAqIGRhdGFbaSArIDFdICsgMC4xMTQgKiBkYXRhW2kgKyAyXSk7XG5cbiAgICAgICAgICAvLyBJbmNyZWFzZSBjb250cmFzdFxuICAgICAgICAgIGNvbnN0IGNvbnRyYXN0ID0gMS41O1xuICAgICAgICAgIGNvbnN0IGZhY3RvciA9ICgyNTkgKiAoY29udHJhc3QgKyAyNTUpKSAvICgyNTUgKiAoMjU5IC0gY29udHJhc3QpKTtcbiAgICAgICAgICBjb25zdCBlbmhhbmNlZCA9IE1hdGgubWluKDI1NSwgTWF0aC5tYXgoMCwgZmFjdG9yICogKGdyYXkgLSAxMjgpICsgMTI4KSk7XG5cbiAgICAgICAgICBkYXRhW2ldID0gZW5oYW5jZWQ7ICAgICAvLyBSZWRcbiAgICAgICAgICBkYXRhW2kgKyAxXSA9IGVuaGFuY2VkOyAvLyBHcmVlblxuICAgICAgICAgIGRhdGFbaSArIDJdID0gZW5oYW5jZWQ7IC8vIEJsdWVcbiAgICAgICAgICAvLyBBbHBoYSBzdGF5cyB0aGUgc2FtZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUHV0IHRoZSBwcm9jZXNzZWQgaW1hZ2UgZGF0YSBiYWNrXG4gICAgICAgIGN0eC5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCAwLCAwKTtcblxuICAgICAgICAvLyBDb252ZXJ0IHRvIGRhdGEgVVJMXG4gICAgICAgIHJlc29sdmUoY2FudmFzLnRvRGF0YVVSTCgnaW1hZ2UvcG5nJykpO1xuICAgICAgfTtcblxuICAgICAgaW1nLm9uZXJyb3IgPSAoKSA9PiByZWplY3QobmV3IEVycm9yKCdGYWlsZWQgdG8gbG9hZCBpbWFnZScpKTtcbiAgICAgIGltZy5zcmMgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGltYWdlRmlsZSk7XG4gICAgfSk7XG4gIH1cblxuICBhc3luYyBwcm9jZXNzUmVjZWlwdEltYWdlKGltYWdlRmlsZTogRmlsZSk6IFByb21pc2U8T0NSUmVzdWx0PiB7XG4gICAgaWYgKCF0aGlzLndvcmtlciB8fCAhdGhpcy5pc0luaXRpYWxpemVkKSB7XG4gICAgICBhd2FpdCB0aGlzLmluaXRpYWxpemUoKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coJ/Cfk4QgUHJlcHJvY2Vzc2luZyByZWNlaXB0IGltYWdlLi4uJyk7XG4gICAgICBjb25zdCBwcmVwcm9jZXNzZWRJbWFnZSA9IGF3YWl0IHRoaXMucHJlcHJvY2Vzc0ltYWdlKGltYWdlRmlsZSk7XG5cbiAgICAgIGNvbnNvbGUubG9nKCfwn5SNIFByb2Nlc3NpbmcgcmVjZWlwdCBpbWFnZSB3aXRoIE9DUi4uLicpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy53b3JrZXIhLnJlY29nbml6ZShwcmVwcm9jZXNzZWRJbWFnZSk7XG5cbiAgICAgIGNvbnNvbGUubG9nKCfinIUgT0NSIGNvbXBsZXRlZCcsIHtcbiAgICAgICAgY29uZmlkZW5jZTogcmVzdWx0LmRhdGEuY29uZmlkZW5jZSxcbiAgICAgICAgdGV4dExlbmd0aDogcmVzdWx0LmRhdGEudGV4dC5sZW5ndGgsXG4gICAgICAgIHJhd1RleHQ6IHJlc3VsdC5kYXRhLnRleHQuc3Vic3RyaW5nKDAsIDIwMCkgKyAnLi4uJ1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRleHQ6IHJlc3VsdC5kYXRhLnRleHQsXG4gICAgICAgIGNvbmZpZGVuY2U6IHJlc3VsdC5kYXRhLmNvbmZpZGVuY2VcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBPQ1IgcHJvY2Vzc2luZyBmYWlsZWQ6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gcHJvY2VzcyBpbWFnZSB3aXRoIE9DUicpO1xuICAgIH1cbiAgfVxuXG4gIHBhcnNlUmVjZWlwdFRleHQob2NyVGV4dDogc3RyaW5nLCBjb25maWRlbmNlOiBudW1iZXIpOiBQYXJzZWRSZWNlaXB0IHtcbiAgICBjb25zb2xlLmxvZygn8J+UjSBQYXJzaW5nIHJlY2VpcHQgdGV4dC4uLicpO1xuICAgIGNvbnNvbGUubG9nKCdSYXcgT0NSIHRleHQ6Jywgb2NyVGV4dCk7XG5cbiAgICBjb25zdCBsaW5lcyA9IG9jclRleHQuc3BsaXQoJ1xcbicpLm1hcChsaW5lID0+IGxpbmUudHJpbSgpKS5maWx0ZXIobGluZSA9PiBsaW5lLmxlbmd0aCA+IDApO1xuXG4gICAgLy8gRXh0cmFjdCBtZXJjaGFudCBuYW1lICh1c3VhbGx5IGZpcnN0IG9yIHNlY29uZCBsaW5lKVxuICAgIGNvbnN0IG1lcmNoYW50ID0gdGhpcy5leHRyYWN0TWVyY2hhbnQobGluZXMpO1xuXG4gICAgLy8gRXh0cmFjdCB0b3RhbCBhbW91bnRcbiAgICBjb25zdCBhbW91bnQgPSB0aGlzLmV4dHJhY3RUb3RhbEFtb3VudChsaW5lcyk7XG5cbiAgICAvLyBFeHRyYWN0IGRhdGVcbiAgICBjb25zdCBkYXRlID0gdGhpcy5leHRyYWN0RGF0ZShsaW5lcyk7XG5cbiAgICAvLyBFeHRyYWN0IGxpbmUgaXRlbXNcbiAgICBjb25zdCBpdGVtcyA9IHRoaXMuZXh0cmFjdEl0ZW1zKGxpbmVzKTtcblxuICAgIGNvbnN0IHBhcnNlZDogUGFyc2VkUmVjZWlwdCA9IHtcbiAgICAgIG1lcmNoYW50LFxuICAgICAgYW1vdW50LFxuICAgICAgZGF0ZSxcbiAgICAgIGl0ZW1zLFxuICAgICAgcmF3VGV4dDogb2NyVGV4dCxcbiAgICAgIGNvbmZpZGVuY2U6IE1hdGgubWF4KGNvbmZpZGVuY2UgKiAwLjgsIDYwKSAvLyBBZGp1c3QgY29uZmlkZW5jZSBmb3IgcGFyc2luZyB1bmNlcnRhaW50eVxuICAgIH07XG5cbiAgICBjb25zb2xlLmxvZygn4pyFIFJlY2VpcHQgcGFyc2VkIHN1Y2Nlc3NmdWxseTonLCBwYXJzZWQpO1xuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cblxuICBwcml2YXRlIGV4dHJhY3RNZXJjaGFudChsaW5lczogc3RyaW5nW10pOiBzdHJpbmcge1xuICAgIC8vIENvbW1vbiBtZXJjaGFudCBwYXR0ZXJucyB0byBsb29rIGZvclxuICAgIGNvbnN0IG1lcmNoYW50UGF0dGVybnMgPSBbXG4gICAgICAvXihbQS1aYS16XFxzJicuLV17Myw0MH0pJC8sXG4gICAgICAvXihbQS1aXFxzJicuLV17Myw0MH0pXFxzK1NUT1JFLyxcbiAgICAgIC9eKFtBLVpcXHMmJy4tXXszLDQwfSlcXHMrTUFSS0VULyxcbiAgICAgIC9eKFtBLVpcXHMmJy4tXXszLDQwfSlcXHMrSU5DL1xuICAgIF07XG5cbiAgICAvLyBMb29rIGZvciBtZXJjaGFudCBuYW1lIGluIGZpcnN0IDcgbGluZXNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE1hdGgubWluKDcsIGxpbmVzLmxlbmd0aCk7IGkrKykge1xuICAgICAgY29uc3QgbGluZSA9IGxpbmVzW2ldLnRyaW0oKTtcblxuICAgICAgLy8gU2tpcCBvYnZpb3VzbHkgbm9uLW1lcmNoYW50IGxpbmVzXG4gICAgICBpZiAobGluZS5tYXRjaCgvXlxcZCsvKSB8fCBsaW5lLmluY2x1ZGVzKCdSRUNFSVBUJykgfHwgbGluZS5pbmNsdWRlcygnSU5WT0lDRScpIHx8XG4gICAgICAgICAgbGluZS5pbmNsdWRlcygnIycpIHx8IGxpbmUuaW5jbHVkZXMoJ1RFTCcpIHx8IGxpbmUuaW5jbHVkZXMoJ1dXVycpIHx8XG4gICAgICAgICAgbGluZS5pbmNsdWRlcygnQCcpIHx8IGxpbmUuaW5jbHVkZXMoJy5DT00nKSB8fCBsaW5lLmluY2x1ZGVzKCdTVFJFRVQnKSB8fFxuICAgICAgICAgIGxpbmUuaW5jbHVkZXMoJ0FWRScpIHx8IGxpbmUuaW5jbHVkZXMoJ0JMVkQnKSB8fCBsaW5lLmluY2x1ZGVzKCdSRCcpIHx8XG4gICAgICAgICAgbGluZS5sZW5ndGggPCAzIHx8IGxpbmUubGVuZ3RoID4gNTApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIFRyeSBtZXJjaGFudCBwYXR0ZXJuc1xuICAgICAgZm9yIChjb25zdCBwYXR0ZXJuIG9mIG1lcmNoYW50UGF0dGVybnMpIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBsaW5lLm1hdGNoKHBhdHRlcm4pO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICByZXR1cm4gbWF0Y2hbMV0udHJpbSgpLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gSWYgbm8gcGF0dGVybiBtYXRjaGVzIGJ1dCBsaW5lIGxvb2tzIGxpa2UgbWVyY2hhbnQgbmFtZVxuICAgICAgaWYgKGxpbmUubWF0Y2goL15bQS1aYS16XFxzJicuLV0rJC8pICYmIGxpbmUubGVuZ3RoID49IDMgJiYgbGluZS5sZW5ndGggPD0gNDApIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgaXQncyBub3QgYSBjb21tb24gbm9uLW1lcmNoYW50IHdvcmRcbiAgICAgICAgY29uc3Qgbm9uTWVyY2hhbnRXb3JkcyA9IFsnVEhBTksnLCAnWU9VJywgJ1ZJU0lUJywgJ0FHQUlOJywgJ0NVU1RPTUVSJywgJ0NPUFknXTtcbiAgICAgICAgaWYgKCFub25NZXJjaGFudFdvcmRzLnNvbWUod29yZCA9PiBsaW5lLmluY2x1ZGVzKHdvcmQpKSkge1xuICAgICAgICAgIHJldHVybiBsaW5lLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gJ1VOS05PV04gTUVSQ0hBTlQnO1xuICB9XG5cbiAgcHJpdmF0ZSBleHRyYWN0VG90YWxBbW91bnQobGluZXM6IHN0cmluZ1tdKTogbnVtYmVyIHtcbiAgICAvLyBFbmhhbmNlZCB0b3RhbCBhbW91bnQgcGF0dGVybnNcbiAgICBjb25zdCB0b3RhbFBhdHRlcm5zID0gW1xuICAgICAgL1RPVEFMLio/WyRdPyhcXGQrXFwuP1xcZHsyfSkvaSxcbiAgICAgIC9BTU9VTlRcXHMrRFVFLio/WyRdPyhcXGQrXFwuP1xcZHsyfSkvaSxcbiAgICAgIC9CQUxBTkNFLio/WyRdPyhcXGQrXFwuP1xcZHsyfSkvaSxcbiAgICAgIC9HUkFORFxccytUT1RBTC4qP1skXT8oXFxkK1xcLj9cXGR7Mn0pL2ksXG4gICAgICAvRklOQUxcXHMrVE9UQUwuKj9bJF0/KFxcZCtcXC4/XFxkezJ9KS9pLFxuICAgICAgL1skXShcXGQrXFwuXFxkezJ9KVxccyokLywgLy8gTGluZSBlbmRpbmcgd2l0aCBjdXJyZW5jeSBhbW91bnRcbiAgICAgIC8oXFxkK1xcLlxcZHsyfSlcXHMqVE9UQUwvaSxcbiAgICAgIC9UT1RBTFxccytbJF0/KFxcZCtcXC5cXGR7Mn0pL2ksXG4gICAgICAvWyRdXFxzKihcXGQrXFwuXFxkezJ9KVxccypUT1RBTC9pXG4gICAgXTtcblxuICAgIGNvbnNvbGUubG9nKCfwn5SNIExvb2tpbmcgZm9yIHRvdGFsIGFtb3VudCBpbiBsaW5lczonLCBsaW5lcy5zbGljZSgtMTApKTtcblxuICAgIC8vIFNlYXJjaCBmcm9tIGJvdHRvbSB1cCBhcyB0b3RhbHMgYXJlIHVzdWFsbHkgYXQgdGhlIGVuZFxuICAgIGZvciAobGV0IGkgPSBsaW5lcy5sZW5ndGggLSAxOyBpID49IE1hdGgubWF4KDAsIGxpbmVzLmxlbmd0aCAtIDE1KTsgaS0tKSB7XG4gICAgICBjb25zdCBsaW5lID0gbGluZXNbaV0udHJpbSgpO1xuXG4gICAgICBpZiAobGluZS5sZW5ndGggPT09IDApIGNvbnRpbnVlO1xuXG4gICAgICBjb25zb2xlLmxvZyhgQ2hlY2tpbmcgbGluZSAke2l9OiBcIiR7bGluZX1cImApO1xuXG4gICAgICBmb3IgKGNvbnN0IHBhdHRlcm4gb2YgdG90YWxQYXR0ZXJucykge1xuICAgICAgICBjb25zdCBtYXRjaCA9IGxpbmUubWF0Y2gocGF0dGVybik7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgIGNvbnN0IGFtb3VudCA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBGb3VuZCBwb3RlbnRpYWwgdG90YWw6ICR7YW1vdW50fSBmcm9tIHBhdHRlcm46ICR7cGF0dGVybn1gKTtcbiAgICAgICAgICBpZiAoIWlzTmFOKGFtb3VudCkgJiYgYW1vdW50ID4gMCAmJiBhbW91bnQgPCAxMDAwMCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYOKchSBVc2luZyB0b3RhbCBhbW91bnQ6ICR7YW1vdW50fWApO1xuICAgICAgICAgICAgcmV0dXJuIGFtb3VudDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZygn4pqg77iPIE5vIGNsZWFyIHRvdGFsIGZvdW5kLCBsb29raW5nIGZvciBsYXJnZXN0IGFtb3VudCcpO1xuXG4gICAgLy8gSWYgbm8gY2xlYXIgdG90YWwgZm91bmQsIGxvb2sgZm9yIGxhcmdlc3QgcmVhc29uYWJsZSBhbW91bnRcbiAgICBjb25zdCBhbW91bnRzOiBudW1iZXJbXSA9IFtdO1xuICAgIGxpbmVzLmZvckVhY2goKGxpbmUsIGluZGV4KSA9PiB7XG4gICAgICAvLyBMb29rIGZvciBtb25leSBhbW91bnRzOiAkWC5YWCBvciBYLlhYXG4gICAgICBjb25zdCBtYXRjaGVzID0gbGluZS5tYXRjaCgvWyRdPyhcXGQrXFwuXFxkezJ9KS9nKSB8fCBbXTtcbiAgICAgIG1hdGNoZXMuZm9yRWFjaChtYXRjaCA9PiB7XG4gICAgICAgIGNvbnN0IGFtb3VudCA9IHBhcnNlRmxvYXQobWF0Y2gucmVwbGFjZSgnJCcsICcnKSk7XG4gICAgICAgIGlmICghaXNOYU4oYW1vdW50KSAmJiBhbW91bnQgPiAwICYmIGFtb3VudCA8IDEwMDAwKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYEZvdW5kIGFtb3VudCAke2Ftb3VudH0gb24gbGluZSAke2luZGV4fTogXCIke2xpbmV9XCJgKTtcbiAgICAgICAgICBhbW91bnRzLnB1c2goYW1vdW50KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBjb25zdCBtYXhBbW91bnQgPSBhbW91bnRzLmxlbmd0aCA+IDAgPyBNYXRoLm1heCguLi5hbW91bnRzKSA6IDA7XG4gICAgY29uc29sZS5sb2coYFVzaW5nIGxhcmdlc3QgYW1vdW50IGZvdW5kOiAke21heEFtb3VudH1gKTtcbiAgICByZXR1cm4gbWF4QW1vdW50O1xuICB9XG5cbiAgcHJpdmF0ZSBleHRyYWN0RGF0ZShsaW5lczogc3RyaW5nW10pOiBzdHJpbmcge1xuICAgIGNvbnN0IGRhdGVQYXR0ZXJucyA9IFtcbiAgICAgIC8oXFxkezEsMn1cXC9cXGR7MSwyfVxcL1xcZHsyLDR9KS8sXG4gICAgICAvKFxcZHsxLDJ9LVxcZHsxLDJ9LVxcZHsyLDR9KS8sXG4gICAgICAvKFxcZHs0fS1cXGR7Mn0tXFxkezJ9KS8sXG4gICAgICAvKEphbnxGZWJ8TWFyfEFwcnxNYXl8SnVufEp1bHxBdWd8U2VwfE9jdHxOb3Z8RGVjKS4qPyhcXGR7MSwyfSksP1xccyooXFxkezR9KS9pXG4gICAgXTtcblxuICAgIGZvciAoY29uc3QgbGluZSBvZiBsaW5lcykge1xuICAgICAgZm9yIChjb25zdCBwYXR0ZXJuIG9mIGRhdGVQYXR0ZXJucykge1xuICAgICAgICBjb25zdCBtYXRjaCA9IGxpbmUubWF0Y2gocGF0dGVybik7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBUcnkgdG8gcGFyc2UgYW5kIG5vcm1hbGl6ZSB0aGUgZGF0ZVxuICAgICAgICAgICAgY29uc3QgZGF0ZVN0ciA9IG1hdGNoWzBdO1xuICAgICAgICAgICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKGRhdGVTdHIpO1xuICAgICAgICAgICAgaWYgKCFpc05hTihkYXRlLmdldFRpbWUoKSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGRhdGUudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdOyAvLyBSZXR1cm4gWVlZWS1NTS1ERCBmb3JtYXRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEZWZhdWx0IHRvIHRvZGF5IGlmIG5vIGRhdGUgZm91bmRcbiAgICByZXR1cm4gbmV3IERhdGUoKS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF07XG4gIH1cblxuICBwcml2YXRlIGV4dHJhY3RJdGVtcyhsaW5lczogc3RyaW5nW10pOiBBcnJheTx7IG5hbWU6IHN0cmluZzsgcHJpY2U6IG51bWJlcjsgcXVhbnRpdHk/OiBudW1iZXIgfT4ge1xuICAgIGNvbnN0IGl0ZW1zOiBBcnJheTx7IG5hbWU6IHN0cmluZzsgcHJpY2U6IG51bWJlcjsgcXVhbnRpdHk/OiBudW1iZXIgfT4gPSBbXTtcblxuICAgIGZvciAoY29uc3QgbGluZSBvZiBsaW5lcykge1xuICAgICAgLy8gTG9vayBmb3IgbGluZXMgd2l0aCBpdGVtIG5hbWUgYW5kIHByaWNlXG4gICAgICAvLyBQYXR0ZXJuOiBcIklURU0gTkFNRSAgICAkWC5YWFwiIG9yIFwiUVRZIElURU0gTkFNRSAkWC5YWFwiXG4gICAgICBjb25zdCBpdGVtUGF0dGVybnMgPSBbXG4gICAgICAgIC9eKFxcZCspXFxzKyguKz8pXFxzK1xcJD8oXFxkK1xcLlxcZHsyfSkkLywgIC8vIFwiMiBCQU5BTkFTICQzLjk5XCJcbiAgICAgICAgL14oLis/KVxccytcXCQ/KFxcZCtcXC5cXGR7Mn0pJC8sICAgICAgICAgICAvLyBcIkJBTkFOQVMgJDMuOTlcIlxuICAgICAgICAvXiguKz8pXFxzKyhcXGQrXFwuXFxkezJ9KVxccyokLyAgICAgICAgICAgIC8vIFwiQkFOQU5BUyAzLjk5XCJcbiAgICAgIF07XG5cbiAgICAgIGZvciAoY29uc3QgcGF0dGVybiBvZiBpdGVtUGF0dGVybnMpIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBsaW5lLm1hdGNoKHBhdHRlcm4pO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICBsZXQgcXVhbnRpdHk6IG51bWJlciB8IHVuZGVmaW5lZDtcbiAgICAgICAgICBsZXQgbmFtZTogc3RyaW5nO1xuICAgICAgICAgIGxldCBwcmljZTogbnVtYmVyO1xuXG4gICAgICAgICAgaWYgKG1hdGNoLmxlbmd0aCA9PT0gNCkge1xuICAgICAgICAgICAgLy8gUGF0dGVybiB3aXRoIHF1YW50aXR5XG4gICAgICAgICAgICBxdWFudGl0eSA9IHBhcnNlSW50KG1hdGNoWzFdKTtcbiAgICAgICAgICAgIG5hbWUgPSBtYXRjaFsyXS50cmltKCk7XG4gICAgICAgICAgICBwcmljZSA9IHBhcnNlRmxvYXQobWF0Y2hbM10pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBQYXR0ZXJuIHdpdGhvdXQgcXVhbnRpdHlcbiAgICAgICAgICAgIG5hbWUgPSBtYXRjaFsxXS50cmltKCk7XG4gICAgICAgICAgICBwcmljZSA9IHBhcnNlRmxvYXQobWF0Y2hbMl0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEZpbHRlciBvdXQgb2J2aW91c2x5IG5vbi1pdGVtIGxpbmVzXG4gICAgICAgICAgaWYgKG5hbWUgJiYgIW5hbWUubWF0Y2goL1RPVEFMfFRBWHxTVUJUT1RBTHxDSEFOR0V8QkFMQU5DRXxSRUNFSVBUfFNUT1JFfFRIQU5LL2kpICYmXG4gICAgICAgICAgICAgIG5hbWUubGVuZ3RoID4gMiAmJiBuYW1lLmxlbmd0aCA8IDUwICYmIHByaWNlID4gMCAmJiBwcmljZSA8IDEwMDApIHtcblxuICAgICAgICAgICAgaXRlbXMucHVzaCh7XG4gICAgICAgICAgICAgIG5hbWU6IG5hbWUudG9VcHBlckNhc2UoKSxcbiAgICAgICAgICAgICAgcHJpY2UsXG4gICAgICAgICAgICAgIHF1YW50aXR5XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaXRlbXM7XG4gIH1cblxuICBhc3luYyBjbGVhbnVwKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICh0aGlzLndvcmtlcikge1xuICAgICAgYXdhaXQgdGhpcy53b3JrZXIudGVybWluYXRlKCk7XG4gICAgICB0aGlzLndvcmtlciA9IG51bGw7XG4gICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgIGNvbnNvbGUubG9nKCfwn6e5IE9DUiBlbmdpbmUgY2xlYW5lZCB1cCcpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBFeHBvcnQgc2luZ2xldG9uIGluc3RhbmNlXG5leHBvcnQgY29uc3Qgb2NyU2VydmljZSA9IG5ldyBPQ1JTZXJ2aWNlKCk7Il0sIm5hbWVzIjpbImNyZWF0ZVdvcmtlciIsIk9DUlNlcnZpY2UiLCJpbml0aWFsaXplIiwiaXNJbml0aWFsaXplZCIsImNvbnNvbGUiLCJsb2ciLCJ3b3JrZXIiLCJzZXRQYXJhbWV0ZXJzIiwiZXJyb3IiLCJFcnJvciIsInByZXByb2Nlc3NJbWFnZSIsImltYWdlRmlsZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiY2FudmFzIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiY3R4IiwiZ2V0Q29udGV4dCIsImltZyIsIkltYWdlIiwib25sb2FkIiwid2lkdGgiLCJoZWlnaHQiLCJkcmF3SW1hZ2UiLCJpbWFnZURhdGEiLCJnZXRJbWFnZURhdGEiLCJkYXRhIiwiaSIsImxlbmd0aCIsImdyYXkiLCJNYXRoIiwicm91bmQiLCJjb250cmFzdCIsImZhY3RvciIsImVuaGFuY2VkIiwibWluIiwibWF4IiwicHV0SW1hZ2VEYXRhIiwidG9EYXRhVVJMIiwib25lcnJvciIsInNyYyIsIlVSTCIsImNyZWF0ZU9iamVjdFVSTCIsInByb2Nlc3NSZWNlaXB0SW1hZ2UiLCJwcmVwcm9jZXNzZWRJbWFnZSIsInJlc3VsdCIsInJlY29nbml6ZSIsImNvbmZpZGVuY2UiLCJ0ZXh0TGVuZ3RoIiwidGV4dCIsInJhd1RleHQiLCJzdWJzdHJpbmciLCJwYXJzZVJlY2VpcHRUZXh0Iiwib2NyVGV4dCIsImxpbmVzIiwic3BsaXQiLCJtYXAiLCJsaW5lIiwidHJpbSIsImZpbHRlciIsIm1lcmNoYW50IiwiZXh0cmFjdE1lcmNoYW50IiwiYW1vdW50IiwiZXh0cmFjdFRvdGFsQW1vdW50IiwiZGF0ZSIsImV4dHJhY3REYXRlIiwiaXRlbXMiLCJleHRyYWN0SXRlbXMiLCJwYXJzZWQiLCJtZXJjaGFudFBhdHRlcm5zIiwibWF0Y2giLCJpbmNsdWRlcyIsInBhdHRlcm4iLCJ0b1VwcGVyQ2FzZSIsIm5vbk1lcmNoYW50V29yZHMiLCJzb21lIiwid29yZCIsInRvdGFsUGF0dGVybnMiLCJzbGljZSIsInBhcnNlRmxvYXQiLCJpc05hTiIsImFtb3VudHMiLCJmb3JFYWNoIiwiaW5kZXgiLCJtYXRjaGVzIiwicmVwbGFjZSIsInB1c2giLCJtYXhBbW91bnQiLCJkYXRlUGF0dGVybnMiLCJkYXRlU3RyIiwiRGF0ZSIsImdldFRpbWUiLCJ0b0lTT1N0cmluZyIsImUiLCJpdGVtUGF0dGVybnMiLCJxdWFudGl0eSIsIm5hbWUiLCJwcmljZSIsInBhcnNlSW50IiwiY2xlYW51cCIsInRlcm1pbmF0ZSIsIm9jclNlcnZpY2UiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./services/ocrService.ts\n"));

/***/ })

});