"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/receipts/page",{

/***/ "(app-pages-browser)/./services/ocrService.ts":
/*!********************************!*\
  !*** ./services/ocrService.ts ***!
  \********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ocrService: () => (/* binding */ ocrService)\n/* harmony export */ });\n/* harmony import */ var tesseract_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tesseract.js */ \"(app-pages-browser)/../../node_modules/tesseract.js/src/index.js\");\n/* harmony import */ var tesseract_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(tesseract_js__WEBPACK_IMPORTED_MODULE_0__);\n\nclass OCRService {\n    async initialize() {\n        if (this.isInitialized) return;\n        try {\n            console.log('ðŸ” Initializing OCR engine...');\n            this.worker = await (0,tesseract_js__WEBPACK_IMPORTED_MODULE_0__.createWorker)('eng');\n            // Configure Tesseract for better receipt reading\n            await this.worker.setParameters({\n                'tessedit_char_whitelist': '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz.,$/:-# ',\n                'tessedit_pageseg_mode': '6',\n                'preserve_interword_spaces': '1'\n            });\n            this.isInitialized = true;\n            console.log('âœ… OCR engine initialized successfully');\n        } catch (error) {\n            console.error('âŒ Failed to initialize OCR engine:', error);\n            throw new Error('Failed to initialize OCR engine');\n        }\n    }\n    async preprocessImage(imageFile) {\n        return new Promise((resolve, reject)=>{\n            const canvas = document.createElement('canvas');\n            const ctx = canvas.getContext('2d');\n            const img = new Image();\n            img.onload = ()=>{\n                // Set canvas size\n                canvas.width = img.width;\n                canvas.height = img.height;\n                if (!ctx) {\n                    reject(new Error('Could not get canvas context'));\n                    return;\n                }\n                // Draw original image\n                ctx.drawImage(img, 0, 0);\n                // Get image data for processing\n                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n                const data = imageData.data;\n                // Convert to grayscale and increase contrast\n                for(let i = 0; i < data.length; i += 4){\n                    const gray = Math.round(0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2]);\n                    // Increase contrast\n                    const contrast = 1.5;\n                    const factor = 259 * (contrast + 255) / (255 * (259 - contrast));\n                    const enhanced = Math.min(255, Math.max(0, factor * (gray - 128) + 128));\n                    data[i] = enhanced; // Red\n                    data[i + 1] = enhanced; // Green\n                    data[i + 2] = enhanced; // Blue\n                // Alpha stays the same\n                }\n                // Put the processed image data back\n                ctx.putImageData(imageData, 0, 0);\n                // Convert to data URL\n                resolve(canvas.toDataURL('image/png'));\n            };\n            img.onerror = ()=>reject(new Error('Failed to load image'));\n            img.src = URL.createObjectURL(imageFile);\n        });\n    }\n    async processReceiptImage(imageFile) {\n        if (!this.worker || !this.isInitialized) {\n            await this.initialize();\n        }\n        try {\n            console.log('ðŸ“„ Preprocessing receipt image...');\n            const preprocessedImage = await this.preprocessImage(imageFile);\n            console.log('ðŸ” Processing receipt image with OCR...');\n            const result = await this.worker.recognize(preprocessedImage);\n            console.log('âœ… OCR completed', {\n                confidence: result.data.confidence,\n                textLength: result.data.text.length,\n                rawText: result.data.text.substring(0, 200) + '...'\n            });\n            return {\n                text: result.data.text,\n                confidence: result.data.confidence\n            };\n        } catch (error) {\n            console.error('âŒ OCR processing failed:', error);\n            throw new Error('Failed to process image with OCR');\n        }\n    }\n    parseReceiptText(ocrText, confidence) {\n        console.log('ðŸ” Parsing receipt text...');\n        console.log('Raw OCR text:', ocrText);\n        const lines = ocrText.split('\\n').map((line)=>line.trim()).filter((line)=>line.length > 0);\n        // Extract merchant name (usually first or second line)\n        const merchant = this.extractMerchant(lines);\n        // Extract total amount\n        const amount = this.extractTotalAmount(lines);\n        // Extract date\n        const date = this.extractDate(lines);\n        // Extract line items\n        const items = this.extractItems(lines);\n        const parsed = {\n            merchant,\n            amount,\n            date,\n            items,\n            rawText: ocrText,\n            confidence: Math.max(confidence * 0.8, 60) // Adjust confidence for parsing uncertainty\n        };\n        console.log('âœ… Receipt parsed successfully:', parsed);\n        return parsed;\n    }\n    extractMerchant(lines) {\n        // Look for merchant name in first few lines\n        for(let i = 0; i < Math.min(5, lines.length); i++){\n            const line = lines[i];\n            // Skip lines that are clearly addresses, phone numbers, or receipt info\n            if (line.match(/^\\d+/) || line.includes('RECEIPT') || line.includes('STORE') || line.includes('#') || line.includes('TEL') || line.includes('WWW')) {\n                continue;\n            }\n            // Look for lines with actual merchant names (letters, possibly with spaces)\n            if (line.match(/^[A-Za-z\\s&'.-]+$/) && line.length > 3 && line.length < 50) {\n                return line.toUpperCase();\n            }\n        }\n        return 'UNKNOWN MERCHANT';\n    }\n    extractTotalAmount(lines) {\n        // Look for total amount patterns\n        const totalPatterns = [\n            /TOTAL.*?\\$?(\\d+\\.?\\d*)/i,\n            /AMOUNT.*?\\$?(\\d+\\.?\\d*)/i,\n            /BALANCE.*?\\$?(\\d+\\.?\\d*)/i,\n            /\\$(\\d+\\.\\d{2})\\s*$/,\n            /(\\d+\\.\\d{2})\\s*TOTAL/i\n        ];\n        // Search from bottom up as totals are usually at the end\n        for(let i = lines.length - 1; i >= 0; i--){\n            const line = lines[i];\n            for (const pattern of totalPatterns){\n                const match = line.match(pattern);\n                if (match) {\n                    const amount = parseFloat(match[1]);\n                    if (!isNaN(amount) && amount > 0 && amount < 10000) {\n                        return amount;\n                    }\n                }\n            }\n        }\n        // If no clear total found, look for largest reasonable amount\n        const amounts = [];\n        lines.forEach((line)=>{\n            const matches = line.match(/\\$?(\\d+\\.\\d{2})/g) || [];\n            matches.forEach((match)=>{\n                const amount = parseFloat(match.replace('$', ''));\n                if (!isNaN(amount) && amount > 0 && amount < 10000) {\n                    amounts.push(amount);\n                }\n            });\n        });\n        return amounts.length > 0 ? Math.max(...amounts) : 0;\n    }\n    extractDate(lines) {\n        const datePatterns = [\n            /(\\d{1,2}\\/\\d{1,2}\\/\\d{2,4})/,\n            /(\\d{1,2}-\\d{1,2}-\\d{2,4})/,\n            /(\\d{4}-\\d{2}-\\d{2})/,\n            /(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec).*?(\\d{1,2}),?\\s*(\\d{4})/i\n        ];\n        for (const line of lines){\n            for (const pattern of datePatterns){\n                const match = line.match(pattern);\n                if (match) {\n                    try {\n                        // Try to parse and normalize the date\n                        const dateStr = match[0];\n                        const date = new Date(dateStr);\n                        if (!isNaN(date.getTime())) {\n                            return date.toISOString().split('T')[0]; // Return YYYY-MM-DD format\n                        }\n                    } catch (e) {\n                        continue;\n                    }\n                }\n            }\n        }\n        // Default to today if no date found\n        return new Date().toISOString().split('T')[0];\n    }\n    extractItems(lines) {\n        const items = [];\n        for (const line of lines){\n            // Look for lines with item name and price\n            // Pattern: \"ITEM NAME    $X.XX\" or \"QTY ITEM NAME $X.XX\"\n            const itemPatterns = [\n                /^(\\d+)\\s+(.+?)\\s+\\$?(\\d+\\.\\d{2})$/,\n                /^(.+?)\\s+\\$?(\\d+\\.\\d{2})$/,\n                /^(.+?)\\s+(\\d+\\.\\d{2})\\s*$/ // \"BANANAS 3.99\"\n            ];\n            for (const pattern of itemPatterns){\n                const match = line.match(pattern);\n                if (match) {\n                    let quantity;\n                    let name;\n                    let price;\n                    if (match.length === 4) {\n                        // Pattern with quantity\n                        quantity = parseInt(match[1]);\n                        name = match[2].trim();\n                        price = parseFloat(match[3]);\n                    } else {\n                        // Pattern without quantity\n                        name = match[1].trim();\n                        price = parseFloat(match[2]);\n                    }\n                    // Filter out obviously non-item lines\n                    if (name && !name.match(/TOTAL|TAX|SUBTOTAL|CHANGE|BALANCE|RECEIPT|STORE|THANK/i) && name.length > 2 && name.length < 50 && price > 0 && price < 1000) {\n                        items.push({\n                            name: name.toUpperCase(),\n                            price,\n                            quantity\n                        });\n                    }\n                    break;\n                }\n            }\n        }\n        return items;\n    }\n    async cleanup() {\n        if (this.worker) {\n            await this.worker.terminate();\n            this.worker = null;\n            this.isInitialized = false;\n            console.log('ðŸ§¹ OCR engine cleaned up');\n        }\n    }\n    constructor(){\n        this.worker = null;\n        this.isInitialized = false;\n    }\n}\n// Export singleton instance\nconst ocrService = new OCRService();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NlcnZpY2VzL29jclNlcnZpY2UudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTRDO0FBb0I1QyxNQUFNQztJQUlKLE1BQU1DLGFBQTRCO1FBQ2hDLElBQUksSUFBSSxDQUFDQyxhQUFhLEVBQUU7UUFFeEIsSUFBSTtZQUNGQyxRQUFRQyxHQUFHLENBQUM7WUFDWixJQUFJLENBQUNDLE1BQU0sR0FBRyxNQUFNTiwwREFBWUEsQ0FBQztZQUVqQyxpREFBaUQ7WUFDakQsTUFBTSxJQUFJLENBQUNNLE1BQU0sQ0FBQ0MsYUFBYSxDQUFDO2dCQUM5QiwyQkFBMkI7Z0JBQzNCLHlCQUF5QjtnQkFDekIsNkJBQTZCO1lBQy9CO1lBRUEsSUFBSSxDQUFDSixhQUFhLEdBQUc7WUFDckJDLFFBQVFDLEdBQUcsQ0FBQztRQUNkLEVBQUUsT0FBT0csT0FBTztZQUNkSixRQUFRSSxLQUFLLENBQUMsc0NBQXNDQTtZQUNwRCxNQUFNLElBQUlDLE1BQU07UUFDbEI7SUFDRjtJQUVBLE1BQWNDLGdCQUFnQkMsU0FBZSxFQUFtQjtRQUM5RCxPQUFPLElBQUlDLFFBQVEsQ0FBQ0MsU0FBU0M7WUFDM0IsTUFBTUMsU0FBU0MsU0FBU0MsYUFBYSxDQUFDO1lBQ3RDLE1BQU1DLE1BQU1ILE9BQU9JLFVBQVUsQ0FBQztZQUM5QixNQUFNQyxNQUFNLElBQUlDO1lBRWhCRCxJQUFJRSxNQUFNLEdBQUc7Z0JBQ1gsa0JBQWtCO2dCQUNsQlAsT0FBT1EsS0FBSyxHQUFHSCxJQUFJRyxLQUFLO2dCQUN4QlIsT0FBT1MsTUFBTSxHQUFHSixJQUFJSSxNQUFNO2dCQUUxQixJQUFJLENBQUNOLEtBQUs7b0JBQ1JKLE9BQU8sSUFBSUwsTUFBTTtvQkFDakI7Z0JBQ0Y7Z0JBRUEsc0JBQXNCO2dCQUN0QlMsSUFBSU8sU0FBUyxDQUFDTCxLQUFLLEdBQUc7Z0JBRXRCLGdDQUFnQztnQkFDaEMsTUFBTU0sWUFBWVIsSUFBSVMsWUFBWSxDQUFDLEdBQUcsR0FBR1osT0FB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Vzs0QkFDdEJtQjs0QkFDQUY7d0JBQ0Y7b0JBQ0Y7b0JBQ0E7Z0JBQ0Y7WUFDRjtRQUNGO1FBRUEsT0FBT3RCO0lBQ1Q7SUFFQSxNQUFNMEIsVUFBeUI7UUFDN0IsSUFBSSxJQUFJLENBQUN4RixNQUFNLEVBQUU7WUFDZixNQUFNLElBQUksQ0FBQ0EsTUFBTSxDQUFDeUYsU0FBUztZQUMzQixJQUFJLENBQUN6RixNQUFNLEdBQUc7WUFDZCxJQUFJLENBQUNILGFBQWEsR0FBRztZQUNyQkMsUUFBUUMsR0FBRyxDQUFDO1FBQ2Q7SUFDRjs7YUFwUlFDLFNBQWtDO2FBQ2xDSCxnQkFBZ0I7O0FBb1IxQjtBQUVBLDRCQUE0QjtBQUNyQixNQUFNNkYsYUFBYSxJQUFJL0YsYUFBYSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxuYXRoYVxcT25lRHJpdmVcXERlc2t0b3BcXE1vbmV5UXVlc3RWM1xccGFja2FnZXNcXHdlYnNpdGVcXHNlcnZpY2VzXFxvY3JTZXJ2aWNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZVdvcmtlciB9IGZyb20gJ3Rlc3NlcmFjdC5qcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgT0NSUmVzdWx0IHtcbiAgdGV4dDogc3RyaW5nO1xuICBjb25maWRlbmNlOiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGFyc2VkUmVjZWlwdCB7XG4gIG1lcmNoYW50OiBzdHJpbmc7XG4gIGFtb3VudDogbnVtYmVyO1xuICBkYXRlOiBzdHJpbmc7XG4gIGl0ZW1zOiBBcnJheTx7XG4gICAgbmFtZTogc3RyaW5nO1xuICAgIHByaWNlOiBudW1iZXI7XG4gICAgcXVhbnRpdHk/OiBudW1iZXI7XG4gIH0+O1xuICByYXdUZXh0OiBzdHJpbmc7XG4gIGNvbmZpZGVuY2U6IG51bWJlcjtcbn1cblxuY2xhc3MgT0NSU2VydmljZSB7XG4gIHByaXZhdGUgd29ya2VyOiBUZXNzZXJhY3QuV29ya2VyIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgaXNJbml0aWFsaXplZCA9IGZhbHNlO1xuXG4gIGFzeW5jIGluaXRpYWxpemUoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKHRoaXMuaXNJbml0aWFsaXplZCkgcmV0dXJuO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKCfwn5SNIEluaXRpYWxpemluZyBPQ1IgZW5naW5lLi4uJyk7XG4gICAgICB0aGlzLndvcmtlciA9IGF3YWl0IGNyZWF0ZVdvcmtlcignZW5nJyk7XG5cbiAgICAgIC8vIENvbmZpZ3VyZSBUZXNzZXJhY3QgZm9yIGJldHRlciByZWNlaXB0IHJlYWRpbmdcbiAgICAgIGF3YWl0IHRoaXMud29ya2VyLnNldFBhcmFtZXRlcnMoe1xuICAgICAgICAndGVzc2VkaXRfY2hhcl93aGl0ZWxpc3QnOiAnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXouLCQvOi0jICcsXG4gICAgICAgICd0ZXNzZWRpdF9wYWdlc2VnX21vZGUnOiAnNicsIC8vIFNpbmdsZSB1bmlmb3JtIGJsb2NrIG9mIHRleHRcbiAgICAgICAgJ3ByZXNlcnZlX2ludGVyd29yZF9zcGFjZXMnOiAnMSdcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgY29uc29sZS5sb2coJ+KchSBPQ1IgZW5naW5lIGluaXRpYWxpemVkIHN1Y2Nlc3NmdWxseScpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgRmFpbGVkIHRvIGluaXRpYWxpemUgT0NSIGVuZ2luZTonLCBlcnJvcik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBpbml0aWFsaXplIE9DUiBlbmdpbmUnKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIHByZXByb2Nlc3NJbWFnZShpbWFnZUZpbGU6IEZpbGUpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgY29uc3QgaW1nID0gbmV3IEltYWdlKCk7XG5cbiAgICAgIGltZy5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgIC8vIFNldCBjYW52YXMgc2l6ZVxuICAgICAgICBjYW52YXMud2lkdGggPSBpbWcud2lkdGg7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBpbWcuaGVpZ2h0O1xuXG4gICAgICAgIGlmICghY3R4KSB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignQ291bGQgbm90IGdldCBjYW52YXMgY29udGV4dCcpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEcmF3IG9yaWdpbmFsIGltYWdlXG4gICAgICAgIGN0eC5kcmF3SW1hZ2UoaW1nLCAwLCAwKTtcblxuICAgICAgICAvLyBHZXQgaW1hZ2UgZGF0YSBmb3IgcHJvY2Vzc2luZ1xuICAgICAgICBjb25zdCBpbWFnZURhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBpbWFnZURhdGEuZGF0YTtcblxuICAgICAgICAvLyBDb252ZXJ0IHRvIGdyYXlzY2FsZSBhbmQgaW5jcmVhc2UgY29udHJhc3RcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSArPSA0KSB7XG4gICAgICAgICAgY29uc3QgZ3JheSA9IE1hdGgucm91bmQoMC4yOTkgKiBkYXRhW2ldICsgMC41ODcgKiBkYXRhW2kgKyAxXSArIDAuMTE0ICogZGF0YVtpICsgMl0pO1xuXG4gICAgICAgICAgLy8gSW5jcmVhc2UgY29udHJhc3RcbiAgICAgICAgICBjb25zdCBjb250cmFzdCA9IDEuNTtcbiAgICAgICAgICBjb25zdCBmYWN0b3IgPSAoMjU5ICogKGNvbnRyYXN0ICsgMjU1KSkgLyAoMjU1ICogKDI1OSAtIGNvbnRyYXN0KSk7XG4gICAgICAgICAgY29uc3QgZW5oYW5jZWQgPSBNYXRoLm1pbigyNTUsIE1hdGgubWF4KDAsIGZhY3RvciAqIChncmF5IC0gMTI4KSArIDEyOCkpO1xuXG4gICAgICAgICAgZGF0YVtpXSA9IGVuaGFuY2VkOyAgICAgLy8gUmVkXG4gICAgICAgICAgZGF0YVtpICsgMV0gPSBlbmhhbmNlZDsgLy8gR3JlZW5cbiAgICAgICAgICBkYXRhW2kgKyAyXSA9IGVuaGFuY2VkOyAvLyBCbHVlXG4gICAgICAgICAgLy8gQWxwaGEgc3RheXMgdGhlIHNhbWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFB1dCB0aGUgcHJvY2Vzc2VkIGltYWdlIGRhdGEgYmFja1xuICAgICAgICBjdHgucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSwgMCwgMCk7XG5cbiAgICAgICAgLy8gQ29udmVydCB0byBkYXRhIFVSTFxuICAgICAgICByZXNvbHZlKGNhbnZhcy50b0RhdGFVUkwoJ2ltYWdlL3BuZycpKTtcbiAgICAgIH07XG5cbiAgICAgIGltZy5vbmVycm9yID0gKCkgPT4gcmVqZWN0KG5ldyBFcnJvcignRmFpbGVkIHRvIGxvYWQgaW1hZ2UnKSk7XG4gICAgICBpbWcuc3JjID0gVVJMLmNyZWF0ZU9iamVjdFVSTChpbWFnZUZpbGUpO1xuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgcHJvY2Vzc1JlY2VpcHRJbWFnZShpbWFnZUZpbGU6IEZpbGUpOiBQcm9taXNlPE9DUlJlc3VsdD4ge1xuICAgIGlmICghdGhpcy53b3JrZXIgfHwgIXRoaXMuaXNJbml0aWFsaXplZCkge1xuICAgICAgYXdhaXQgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKCfwn5OEIFByZXByb2Nlc3NpbmcgcmVjZWlwdCBpbWFnZS4uLicpO1xuICAgICAgY29uc3QgcHJlcHJvY2Vzc2VkSW1hZ2UgPSBhd2FpdCB0aGlzLnByZXByb2Nlc3NJbWFnZShpbWFnZUZpbGUpO1xuXG4gICAgICBjb25zb2xlLmxvZygn8J+UjSBQcm9jZXNzaW5nIHJlY2VpcHQgaW1hZ2Ugd2l0aCBPQ1IuLi4nKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMud29ya2VyIS5yZWNvZ25pemUocHJlcHJvY2Vzc2VkSW1hZ2UpO1xuXG4gICAgICBjb25zb2xlLmxvZygn4pyFIE9DUiBjb21wbGV0ZWQnLCB7XG4gICAgICAgIGNvbmZpZGVuY2U6IHJlc3VsdC5kYXRhLmNvbmZpZGVuY2UsXG4gICAgICAgIHRleHRMZW5ndGg6IHJlc3VsdC5kYXRhLnRleHQubGVuZ3RoLFxuICAgICAgICByYXdUZXh0OiByZXN1bHQuZGF0YS50ZXh0LnN1YnN0cmluZygwLCAyMDApICsgJy4uLidcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0ZXh0OiByZXN1bHQuZGF0YS50ZXh0LFxuICAgICAgICBjb25maWRlbmNlOiByZXN1bHQuZGF0YS5jb25maWRlbmNlXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgT0NSIHByb2Nlc3NpbmcgZmFpbGVkOicsIGVycm9yKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHByb2Nlc3MgaW1hZ2Ugd2l0aCBPQ1InKTtcbiAgICB9XG4gIH1cblxuICBwYXJzZVJlY2VpcHRUZXh0KG9jclRleHQ6IHN0cmluZywgY29uZmlkZW5jZTogbnVtYmVyKTogUGFyc2VkUmVjZWlwdCB7XG4gICAgY29uc29sZS5sb2coJ/CflI0gUGFyc2luZyByZWNlaXB0IHRleHQuLi4nKTtcbiAgICBjb25zb2xlLmxvZygnUmF3IE9DUiB0ZXh0OicsIG9jclRleHQpO1xuXG4gICAgY29uc3QgbGluZXMgPSBvY3JUZXh0LnNwbGl0KCdcXG4nKS5tYXAobGluZSA9PiBsaW5lLnRyaW0oKSkuZmlsdGVyKGxpbmUgPT4gbGluZS5sZW5ndGggPiAwKTtcblxuICAgIC8vIEV4dHJhY3QgbWVyY2hhbnQgbmFtZSAodXN1YWxseSBmaXJzdCBvciBzZWNvbmQgbGluZSlcbiAgICBjb25zdCBtZXJjaGFudCA9IHRoaXMuZXh0cmFjdE1lcmNoYW50KGxpbmVzKTtcblxuICAgIC8vIEV4dHJhY3QgdG90YWwgYW1vdW50XG4gICAgY29uc3QgYW1vdW50ID0gdGhpcy5leHRyYWN0VG90YWxBbW91bnQobGluZXMpO1xuXG4gICAgLy8gRXh0cmFjdCBkYXRlXG4gICAgY29uc3QgZGF0ZSA9IHRoaXMuZXh0cmFjdERhdGUobGluZXMpO1xuXG4gICAgLy8gRXh0cmFjdCBsaW5lIGl0ZW1zXG4gICAgY29uc3QgaXRlbXMgPSB0aGlzLmV4dHJhY3RJdGVtcyhsaW5lcyk7XG5cbiAgICBjb25zdCBwYXJzZWQ6IFBhcnNlZFJlY2VpcHQgPSB7XG4gICAgICBtZXJjaGFudCxcbiAgICAgIGFtb3VudCxcbiAgICAgIGRhdGUsXG4gICAgICBpdGVtcyxcbiAgICAgIHJhd1RleHQ6IG9jclRleHQsXG4gICAgICBjb25maWRlbmNlOiBNYXRoLm1heChjb25maWRlbmNlICogMC44LCA2MCkgLy8gQWRqdXN0IGNvbmZpZGVuY2UgZm9yIHBhcnNpbmcgdW5jZXJ0YWludHlcbiAgICB9O1xuXG4gICAgY29uc29sZS5sb2coJ+KchSBSZWNlaXB0IHBhcnNlZCBzdWNjZXNzZnVsbHk6JywgcGFyc2VkKTtcbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG5cbiAgcHJpdmF0ZSBleHRyYWN0TWVyY2hhbnQobGluZXM6IHN0cmluZ1tdKTogc3RyaW5nIHtcbiAgICAvLyBMb29rIGZvciBtZXJjaGFudCBuYW1lIGluIGZpcnN0IGZldyBsaW5lc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTWF0aC5taW4oNSwgbGluZXMubGVuZ3RoKTsgaSsrKSB7XG4gICAgICBjb25zdCBsaW5lID0gbGluZXNbaV07XG4gICAgICAvLyBTa2lwIGxpbmVzIHRoYXQgYXJlIGNsZWFybHkgYWRkcmVzc2VzLCBwaG9uZSBudW1iZXJzLCBvciByZWNlaXB0IGluZm9cbiAgICAgIGlmIChsaW5lLm1hdGNoKC9eXFxkKy8pIHx8IGxpbmUuaW5jbHVkZXMoJ1JFQ0VJUFQnKSB8fCBsaW5lLmluY2x1ZGVzKCdTVE9SRScpIHx8XG4gICAgICAgICAgbGluZS5pbmNsdWRlcygnIycpIHx8IGxpbmUuaW5jbHVkZXMoJ1RFTCcpIHx8IGxpbmUuaW5jbHVkZXMoJ1dXVycpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgLy8gTG9vayBmb3IgbGluZXMgd2l0aCBhY3R1YWwgbWVyY2hhbnQgbmFtZXMgKGxldHRlcnMsIHBvc3NpYmx5IHdpdGggc3BhY2VzKVxuICAgICAgaWYgKGxpbmUubWF0Y2goL15bQS1aYS16XFxzJicuLV0rJC8pICYmIGxpbmUubGVuZ3RoID4gMyAmJiBsaW5lLmxlbmd0aCA8IDUwKSB7XG4gICAgICAgIHJldHVybiBsaW5lLnRvVXBwZXJDYXNlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAnVU5LTk9XTiBNRVJDSEFOVCc7XG4gIH1cblxuICBwcml2YXRlIGV4dHJhY3RUb3RhbEFtb3VudChsaW5lczogc3RyaW5nW10pOiBudW1iZXIge1xuICAgIC8vIExvb2sgZm9yIHRvdGFsIGFtb3VudCBwYXR0ZXJuc1xuICAgIGNvbnN0IHRvdGFsUGF0dGVybnMgPSBbXG4gICAgICAvVE9UQUwuKj9cXCQ/KFxcZCtcXC4/XFxkKikvaSxcbiAgICAgIC9BTU9VTlQuKj9cXCQ/KFxcZCtcXC4/XFxkKikvaSxcbiAgICAgIC9CQUxBTkNFLio/XFwkPyhcXGQrXFwuP1xcZCopL2ksXG4gICAgICAvXFwkKFxcZCtcXC5cXGR7Mn0pXFxzKiQvLCAvLyBMaW5lIGVuZGluZyB3aXRoIGN1cnJlbmN5IGFtb3VudFxuICAgICAgLyhcXGQrXFwuXFxkezJ9KVxccypUT1RBTC9pXG4gICAgXTtcblxuICAgIC8vIFNlYXJjaCBmcm9tIGJvdHRvbSB1cCBhcyB0b3RhbHMgYXJlIHVzdWFsbHkgYXQgdGhlIGVuZFxuICAgIGZvciAobGV0IGkgPSBsaW5lcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgY29uc3QgbGluZSA9IGxpbmVzW2ldO1xuXG4gICAgICBmb3IgKGNvbnN0IHBhdHRlcm4gb2YgdG90YWxQYXR0ZXJucykge1xuICAgICAgICBjb25zdCBtYXRjaCA9IGxpbmUubWF0Y2gocGF0dGVybik7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgIGNvbnN0IGFtb3VudCA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICAgICAgICAgIGlmICghaXNOYU4oYW1vdW50KSAmJiBhbW91bnQgPiAwICYmIGFtb3VudCA8IDEwMDAwKSB7IC8vIFJlYXNvbmFibGUgYm91bmRzXG4gICAgICAgICAgICByZXR1cm4gYW1vdW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIG5vIGNsZWFyIHRvdGFsIGZvdW5kLCBsb29rIGZvciBsYXJnZXN0IHJlYXNvbmFibGUgYW1vdW50XG4gICAgY29uc3QgYW1vdW50czogbnVtYmVyW10gPSBbXTtcbiAgICBsaW5lcy5mb3JFYWNoKGxpbmUgPT4ge1xuICAgICAgY29uc3QgbWF0Y2hlcyA9IGxpbmUubWF0Y2goL1xcJD8oXFxkK1xcLlxcZHsyfSkvZykgfHwgW107XG4gICAgICBtYXRjaGVzLmZvckVhY2gobWF0Y2ggPT4ge1xuICAgICAgICBjb25zdCBhbW91bnQgPSBwYXJzZUZsb2F0KG1hdGNoLnJlcGxhY2UoJyQnLCAnJykpO1xuICAgICAgICBpZiAoIWlzTmFOKGFtb3VudCkgJiYgYW1vdW50ID4gMCAmJiBhbW91bnQgPCAxMDAwMCkge1xuICAgICAgICAgIGFtb3VudHMucHVzaChhbW91bnQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHJldHVybiBhbW91bnRzLmxlbmd0aCA+IDAgPyBNYXRoLm1heCguLi5hbW91bnRzKSA6IDA7XG4gIH1cblxuICBwcml2YXRlIGV4dHJhY3REYXRlKGxpbmVzOiBzdHJpbmdbXSk6IHN0cmluZyB7XG4gICAgY29uc3QgZGF0ZVBhdHRlcm5zID0gW1xuICAgICAgLyhcXGR7MSwyfVxcL1xcZHsxLDJ9XFwvXFxkezIsNH0pLyxcbiAgICAgIC8oXFxkezEsMn0tXFxkezEsMn0tXFxkezIsNH0pLyxcbiAgICAgIC8oXFxkezR9LVxcZHsyfS1cXGR7Mn0pLyxcbiAgICAgIC8oSmFufEZlYnxNYXJ8QXByfE1heXxKdW58SnVsfEF1Z3xTZXB8T2N0fE5vdnxEZWMpLio/KFxcZHsxLDJ9KSw/XFxzKihcXGR7NH0pL2lcbiAgICBdO1xuXG4gICAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgICBmb3IgKGNvbnN0IHBhdHRlcm4gb2YgZGF0ZVBhdHRlcm5zKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gbGluZS5tYXRjaChwYXR0ZXJuKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFRyeSB0byBwYXJzZSBhbmQgbm9ybWFsaXplIHRoZSBkYXRlXG4gICAgICAgICAgICBjb25zdCBkYXRlU3RyID0gbWF0Y2hbMF07XG4gICAgICAgICAgICBjb25zdCBkYXRlID0gbmV3IERhdGUoZGF0ZVN0cik7XG4gICAgICAgICAgICBpZiAoIWlzTmFOKGRhdGUuZ2V0VGltZSgpKSkge1xuICAgICAgICAgICAgICByZXR1cm4gZGF0ZS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF07IC8vIFJldHVybiBZWVlZLU1NLUREIGZvcm1hdFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIERlZmF1bHQgdG8gdG9kYXkgaWYgbm8gZGF0ZSBmb3VuZFxuICAgIHJldHVybiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXTtcbiAgfVxuXG4gIHByaXZhdGUgZXh0cmFjdEl0ZW1zKGxpbmVzOiBzdHJpbmdbXSk6IEFycmF5PHsgbmFtZTogc3RyaW5nOyBwcmljZTogbnVtYmVyOyBxdWFudGl0eT86IG51bWJlciB9PiB7XG4gICAgY29uc3QgaXRlbXM6IEFycmF5PHsgbmFtZTogc3RyaW5nOyBwcmljZTogbnVtYmVyOyBxdWFudGl0eT86IG51bWJlciB9PiA9IFtdO1xuXG4gICAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgICAvLyBMb29rIGZvciBsaW5lcyB3aXRoIGl0ZW0gbmFtZSBhbmQgcHJpY2VcbiAgICAgIC8vIFBhdHRlcm46IFwiSVRFTSBOQU1FICAgICRYLlhYXCIgb3IgXCJRVFkgSVRFTSBOQU1FICRYLlhYXCJcbiAgICAgIGNvbnN0IGl0ZW1QYXR0ZXJucyA9IFtcbiAgICAgICAgL14oXFxkKylcXHMrKC4rPylcXHMrXFwkPyhcXGQrXFwuXFxkezJ9KSQvLCAgLy8gXCIyIEJBTkFOQVMgJDMuOTlcIlxuICAgICAgICAvXiguKz8pXFxzK1xcJD8oXFxkK1xcLlxcZHsyfSkkLywgICAgICAgICAgIC8vIFwiQkFOQU5BUyAkMy45OVwiXG4gICAgICAgIC9eKC4rPylcXHMrKFxcZCtcXC5cXGR7Mn0pXFxzKiQvICAgICAgICAgICAgLy8gXCJCQU5BTkFTIDMuOTlcIlxuICAgICAgXTtcblxuICAgICAgZm9yIChjb25zdCBwYXR0ZXJuIG9mIGl0ZW1QYXR0ZXJucykge1xuICAgICAgICBjb25zdCBtYXRjaCA9IGxpbmUubWF0Y2gocGF0dGVybik7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgIGxldCBxdWFudGl0eTogbnVtYmVyIHwgdW5kZWZpbmVkO1xuICAgICAgICAgIGxldCBuYW1lOiBzdHJpbmc7XG4gICAgICAgICAgbGV0IHByaWNlOiBudW1iZXI7XG5cbiAgICAgICAgICBpZiAobWF0Y2gubGVuZ3RoID09PSA0KSB7XG4gICAgICAgICAgICAvLyBQYXR0ZXJuIHdpdGggcXVhbnRpdHlcbiAgICAgICAgICAgIHF1YW50aXR5ID0gcGFyc2VJbnQobWF0Y2hbMV0pO1xuICAgICAgICAgICAgbmFtZSA9IG1hdGNoWzJdLnRyaW0oKTtcbiAgICAgICAgICAgIHByaWNlID0gcGFyc2VGbG9hdChtYXRjaFszXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFBhdHRlcm4gd2l0aG91dCBxdWFudGl0eVxuICAgICAgICAgICAgbmFtZSA9IG1hdGNoWzFdLnRyaW0oKTtcbiAgICAgICAgICAgIHByaWNlID0gcGFyc2VGbG9hdChtYXRjaFsyXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gRmlsdGVyIG91dCBvYnZpb3VzbHkgbm9uLWl0ZW0gbGluZXNcbiAgICAgICAgICBpZiAobmFtZSAmJiAhbmFtZS5tYXRjaCgvVE9UQUx8VEFYfFNVQlRPVEFMfENIQU5HRXxCQUxBTkNFfFJFQ0VJUFR8U1RPUkV8VEhBTksvaSkgJiZcbiAgICAgICAgICAgICAgbmFtZS5sZW5ndGggPiAyICYmIG5hbWUubGVuZ3RoIDwgNTAgJiYgcHJpY2UgPiAwICYmIHByaWNlIDwgMTAwMCkge1xuXG4gICAgICAgICAgICBpdGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgbmFtZTogbmFtZS50b1VwcGVyQ2FzZSgpLFxuICAgICAgICAgICAgICBwcmljZSxcbiAgICAgICAgICAgICAgcXVhbnRpdHlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpdGVtcztcbiAgfVxuXG4gIGFzeW5jIGNsZWFudXAoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKHRoaXMud29ya2VyKSB7XG4gICAgICBhd2FpdCB0aGlzLndvcmtlci50ZXJtaW5hdGUoKTtcbiAgICAgIHRoaXMud29ya2VyID0gbnVsbDtcbiAgICAgIHRoaXMuaXNJbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgY29uc29sZS5sb2coJ/Cfp7kgT0NSIGVuZ2luZSBjbGVhbmVkIHVwJyk7XG4gICAgfVxuICB9XG59XG5cbi8vIEV4cG9ydCBzaW5nbGV0b24gaW5zdGFuY2VcbmV4cG9ydCBjb25zdCBvY3JTZXJ2aWNlID0gbmV3IE9DUlNlcnZpY2UoKTsiXSwibmFtZXMiOlsiY3JlYXRlV29ya2VyIiwiT0NSU2VydmljZSIsImluaXRpYWxpemUiLCJpc0luaXRpYWxpemVkIiwiY29uc29sZSIsImxvZyIsIndvcmtlciIsInNldFBhcmFtZXRlcnMiLCJlcnJvciIsIkVycm9yIiwicHJlcHJvY2Vzc0ltYWdlIiwiaW1hZ2VGaWxlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJjYW52YXMiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJjdHgiLCJnZXRDb250ZXh0IiwiaW1nIiwiSW1hZ2UiLCJvbmxvYWQiLCJ3aWR0aCIsImhlaWdodCIsImRyYXdJbWFnZSIsImltYWdlRGF0YSIsImdldEltYWdlRGF0YSIsImRhdGEiLCJpIiwibGVuZ3RoIiwiZ3JheSIsIk1hdGgiLCJyb3VuZCIsImNvbnRyYXN0IiwiZmFjdG9yIiwiZW5oYW5jZWQiLCJtaW4iLCJtYXgiLCJwdXRJbWFnZURhdGEiLCJ0b0RhdGFVUkwiLCJvbmVycm9yIiwic3JjIiwiVVJMIiwiY3JlYXRlT2JqZWN0VVJMIiwicHJvY2Vzc1JlY2VpcHRJbWFnZSIsInByZXByb2Nlc3NlZEltYWdlIiwicmVzdWx0IiwicmVjb2duaXplIiwiY29uZmlkZW5jZSIsInRleHRMZW5ndGgiLCJ0ZXh0IiwicmF3VGV4dCIsInN1YnN0cmluZyIsInBhcnNlUmVjZWlwdFRleHQiLCJvY3JUZXh0IiwibGluZXMiLCJzcGxpdCIsIm1hcCIsImxpbmUiLCJ0cmltIiwiZmlsdGVyIiwibWVyY2hhbnQiLCJleHRyYWN0TWVyY2hhbnQiLCJhbW91bnQiLCJleHRyYWN0VG90YWxBbW91bnQiLCJkYXRlIiwiZXh0cmFjdERhdGUiLCJpdGVtcyIsImV4dHJhY3RJdGVtcyIsInBhcnNlZCIsIm1hdGNoIiwiaW5jbHVkZXMiLCJ0b1VwcGVyQ2FzZSIsInRvdGFsUGF0dGVybnMiLCJwYXR0ZXJuIiwicGFyc2VGbG9hdCIsImlzTmFOIiwiYW1vdW50cyIsImZvckVhY2giLCJtYXRjaGVzIiwicmVwbGFjZSIsInB1c2giLCJkYXRlUGF0dGVybnMiLCJkYXRlU3RyIiwiRGF0ZSIsImdldFRpbWUiLCJ0b0lTT1N0cmluZyIsImUiLCJpdGVtUGF0dGVybnMiLCJxdWFudGl0eSIsIm5hbWUiLCJwcmljZSIsInBhcnNlSW50IiwiY2xlYW51cCIsInRlcm1pbmF0ZSIsIm9jclNlcnZpY2UiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./services/ocrService.ts\n"));

/***/ })

});