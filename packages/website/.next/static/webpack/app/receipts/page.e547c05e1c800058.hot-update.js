"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/receipts/page",{

/***/ "(app-pages-browser)/./services/ocrService.ts":
/*!********************************!*\
  !*** ./services/ocrService.ts ***!
  \********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ocrService: () => (/* binding */ ocrService)\n/* harmony export */ });\n/* harmony import */ var tesseract_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tesseract.js */ \"(app-pages-browser)/../../node_modules/tesseract.js/src/index.js\");\n/* harmony import */ var tesseract_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(tesseract_js__WEBPACK_IMPORTED_MODULE_0__);\n\nclass OCRService {\n    async initialize() {\n        if (this.isInitialized) return;\n        try {\n            console.log('🔍 Initializing OCR engine...');\n            this.worker = await (0,tesseract_js__WEBPACK_IMPORTED_MODULE_0__.createWorker)('eng');\n            // Configure Tesseract for better receipt reading with more characters\n            await this.worker.setParameters({\n                'tessedit_char_whitelist': '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz.,$/:-#%*()&@+ ',\n                'tessedit_pageseg_mode': '4',\n                'preserve_interword_spaces': '1',\n                'tessedit_create_hocr': '1',\n                'textord_min_linesize': '1.25',\n                'textord_tabfind_find_tables': '1',\n                'textord_tablefind_good_width': '3',\n                'textord_tabfind_show_vlines': '1' // Show vertical lines for debugging\n            });\n            this.isInitialized = true;\n            console.log('✅ OCR engine initialized successfully');\n        } catch (error) {\n            console.error('❌ Failed to initialize OCR engine:', error);\n            throw new Error('Failed to initialize OCR engine');\n        }\n    }\n    async preprocessImage(imageFile) {\n        return new Promise((resolve, reject)=>{\n            const canvas = document.createElement('canvas');\n            const ctx = canvas.getContext('2d');\n            const img = new Image();\n            img.onload = ()=>{\n                // Set canvas size\n                canvas.width = img.width;\n                canvas.height = img.height;\n                if (!ctx) {\n                    reject(new Error('Could not get canvas context'));\n                    return;\n                }\n                // Draw original image\n                ctx.drawImage(img, 0, 0);\n                // Get image data for processing\n                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n                const data = imageData.data;\n                // Convert to grayscale and increase contrast\n                for(let i = 0; i < data.length; i += 4){\n                    const gray = Math.round(0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2]);\n                    // Increase contrast\n                    const contrast = 1.5;\n                    const factor = 259 * (contrast + 255) / (255 * (259 - contrast));\n                    const enhanced = Math.min(255, Math.max(0, factor * (gray - 128) + 128));\n                    data[i] = enhanced; // Red\n                    data[i + 1] = enhanced; // Green\n                    data[i + 2] = enhanced; // Blue\n                // Alpha stays the same\n                }\n                // Put the processed image data back\n                ctx.putImageData(imageData, 0, 0);\n                // Convert to data URL\n                resolve(canvas.toDataURL('image/png'));\n            };\n            img.onerror = ()=>reject(new Error('Failed to load image'));\n            img.src = URL.createObjectURL(imageFile);\n        });\n    }\n    reconstructAlignedText(ocrData) {\n        if (!ocrData.lines || ocrData.lines.length === 0) {\n            return ocrData.text || '';\n        }\n        console.log('🔧 Reconstructing aligned text from', ocrData.lines.length, 'lines');\n        const lines = [];\n        for (const line of ocrData.lines){\n            if (!line.words || line.words.length === 0) continue;\n            // Sort words by x position (left to right)\n            const sortedWords = [\n                ...line.words\n            ].sort((a, b)=>a.bbox.x0 - b.bbox.x0);\n            let lineText = '';\n            let lastX = 0;\n            for(let i = 0; i < sortedWords.length; i++){\n                const word = sortedWords[i];\n                const wordText = word.text.trim();\n                if (wordText.length === 0) continue;\n                // Calculate spacing needed based on x-position\n                const currentX = word.bbox.x0;\n                const wordWidth = word.bbox.x1 - word.bbox.x0;\n                if (i > 0) {\n                    // Calculate gap between this word and previous word\n                    const gap = currentX - lastX;\n                    const avgCharWidth = 10; // Approximate character width\n                    const spacesNeeded = Math.max(1, Math.floor(gap / avgCharWidth));\n                    // Add appropriate spacing (but cap it to prevent excessive spacing)\n                    lineText += ' '.repeat(Math.min(spacesNeeded, 20));\n                }\n                lineText += wordText;\n                lastX = word.bbox.x1;\n            }\n            if (lineText.trim().length > 0) {\n                lines.push(lineText);\n            }\n        }\n        const reconstructedText = lines.join('\\n');\n        console.log('✅ Reconstructed text with alignment:', reconstructedText.substring(0, 200) + '...');\n        return reconstructedText;\n    }\n    async processReceiptImage(imageFile) {\n        if (!this.worker || !this.isInitialized) {\n            await this.initialize();\n        }\n        try {\n            var _result_data_words;\n            console.log('📄 Preprocessing receipt image...');\n            const preprocessedImage = await this.preprocessImage(imageFile);\n            console.log('🔍 Processing receipt image with OCR...');\n            const result = await this.worker.recognize(preprocessedImage);\n            console.log('✅ OCR completed', {\n                confidence: result.data.confidence,\n                textLength: result.data.text.length,\n                wordsFound: ((_result_data_words = result.data.words) === null || _result_data_words === void 0 ? void 0 : _result_data_words.length) || 0\n            });\n            // Reconstruct text with better alignment using word positions\n            const alignedText = this.reconstructAlignedText(result.data);\n            return {\n                text: alignedText,\n                confidence: result.data.confidence\n            };\n        } catch (error) {\n            console.error('❌ OCR processing failed:', error);\n            throw new Error('Failed to process image with OCR');\n        }\n    }\n    parseReceiptText(ocrText, confidence) {\n        console.log('🔍 Parsing receipt text...');\n        console.log('Raw OCR text:', ocrText);\n        const lines = ocrText.split('\\n').map((line)=>line.trim()).filter((line)=>line.length > 0);\n        // Extract merchant name (usually first or second line)\n        const merchant = this.extractMerchant(lines);\n        // Extract line items FIRST (including tax)\n        const items = this.extractItems(lines);\n        // Extract total amount using the new rule\n        const amount = this.extractValidatedTotal(lines, items);\n        // Extract date\n        const date = this.extractDate(lines);\n        const parsed = {\n            merchant,\n            amount,\n            date,\n            items,\n            rawText: ocrText,\n            confidence: Math.max(confidence * 0.8, 60) // Adjust confidence for parsing uncertainty\n        };\n        console.log('✅ Receipt parsed successfully:', parsed);\n        return parsed;\n    }\n    extractMerchant(lines) {\n        // Common merchant patterns to look for\n        const merchantPatterns = [\n            /^([A-Za-z\\s&'.-]{3,40})$/,\n            /^([A-Z\\s&'.-]{3,40})\\s+STORE/,\n            /^([A-Z\\s&'.-]{3,40})\\s+MARKET/,\n            /^([A-Z\\s&'.-]{3,40})\\s+INC/\n        ];\n        // Look for merchant name in first 7 lines\n        for(let i = 0; i < Math.min(7, lines.length); i++){\n            const line = lines[i].trim();\n            // Skip obviously non-merchant lines\n            if (line.match(/^\\d+/) || line.includes('RECEIPT') || line.includes('INVOICE') || line.includes('#') || line.includes('TEL') || line.includes('WWW') || line.includes('@') || line.includes('.COM') || line.includes('STREET') || line.includes('AVE') || line.includes('BLVD') || line.includes('RD') || line.length < 3 || line.length > 50) {\n                continue;\n            }\n            // Try merchant patterns\n            for (const pattern of merchantPatterns){\n                const match = line.match(pattern);\n                if (match) {\n                    return match[1].trim().toUpperCase();\n                }\n            }\n            // If no pattern matches but line looks like merchant name\n            if (line.match(/^[A-Za-z\\s&'.-]+$/) && line.length >= 3 && line.length <= 40) {\n                // Check if it's not a common non-merchant word\n                const nonMerchantWords = [\n                    'THANK',\n                    'YOU',\n                    'VISIT',\n                    'AGAIN',\n                    'CUSTOMER',\n                    'COPY'\n                ];\n                if (!nonMerchantWords.some((word)=>line.includes(word))) {\n                    return line.toUpperCase();\n                }\n            }\n        }\n        return 'UNKNOWN MERCHANT';\n    }\n    extractValidatedTotal(lines, items) {\n        console.log('🔍 Looking for total that matches item sum...');\n        // Calculate expected total from items\n        const itemsTotal = items.reduce((sum, item)=>sum + item.price, 0);\n        console.log(\"Items sum to: $\".concat(itemsTotal.toFixed(2)));\n        // Look specifically for \"Total\" followed by dollar amount\n        const totalPatterns = [\n            /TOTAL\\s+[$]?(\\d+\\.\\d{2})/i,\n            /TOTAL\\s*:\\s*[$]?(\\d+\\.\\d{2})/i,\n            /TOTAL.*?[$](\\d+\\.\\d{2})/i\n        ];\n        const foundTotals = [];\n        // Find all potential totals\n        for(let i = 0; i < lines.length; i++){\n            const line = lines[i].trim();\n            for (const pattern of totalPatterns){\n                const match = line.match(pattern);\n                if (match) {\n                    const amount = parseFloat(match[1]);\n                    if (!isNaN(amount) && amount > 0) {\n                        foundTotals.push({\n                            amount,\n                            line\n                        });\n                        console.log(\"Found potential total: $\".concat(amount, ' in \"').concat(line, '\"'));\n                    }\n                }\n            }\n        }\n        // If we have items, try to match total to items sum\n        if (itemsTotal > 0 && foundTotals.length > 0) {\n            console.log('Validating totals against items sum...');\n            for (const total of foundTotals){\n                const difference = Math.abs(total.amount - itemsTotal);\n                console.log(\"Total $\".concat(total.amount, \" vs Items $\").concat(itemsTotal.toFixed(2), \" - difference: $\").concat(difference.toFixed(2)));\n                // Allow small rounding differences (±$0.05)\n                if (difference <= 0.05) {\n                    console.log(\"✅ Found matching total: $\".concat(total.amount));\n                    return total.amount;\n                }\n            }\n            // If no exact match, look for closest total that's reasonable\n            const sortedByCloseness = foundTotals.sort((a, b)=>Math.abs(a.amount - itemsTotal) - Math.abs(b.amount - itemsTotal));\n            const closest = sortedByCloseness[0];\n            if (closest && Math.abs(closest.amount - itemsTotal) <= itemsTotal * 0.1) {\n                console.log(\"⚠️ Using closest total: $\".concat(closest.amount, \" (\").concat(Math.abs(closest.amount - itemsTotal).toFixed(2), \" difference)\"));\n                return closest.amount;\n            }\n        }\n        // Fallback: use any \"Total\" we found\n        if (foundTotals.length > 0) {\n            console.log(\"⚠️ Using first total found: $\".concat(foundTotals[0].amount));\n            return foundTotals[0].amount;\n        }\n        // Final fallback: use items sum if we have items\n        if (itemsTotal > 0) {\n            console.log(\"⚠️ No total found, using items sum: $\".concat(itemsTotal.toFixed(2)));\n            return itemsTotal;\n        }\n        // Last resort: use old method\n        console.log('⚠️ Falling back to old total extraction method');\n        return this.extractTotalAmount(lines);\n    }\n    extractTotalAmount(lines) {\n        // Enhanced total amount patterns\n        const totalPatterns = [\n            /TOTAL.*?[$]?(\\d+\\.?\\d{2})/i,\n            /AMOUNT\\s+DUE.*?[$]?(\\d+\\.?\\d{2})/i,\n            /BALANCE.*?[$]?(\\d+\\.?\\d{2})/i,\n            /GRAND\\s+TOTAL.*?[$]?(\\d+\\.?\\d{2})/i,\n            /FINAL\\s+TOTAL.*?[$]?(\\d+\\.?\\d{2})/i,\n            /[$](\\d+\\.\\d{2})\\s*$/,\n            /(\\d+\\.\\d{2})\\s*TOTAL/i,\n            /TOTAL\\s+[$]?(\\d+\\.\\d{2})/i,\n            /[$]\\s*(\\d+\\.\\d{2})\\s*TOTAL/i\n        ];\n        console.log('🔍 Looking for total amount in lines:', lines.slice(-10));\n        // Search from bottom up as totals are usually at the end\n        for(let i = lines.length - 1; i >= Math.max(0, lines.length - 15); i--){\n            const line = lines[i].trim();\n            if (line.length === 0) continue;\n            console.log(\"Checking line \".concat(i, ': \"').concat(line, '\"'));\n            for (const pattern of totalPatterns){\n                const match = line.match(pattern);\n                if (match) {\n                    const amount = parseFloat(match[1]);\n                    console.log(\"Found potential total: \".concat(amount, \" from pattern: \").concat(pattern));\n                    if (!isNaN(amount) && amount > 0 && amount < 10000) {\n                        console.log(\"✅ Using total amount: \".concat(amount));\n                        return amount;\n                    }\n                }\n            }\n        }\n        console.log('⚠️ No clear total found, looking for largest amount');\n        // If no clear total found, look for largest reasonable amount\n        const amounts = [];\n        lines.forEach((line, index)=>{\n            // Look for money amounts: $X.XX or X.XX\n            const matches = line.match(/[$]?(\\d+\\.\\d{2})/g) || [];\n            matches.forEach((match)=>{\n                const amount = parseFloat(match.replace('$', ''));\n                if (!isNaN(amount) && amount > 0 && amount < 10000) {\n                    console.log(\"Found amount \".concat(amount, \" on line \").concat(index, ': \"').concat(line, '\"'));\n                    amounts.push(amount);\n                }\n            });\n        });\n        const maxAmount = amounts.length > 0 ? Math.max(...amounts) : 0;\n        console.log(\"Using largest amount found: \".concat(maxAmount));\n        return maxAmount;\n    }\n    extractDate(lines) {\n        const datePatterns = [\n            /(\\d{1,2}\\/\\d{1,2}\\/\\d{2,4})/,\n            /(\\d{1,2}-\\d{1,2}-\\d{2,4})/,\n            /(\\d{4}-\\d{2}-\\d{2})/,\n            /(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec).*?(\\d{1,2}),?\\s*(\\d{4})/i\n        ];\n        for (const line of lines){\n            for (const pattern of datePatterns){\n                const match = line.match(pattern);\n                if (match) {\n                    try {\n                        // Try to parse and normalize the date\n                        const dateStr = match[0];\n                        const date = new Date(dateStr);\n                        if (!isNaN(date.getTime())) {\n                            return date.toISOString().split('T')[0]; // Return YYYY-MM-DD format\n                        }\n                    } catch (e) {\n                        continue;\n                    }\n                }\n            }\n        }\n        // Default to today if no date found\n        return new Date().toISOString().split('T')[0];\n    }\n    extractItems(lines) {\n        const items = [];\n        console.log('🔍 Extracting items from lines...');\n        for(let i = 0; i < lines.length; i++){\n            const line = lines[i].trim();\n            if (line.length === 0) continue;\n            // Enhanced item patterns\n            const itemPatterns = [\n                /^(\\d+)\\s+(.+?)\\s+[$]?(\\d+\\.\\d{2})$/,\n                /^(\\d+)\\s+(.+?)\\s+(\\d+\\.\\d{2})\\s*$/,\n                /^(.+?)\\s{2,}[$]?(\\d+\\.\\d{2})$/,\n                /^(.+?)\\s+[$](\\d+\\.\\d{2})$/,\n                /^(.+?)\\s+(\\d+\\.\\d{2})\\s*$/,\n                /^(.{3,30}?)\\s+(\\d{1,3}\\.\\d{2})$/ // Generic: name followed by price\n            ];\n            for (const pattern of itemPatterns){\n                const match = line.match(pattern);\n                if (match) {\n                    let quantity;\n                    let name;\n                    let price;\n                    if (match.length === 4) {\n                        // Pattern with quantity\n                        quantity = parseInt(match[1]);\n                        name = match[2].trim();\n                        price = parseFloat(match[3]);\n                    } else {\n                        // Pattern without quantity\n                        name = match[1].trim();\n                        price = parseFloat(match[2]);\n                    }\n                    // Check if this is a tax item (include it!)\n                    const isTaxItem = /TAX|HST|GST|PST|VAT/i.test(name) || /TAX|HST|GST|PST|VAT/i.test(line);\n                    // Enhanced filtering for non-item lines (but allow tax items)\n                    const excludePatterns = [\n                        /TOTAL|SUBTOTAL|CHANGE|BALANCE|RECEIPT|STORE|THANK|VISIT|AGAIN|CUSTOMER|COPY/i,\n                        /^(SUB|GRAND|FINAL)/i,\n                        /PAYMENT|CASH|CREDIT|DEBIT|CARD/i,\n                        /^(DATE|TIME|CLERK|CASHIER)/i,\n                        /^\\d{1,2}\\/\\d{1,2}\\/\\d{2,4}/,\n                        /^\\d{2}:\\d{2}/\n                    ];\n                    const shouldExclude = !isTaxItem && (excludePatterns.some((pattern)=>pattern.test(name)) || excludePatterns.some((pattern)=>pattern.test(line)));\n                    if (name && !shouldExclude && name.length >= 2 && name.length <= 50 && price > 0 && price <= 1000 && !name.match(/^\\d+$/) && // Not just numbers\n                    name.match(/[A-Za-z]/) // Contains at least one letter\n                    ) {\n                        const itemType = isTaxItem ? ' [TAX]' : '';\n                        console.log('✅ Found item: \"'.concat(name, '\" - $').concat(price) + (quantity ? \" (qty: \".concat(quantity, \")\") : '') + itemType);\n                        items.push({\n                            name: name.toUpperCase(),\n                            price,\n                            quantity\n                        });\n                    }\n                    break;\n                }\n            }\n        }\n        console.log(\"Found \".concat(items.length, \" items total\"));\n        return items;\n    }\n    async cleanup() {\n        if (this.worker) {\n            await this.worker.terminate();\n            this.worker = null;\n            this.isInitialized = false;\n            console.log('🧹 OCR engine cleaned up');\n        }\n    }\n    constructor(){\n        this.worker = null;\n        this.isInitialized = false;\n    }\n}\n// Export singleton instance\nconst ocrService = new OCRService();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NlcnZpY2VzL29jclNlcnZpY2UudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTRDO0FBb0I1QyxNQUFNQztJQUlKLE1BQU1DLGFBQTRCO1FBQ2hDLElBQUksSUFBSSxDQUFDQyxhQUFhLEVBQUU7UUFFeEIsSUFBSTtZQUNGQyxRQUFRQyxHQUFHLENBQUM7WUFDWixJQUFJLENBQUNDLE1BQU0sR0FBRyxNQUFNTiwwREFBWUEsQ0FBQztZQUVqQyxzRUFBc0U7WUFDdEUsTUFBTSxJQUFJLENBQUNNLE1BQU0sQ0FBQ0MsYUFBYSxDQUFDO2dCQUM5QiwyQkFBMkI7Z0JBQzNCLHlCQUF5QjtnQkFDekIsNkJBQTZCO2dCQUM3Qix3QkFBd0I7Z0JBQ3hCLHdCQUF3QjtnQkFDeEIsK0JBQStCO2dCQUMvQixnQ0FBZ0M7Z0JBQ2hDLCtCQUErQixJQUFJLG9DQUFvQztZQUN6RTtZQUVBLElBQUksQ0FBQ0osYUFBYSxHQUFHO1lBQ3JCQyxRQUFRQyxHQUFHLENBQUM7UUFDZCxFQUFFLE9BQU9HLE9BQU87WUFDZEosUUFBUUksS0FBSyxDQUFDLHNDQUFzQ0E7WUFDcEQsTUFBTSxJQUFJQyxNQUFNO1FBQ2xCO0lBQ0Y7SUFFQSxNQUFjQyxnQkFBZ0JDLFNBQWUsRUFBbUI7UUFDOUQsT0FBTyxJQUFJQyxRQUFRLENBQUNDLFNBQVNDO1lBQzNCLE1BQU1DLFNBQVNDLFNBQVNDLGFBQWEsQ0FBQztZQUN0QyxNQUFNQyxNQUFNSCxPQUFPSSxVQUFVLENBQUM7WUFDOUIsTUFBTUMsTUFBTSxJQUFJQztZQUVoQkQsSUFBSUUsTUFBTSxHQUFHO2dCQUNYLGtCQUFrQjtnQkFDbEJQLE9BQU9RLEtBQUssR0FBR0gsSUFBSUcsS0FBSztnQkFDeEJSLE9BQU9TLE1BQU0sR0FBR0osSUFBSUksTUFBTTtnQkFFMUIsSUFBSSxDQUFDTixLQUFLO29CQUNSSixPQUFPLElBQUlMLE1BQU07b0JBQ2pCO2dCQUNGO2dCQUVBLHNCQUFzQjtnQkFDdEJTLElBQUlPLFNB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U0FBa0M7YUFDbENILGdCQUFnQjs7QUF3ZTFCO0FBRUEsNEJBQTRCO0FBQ3JCLE1BQU02SSxhQUFhLElBQUkvSSxhQUFhIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXG5hdGhhXFxPbmVEcml2ZVxcRGVza3RvcFxcTW9uZXlRdWVzdFYzXFxwYWNrYWdlc1xcd2Vic2l0ZVxcc2VydmljZXNcXG9jclNlcnZpY2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlV29ya2VyIH0gZnJvbSAndGVzc2VyYWN0LmpzJztcblxuZXhwb3J0IGludGVyZmFjZSBPQ1JSZXN1bHQge1xuICB0ZXh0OiBzdHJpbmc7XG4gIGNvbmZpZGVuY2U6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQYXJzZWRSZWNlaXB0IHtcbiAgbWVyY2hhbnQ6IHN0cmluZztcbiAgYW1vdW50OiBudW1iZXI7XG4gIGRhdGU6IHN0cmluZztcbiAgaXRlbXM6IEFycmF5PHtcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgcHJpY2U6IG51bWJlcjtcbiAgICBxdWFudGl0eT86IG51bWJlcjtcbiAgfT47XG4gIHJhd1RleHQ6IHN0cmluZztcbiAgY29uZmlkZW5jZTogbnVtYmVyO1xufVxuXG5jbGFzcyBPQ1JTZXJ2aWNlIHtcbiAgcHJpdmF0ZSB3b3JrZXI6IFRlc3NlcmFjdC5Xb3JrZXIgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBpc0luaXRpYWxpemVkID0gZmFsc2U7XG5cbiAgYXN5bmMgaW5pdGlhbGl6ZSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAodGhpcy5pc0luaXRpYWxpemVkKSByZXR1cm47XG5cbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coJ/CflI0gSW5pdGlhbGl6aW5nIE9DUiBlbmdpbmUuLi4nKTtcbiAgICAgIHRoaXMud29ya2VyID0gYXdhaXQgY3JlYXRlV29ya2VyKCdlbmcnKTtcblxuICAgICAgLy8gQ29uZmlndXJlIFRlc3NlcmFjdCBmb3IgYmV0dGVyIHJlY2VpcHQgcmVhZGluZyB3aXRoIG1vcmUgY2hhcmFjdGVyc1xuICAgICAgYXdhaXQgdGhpcy53b3JrZXIuc2V0UGFyYW1ldGVycyh7XG4gICAgICAgICd0ZXNzZWRpdF9jaGFyX3doaXRlbGlzdCc6ICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ei4sJC86LSMlKigpJkArICcsXG4gICAgICAgICd0ZXNzZWRpdF9wYWdlc2VnX21vZGUnOiAnNCcsIC8vIEFzc3VtZSBzaW5nbGUgY29sdW1uIG9mIHRleHQgb2YgdmFyaWFibGUgc2l6ZXNcbiAgICAgICAgJ3ByZXNlcnZlX2ludGVyd29yZF9zcGFjZXMnOiAnMScsXG4gICAgICAgICd0ZXNzZWRpdF9jcmVhdGVfaG9jcic6ICcxJywgLy8gRW5hYmxlIGRldGFpbGVkIHBvc2l0aW9uIGRhdGFcbiAgICAgICAgJ3RleHRvcmRfbWluX2xpbmVzaXplJzogJzEuMjUnLCAvLyBNaW5pbXVtIGxpbmUgc2l6ZSAoaGVscHMgd2l0aCBzbWFsbCBudW1iZXJzKVxuICAgICAgICAndGV4dG9yZF90YWJmaW5kX2ZpbmRfdGFibGVzJzogJzEnLCAvLyBFbmFibGUgdGFibGUgZGV0ZWN0aW9uIGZvciByZWNlaXB0IGNvbHVtbnNcbiAgICAgICAgJ3RleHRvcmRfdGFibGVmaW5kX2dvb2Rfd2lkdGgnOiAnMycsIC8vIEJldHRlciBjb2x1bW4gZGV0ZWN0aW9uXG4gICAgICAgICd0ZXh0b3JkX3RhYmZpbmRfc2hvd192bGluZXMnOiAnMScgLy8gU2hvdyB2ZXJ0aWNhbCBsaW5lcyBmb3IgZGVidWdnaW5nXG4gICAgICB9KTtcblxuICAgICAgdGhpcy5pc0luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgIGNvbnNvbGUubG9nKCfinIUgT0NSIGVuZ2luZSBpbml0aWFsaXplZCBzdWNjZXNzZnVsbHknKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcign4p2MIEZhaWxlZCB0byBpbml0aWFsaXplIE9DUiBlbmdpbmU6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gaW5pdGlhbGl6ZSBPQ1IgZW5naW5lJyk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBwcmVwcm9jZXNzSW1hZ2UoaW1hZ2VGaWxlOiBGaWxlKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIGNvbnN0IGltZyA9IG5ldyBJbWFnZSgpO1xuXG4gICAgICBpbWcub25sb2FkID0gKCkgPT4ge1xuICAgICAgICAvLyBTZXQgY2FudmFzIHNpemVcbiAgICAgICAgY2FudmFzLndpZHRoID0gaW1nLndpZHRoO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaW1nLmhlaWdodDtcblxuICAgICAgICBpZiAoIWN0eCkge1xuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ0NvdWxkIG5vdCBnZXQgY2FudmFzIGNvbnRleHQnKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRHJhdyBvcmlnaW5hbCBpbWFnZVxuICAgICAgICBjdHguZHJhd0ltYWdlKGltZywgMCwgMCk7XG5cbiAgICAgICAgLy8gR2V0IGltYWdlIGRhdGEgZm9yIHByb2Nlc3NpbmdcbiAgICAgICAgY29uc3QgaW1hZ2VEYXRhID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICBjb25zdCBkYXRhID0gaW1hZ2VEYXRhLmRhdGE7XG5cbiAgICAgICAgLy8gQ29udmVydCB0byBncmF5c2NhbGUgYW5kIGluY3JlYXNlIGNvbnRyYXN0XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkgKz0gNCkge1xuICAgICAgICAgIGNvbnN0IGdyYXkgPSBNYXRoLnJvdW5kKDAuMjk5ICogZGF0YVtpXSArIDAuNTg3ICogZGF0YVtpICsgMV0gKyAwLjExNCAqIGRhdGFbaSArIDJdKTtcblxuICAgICAgICAgIC8vIEluY3JlYXNlIGNvbnRyYXN0XG4gICAgICAgICAgY29uc3QgY29udHJhc3QgPSAxLjU7XG4gICAgICAgICAgY29uc3QgZmFjdG9yID0gKDI1OSAqIChjb250cmFzdCArIDI1NSkpIC8gKDI1NSAqICgyNTkgLSBjb250cmFzdCkpO1xuICAgICAgICAgIGNvbnN0IGVuaGFuY2VkID0gTWF0aC5taW4oMjU1LCBNYXRoLm1heCgwLCBmYWN0b3IgKiAoZ3JheSAtIDEyOCkgKyAxMjgpKTtcblxuICAgICAgICAgIGRhdGFbaV0gPSBlbmhhbmNlZDsgICAgIC8vIFJlZFxuICAgICAgICAgIGRhdGFbaSArIDFdID0gZW5oYW5jZWQ7IC8vIEdyZWVuXG4gICAgICAgICAgZGF0YVtpICsgMl0gPSBlbmhhbmNlZDsgLy8gQmx1ZVxuICAgICAgICAgIC8vIEFscGhhIHN0YXlzIHRoZSBzYW1lXG4gICAgICAgIH1cblxuICAgICAgICAvLyBQdXQgdGhlIHByb2Nlc3NlZCBpbWFnZSBkYXRhIGJhY2tcbiAgICAgICAgY3R4LnB1dEltYWdlRGF0YShpbWFnZURhdGEsIDAsIDApO1xuXG4gICAgICAgIC8vIENvbnZlcnQgdG8gZGF0YSBVUkxcbiAgICAgICAgcmVzb2x2ZShjYW52YXMudG9EYXRhVVJMKCdpbWFnZS9wbmcnKSk7XG4gICAgICB9O1xuXG4gICAgICBpbWcub25lcnJvciA9ICgpID0+IHJlamVjdChuZXcgRXJyb3IoJ0ZhaWxlZCB0byBsb2FkIGltYWdlJykpO1xuICAgICAgaW1nLnNyYyA9IFVSTC5jcmVhdGVPYmplY3RVUkwoaW1hZ2VGaWxlKTtcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgcmVjb25zdHJ1Y3RBbGlnbmVkVGV4dChvY3JEYXRhOiBhbnkpOiBzdHJpbmcge1xuICAgIGlmICghb2NyRGF0YS5saW5lcyB8fCBvY3JEYXRhLmxpbmVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG9jckRhdGEudGV4dCB8fCAnJztcbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZygn8J+UpyBSZWNvbnN0cnVjdGluZyBhbGlnbmVkIHRleHQgZnJvbScsIG9jckRhdGEubGluZXMubGVuZ3RoLCAnbGluZXMnKTtcblxuICAgIGNvbnN0IGxpbmVzOiBzdHJpbmdbXSA9IFtdO1xuXG4gICAgZm9yIChjb25zdCBsaW5lIG9mIG9jckRhdGEubGluZXMpIHtcbiAgICAgIGlmICghbGluZS53b3JkcyB8fCBsaW5lLndvcmRzLmxlbmd0aCA9PT0gMCkgY29udGludWU7XG5cbiAgICAgIC8vIFNvcnQgd29yZHMgYnkgeCBwb3NpdGlvbiAobGVmdCB0byByaWdodClcbiAgICAgIGNvbnN0IHNvcnRlZFdvcmRzID0gWy4uLmxpbmUud29yZHNdLnNvcnQoKGEsIGIpID0+IGEuYmJveC54MCAtIGIuYmJveC54MCk7XG5cbiAgICAgIGxldCBsaW5lVGV4dCA9ICcnO1xuICAgICAgbGV0IGxhc3RYID0gMDtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzb3J0ZWRXb3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB3b3JkID0gc29ydGVkV29yZHNbaV07XG4gICAgICAgIGNvbnN0IHdvcmRUZXh0ID0gd29yZC50ZXh0LnRyaW0oKTtcblxuICAgICAgICBpZiAod29yZFRleHQubGVuZ3RoID09PSAwKSBjb250aW51ZTtcblxuICAgICAgICAvLyBDYWxjdWxhdGUgc3BhY2luZyBuZWVkZWQgYmFzZWQgb24geC1wb3NpdGlvblxuICAgICAgICBjb25zdCBjdXJyZW50WCA9IHdvcmQuYmJveC54MDtcbiAgICAgICAgY29uc3Qgd29yZFdpZHRoID0gd29yZC5iYm94LngxIC0gd29yZC5iYm94LngwO1xuXG4gICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgIC8vIENhbGN1bGF0ZSBnYXAgYmV0d2VlbiB0aGlzIHdvcmQgYW5kIHByZXZpb3VzIHdvcmRcbiAgICAgICAgICBjb25zdCBnYXAgPSBjdXJyZW50WCAtIGxhc3RYO1xuICAgICAgICAgIGNvbnN0IGF2Z0NoYXJXaWR0aCA9IDEwOyAvLyBBcHByb3hpbWF0ZSBjaGFyYWN0ZXIgd2lkdGhcbiAgICAgICAgICBjb25zdCBzcGFjZXNOZWVkZWQgPSBNYXRoLm1heCgxLCBNYXRoLmZsb29yKGdhcCAvIGF2Z0NoYXJXaWR0aCkpO1xuXG4gICAgICAgICAgLy8gQWRkIGFwcHJvcHJpYXRlIHNwYWNpbmcgKGJ1dCBjYXAgaXQgdG8gcHJldmVudCBleGNlc3NpdmUgc3BhY2luZylcbiAgICAgICAgICBsaW5lVGV4dCArPSAnICcucmVwZWF0KE1hdGgubWluKHNwYWNlc05lZWRlZCwgMjApKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxpbmVUZXh0ICs9IHdvcmRUZXh0O1xuICAgICAgICBsYXN0WCA9IHdvcmQuYmJveC54MTtcbiAgICAgIH1cblxuICAgICAgaWYgKGxpbmVUZXh0LnRyaW0oKS5sZW5ndGggPiAwKSB7XG4gICAgICAgIGxpbmVzLnB1c2gobGluZVRleHQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHJlY29uc3RydWN0ZWRUZXh0ID0gbGluZXMuam9pbignXFxuJyk7XG4gICAgY29uc29sZS5sb2coJ+KchSBSZWNvbnN0cnVjdGVkIHRleHQgd2l0aCBhbGlnbm1lbnQ6JywgcmVjb25zdHJ1Y3RlZFRleHQuc3Vic3RyaW5nKDAsIDIwMCkgKyAnLi4uJyk7XG4gICAgcmV0dXJuIHJlY29uc3RydWN0ZWRUZXh0O1xuICB9XG5cbiAgYXN5bmMgcHJvY2Vzc1JlY2VpcHRJbWFnZShpbWFnZUZpbGU6IEZpbGUpOiBQcm9taXNlPE9DUlJlc3VsdD4ge1xuICAgIGlmICghdGhpcy53b3JrZXIgfHwgIXRoaXMuaXNJbml0aWFsaXplZCkge1xuICAgICAgYXdhaXQgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKCfwn5OEIFByZXByb2Nlc3NpbmcgcmVjZWlwdCBpbWFnZS4uLicpO1xuICAgICAgY29uc3QgcHJlcHJvY2Vzc2VkSW1hZ2UgPSBhd2FpdCB0aGlzLnByZXByb2Nlc3NJbWFnZShpbWFnZUZpbGUpO1xuXG4gICAgICBjb25zb2xlLmxvZygn8J+UjSBQcm9jZXNzaW5nIHJlY2VpcHQgaW1hZ2Ugd2l0aCBPQ1IuLi4nKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMud29ya2VyIS5yZWNvZ25pemUocHJlcHJvY2Vzc2VkSW1hZ2UpO1xuXG4gICAgICBjb25zb2xlLmxvZygn4pyFIE9DUiBjb21wbGV0ZWQnLCB7XG4gICAgICAgIGNvbmZpZGVuY2U6IHJlc3VsdC5kYXRhLmNvbmZpZGVuY2UsXG4gICAgICAgIHRleHRMZW5ndGg6IHJlc3VsdC5kYXRhLnRleHQubGVuZ3RoLFxuICAgICAgICB3b3Jkc0ZvdW5kOiByZXN1bHQuZGF0YS53b3Jkcz8ubGVuZ3RoIHx8IDBcbiAgICAgIH0pO1xuXG4gICAgICAvLyBSZWNvbnN0cnVjdCB0ZXh0IHdpdGggYmV0dGVyIGFsaWdubWVudCB1c2luZyB3b3JkIHBvc2l0aW9uc1xuICAgICAgY29uc3QgYWxpZ25lZFRleHQgPSB0aGlzLnJlY29uc3RydWN0QWxpZ25lZFRleHQocmVzdWx0LmRhdGEpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0ZXh0OiBhbGlnbmVkVGV4dCxcbiAgICAgICAgY29uZmlkZW5jZTogcmVzdWx0LmRhdGEuY29uZmlkZW5jZVxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcign4p2MIE9DUiBwcm9jZXNzaW5nIGZhaWxlZDonLCBlcnJvcik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBwcm9jZXNzIGltYWdlIHdpdGggT0NSJyk7XG4gICAgfVxuICB9XG5cbiAgcGFyc2VSZWNlaXB0VGV4dChvY3JUZXh0OiBzdHJpbmcsIGNvbmZpZGVuY2U6IG51bWJlcik6IFBhcnNlZFJlY2VpcHQge1xuICAgIGNvbnNvbGUubG9nKCfwn5SNIFBhcnNpbmcgcmVjZWlwdCB0ZXh0Li4uJyk7XG4gICAgY29uc29sZS5sb2coJ1JhdyBPQ1IgdGV4dDonLCBvY3JUZXh0KTtcblxuICAgIGNvbnN0IGxpbmVzID0gb2NyVGV4dC5zcGxpdCgnXFxuJykubWFwKGxpbmUgPT4gbGluZS50cmltKCkpLmZpbHRlcihsaW5lID0+IGxpbmUubGVuZ3RoID4gMCk7XG5cbiAgICAvLyBFeHRyYWN0IG1lcmNoYW50IG5hbWUgKHVzdWFsbHkgZmlyc3Qgb3Igc2Vjb25kIGxpbmUpXG4gICAgY29uc3QgbWVyY2hhbnQgPSB0aGlzLmV4dHJhY3RNZXJjaGFudChsaW5lcyk7XG5cbiAgICAvLyBFeHRyYWN0IGxpbmUgaXRlbXMgRklSU1QgKGluY2x1ZGluZyB0YXgpXG4gICAgY29uc3QgaXRlbXMgPSB0aGlzLmV4dHJhY3RJdGVtcyhsaW5lcyk7XG5cbiAgICAvLyBFeHRyYWN0IHRvdGFsIGFtb3VudCB1c2luZyB0aGUgbmV3IHJ1bGVcbiAgICBjb25zdCBhbW91bnQgPSB0aGlzLmV4dHJhY3RWYWxpZGF0ZWRUb3RhbChsaW5lcywgaXRlbXMpO1xuXG4gICAgLy8gRXh0cmFjdCBkYXRlXG4gICAgY29uc3QgZGF0ZSA9IHRoaXMuZXh0cmFjdERhdGUobGluZXMpO1xuXG4gICAgY29uc3QgcGFyc2VkOiBQYXJzZWRSZWNlaXB0ID0ge1xuICAgICAgbWVyY2hhbnQsXG4gICAgICBhbW91bnQsXG4gICAgICBkYXRlLFxuICAgICAgaXRlbXMsXG4gICAgICByYXdUZXh0OiBvY3JUZXh0LFxuICAgICAgY29uZmlkZW5jZTogTWF0aC5tYXgoY29uZmlkZW5jZSAqIDAuOCwgNjApIC8vIEFkanVzdCBjb25maWRlbmNlIGZvciBwYXJzaW5nIHVuY2VydGFpbnR5XG4gICAgfTtcblxuICAgIGNvbnNvbGUubG9nKCfinIUgUmVjZWlwdCBwYXJzZWQgc3VjY2Vzc2Z1bGx5OicsIHBhcnNlZCk7XG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuXG4gIHByaXZhdGUgZXh0cmFjdE1lcmNoYW50KGxpbmVzOiBzdHJpbmdbXSk6IHN0cmluZyB7XG4gICAgLy8gQ29tbW9uIG1lcmNoYW50IHBhdHRlcm5zIHRvIGxvb2sgZm9yXG4gICAgY29uc3QgbWVyY2hhbnRQYXR0ZXJucyA9IFtcbiAgICAgIC9eKFtBLVphLXpcXHMmJy4tXXszLDQwfSkkLyxcbiAgICAgIC9eKFtBLVpcXHMmJy4tXXszLDQwfSlcXHMrU1RPUkUvLFxuICAgICAgL14oW0EtWlxccyYnLi1dezMsNDB9KVxccytNQVJLRVQvLFxuICAgICAgL14oW0EtWlxccyYnLi1dezMsNDB9KVxccytJTkMvXG4gICAgXTtcblxuICAgIC8vIExvb2sgZm9yIG1lcmNoYW50IG5hbWUgaW4gZmlyc3QgNyBsaW5lc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTWF0aC5taW4oNywgbGluZXMubGVuZ3RoKTsgaSsrKSB7XG4gICAgICBjb25zdCBsaW5lID0gbGluZXNbaV0udHJpbSgpO1xuXG4gICAgICAvLyBTa2lwIG9idmlvdXNseSBub24tbWVyY2hhbnQgbGluZXNcbiAgICAgIGlmIChsaW5lLm1hdGNoKC9eXFxkKy8pIHx8IGxpbmUuaW5jbHVkZXMoJ1JFQ0VJUFQnKSB8fCBsaW5lLmluY2x1ZGVzKCdJTlZPSUNFJykgfHxcbiAgICAgICAgICBsaW5lLmluY2x1ZGVzKCcjJykgfHwgbGluZS5pbmNsdWRlcygnVEVMJykgfHwgbGluZS5pbmNsdWRlcygnV1dXJykgfHxcbiAgICAgICAgICBsaW5lLmluY2x1ZGVzKCdAJykgfHwgbGluZS5pbmNsdWRlcygnLkNPTScpIHx8IGxpbmUuaW5jbHVkZXMoJ1NUUkVFVCcpIHx8XG4gICAgICAgICAgbGluZS5pbmNsdWRlcygnQVZFJykgfHwgbGluZS5pbmNsdWRlcygnQkxWRCcpIHx8IGxpbmUuaW5jbHVkZXMoJ1JEJykgfHxcbiAgICAgICAgICBsaW5lLmxlbmd0aCA8IDMgfHwgbGluZS5sZW5ndGggPiA1MCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gVHJ5IG1lcmNoYW50IHBhdHRlcm5zXG4gICAgICBmb3IgKGNvbnN0IHBhdHRlcm4gb2YgbWVyY2hhbnRQYXR0ZXJucykge1xuICAgICAgICBjb25zdCBtYXRjaCA9IGxpbmUubWF0Y2gocGF0dGVybik7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgIHJldHVybiBtYXRjaFsxXS50cmltKCkudG9VcHBlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBJZiBubyBwYXR0ZXJuIG1hdGNoZXMgYnV0IGxpbmUgbG9va3MgbGlrZSBtZXJjaGFudCBuYW1lXG4gICAgICBpZiAobGluZS5tYXRjaCgvXltBLVphLXpcXHMmJy4tXSskLykgJiYgbGluZS5sZW5ndGggPj0gMyAmJiBsaW5lLmxlbmd0aCA8PSA0MCkge1xuICAgICAgICAvLyBDaGVjayBpZiBpdCdzIG5vdCBhIGNvbW1vbiBub24tbWVyY2hhbnQgd29yZFxuICAgICAgICBjb25zdCBub25NZXJjaGFudFdvcmRzID0gWydUSEFOSycsICdZT1UnLCAnVklTSVQnLCAnQUdBSU4nLCAnQ1VTVE9NRVInLCAnQ09QWSddO1xuICAgICAgICBpZiAoIW5vbk1lcmNoYW50V29yZHMuc29tZSh3b3JkID0+IGxpbmUuaW5jbHVkZXMod29yZCkpKSB7XG4gICAgICAgICAgcmV0dXJuIGxpbmUudG9VcHBlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnVU5LTk9XTiBNRVJDSEFOVCc7XG4gIH1cblxuICBwcml2YXRlIGV4dHJhY3RWYWxpZGF0ZWRUb3RhbChsaW5lczogc3RyaW5nW10sIGl0ZW1zOiBBcnJheTx7IG5hbWU6IHN0cmluZzsgcHJpY2U6IG51bWJlcjsgcXVhbnRpdHk/OiBudW1iZXIgfT4pOiBudW1iZXIge1xuICAgIGNvbnNvbGUubG9nKCfwn5SNIExvb2tpbmcgZm9yIHRvdGFsIHRoYXQgbWF0Y2hlcyBpdGVtIHN1bS4uLicpO1xuXG4gICAgLy8gQ2FsY3VsYXRlIGV4cGVjdGVkIHRvdGFsIGZyb20gaXRlbXNcbiAgICBjb25zdCBpdGVtc1RvdGFsID0gaXRlbXMucmVkdWNlKChzdW0sIGl0ZW0pID0+IHN1bSArIGl0ZW0ucHJpY2UsIDApO1xuICAgIGNvbnNvbGUubG9nKGBJdGVtcyBzdW0gdG86ICQke2l0ZW1zVG90YWwudG9GaXhlZCgyKX1gKTtcblxuICAgIC8vIExvb2sgc3BlY2lmaWNhbGx5IGZvciBcIlRvdGFsXCIgZm9sbG93ZWQgYnkgZG9sbGFyIGFtb3VudFxuICAgIGNvbnN0IHRvdGFsUGF0dGVybnMgPSBbXG4gICAgICAvVE9UQUxcXHMrWyRdPyhcXGQrXFwuXFxkezJ9KS9pLCAgICAgICAgICAgLy8gXCJUT1RBTCAkMTIuMzRcIlxuICAgICAgL1RPVEFMXFxzKjpcXHMqWyRdPyhcXGQrXFwuXFxkezJ9KS9pLCAgICAgIC8vIFwiVE9UQUw6ICQxMi4zNFwiXG4gICAgICAvVE9UQUwuKj9bJF0oXFxkK1xcLlxcZHsyfSkvaSwgICAgICAgICAgIC8vIFwiVE9UQUwgeHh4ICQxMi4zNFwiXG4gICAgXTtcblxuICAgIGNvbnN0IGZvdW5kVG90YWxzOiBBcnJheTx7IGFtb3VudDogbnVtYmVyOyBsaW5lOiBzdHJpbmcgfT4gPSBbXTtcblxuICAgIC8vIEZpbmQgYWxsIHBvdGVudGlhbCB0b3RhbHNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBsaW5lID0gbGluZXNbaV0udHJpbSgpO1xuXG4gICAgICBmb3IgKGNvbnN0IHBhdHRlcm4gb2YgdG90YWxQYXR0ZXJucykge1xuICAgICAgICBjb25zdCBtYXRjaCA9IGxpbmUubWF0Y2gocGF0dGVybik7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgIGNvbnN0IGFtb3VudCA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICAgICAgICAgIGlmICghaXNOYU4oYW1vdW50KSAmJiBhbW91bnQgPiAwKSB7XG4gICAgICAgICAgICBmb3VuZFRvdGFscy5wdXNoKHsgYW1vdW50LCBsaW5lIH0pO1xuICAgICAgICAgICAgY29uc29sZS5sb2coYEZvdW5kIHBvdGVudGlhbCB0b3RhbDogJCR7YW1vdW50fSBpbiBcIiR7bGluZX1cImApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHdlIGhhdmUgaXRlbXMsIHRyeSB0byBtYXRjaCB0b3RhbCB0byBpdGVtcyBzdW1cbiAgICBpZiAoaXRlbXNUb3RhbCA+IDAgJiYgZm91bmRUb3RhbHMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc29sZS5sb2coJ1ZhbGlkYXRpbmcgdG90YWxzIGFnYWluc3QgaXRlbXMgc3VtLi4uJyk7XG5cbiAgICAgIGZvciAoY29uc3QgdG90YWwgb2YgZm91bmRUb3RhbHMpIHtcbiAgICAgICAgY29uc3QgZGlmZmVyZW5jZSA9IE1hdGguYWJzKHRvdGFsLmFtb3VudCAtIGl0ZW1zVG90YWwpO1xuICAgICAgICBjb25zb2xlLmxvZyhgVG90YWwgJCR7dG90YWwuYW1vdW50fSB2cyBJdGVtcyAkJHtpdGVtc1RvdGFsLnRvRml4ZWQoMil9IC0gZGlmZmVyZW5jZTogJCR7ZGlmZmVyZW5jZS50b0ZpeGVkKDIpfWApO1xuXG4gICAgICAgIC8vIEFsbG93IHNtYWxsIHJvdW5kaW5nIGRpZmZlcmVuY2VzICjCsSQwLjA1KVxuICAgICAgICBpZiAoZGlmZmVyZW5jZSA8PSAwLjA1KSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYOKchSBGb3VuZCBtYXRjaGluZyB0b3RhbDogJCR7dG90YWwuYW1vdW50fWApO1xuICAgICAgICAgIHJldHVybiB0b3RhbC5hbW91bnQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gSWYgbm8gZXhhY3QgbWF0Y2gsIGxvb2sgZm9yIGNsb3Nlc3QgdG90YWwgdGhhdCdzIHJlYXNvbmFibGVcbiAgICAgIGNvbnN0IHNvcnRlZEJ5Q2xvc2VuZXNzID0gZm91bmRUb3RhbHMuc29ydCgoYSwgYikgPT5cbiAgICAgICAgTWF0aC5hYnMoYS5hbW91bnQgLSBpdGVtc1RvdGFsKSAtIE1hdGguYWJzKGIuYW1vdW50IC0gaXRlbXNUb3RhbClcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IGNsb3Nlc3QgPSBzb3J0ZWRCeUNsb3NlbmVzc1swXTtcbiAgICAgIGlmIChjbG9zZXN0ICYmIE1hdGguYWJzKGNsb3Nlc3QuYW1vdW50IC0gaXRlbXNUb3RhbCkgPD0gaXRlbXNUb3RhbCAqIDAuMSkgeyAvLyBXaXRoaW4gMTAlXG4gICAgICAgIGNvbnNvbGUubG9nKGDimqDvuI8gVXNpbmcgY2xvc2VzdCB0b3RhbDogJCR7Y2xvc2VzdC5hbW91bnR9ICgke01hdGguYWJzKGNsb3Nlc3QuYW1vdW50IC0gaXRlbXNUb3RhbCkudG9GaXhlZCgyKX0gZGlmZmVyZW5jZSlgKTtcbiAgICAgICAgcmV0dXJuIGNsb3Nlc3QuYW1vdW50O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEZhbGxiYWNrOiB1c2UgYW55IFwiVG90YWxcIiB3ZSBmb3VuZFxuICAgIGlmIChmb3VuZFRvdGFscy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zb2xlLmxvZyhg4pqg77iPIFVzaW5nIGZpcnN0IHRvdGFsIGZvdW5kOiAkJHtmb3VuZFRvdGFsc1swXS5hbW91bnR9YCk7XG4gICAgICByZXR1cm4gZm91bmRUb3RhbHNbMF0uYW1vdW50O1xuICAgIH1cblxuICAgIC8vIEZpbmFsIGZhbGxiYWNrOiB1c2UgaXRlbXMgc3VtIGlmIHdlIGhhdmUgaXRlbXNcbiAgICBpZiAoaXRlbXNUb3RhbCA+IDApIHtcbiAgICAgIGNvbnNvbGUubG9nKGDimqDvuI8gTm8gdG90YWwgZm91bmQsIHVzaW5nIGl0ZW1zIHN1bTogJCR7aXRlbXNUb3RhbC50b0ZpeGVkKDIpfWApO1xuICAgICAgcmV0dXJuIGl0ZW1zVG90YWw7XG4gICAgfVxuXG4gICAgLy8gTGFzdCByZXNvcnQ6IHVzZSBvbGQgbWV0aG9kXG4gICAgY29uc29sZS5sb2coJ+KaoO+4jyBGYWxsaW5nIGJhY2sgdG8gb2xkIHRvdGFsIGV4dHJhY3Rpb24gbWV0aG9kJyk7XG4gICAgcmV0dXJuIHRoaXMuZXh0cmFjdFRvdGFsQW1vdW50KGxpbmVzKTtcbiAgfVxuXG4gIHByaXZhdGUgZXh0cmFjdFRvdGFsQW1vdW50KGxpbmVzOiBzdHJpbmdbXSk6IG51bWJlciB7XG4gICAgLy8gRW5oYW5jZWQgdG90YWwgYW1vdW50IHBhdHRlcm5zXG4gICAgY29uc3QgdG90YWxQYXR0ZXJucyA9IFtcbiAgICAgIC9UT1RBTC4qP1skXT8oXFxkK1xcLj9cXGR7Mn0pL2ksXG4gICAgICAvQU1PVU5UXFxzK0RVRS4qP1skXT8oXFxkK1xcLj9cXGR7Mn0pL2ksXG4gICAgICAvQkFMQU5DRS4qP1skXT8oXFxkK1xcLj9cXGR7Mn0pL2ksXG4gICAgICAvR1JBTkRcXHMrVE9UQUwuKj9bJF0/KFxcZCtcXC4/XFxkezJ9KS9pLFxuICAgICAgL0ZJTkFMXFxzK1RPVEFMLio/WyRdPyhcXGQrXFwuP1xcZHsyfSkvaSxcbiAgICAgIC9bJF0oXFxkK1xcLlxcZHsyfSlcXHMqJC8sIC8vIExpbmUgZW5kaW5nIHdpdGggY3VycmVuY3kgYW1vdW50XG4gICAgICAvKFxcZCtcXC5cXGR7Mn0pXFxzKlRPVEFML2ksXG4gICAgICAvVE9UQUxcXHMrWyRdPyhcXGQrXFwuXFxkezJ9KS9pLFxuICAgICAgL1skXVxccyooXFxkK1xcLlxcZHsyfSlcXHMqVE9UQUwvaVxuICAgIF07XG5cbiAgICBjb25zb2xlLmxvZygn8J+UjSBMb29raW5nIGZvciB0b3RhbCBhbW91bnQgaW4gbGluZXM6JywgbGluZXMuc2xpY2UoLTEwKSk7XG5cbiAgICAvLyBTZWFyY2ggZnJvbSBib3R0b20gdXAgYXMgdG90YWxzIGFyZSB1c3VhbGx5IGF0IHRoZSBlbmRcbiAgICBmb3IgKGxldCBpID0gbGluZXMubGVuZ3RoIC0gMTsgaSA+PSBNYXRoLm1heCgwLCBsaW5lcy5sZW5ndGggLSAxNSk7IGktLSkge1xuICAgICAgY29uc3QgbGluZSA9IGxpbmVzW2ldLnRyaW0oKTtcblxuICAgICAgaWYgKGxpbmUubGVuZ3RoID09PSAwKSBjb250aW51ZTtcblxuICAgICAgY29uc29sZS5sb2coYENoZWNraW5nIGxpbmUgJHtpfTogXCIke2xpbmV9XCJgKTtcblxuICAgICAgZm9yIChjb25zdCBwYXR0ZXJuIG9mIHRvdGFsUGF0dGVybnMpIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBsaW5lLm1hdGNoKHBhdHRlcm4pO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICBjb25zdCBhbW91bnQgPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgRm91bmQgcG90ZW50aWFsIHRvdGFsOiAke2Ftb3VudH0gZnJvbSBwYXR0ZXJuOiAke3BhdHRlcm59YCk7XG4gICAgICAgICAgaWYgKCFpc05hTihhbW91bnQpICYmIGFtb3VudCA+IDAgJiYgYW1vdW50IDwgMTAwMDApIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDinIUgVXNpbmcgdG90YWwgYW1vdW50OiAke2Ftb3VudH1gKTtcbiAgICAgICAgICAgIHJldHVybiBhbW91bnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coJ+KaoO+4jyBObyBjbGVhciB0b3RhbCBmb3VuZCwgbG9va2luZyBmb3IgbGFyZ2VzdCBhbW91bnQnKTtcblxuICAgIC8vIElmIG5vIGNsZWFyIHRvdGFsIGZvdW5kLCBsb29rIGZvciBsYXJnZXN0IHJlYXNvbmFibGUgYW1vdW50XG4gICAgY29uc3QgYW1vdW50czogbnVtYmVyW10gPSBbXTtcbiAgICBsaW5lcy5mb3JFYWNoKChsaW5lLCBpbmRleCkgPT4ge1xuICAgICAgLy8gTG9vayBmb3IgbW9uZXkgYW1vdW50czogJFguWFggb3IgWC5YWFxuICAgICAgY29uc3QgbWF0Y2hlcyA9IGxpbmUubWF0Y2goL1skXT8oXFxkK1xcLlxcZHsyfSkvZykgfHwgW107XG4gICAgICBtYXRjaGVzLmZvckVhY2gobWF0Y2ggPT4ge1xuICAgICAgICBjb25zdCBhbW91bnQgPSBwYXJzZUZsb2F0KG1hdGNoLnJlcGxhY2UoJyQnLCAnJykpO1xuICAgICAgICBpZiAoIWlzTmFOKGFtb3VudCkgJiYgYW1vdW50ID4gMCAmJiBhbW91bnQgPCAxMDAwMCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBGb3VuZCBhbW91bnQgJHthbW91bnR9IG9uIGxpbmUgJHtpbmRleH06IFwiJHtsaW5lfVwiYCk7XG4gICAgICAgICAgYW1vdW50cy5wdXNoKGFtb3VudCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgY29uc3QgbWF4QW1vdW50ID0gYW1vdW50cy5sZW5ndGggPiAwID8gTWF0aC5tYXgoLi4uYW1vdW50cykgOiAwO1xuICAgIGNvbnNvbGUubG9nKGBVc2luZyBsYXJnZXN0IGFtb3VudCBmb3VuZDogJHttYXhBbW91bnR9YCk7XG4gICAgcmV0dXJuIG1heEFtb3VudDtcbiAgfVxuXG4gIHByaXZhdGUgZXh0cmFjdERhdGUobGluZXM6IHN0cmluZ1tdKTogc3RyaW5nIHtcbiAgICBjb25zdCBkYXRlUGF0dGVybnMgPSBbXG4gICAgICAvKFxcZHsxLDJ9XFwvXFxkezEsMn1cXC9cXGR7Miw0fSkvLFxuICAgICAgLyhcXGR7MSwyfS1cXGR7MSwyfS1cXGR7Miw0fSkvLFxuICAgICAgLyhcXGR7NH0tXFxkezJ9LVxcZHsyfSkvLFxuICAgICAgLyhKYW58RmVifE1hcnxBcHJ8TWF5fEp1bnxKdWx8QXVnfFNlcHxPY3R8Tm92fERlYykuKj8oXFxkezEsMn0pLD9cXHMqKFxcZHs0fSkvaVxuICAgIF07XG5cbiAgICBmb3IgKGNvbnN0IGxpbmUgb2YgbGluZXMpIHtcbiAgICAgIGZvciAoY29uc3QgcGF0dGVybiBvZiBkYXRlUGF0dGVybnMpIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBsaW5lLm1hdGNoKHBhdHRlcm4pO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gVHJ5IHRvIHBhcnNlIGFuZCBub3JtYWxpemUgdGhlIGRhdGVcbiAgICAgICAgICAgIGNvbnN0IGRhdGVTdHIgPSBtYXRjaFswXTtcbiAgICAgICAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShkYXRlU3RyKTtcbiAgICAgICAgICAgIGlmICghaXNOYU4oZGF0ZS5nZXRUaW1lKCkpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBkYXRlLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXTsgLy8gUmV0dXJuIFlZWVktTU0tREQgZm9ybWF0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRGVmYXVsdCB0byB0b2RheSBpZiBubyBkYXRlIGZvdW5kXG4gICAgcmV0dXJuIG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdO1xuICB9XG5cbiAgcHJpdmF0ZSBleHRyYWN0SXRlbXMobGluZXM6IHN0cmluZ1tdKTogQXJyYXk8eyBuYW1lOiBzdHJpbmc7IHByaWNlOiBudW1iZXI7IHF1YW50aXR5PzogbnVtYmVyIH0+IHtcbiAgICBjb25zdCBpdGVtczogQXJyYXk8eyBuYW1lOiBzdHJpbmc7IHByaWNlOiBudW1iZXI7IHF1YW50aXR5PzogbnVtYmVyIH0+ID0gW107XG5cbiAgICBjb25zb2xlLmxvZygn8J+UjSBFeHRyYWN0aW5nIGl0ZW1zIGZyb20gbGluZXMuLi4nKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGxpbmUgPSBsaW5lc1tpXS50cmltKCk7XG4gICAgICBpZiAobGluZS5sZW5ndGggPT09IDApIGNvbnRpbnVlO1xuXG4gICAgICAvLyBFbmhhbmNlZCBpdGVtIHBhdHRlcm5zXG4gICAgICBjb25zdCBpdGVtUGF0dGVybnMgPSBbXG4gICAgICAgIC9eKFxcZCspXFxzKyguKz8pXFxzK1skXT8oXFxkK1xcLlxcZHsyfSkkLywgICAgICAgIC8vIFwiMiBCQU5BTkFTICQzLjk5XCJcbiAgICAgICAgL14oXFxkKylcXHMrKC4rPylcXHMrKFxcZCtcXC5cXGR7Mn0pXFxzKiQvLCAgICAgICAgIC8vIFwiMiBCQU5BTkFTIDMuOTlcIlxuICAgICAgICAvXiguKz8pXFxzezIsfVskXT8oXFxkK1xcLlxcZHsyfSkkLywgICAgICAgICAgICAgLy8gXCJCQU5BTkFTICAgICQzLjk5XCIgKG11bHRpcGxlIHNwYWNlcylcbiAgICAgICAgL14oLis/KVxccytbJF0oXFxkK1xcLlxcZHsyfSkkLywgICAgICAgICAgICAgICAgIC8vIFwiQkFOQU5BUyAkMy45OVwiXG4gICAgICAgIC9eKC4rPylcXHMrKFxcZCtcXC5cXGR7Mn0pXFxzKiQvLCAgICAgICAgICAgICAgICAgLy8gXCJCQU5BTkFTIDMuOTlcIlxuICAgICAgICAvXiguezMsMzB9PylcXHMrKFxcZHsxLDN9XFwuXFxkezJ9KSQvICAgICAgICAgICAgLy8gR2VuZXJpYzogbmFtZSBmb2xsb3dlZCBieSBwcmljZVxuICAgICAgXTtcblxuICAgICAgZm9yIChjb25zdCBwYXR0ZXJuIG9mIGl0ZW1QYXR0ZXJucykge1xuICAgICAgICBjb25zdCBtYXRjaCA9IGxpbmUubWF0Y2gocGF0dGVybik7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgIGxldCBxdWFudGl0eTogbnVtYmVyIHwgdW5kZWZpbmVkO1xuICAgICAgICAgIGxldCBuYW1lOiBzdHJpbmc7XG4gICAgICAgICAgbGV0IHByaWNlOiBudW1iZXI7XG5cbiAgICAgICAgICBpZiAobWF0Y2gubGVuZ3RoID09PSA0KSB7XG4gICAgICAgICAgICAvLyBQYXR0ZXJuIHdpdGggcXVhbnRpdHlcbiAgICAgICAgICAgIHF1YW50aXR5ID0gcGFyc2VJbnQobWF0Y2hbMV0pO1xuICAgICAgICAgICAgbmFtZSA9IG1hdGNoWzJdLnRyaW0oKTtcbiAgICAgICAgICAgIHByaWNlID0gcGFyc2VGbG9hdChtYXRjaFszXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFBhdHRlcm4gd2l0aG91dCBxdWFudGl0eVxuICAgICAgICAgICAgbmFtZSA9IG1hdGNoWzFdLnRyaW0oKTtcbiAgICAgICAgICAgIHByaWNlID0gcGFyc2VGbG9hdChtYXRjaFsyXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhIHRheCBpdGVtIChpbmNsdWRlIGl0ISlcbiAgICAgICAgICBjb25zdCBpc1RheEl0ZW0gPSAvVEFYfEhTVHxHU1R8UFNUfFZBVC9pLnRlc3QobmFtZSkgfHwgL1RBWHxIU1R8R1NUfFBTVHxWQVQvaS50ZXN0KGxpbmUpO1xuXG4gICAgICAgICAgLy8gRW5oYW5jZWQgZmlsdGVyaW5nIGZvciBub24taXRlbSBsaW5lcyAoYnV0IGFsbG93IHRheCBpdGVtcylcbiAgICAgICAgICBjb25zdCBleGNsdWRlUGF0dGVybnMgPSBbXG4gICAgICAgICAgICAvVE9UQUx8U1VCVE9UQUx8Q0hBTkdFfEJBTEFOQ0V8UkVDRUlQVHxTVE9SRXxUSEFOS3xWSVNJVHxBR0FJTnxDVVNUT01FUnxDT1BZL2ksXG4gICAgICAgICAgICAvXihTVUJ8R1JBTkR8RklOQUwpL2ksXG4gICAgICAgICAgICAvUEFZTUVOVHxDQVNIfENSRURJVHxERUJJVHxDQVJEL2ksXG4gICAgICAgICAgICAvXihEQVRFfFRJTUV8Q0xFUkt8Q0FTSElFUikvaSxcbiAgICAgICAgICAgIC9eXFxkezEsMn1cXC9cXGR7MSwyfVxcL1xcZHsyLDR9LywgLy8gRGF0ZSBwYXR0ZXJuc1xuICAgICAgICAgICAgL15cXGR7Mn06XFxkezJ9LywgLy8gVGltZSBwYXR0ZXJuc1xuICAgICAgICAgIF07XG5cbiAgICAgICAgICBjb25zdCBzaG91bGRFeGNsdWRlID0gIWlzVGF4SXRlbSAmJiAoXG4gICAgICAgICAgICBleGNsdWRlUGF0dGVybnMuc29tZShwYXR0ZXJuID0+IHBhdHRlcm4udGVzdChuYW1lKSkgfHxcbiAgICAgICAgICAgIGV4Y2x1ZGVQYXR0ZXJucy5zb21lKHBhdHRlcm4gPT4gcGF0dGVybi50ZXN0KGxpbmUpKVxuICAgICAgICAgICk7XG5cbiAgICAgICAgICBpZiAobmFtZSAmJiAhc2hvdWxkRXhjbHVkZSAmJlxuICAgICAgICAgICAgICBuYW1lLmxlbmd0aCA+PSAyICYmIG5hbWUubGVuZ3RoIDw9IDUwICYmXG4gICAgICAgICAgICAgIHByaWNlID4gMCAmJiBwcmljZSA8PSAxMDAwICYmXG4gICAgICAgICAgICAgICFuYW1lLm1hdGNoKC9eXFxkKyQvKSAmJiAvLyBOb3QganVzdCBudW1iZXJzXG4gICAgICAgICAgICAgIG5hbWUubWF0Y2goL1tBLVphLXpdLykgIC8vIENvbnRhaW5zIGF0IGxlYXN0IG9uZSBsZXR0ZXJcbiAgICAgICAgICApIHtcblxuICAgICAgICAgICAgY29uc3QgaXRlbVR5cGUgPSBpc1RheEl0ZW0gPyAnIFtUQVhdJyA6ICcnO1xuICAgICAgICAgICAgY29uc29sZS5sb2coYOKchSBGb3VuZCBpdGVtOiBcIiR7bmFtZX1cIiAtICQke3ByaWNlfWAgKyAocXVhbnRpdHkgPyBgIChxdHk6ICR7cXVhbnRpdHl9KWAgOiAnJykgKyBpdGVtVHlwZSk7XG5cbiAgICAgICAgICAgIGl0ZW1zLnB1c2goe1xuICAgICAgICAgICAgICBuYW1lOiBuYW1lLnRvVXBwZXJDYXNlKCksXG4gICAgICAgICAgICAgIHByaWNlLFxuICAgICAgICAgICAgICBxdWFudGl0eVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coYEZvdW5kICR7aXRlbXMubGVuZ3RofSBpdGVtcyB0b3RhbGApO1xuICAgIHJldHVybiBpdGVtcztcbiAgfVxuXG4gIGFzeW5jIGNsZWFudXAoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKHRoaXMud29ya2VyKSB7XG4gICAgICBhd2FpdCB0aGlzLndvcmtlci50ZXJtaW5hdGUoKTtcbiAgICAgIHRoaXMud29ya2VyID0gbnVsbDtcbiAgICAgIHRoaXMuaXNJbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgY29uc29sZS5sb2coJ/Cfp7kgT0NSIGVuZ2luZSBjbGVhbmVkIHVwJyk7XG4gICAgfVxuICB9XG59XG5cbi8vIEV4cG9ydCBzaW5nbGV0b24gaW5zdGFuY2VcbmV4cG9ydCBjb25zdCBvY3JTZXJ2aWNlID0gbmV3IE9DUlNlcnZpY2UoKTsiXSwibmFtZXMiOlsiY3JlYXRlV29ya2VyIiwiT0NSU2VydmljZSIsImluaXRpYWxpemUiLCJpc0luaXRpYWxpemVkIiwiY29uc29sZSIsImxvZyIsIndvcmtlciIsInNldFBhcmFtZXRlcnMiLCJlcnJvciIsIkVycm9yIiwicHJlcHJvY2Vzc0ltYWdlIiwiaW1hZ2VGaWxlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJjYW52YXMiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJjdHgiLCJnZXRDb250ZXh0IiwiaW1nIiwiSW1hZ2UiLCJvbmxvYWQiLCJ3aWR0aCIsImhlaWdodCIsImRyYXdJbWFnZSIsImltYWdlRGF0YSIsImdldEltYWdlRGF0YSIsImRhdGEiLCJpIiwibGVuZ3RoIiwiZ3JheSIsIk1hdGgiLCJyb3VuZCIsImNvbnRyYXN0IiwiZmFjdG9yIiwiZW5oYW5jZWQiLCJtaW4iLCJtYXgiLCJwdXRJbWFnZURhdGEiLCJ0b0RhdGFVUkwiLCJvbmVycm9yIiwic3JjIiwiVVJMIiwiY3JlYXRlT2JqZWN0VVJMIiwicmVjb25zdHJ1Y3RBbGlnbmVkVGV4dCIsIm9jckRhdGEiLCJsaW5lcyIsInRleHQiLCJsaW5lIiwid29yZHMiLCJzb3J0ZWRXb3JkcyIsInNvcnQiLCJhIiwiYiIsImJib3giLCJ4MCIsImxpbmVUZXh0IiwibGFzdFgiLCJ3b3JkIiwid29yZFRleHQiLCJ0cmltIiwiY3VycmVudFgiLCJ3b3JkV2lkdGgiLCJ4MSIsImdhcCIsImF2Z0NoYXJXaWR0aCIsInNwYWNlc05lZWRlZCIsImZsb29yIiwicmVwZWF0IiwicHVzaCIsInJlY29uc3RydWN0ZWRUZXh0Iiwiam9pbiIsInN1YnN0cmluZyIsInByb2Nlc3NSZWNlaXB0SW1hZ2UiLCJyZXN1bHQiLCJwcmVwcm9jZXNzZWRJbWFnZSIsInJlY29nbml6ZSIsImNvbmZpZGVuY2UiLCJ0ZXh0TGVuZ3RoIiwid29yZHNGb3VuZCIsImFsaWduZWRUZXh0IiwicGFyc2VSZWNlaXB0VGV4dCIsIm9jclRleHQiLCJzcGxpdCIsIm1hcCIsImZpbHRlciIsIm1lcmNoYW50IiwiZXh0cmFjdE1lcmNoYW50IiwiaXRlbXMiLCJleHRyYWN0SXRlbXMiLCJhbW91bnQiLCJleHRyYWN0VmFsaWRhdGVkVG90YWwiLCJkYXRlIiwiZXh0cmFjdERhdGUiLCJwYXJzZWQiLCJyYXdUZXh0IiwibWVyY2hhbnRQYXR0ZXJucyIsIm1hdGNoIiwiaW5jbHVkZXMiLCJwYXR0ZXJuIiwidG9VcHBlckNhc2UiLCJub25NZXJjaGFudFdvcmRzIiwic29tZSIsIml0ZW1zVG90YWwiLCJyZWR1Y2UiLCJzdW0iLCJpdGVtIiwicHJpY2UiLCJ0b0ZpeGVkIiwidG90YWxQYXR0ZXJucyIsImZvdW5kVG90YWxzIiwicGFyc2VGbG9hdCIsImlzTmFOIiwidG90YWwiLCJkaWZmZXJlbmNlIiwiYWJzIiwic29ydGVkQnlDbG9zZW5lc3MiLCJjbG9zZXN0IiwiZXh0cmFjdFRvdGFsQW1vdW50Iiwic2xpY2UiLCJhbW91bnRzIiwiZm9yRWFjaCIsImluZGV4IiwibWF0Y2hlcyIsInJlcGxhY2UiLCJtYXhBbW91bnQiLCJkYXRlUGF0dGVybnMiLCJkYXRlU3RyIiwiRGF0ZSIsImdldFRpbWUiLCJ0b0lTT1N0cmluZyIsImUiLCJpdGVtUGF0dGVybnMiLCJxdWFudGl0eSIsIm5hbWUiLCJwYXJzZUludCIsImlzVGF4SXRlbSIsInRlc3QiLCJleGNsdWRlUGF0dGVybnMiLCJzaG91bGRFeGNsdWRlIiwiaXRlbVR5cGUiLCJjbGVhbnVwIiwidGVybWluYXRlIiwib2NyU2VydmljZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./services/ocrService.ts\n"));

/***/ })

});