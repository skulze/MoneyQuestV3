"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/transactions/page",{

/***/ "(app-pages-browser)/./lib/database/IndexedDBWrapper.ts":
/*!******************************************!*\
  !*** ./lib/database/IndexedDBWrapper.ts ***!
  \******************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IndexedDBWrapper: function() { return /* binding */ IndexedDBWrapper; }\n/* harmony export */ });\n/* harmony import */ var dexie__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! dexie */ \"(app-pages-browser)/../../node_modules/dexie/import-wrapper.mjs\");\n\nclass MoneyQuestDB extends dexie__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    constructor(){\n        super(\"MoneyQuestDB\");\n        this.version(1).stores({\n            users: \"id, cognitoId, email, createdAt\",\n            accounts: \"id, userId, name, type, isActive, createdAt\",\n            categories: \"id, userId, name, type, isDefault, createdAt\",\n            transactions: \"id, accountId, date, categoryId, isParent, parentTransactionId, createdAt\",\n            transaction_splits: \"id, transactionId, categoryId, createdAt\",\n            budgets: \"id, userId, categoryId, period, startDate, isActive, createdAt\",\n            currencies: \"id, code, name, isActive, createdAt\",\n            investments: \"id, portfolioId, symbol, createdAt\",\n            portfolios: \"id, userId, name, isActive, createdAt\",\n            net_worth_snapshots: \"id, userId, date, createdAt\"\n        });\n    }\n}\nclass IndexedDBWrapper {\n    // ==========================================\n    // Core CRUD Operations\n    // ==========================================\n    async insert(table, data) {\n        try {\n            const dbTable = this.getTable(table);\n            const id = await dbTable.add(data);\n            // Return the inserted data with the generated ID if needed\n            if (typeof id === \"string\" && data.id === undefined) {\n                return {\n                    ...data,\n                    id\n                };\n            }\n            return data;\n        } catch (error) {\n            console.error(\"Failed to insert into \".concat(table, \":\"), error);\n            throw new Error(\"Database insert failed: \".concat(error));\n        }\n    }\n    async query(table, filter) {\n        try {\n            const dbTable = this.getTable(table);\n            let collection = dbTable.toCollection();\n            if (filter) {\n                // Apply filters based on the filter object\n                if (filter.id) {\n                    return [\n                        await dbTable.get(filter.id)\n                    ];\n                }\n                // Apply common filters\n                Object.keys(filter).forEach((key)=>{\n                    if (filter[key] !== undefined && filter[key] !== null) {\n                        collection = collection.filter((item)=>{\n                            const value = item[key];\n                            const filterValue = filter[key];\n                            // Handle date range filters\n                            if (key === \"startDate\" && value instanceof Date) {\n                                return value >= filterValue;\n                            }\n                            if (key === \"endDate\" && value instanceof Date) {\n                                return value <= filterValue;\n                            }\n                            // Handle exact matches\n                            return value === filterValue;\n                        });\n                    }\n                });\n            }\n            const results = await collection.toArray();\n            return results;\n        } catch (error) {\n            console.error(\"Failed to query \".concat(table, \":\"), error);\n            throw new Error(\"Database query failed: \".concat(error));\n        }\n    }\n    async update(table, id, data) {\n        try {\n            const dbTable = this.getTable(table);\n            // Get existing record\n            const existing = await dbTable.get(id);\n            if (!existing) {\n                throw new Error(\"Record with id \".concat(id, \" not found in \").concat(table));\n            }\n            // Merge updates\n            const updated = {\n                ...existing,\n                ...data,\n                updatedAt: new Date()\n            };\n            // Update in database\n            await dbTable.update(id, updated);\n            return updated;\n        } catch (error) {\n            console.error(\"Failed to update \".concat(table, \":\"), error);\n            throw new Error(\"Database update failed: \".concat(error));\n        }\n    }\n    async delete(table, id) {\n        try {\n            const dbTable = this.getTable(table);\n            await dbTable.delete(id);\n        } catch (error) {\n            console.error(\"Failed to delete from \".concat(table, \":\"), error);\n            throw new Error(\"Database delete failed: \".concat(error));\n        }\n    }\n    // ==========================================\n    // Analytics Queries\n    // ==========================================\n    async getCategorySpending(userId, startDate, endDate) {\n        try {\n            // Get user's transactions in date range\n            const transactions = await this.db.transactions.where(\"date\").between(startDate, endDate, true, true).filter((t)=>{\n                // We need to check if the account belongs to the user\n                // This would normally be a JOIN operation\n                return true; // Simplified for now\n            }).toArray();\n            // Get user's categories\n            const categories = await this.db.categories.where(\"userId\").equals(userId).toArray();\n            // Calculate spending by category\n            const categoryMap = new Map();\n            // Initialize categories\n            categories.forEach((cat)=>{\n                categoryMap.set(cat.id, {\n                    categoryId: cat.id,\n                    categoryName: cat.name,\n                    totalAmount: 0,\n                    transactionCount: 0,\n                    percentage: 0\n                });\n            });\n            // Aggregate transaction amounts\n            let totalSpending = 0;\n            for (const transaction of transactions){\n                if (transaction.categoryId) {\n                    const category = categoryMap.get(transaction.categoryId);\n                    if (category) {\n                        category.totalAmount += Math.abs(transaction.originalAmount);\n                        category.transactionCount += 1;\n                        totalSpending += Math.abs(transaction.originalAmount);\n                    }\n                }\n                // Handle splits\n                const splits = await this.db.transaction_splits.where(\"transactionId\").equals(transaction.id).toArray();\n                splits.forEach((split)=>{\n                    const category = categoryMap.get(split.categoryId);\n                    if (category) {\n                        category.totalAmount += Math.abs(split.amount);\n                        totalSpending += Math.abs(split.amount);\n                    }\n                });\n            }\n            // Calculate percentages\n            categoryMap.forEach((category)=>{\n                if (totalSpending > 0) {\n                    category.percentage = category.totalAmount / totalSpending * 100;\n                }\n            });\n            return Array.from(categoryMap.values()).filter((cat)=>cat.totalAmount > 0).sort((a, b)=>b.totalAmount - a.totalAmount);\n        } catch (error) {\n            console.error(\"Failed to get category spending:\", error);\n            throw new Error(\"Analytics query failed: \".concat(error));\n        }\n    }\n    async getBudgetProgress(userId) {\n        try {\n            const budgets = await this.db.budgets.where(\"userId\").equals(userId).filter((b)=>b.isActive).toArray();\n            const budgetStatus = [];\n            for (const budget of budgets){\n                var _categorySpending_find;\n                // Calculate period start/end dates\n                const now = new Date();\n                let periodStart = new Date(budget.startDate);\n                let periodEnd = new Date(budget.startDate);\n                if (budget.period === \"monthly\") {\n                    periodStart = new Date(now.getFullYear(), now.getMonth(), 1);\n                    periodEnd = new Date(now.getFullYear(), now.getMonth() + 1, 0);\n                } else if (budget.period === \"yearly\") {\n                    periodStart = new Date(now.getFullYear(), 0, 1);\n                    periodEnd = new Date(now.getFullYear(), 11, 31);\n                }\n                // Calculate spending for this category in the period\n                const categorySpending = await this.getCategorySpending(userId, periodStart, periodEnd);\n                const spent = ((_categorySpending_find = categorySpending.find((c)=>c.categoryId === budget.categoryId)) === null || _categorySpending_find === void 0 ? void 0 : _categorySpending_find.totalAmount) || 0;\n                // Get category details\n                const category = await this.db.categories.get(budget.categoryId);\n                budgetStatus.push({\n                    budgetId: budget.id,\n                    categoryId: budget.categoryId,\n                    categoryName: (category === null || category === void 0 ? void 0 : category.name) || \"Unknown Category\",\n                    budgetAmount: budget.amount,\n                    spentAmount: spent,\n                    remainingAmount: budget.amount - spent,\n                    percentageUsed: spent / budget.amount * 100,\n                    period: budget.period,\n                    isOverBudget: spent > budget.amount\n                });\n            }\n            return budgetStatus;\n        } catch (error) {\n            console.error(\"Failed to get budget progress:\", error);\n            throw new Error(\"Budget progress query failed: \".concat(error));\n        }\n    }\n    // ==========================================\n    // Export/Import Operations\n    // ==========================================\n    async exportAll() {\n        try {\n            const data = {};\n            // Export all tables\n            const tables = [\n                \"users\",\n                \"accounts\",\n                \"categories\",\n                \"transactions\",\n                \"transaction_splits\",\n                \"budgets\",\n                \"currencies\",\n                \"investments\",\n                \"portfolios\",\n                \"net_worth_snapshots\"\n            ];\n            for (const tableName of tables){\n                const table = this.getTable(tableName);\n                data[tableName] = await table.toArray();\n            }\n            return {\n                version: 1,\n                exportedAt: new Date(),\n                data\n            };\n        } catch (error) {\n            console.error(\"Failed to export data:\", error);\n            throw new Error(\"Data export failed: \".concat(error));\n        }\n    }\n    async importData(importData) {\n        try {\n            if (!importData.data) {\n                throw new Error(\"Invalid import data format\");\n            }\n            // Clear existing data (optional - might want to merge instead)\n            await this.db.transaction(\"rw\", [\n                this.db.users,\n                this.db.accounts,\n                this.db.categories,\n                this.db.transactions,\n                this.db.transaction_splits,\n                this.db.budgets,\n                this.db.currencies,\n                this.db.investments,\n                this.db.portfolios,\n                this.db.net_worth_snapshots\n            ], async ()=>{\n                // Import data table by table\n                const tables = [\n                    \"users\",\n                    \"accounts\",\n                    \"categories\",\n                    \"transactions\",\n                    \"transaction_splits\",\n                    \"budgets\",\n                    \"currencies\",\n                    \"investments\",\n                    \"portfolios\",\n                    \"net_worth_snapshots\"\n                ];\n                for (const tableName of tables){\n                    if (importData.data[tableName]) {\n                        const table = this.getTable(tableName);\n                        await table.bulkAdd(importData.data[tableName]);\n                    }\n                }\n            });\n        } catch (error) {\n            console.error(\"Failed to import data:\", error);\n            throw new Error(\"Data import failed: \".concat(error));\n        }\n    }\n    // ==========================================\n    // Utility Methods\n    // ==========================================\n    getTable(tableName) {\n        const table = this.db[tableName];\n        if (!table) {\n            throw new Error(\"Table \".concat(tableName, \" not found\"));\n        }\n        return table;\n    }\n    // Initialize with default data\n    async initialize(userId) {\n        try {\n            console.log(\"Starting IndexedDB initialization for user: \".concat(userId));\n            // Check if already initialized\n            const user = await this.db.users.get(userId);\n            if (user) {\n                console.log(\"User \".concat(userId, \" already initialized\"));\n                return; // Already initialized\n            }\n            console.log(\"Creating new user profile for: \".concat(userId));\n            // Create user record\n            const newUser = {\n                id: userId,\n                cognitoId: userId,\n                email: \"\".concat(userId, \"@moneyquest.com\"),\n                preferences: JSON.stringify({\n                    theme: \"light\",\n                    currency: \"USD\"\n                }),\n                createdAt: new Date(),\n                updatedAt: new Date()\n            };\n            // Create default currencies\n            const defaultCurrencies = [\n                {\n                    id: \"usd\",\n                    code: \"USD\",\n                    name: \"US Dollar\",\n                    symbol: \"$\",\n                    isActive: true,\n                    createdAt: new Date(),\n                    updatedAt: new Date()\n                },\n                {\n                    id: \"eur\",\n                    code: \"EUR\",\n                    name: \"Euro\",\n                    symbol: \"€\",\n                    isActive: true,\n                    createdAt: new Date(),\n                    updatedAt: new Date()\n                }\n            ];\n            // Create default categories\n            const defaultCategories = [\n                {\n                    name: \"Groceries\",\n                    type: \"expense\",\n                    color: \"#10B981\"\n                },\n                {\n                    name: \"Transportation\",\n                    type: \"expense\",\n                    color: \"#3B82F6\"\n                },\n                {\n                    name: \"Housing\",\n                    type: \"expense\",\n                    color: \"#8B5CF6\"\n                },\n                {\n                    name: \"Utilities\",\n                    type: \"expense\",\n                    color: \"#F59E0B\"\n                },\n                {\n                    name: \"Entertainment\",\n                    type: \"expense\",\n                    color: \"#EF4444\"\n                },\n                {\n                    name: \"Healthcare\",\n                    type: \"expense\",\n                    color: \"#EC4899\"\n                },\n                {\n                    name: \"Salary\",\n                    type: \"income\",\n                    color: \"#059669\"\n                },\n                {\n                    name: \"Investment\",\n                    type: \"income\",\n                    color: \"#0891B2\"\n                }\n            ].map((cat)=>({\n                    id: \"\".concat(userId, \"-\").concat(cat.name.toLowerCase().replace(/\\s+/g, \"-\")),\n                    userId,\n                    ...cat,\n                    isDefault: true,\n                    createdAt: new Date(),\n                    updatedAt: new Date()\n                }));\n            // Create some demo accounts for new users\n            const defaultAccounts = [\n                {\n                    id: \"\".concat(userId, \"-checking\"),\n                    userId,\n                    name: \"Checking Account\",\n                    type: \"checking\",\n                    balance: 2500.00,\n                    currencyId: \"usd\",\n                    isActive: true,\n                    createdAt: new Date(),\n                    updatedAt: new Date()\n                },\n                {\n                    id: \"\".concat(userId, \"-savings\"),\n                    userId,\n                    name: \"Savings Account\",\n                    type: \"savings\",\n                    balance: 12500.00,\n                    currencyId: \"usd\",\n                    isActive: true,\n                    createdAt: new Date(),\n                    updatedAt: new Date()\n                }\n            ];\n            // Initialize database with transaction\n            await this.db.transaction(\"rw\", [\n                this.db.users,\n                this.db.currencies,\n                this.db.categories,\n                this.db.accounts\n            ], async ()=>{\n                console.log(\"Creating user record...\");\n                await this.db.users.add(newUser);\n                console.log(\"Adding default currencies...\");\n                // Add currencies (only if not exist)\n                for (const currency of defaultCurrencies){\n                    const existing = await this.db.currencies.get(currency.id);\n                    if (!existing) {\n                        await this.db.currencies.add(currency);\n                    }\n                }\n                console.log(\"Adding default categories...\");\n                await this.db.categories.bulkAdd(defaultCategories);\n                console.log(\"Adding default accounts...\");\n                await this.db.accounts.bulkAdd(defaultAccounts);\n            });\n            console.log(\"Successfully initialized database for user: \".concat(userId));\n        } catch (error) {\n            console.error(\"Failed to initialize database:\", error);\n            throw new Error(\"Database initialization failed: \".concat(error));\n        }\n    }\n    constructor(){\n        this.db = new MoneyQuestDB();\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9kYXRhYmFzZS9JbmRleGVkREJXcmFwcGVyLnRzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXFDO0FBeUhyQyxNQUFNQyxxQkFBcUJELDZDQUFLQTtJQVk5QkUsYUFBYztRQUNaLEtBQUssQ0FBQztRQUVOLElBQUksQ0FBQ0MsT0FBTyxDQUFDLEdBQUdDLE1BQU0sQ0FBQztZQUNyQkMsT0FBTztZQUNQQyxVQUFVO1lBQ1ZDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxvQkFBb0I7WUFDcEJDLFNBQVM7WUFDVEMsWUFBWTtZQUNaQyxhQUFhO1lBQ2JDLFlBQVk7WUFDWkMscUJBQXFCO1FBQ3ZCO0lBQ0Y7QUFDRjtBQUVPLE1BQU1DO0lBT1gsNkNBQTZDO0lBQzdDLHVCQUF1QjtJQUN2Qiw2Q0FBNkM7SUFFN0MsTUFBTUMsT0FBVUMsS0FBYSxFQUFFQyxJQUFPLEVBQWM7UUFDbEQsSUFBSTtZQUNGLE1BQU1DLFVBQVUsSUFBSSxDQUFDQyxRQUFRLENBQUNIO1lBQzlCLE1BQU1JLEtBQUssTUFBTUYsUUFBUUcsR0FBRyxDQUFDSjtZQUU3QiwyREFBMkQ7WUFDM0QsSUFBSSxPQUFPRyxPQUFPLFlBQVksS0FBY0EsRUFBRSxLQUFLRSxXQUFXO2dCQUM1RCxPQUFPO29CQUFFLEdBQUdMLElBQUk7b0JBQUVHO2dCQUFHO1lBQ3ZCO1lBRUEsT0FBT0g7UUFDVCxFQUFFLE9BQU9NLE9BQU87WUFDZEMsUUFBUUQsS0FBSyxDQUFDLHlCQUErQixPQUFOUCxPQUFNLE1BQUlPO1lBQ2pELE1BQU0sSUFBSUUsTUFBTSwyQkFBaUMsT0FBTkY7UUFDN0M7SUFDRjtJQUVBLE1BQU1HLE1BQVNWLEtBQWEsRUFBRVcsTUFBWSxFQUFnQjtRQUN4RCxJQUFJO1lBQ0YsTUFBTVQsVUFBVSxJQUFJLENBQUNDLFFBQVEsQ0FBQ0g7WUFDOUIsSUFBSVksYUFBYVYsUUFBUVcsWUFBWTtZQUVyQyxJQUFJRixRQUFRO2dCQUNWLDJDQUEyQztnQkFDM0MsSUFBSUEsT0FBT1AsRUFBRSxFQUFFO29CQUNiLE9BQU87d0JBQUUsTUFBTUYsUUFBUVksR0FBRyxDQUFDSCxPQUFPUCxFQUFFO3FCQUFHO2dCQUN6QztnQkFFQSx1QkFBdUI7Z0JBQ3ZCVyxPQUFPQyxJQUFJLENBQUNMLFFBQVFNLE9BQU8sQ0FBQ0MsQ0FBQUE7b0JBQzFCLElBQUlQLE1BQU0sQ0FBQ08sSUFBSSxLQUFLWixhQUFhSyxNQUFNLENBQUNPLElBQUksS0FBSyxNQUFNO3dCQUNyRE4sYUFBYUEsV0FBV0QsTUFBTSxDQUFDUSxDQUFBQTs0QkFDN0IsTUFBTUMsUUFBUSxJQUFhLENBQUNGLElBQUk7NEJBQ2hDLE1BQU1HLGNBQWNWLE1BQU0sQ0FBQ08sSUFBSTs0QkFFL0IsNEJBQTRCOzRCQUM1QixJQUFJQSxRQUFRLGVBQWVFLGlCQUFpQkUsTUFBTTtnQ0FDaEQsT0FBT0YsU0FBU0M7NEJBQ2xCOzRCQUNBLElBQUlILFFBQVEsYUFBYUUsaUJBQWlCRSxNQUFNO2dDQUM5QyxPQUFPRixTQUFTQzs0QkFDbEI7NEJBRUEsdUJBQXVCOzRCQUN2QixPQUFPRCxVQUFVQzt3QkFDbkI7b0JBQ0Y7Z0JBQ0Y7WUFDRjtZQUVBLE1BQU1FLFVBQVUsTUFBTVgsV0FBV1ksT0FBTztZQUN4QyxPQUFPRDtRQUNULEVBQUUsT0FBT2hCLE9BQU87WUFDZEMsUUFBUUQsS0FBSyxDQUFDLG1CQUF5QixPQUFOUCxPQUFNLE1BQUlPO1lBQzNDLE1BQU0sSUFBSUUsTUFBTSwwQkFBZ0MsT0FBTkY7UUFDNUM7SUFDRjtJQUVBLE1BQU1rQixPQUFVekIsS0FBYSxFQUFFSSxFQUFVLEVBQUVILElBQWdCLEVBQWM7UUFDdkUsSUFBSTtZQUNGLE1BQU1DLFVBQVUsSUFBSSxDQUFDQyxRQUFRLENBQUNIO1lBRTlCLHNCQUFzQjtZQUN0QixNQUFNMEIsV0FBVyxNQUFNeEIsUUFBUVksR0FBRyxDQUFDVjtZQUNuQyxJQUFJLENBQUNzQixVQUFVO2dCQUNiLE1BQU0sSUFBSWpCLE1BQU0sa0JBQXFDVCxPQUFuQkksSUFBRyxrQkFBc0IsT0FBTko7WUFDdkQ7WUFFQSxnQkFBZ0I7WUFDaEIsTUFBTTJCLFVBQVU7Z0JBQUUsR0FBR0QsUUFBUTtnQkFBRSxHQUFHekIsSUFBSTtnQkFBRTJCLFdBQVcsSUFBSU47WUFBTztZQUU5RCxxQkFBcUI7WUFDckIsTUFBTXBCLFFBQVF1QixNQUFNLENBQUNyQixJQUFJdUI7WUFFekIsT0FBT0E7UUFDVCxFQUFFLE9BQU9wQixPQUFPO1lBQ2RDLFFBQVFELEtBQUssQ0FBQyxvQkFBMEIsT0FBTlAsT0FBTSxNQUFJTztZQUM1QyxNQUFNLElBQUlFLE1BQU0sMkJBQWlDLE9BQU5GO1FBQzdDO0lBQ0Y7SUFFQSxNQUFNc0IsT0FBTzdCLEtBQWEsRUFBRUksRUFBVSxFQUFpQjtRQUNyRCxJQUFJO1lBQ0YsTUFBTUYsVUFBVSxJQUFJLENBQUNDLFFBQVEsQ0FBQ0g7WUFDOUIsTUFBTUUsUUFBUTJCLE1BQU0sQ0FBQ3pCO1FBQ3ZCLEVBQUUsT0FBT0csT0FBTztZQUNkQyxRQUFRRCxLQUFLLENBQUMseUJBQStCLE9BQU5QLE9BQU0sTUFBSU87WUFDakQsTUFBTSxJQUFJRSxNQUFNLDJCQUFpQyxPQUFORjtRQUM3QztJQUNGO0lBRUEsNkNBQTZDO0lBQzdDLG9CQUFvQjtJQUNwQiw2Q0FBNkM7SUFFN0MsTUFBTXVCLG9CQUFvQkMsTUFBYyxFQUFFQyxTQUFlLEVBQUVDLE9BQWEsRUFBNEI7UUFDbEcsSUFBSTtZQUNGLHdDQUF3QztZQUN4QyxNQUFNMUMsZUFBZSxNQUFNLElBQUksQ0FBQzJDLEVBQUUsQ0FBQzNDLFlBQVksQ0FDNUM0QyxLQUFLLENBQUMsUUFDTkMsT0FBTyxDQUFDSixXQUFXQyxTQUFTLE1BQU0sTUFDbEN0QixNQUFNLENBQUMwQixDQUFBQTtnQkFDTixzREFBc0Q7Z0JBQ3RELDBDQUEwQztnQkFDMUMsT0FBTyxNQUFNLHFCQUFxQjtZQUNwQyxHQUNDYixPQUFPO1lBRVYsd0JBQXdCO1lBQ3hCLE1BQU1sQyxhQUFhLE1BQU0sSUFBSSxDQUFDNEMsRUFBRSxDQUFDNUMsVUFBVSxDQUN4QzZDLEtBQUssQ0FBQyxVQUNORyxNQUFNLENBQUNQLFFBQ1BQLE9BQU87WUFFVixpQ0FBaUM7WUFDakMsTUFBTWUsY0FBYyxJQUFJQztZQUV4Qix3QkFBd0I7WUFDeEJsRCxXQUFXMkIsT0FBTyxDQUFDd0IsQ0FBQUE7Z0JBQ2pCRixZQUFZRyxHQUFHLENBQUNELElBQUlyQyxFQUFFLEVBQUU7b0JBQ3RCdUMsWUFBWUYsSUFBSXJDLEVBQUU7b0JBQ2xCd0MsY0FBY0gsSUFBSUksSUFBSTtvQkFDdEJDLGFBQWE7b0JBQ2JDLGtCQUFrQjtvQkFDbEJDLFlBQVk7Z0JBQ2Q7WUFDRjtZQUVBLGdDQUFnQztZQUNoQyxJQUFJQyxnQkFBZ0I7WUFFcEIsS0FBSyxNQUFNQyxlQUFlM0QsYUFBYztnQkFDdEMsSUFBSTJELFlBQVlQLFVBQVUsRUFBRTtvQkFDMUIsTUFBTVEsV0FBV1osWUFBWXpCLEdBQUcsQ0FBQ29DLFlBQVlQLFVBQVU7b0JBQ3ZELElBQUlRLFVBQVU7d0JBQ1pBLFNBQVNMLFdBQVcsSUFBSU0sS0FBS0MsR0FBRyxDQUFDSCxZQUFZSSxjQUFjO3dCQUMzREgsU0FBU0osZ0JBQWdCLElBQUk7d0JBQzdCRSxpQkFBaUJHLEtBQUtDLEdBQUcsQ0FBQ0gsWUFBWUksY0FBYztvQkFDdEQ7Z0JBQ0Y7Z0JBRUEsZ0JBQWdCO2dCQUNoQixNQUFNQyxTQUFTLE1BQU0sSUFBSSxDQUFDckIsRUFBRSxDQUFDMUMsa0JBQWtCLENBQzVDMkMsS0FBSyxDQUFDLGlCQUNORyxNQUFNLENBQUNZLFlBQVk5QyxFQUFFLEVBQ3JCb0IsT0FBTztnQkFFVitCLE9BQU90QyxPQUFPLENBQUN1QyxDQUFBQTtvQkFDYixNQUFNTCxXQUFXWixZQUFZekIsR0FBRyxDQUFDMEMsTUFBTWIsVUFBVTtvQkFDakQsSUFBSVEsVUFBVTt3QkFDWkEsU0FBU0wsV0FBVyxJQUFJTSxLQUFLQyxHQUFHLENBQUNHLE1BQU1DLE1BQU07d0JBQzdDUixpQkFBaUJHLEtBQUtDLEdBQUcsQ0FBQ0csTUFBTUMsTUFBTTtvQkFDeEM7Z0JBQ0Y7WUFDRjtZQUVBLHdCQUF3QjtZQUN4QmxCLFlBQVl0QixPQUFPLENBQUNrQyxDQUFBQTtnQkFDbEIsSUFBSUYsZ0JBQWdCLEdBQUc7b0JBQ3JCRSxTQUFTSCxVQUFVLEdBQUcsU0FBVUYsV0FBVyxHQUFHRyxnQkFBaUI7Z0JBQ2pFO1lBQ0Y7WUFFQSxPQUFPUyxNQUFNQyxJQUFJLENBQUNwQixZQUFZcUIsTUFBTSxJQUNqQ2pELE1BQU0sQ0FBQzhCLENBQUFBLE1BQU9BLElBQUlLLFdBQVcsR0FBRyxHQUNoQ2UsSUFBSSxDQUFDLENBQUNDLEdBQUdDLElBQU1BLEVBQUVqQixXQUFXLEdBQUdnQixFQUFFaEIsV0FBVztRQUVqRCxFQUFFLE9BQU92QyxPQUFPO1lBQ2RDLFFBQVFELEtBQUssQ0FBQyxvQ0FBb0NBO1lBQ2xELE1BQU0sSUFBSUUsTUFBTSwyQkFBaUMsT0FBTkY7UUFDN0M7SUFDRjtJQUVBLE1BQU15RCxrQkFBa0JqQyxNQUFjLEVBQTJCO1FBQy9ELElBQUk7WUFDRixNQUFNdEMsVUFBVSxNQUFNLElBQUksQ0FBQ3lDLEVBQUUsQ0FBQ3pDLE9BQU8sQ0FDbEMwQyxLQUFLLENBQUMsVUFDTkcsTUFBTSxDQUFDUCxRQUNQcEIsTUFBTSxDQUFDb0QsQ0FBQUEsSUFBS0EsRUFBRUUsUUFBUSxFQUN0QnpDLE9BQU87WUFFVixNQUFNMEMsZUFBK0IsRUFBRTtZQUV2QyxLQUFLLE1BQU1DLFVBQVUxRSxRQUFTO29CQWdCZDJFO2dCQWZkLG1DQUFtQztnQkFDbkMsTUFBTUMsTUFBTSxJQUFJL0M7Z0JBQ2hCLElBQUlnRCxjQUFjLElBQUloRCxLQUFLNkMsT0FBT25DLFNBQVM7Z0JBQzNDLElBQUl1QyxZQUFZLElBQUlqRCxLQUFLNkMsT0FBT25DLFNBQVM7Z0JBRXpDLElBQUltQyxPQUFPSyxNQUFNLEtBQUssV0FBVztvQkFDL0JGLGNBQWMsSUFBSWhELEtBQUsrQyxJQUFJSSxXQUFXLElBQUlKLElBQUlLLFFBQVEsSUFBSTtvQkFDMURILFlBQVksSUFBSWpELEtBQUsrQyxJQUFJSSxXQUFXLElBQUlKLElBQUlLLFFBQVEsS0FBSyxHQUFHO2dCQUM5RCxPQUFPLElBQUlQLE9BQU9LLE1BQU0sS0FBSyxVQUFVO29CQUNyQ0YsY0FBYyxJQUFJaEQsS0FBSytDLElBQUlJLFdBQVcsSUFBSSxHQUFHO29CQUM3Q0YsWUFBWSxJQUFJakQsS0FBSytDLElBQUlJLFdBQVcsSUFBSSxJQUFJO2dCQUM5QztnQkFFQSxxREFBcUQ7Z0JBQ3JELE1BQU1MLG1CQUFtQixNQUFNLElBQUksQ0FBQ3RDLG1CQUFtQixDQUFDQyxRQUFRdUMsYUFBYUM7Z0JBQzdFLE1BQU1JLFFBQVFQLEVBQUFBLHlCQUFBQSxpQkFBaUJRLElBQUksQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRWxDLFVBQVUsS0FBS3dCLE9BQU94QixVQUFVLGVBQTdEeUIsNkNBQUFBLHVCQUFnRXRCLFdBQVcsS0FBSTtnQkFFN0YsdUJBQXVCO2dCQUN2QixNQUFNSyxXQUFXLE1BQU0sSUFBSSxDQUFDakIsRUFBRSxDQUFDNUMsVUFBVSxDQUFDd0IsR0FBRyxDQUFDcUQsT0FBT3hCLFVBQVU7Z0JBRS9EdUIsYUFBYVksSUFBSSxDQUFDO29CQUNoQkMsVUFBVVosT0FBTy9ELEVBQUU7b0JBQ25CdUMsWUFBWXdCLE9BQU94QixVQUFVO29CQUM3QkMsY0FBY08sQ0FBQUEscUJBQUFBLCtCQUFBQSxTQUFVTixJQUFJLEtBQUk7b0JBQ2hDbUMsY0FBY2IsT0FBT1YsTUFBTTtvQkFDM0J3QixhQUFhTjtvQkFDYk8saUJBQWlCZixPQUFPVixNQUFNLEdBQUdrQjtvQkFDakNRLGdCQUFnQixRQUFTaEIsT0FBT1YsTUFBTSxHQUFJO29CQUMxQ2UsUUFBUUwsT0FBT0ssTUFBTTtvQkFDckJZLGNBQWNULFFBQVFSLE9BQU9WLE1BQU07Z0JBQ3JDO1lBQ0Y7WUFFQSxPQUFPUztRQUNULEVBQUUsT0FBTzNELE9BQU87WUFDZEMsUUFBUUQsS0FBSyxDQUFDLGtDQUFrQ0E7WUFDaEQsTUFBTSxJQUFJRSxNQUFNLGlDQUF1QyxPQUFORjtRQUNuRDtJQUNGO0lBRUEsNkNBQTZDO0lBQzdDLDJCQUEyQjtJQUMzQiw2Q0FBNkM7SUFFN0MsTUFBTThFLFlBQTBCO1FBQzlCLElBQUk7WUFDRixNQUFNcEYsT0FBWSxDQUFDO1lBRW5CLG9CQUFvQjtZQUNwQixNQUFNcUYsU0FBUztnQkFDYjtnQkFBUztnQkFBWTtnQkFBYztnQkFDbkM7Z0JBQXNCO2dCQUFXO2dCQUNqQztnQkFBZTtnQkFBYzthQUM5QjtZQUVELEtBQUssTUFBTUMsYUFBYUQsT0FBUTtnQkFDOUIsTUFBTXRGLFFBQVEsSUFBSSxDQUFDRyxRQUFRLENBQUNvRjtnQkFDNUJ0RixJQUFJLENBQUNzRixVQUFVLEdBQUcsTUFBTXZGLE1BQU13QixPQUFPO1lBQ3ZDO1lBRUEsT0FBTztnQkFDTHRDLFNBQVM7Z0JBQ1RzRyxZQUFZLElBQUlsRTtnQkFDaEJyQjtZQUNGO1FBQ0YsRUFBRSxPQUFPTSxPQUFPO1lBQ2RDLFFBQVFELEtBQUssQ0FBQywwQkFBMEJBO1lBQ3hDLE1BQU0sSUFBSUUsTUFBTSx1QkFBNkIsT0FBTkY7UUFDekM7SUFDRjtJQUVBLE1BQU1rRixXQUFXQSxVQUFlLEVBQWlCO1FBQy9DLElBQUk7WUFDRixJQUFJLENBQUNBLFdBQVd4RixJQUFJLEVBQUU7Z0JBQ3BCLE1BQU0sSUFBSVEsTUFBTTtZQUNsQjtZQUVBLCtEQUErRDtZQUMvRCxNQUFNLElBQUksQ0FBQ3lCLEVBQUUsQ0FBQ2dCLFdBQVcsQ0FBQyxNQUFNO2dCQUM5QixJQUFJLENBQUNoQixFQUFFLENBQUM5QyxLQUFLO2dCQUFFLElBQUksQ0FBQzhDLEVBQUUsQ0FBQzdDLFFBQVE7Z0JBQUUsSUFBSSxDQUFDNkMsRUFBRSxDQUFDNUMsVUFBVTtnQkFDbkQsSUFBSSxDQUFDNEMsRUFBRSxDQUFDM0MsWUFBWTtnQkFBRSxJQUFJLENBQUMyQyxFQUFFLENBQUMxQyxrQkFBa0I7Z0JBQ2hELElBQUksQ0FBQzBDLEVBQUUsQ0FBQ3pDLE9BQU87Z0JBQUUsSUFBSSxDQUFDeUMsRUFBRSxDQUFDeEMsVUFBVTtnQkFBRSxJQUFJLENBQUN3QyxFQUFFLENBQUN2QyxXQUFXO2dCQUN4RCxJQUFJLENBQUN1QyxFQUFFLENBQUN0QyxVQUFVO2dCQUFFLElBQUksQ0FBQ3NDLEVBQUUsQ0FBQ3JDLG1CQUFtQjthQUNoRCxFQUFFO2dCQUNELDZCQUE2QjtnQkFDN0IsTUFBTXlGLFNBQVM7b0JBQ2I7b0JBQVM7b0JBQVk7b0JBQWM7b0JBQ25DO29CQUFzQjtvQkFBVztvQkFDakM7b0JBQWU7b0JBQWM7aUJBQzlCO2dCQUVELEtBQUssTUFBTUMsYUFBYUQsT0FBUTtvQkFDOUIsSUFBSUcsV0FBV3hGLElBQUksQ0FBQ3NGLFVBQVUsRUFBRTt3QkFDOUIsTUFBTXZGLFFBQVEsSUFBSSxDQUFDRyxRQUFRLENBQUNvRjt3QkFDNUIsTUFBTXZGLE1BQU0wRixPQUFPLENBQUNELFdBQVd4RixJQUFJLENBQUNzRixVQUFVO29CQUNoRDtnQkFDRjtZQUNGO1FBRUYsRUFBRSxPQUFPaEYsT0FBTztZQUNkQyxRQUFRRCxLQUFLLENBQUMsMEJBQTBCQTtZQUN4QyxNQUFNLElBQUlFLE1BQU0sdUJBQTZCLE9BQU5GO1FBQ3pDO0lBQ0Y7SUFFQSw2Q0FBNkM7SUFDN0Msa0JBQWtCO0lBQ2xCLDZDQUE2QztJQUVyQ0osU0FBU29GLFNBQWlCLEVBQVM7UUFDekMsTUFBTXZGLFFBQVEsSUFBSyxDQUFDa0MsRUFBRSxDQUFTcUQsVUFBVTtRQUN6QyxJQUFJLENBQUN2RixPQUFPO1lBQ1YsTUFBTSxJQUFJUyxNQUFNLFNBQW1CLE9BQVY4RSxXQUFVO1FBQ3JDO1FBQ0EsT0FBT3ZGO0lBQ1Q7SUFFQSwrQkFBK0I7SUFDL0IsTUFBTTJGLFdBQVc1RCxNQUFjLEVBQWlCO1FBQzlDLElBQUk7WUFDRnZCLFFBQVFvRixHQUFHLENBQUMsK0NBQXNELE9BQVA3RDtZQUUzRCwrQkFBK0I7WUFDL0IsTUFBTThELE9BQU8sTUFBTSxJQUFJLENBQUMzRCxFQUFFLENBQUM5QyxLQUFLLENBQUMwQixHQUFHLENBQUNpQjtZQUNyQyxJQUFJOEQsTUFBTTtnQkFDUnJGLFFBQVFvRixHQUFHLENBQUMsUUFBZSxPQUFQN0QsUUFBTztnQkFDM0IsUUFBUSxzQkFBc0I7WUFDaEM7WUFFQXZCLFFBQVFvRixHQUFHLENBQUMsa0NBQXlDLE9BQVA3RDtZQUU5QyxxQkFBcUI7WUFDckIsTUFBTStELFVBQVU7Z0JBQ2QxRixJQUFJMkI7Z0JBQ0pnRSxXQUFXaEU7Z0JBQ1hpRSxPQUFPLEdBQVUsT0FBUGpFLFFBQU87Z0JBQ2pCa0UsYUFBYUMsS0FBS0MsU0FBUyxDQUFDO29CQUFFQyxPQUFPO29CQUFTQyxVQUFVO2dCQUFNO2dCQUM5REMsV0FBVyxJQUFJaEY7Z0JBQ2ZNLFdBQVcsSUFBSU47WUFDakI7WUFFQSw0QkFBNEI7WUFDNUIsTUFBTWlGLG9CQUFvQjtnQkFDeEI7b0JBQ0VuRyxJQUFJO29CQUNKb0csTUFBTTtvQkFDTjNELE1BQU07b0JBQ040RCxRQUFRO29CQUNSeEMsVUFBVTtvQkFDVnFDLFdBQVcsSUFBSWhGO29CQUNmTSxXQUFXLElBQUlOO2dCQUNqQjtnQkFDQTtvQkFDRWxCLElBQUk7b0JBQ0pvRyxNQUFNO29CQUNOM0QsTUFBTTtvQkFDTjRELFFBQVE7b0JBQ1J4QyxVQUFVO29CQUNWcUMsV0FBVyxJQUFJaEY7b0JBQ2ZNLFdBQVcsSUFBSU47Z0JBQ2pCO2FBQ0Q7WUFFRCw0QkFBNEI7WUFDNUIsTUFBTW9GLG9CQUFvQjtnQkFDeEI7b0JBQUU3RCxNQUFNO29CQUFhOEQsTUFBTTtvQkFBV0MsT0FBTztnQkFBVTtnQkFDdkQ7b0JBQUUvRCxNQUFNO29CQUFrQjhELE1BQU07b0JBQVdDLE9BQU87Z0JBQVU7Z0JBQzVEO29CQUFFL0QsTUFBTTtvQkFBVzhELE1BQU07b0JBQVdDLE9BQU87Z0JBQVU7Z0JBQ3JEO29CQUFFL0QsTUFBTTtvQkFBYThELE1BQU07b0JBQVdDLE9BQU87Z0JBQVU7Z0JBQ3ZEO29CQUFFL0QsTUFBTTtvQkFBaUI4RCxNQUFNO29CQUFXQyxPQUFPO2dCQUFVO2dCQUMzRDtvQkFBRS9ELE1BQU07b0JBQWM4RCxNQUFNO29CQUFXQyxPQUFPO2dCQUFVO2dCQUN4RDtvQkFBRS9ELE1BQU07b0JBQVU4RCxNQUFNO29CQUFVQyxPQUFPO2dCQUFVO2dCQUNuRDtvQkFBRS9ELE1BQU07b0JBQWM4RCxNQUFNO29CQUFVQyxPQUFPO2dCQUFVO2FBQ3hELENBQUNDLEdBQUcsQ0FBQ3BFLENBQUFBLE1BQVE7b0JBQ1pyQyxJQUFJLEdBQWFxQyxPQUFWVixRQUFPLEtBQStDLE9BQTVDVSxJQUFJSSxJQUFJLENBQUNpRSxXQUFXLEdBQUdDLE9BQU8sQ0FBQyxRQUFRO29CQUN4RGhGO29CQUNBLEdBQUdVLEdBQUc7b0JBQ051RSxXQUFXO29CQUNYVixXQUFXLElBQUloRjtvQkFDZk0sV0FBVyxJQUFJTjtnQkFDakI7WUFFQSwwQ0FBMEM7WUFDMUMsTUFBTTJGLGtCQUFrQjtnQkFDdEI7b0JBQ0U3RyxJQUFJLEdBQVUsT0FBUDJCLFFBQU87b0JBQ2RBO29CQUNBYyxNQUFNO29CQUNOOEQsTUFBTTtvQkFDTk8sU0FBUztvQkFDVEMsWUFBWTtvQkFDWmxELFVBQVU7b0JBQ1ZxQyxXQUFXLElBQUloRjtvQkFDZk0sV0FBVyxJQUFJTjtnQkFDakI7Z0JBQ0E7b0JBQ0VsQixJQUFJLEdBQVUsT0FBUDJCLFFBQU87b0JBQ2RBO29CQUNBYyxNQUFNO29CQUNOOEQsTUFBTTtvQkFDTk8sU0FBUztvQkFDVEMsWUFBWTtvQkFDWmxELFVBQVU7b0JBQ1ZxQyxXQUFXLElBQUloRjtvQkFDZk0sV0FBVyxJQUFJTjtnQkFDakI7YUFDRDtZQUVELHVDQUF1QztZQUN2QyxNQUFNLElBQUksQ0FBQ1ksRUFBRSxDQUFDZ0IsV0FBVyxDQUFDLE1BQU07Z0JBQzlCLElBQUksQ0FBQ2hCLEVBQUUsQ0FBQzlDLEtBQUs7Z0JBQ2IsSUFBSSxDQUFDOEMsRUFBRSxDQUFDeEMsVUFBVTtnQkFDbEIsSUFBSSxDQUFDd0MsRUFBRSxDQUFDNUMsVUFBVTtnQkFDbEIsSUFBSSxDQUFDNEMsRUFBRSxDQUFDN0MsUUFBUTthQUNqQixFQUFFO2dCQUNEbUIsUUFBUW9GLEdBQUcsQ0FBQztnQkFDWixNQUFNLElBQUksQ0FBQzFELEVBQUUsQ0FBQzlDLEtBQUssQ0FBQ2lCLEdBQUcsQ0FBQ3lGO2dCQUV4QnRGLFFBQVFvRixHQUFHLENBQUM7Z0JBQ1oscUNBQXFDO2dCQUNyQyxLQUFLLE1BQU1TLFlBQVlFLGtCQUFtQjtvQkFDeEMsTUFBTTdFLFdBQVcsTUFBTSxJQUFJLENBQUNRLEVBQUUsQ0FBQ3hDLFVBQVUsQ0FBQ29CLEdBQUcsQ0FBQ3VGLFNBQVNqRyxFQUFFO29CQUN6RCxJQUFJLENBQUNzQixVQUFVO3dCQUNiLE1BQU0sSUFBSSxDQUFDUSxFQUFFLENBQUN4QyxVQUFVLENBQUNXLEdBQUcsQ0FBQ2dHO29CQUMvQjtnQkFDRjtnQkFFQTdGLFFBQVFvRixHQUFHLENBQUM7Z0JBQ1osTUFBTSxJQUFJLENBQUMxRCxFQUFFLENBQUM1QyxVQUFVLENBQUNvRyxPQUFPLENBQUNnQjtnQkFFakNsRyxRQUFRb0YsR0FBRyxDQUFDO2dCQUNaLE1BQU0sSUFBSSxDQUFDMUQsRUFBRSxDQUFDN0MsUUFBUSxDQUFDcUcsT0FBTyxDQUFDdUI7WUFDakM7WUFFQXpHLFFBQVFvRixHQUFHLENBQUMsK0NBQXNELE9BQVA3RDtRQUU3RCxFQUFFLE9BQU94QixPQUFPO1lBQ2RDLFFBQVFELEtBQUssQ0FBQyxrQ0FBa0NBO1lBQ2hELE1BQU0sSUFBSUUsTUFBTSxtQ0FBeUMsT0FBTkY7UUFDckQ7SUFDRjtJQWhiQXRCLGFBQWM7UUFDWixJQUFJLENBQUNpRCxFQUFFLEdBQUcsSUFBSWxEO0lBQ2hCO0FBK2FGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2xpYi9kYXRhYmFzZS9JbmRleGVkREJXcmFwcGVyLnRzP2YwZTIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IERleGllLCB7IFRhYmxlIH0gZnJvbSAnZGV4aWUnO1xuaW1wb3J0IHtcbiAgTG9jYWxEQixcbiAgRmlsdGVyXG59IGZyb20gJ0Btb25leXF1ZXN0L3NoYXJlZCc7XG5pbXBvcnQgeyBDYXRlZ29yeVRvdGFsLCBCdWRnZXRTdGF0dXMgfSBmcm9tICdAbW9uZXlxdWVzdC9zaGFyZWQnO1xuXG4vLyBEZWZpbmUgZGF0YWJhc2Ugc2NoZW1hIG1hdGNoaW5nIFByaXNtYSBzY2hlbWFcbmludGVyZmFjZSBVc2VyIHtcbiAgaWQ6IHN0cmluZztcbiAgY29nbml0b0lkOiBzdHJpbmc7XG4gIGVtYWlsOiBzdHJpbmc7XG4gIHByZWZlcmVuY2VzOiBzdHJpbmc7XG4gIGNyZWF0ZWRBdDogRGF0ZTtcbiAgdXBkYXRlZEF0OiBEYXRlO1xufVxuXG5pbnRlcmZhY2UgQWNjb3VudCB7XG4gIGlkOiBzdHJpbmc7XG4gIHVzZXJJZDogc3RyaW5nO1xuICBuYW1lOiBzdHJpbmc7XG4gIHR5cGU6IHN0cmluZztcbiAgYmFsYW5jZTogbnVtYmVyO1xuICBjdXJyZW5jeUlkOiBzdHJpbmc7XG4gIGlzQWN0aXZlOiBib29sZWFuO1xuICBjcmVhdGVkQXQ6IERhdGU7XG4gIHVwZGF0ZWRBdDogRGF0ZTtcbn1cblxuaW50ZXJmYWNlIENhdGVnb3J5IHtcbiAgaWQ6IHN0cmluZztcbiAgdXNlcklkOiBzdHJpbmc7XG4gIG5hbWU6IHN0cmluZztcbiAgdHlwZTogc3RyaW5nO1xuICBjb2xvcjogc3RyaW5nO1xuICBpc0RlZmF1bHQ6IGJvb2xlYW47XG4gIGNyZWF0ZWRBdDogRGF0ZTtcbiAgdXBkYXRlZEF0OiBEYXRlO1xufVxuXG5pbnRlcmZhY2UgVHJhbnNhY3Rpb24ge1xuICBpZDogc3RyaW5nO1xuICBhY2NvdW50SWQ6IHN0cmluZztcbiAgb3JpZ2luYWxBbW91bnQ6IG51bWJlcjtcbiAgZGVzY3JpcHRpb246IHN0cmluZztcbiAgZGF0ZTogRGF0ZTtcbiAgY3VycmVuY3lJZDogc3RyaW5nO1xuICBpc1BhcmVudDogYm9vbGVhbjtcbiAgcGFyZW50VHJhbnNhY3Rpb25JZD86IHN0cmluZztcbiAgY2F0ZWdvcnlJZD86IHN0cmluZztcbiAgY3JlYXRlZEF0OiBEYXRlO1xuICB1cGRhdGVkQXQ6IERhdGU7XG59XG5cbmludGVyZmFjZSBUcmFuc2FjdGlvblNwbGl0IHtcbiAgaWQ6IHN0cmluZztcbiAgdHJhbnNhY3Rpb25JZDogc3RyaW5nO1xuICBhbW91bnQ6IG51bWJlcjtcbiAgY2F0ZWdvcnlJZDogc3RyaW5nO1xuICBkZXNjcmlwdGlvbj86IHN0cmluZztcbiAgcGVyY2VudGFnZTogbnVtYmVyO1xuICBjcmVhdGVkQXQ6IERhdGU7XG4gIHVwZGF0ZWRBdDogRGF0ZTtcbn1cblxuaW50ZXJmYWNlIEJ1ZGdldCB7XG4gIGlkOiBzdHJpbmc7XG4gIHVzZXJJZDogc3RyaW5nO1xuICBjYXRlZ29yeUlkOiBzdHJpbmc7XG4gIGFtb3VudDogbnVtYmVyO1xuICBjdXJyZW5jeUlkOiBzdHJpbmc7XG4gIHBlcmlvZDogc3RyaW5nO1xuICBzdGFydERhdGU6IERhdGU7XG4gIGlzQWN0aXZlOiBib29sZWFuO1xuICBjcmVhdGVkQXQ6IERhdGU7XG4gIHVwZGF0ZWRBdDogRGF0ZTtcbn1cblxuaW50ZXJmYWNlIEN1cnJlbmN5IHtcbiAgaWQ6IHN0cmluZztcbiAgY29kZTogc3RyaW5nO1xuICBuYW1lOiBzdHJpbmc7XG4gIHN5bWJvbDogc3RyaW5nO1xuICBpc0FjdGl2ZTogYm9vbGVhbjtcbiAgY3JlYXRlZEF0OiBEYXRlO1xuICB1cGRhdGVkQXQ6IERhdGU7XG59XG5cbmludGVyZmFjZSBJbnZlc3RtZW50IHtcbiAgaWQ6IHN0cmluZztcbiAgcG9ydGZvbGlvSWQ6IHN0cmluZztcbiAgc3ltYm9sOiBzdHJpbmc7XG4gIG5hbWU6IHN0cmluZztcbiAgcXVhbnRpdHk6IG51bWJlcjtcbiAgY29zdEJhc2lzOiBudW1iZXI7XG4gIGN1cnJlbnRQcmljZTogbnVtYmVyO1xuICBjcmVhdGVkQXQ6IERhdGU7XG4gIHVwZGF0ZWRBdDogRGF0ZTtcbn1cblxuaW50ZXJmYWNlIFBvcnRmb2xpbyB7XG4gIGlkOiBzdHJpbmc7XG4gIHVzZXJJZDogc3RyaW5nO1xuICBuYW1lOiBzdHJpbmc7XG4gIHByb3ZpZGVyPzogc3RyaW5nO1xuICBhY2NvdW50TnVtYmVyPzogc3RyaW5nO1xuICBpc0FjdGl2ZTogYm9vbGVhbjtcbiAgY3JlYXRlZEF0OiBEYXRlO1xuICB1cGRhdGVkQXQ6IERhdGU7XG59XG5cbmludGVyZmFjZSBOZXRXb3J0aFNuYXBzaG90IHtcbiAgaWQ6IHN0cmluZztcbiAgdXNlcklkOiBzdHJpbmc7XG4gIHRvdGFsQXNzZXRzOiBudW1iZXI7XG4gIHRvdGFsTGlhYmlsaXRpZXM6IG51bWJlcjtcbiAgbmV0V29ydGg6IG51bWJlcjtcbiAgZGF0ZTogRGF0ZTtcbiAgY3JlYXRlZEF0OiBEYXRlO1xufVxuXG5jbGFzcyBNb25leVF1ZXN0REIgZXh0ZW5kcyBEZXhpZSB7XG4gIHVzZXJzITogVGFibGU8VXNlcj47XG4gIGFjY291bnRzITogVGFibGU8QWNjb3VudD47XG4gIGNhdGVnb3JpZXMhOiBUYWJsZTxDYXRlZ29yeT47XG4gIHRyYW5zYWN0aW9ucyE6IFRhYmxlPFRyYW5zYWN0aW9uPjtcbiAgdHJhbnNhY3Rpb25fc3BsaXRzITogVGFibGU8VHJhbnNhY3Rpb25TcGxpdD47XG4gIGJ1ZGdldHMhOiBUYWJsZTxCdWRnZXQ+O1xuICBjdXJyZW5jaWVzITogVGFibGU8Q3VycmVuY3k+O1xuICBpbnZlc3RtZW50cyE6IFRhYmxlPEludmVzdG1lbnQ+O1xuICBwb3J0Zm9saW9zITogVGFibGU8UG9ydGZvbGlvPjtcbiAgbmV0X3dvcnRoX3NuYXBzaG90cyE6IFRhYmxlPE5ldFdvcnRoU25hcHNob3Q+O1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCdNb25leVF1ZXN0REInKTtcblxuICAgIHRoaXMudmVyc2lvbigxKS5zdG9yZXMoe1xuICAgICAgdXNlcnM6ICdpZCwgY29nbml0b0lkLCBlbWFpbCwgY3JlYXRlZEF0JyxcbiAgICAgIGFjY291bnRzOiAnaWQsIHVzZXJJZCwgbmFtZSwgdHlwZSwgaXNBY3RpdmUsIGNyZWF0ZWRBdCcsXG4gICAgICBjYXRlZ29yaWVzOiAnaWQsIHVzZXJJZCwgbmFtZSwgdHlwZSwgaXNEZWZhdWx0LCBjcmVhdGVkQXQnLFxuICAgICAgdHJhbnNhY3Rpb25zOiAnaWQsIGFjY291bnRJZCwgZGF0ZSwgY2F0ZWdvcnlJZCwgaXNQYXJlbnQsIHBhcmVudFRyYW5zYWN0aW9uSWQsIGNyZWF0ZWRBdCcsXG4gICAgICB0cmFuc2FjdGlvbl9zcGxpdHM6ICdpZCwgdHJhbnNhY3Rpb25JZCwgY2F0ZWdvcnlJZCwgY3JlYXRlZEF0JyxcbiAgICAgIGJ1ZGdldHM6ICdpZCwgdXNlcklkLCBjYXRlZ29yeUlkLCBwZXJpb2QsIHN0YXJ0RGF0ZSwgaXNBY3RpdmUsIGNyZWF0ZWRBdCcsXG4gICAgICBjdXJyZW5jaWVzOiAnaWQsIGNvZGUsIG5hbWUsIGlzQWN0aXZlLCBjcmVhdGVkQXQnLFxuICAgICAgaW52ZXN0bWVudHM6ICdpZCwgcG9ydGZvbGlvSWQsIHN5bWJvbCwgY3JlYXRlZEF0JyxcbiAgICAgIHBvcnRmb2xpb3M6ICdpZCwgdXNlcklkLCBuYW1lLCBpc0FjdGl2ZSwgY3JlYXRlZEF0JyxcbiAgICAgIG5ldF93b3J0aF9zbmFwc2hvdHM6ICdpZCwgdXNlcklkLCBkYXRlLCBjcmVhdGVkQXQnXG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEluZGV4ZWREQldyYXBwZXIgaW1wbGVtZW50cyBMb2NhbERCIHtcbiAgcHJpdmF0ZSBkYjogTW9uZXlRdWVzdERCO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZGIgPSBuZXcgTW9uZXlRdWVzdERCKCk7XG4gIH1cblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gQ29yZSBDUlVEIE9wZXJhdGlvbnNcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgYXN5bmMgaW5zZXJ0PFQ+KHRhYmxlOiBzdHJpbmcsIGRhdGE6IFQpOiBQcm9taXNlPFQ+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZGJUYWJsZSA9IHRoaXMuZ2V0VGFibGUodGFibGUpO1xuICAgICAgY29uc3QgaWQgPSBhd2FpdCBkYlRhYmxlLmFkZChkYXRhIGFzIGFueSk7XG5cbiAgICAgIC8vIFJldHVybiB0aGUgaW5zZXJ0ZWQgZGF0YSB3aXRoIHRoZSBnZW5lcmF0ZWQgSUQgaWYgbmVlZGVkXG4gICAgICBpZiAodHlwZW9mIGlkID09PSAnc3RyaW5nJyAmJiAoZGF0YSBhcyBhbnkpLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHsgLi4uZGF0YSwgaWQgfSBhcyBUO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIGluc2VydCBpbnRvICR7dGFibGV9OmAsIGVycm9yKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRGF0YWJhc2UgaW5zZXJ0IGZhaWxlZDogJHtlcnJvcn1gKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBxdWVyeTxUPih0YWJsZTogc3RyaW5nLCBmaWx0ZXI/OiBhbnkpOiBQcm9taXNlPFRbXT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkYlRhYmxlID0gdGhpcy5nZXRUYWJsZSh0YWJsZSk7XG4gICAgICBsZXQgY29sbGVjdGlvbiA9IGRiVGFibGUudG9Db2xsZWN0aW9uKCk7XG5cbiAgICAgIGlmIChmaWx0ZXIpIHtcbiAgICAgICAgLy8gQXBwbHkgZmlsdGVycyBiYXNlZCBvbiB0aGUgZmlsdGVyIG9iamVjdFxuICAgICAgICBpZiAoZmlsdGVyLmlkKSB7XG4gICAgICAgICAgcmV0dXJuIFsoYXdhaXQgZGJUYWJsZS5nZXQoZmlsdGVyLmlkKSldIGFzIFRbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFwcGx5IGNvbW1vbiBmaWx0ZXJzXG4gICAgICAgIE9iamVjdC5rZXlzKGZpbHRlcikuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgIGlmIChmaWx0ZXJba2V5XSAhPT0gdW5kZWZpbmVkICYmIGZpbHRlcltrZXldICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb2xsZWN0aW9uID0gY29sbGVjdGlvbi5maWx0ZXIoaXRlbSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gKGl0ZW0gYXMgYW55KVtrZXldO1xuICAgICAgICAgICAgICBjb25zdCBmaWx0ZXJWYWx1ZSA9IGZpbHRlcltrZXldO1xuXG4gICAgICAgICAgICAgIC8vIEhhbmRsZSBkYXRlIHJhbmdlIGZpbHRlcnNcbiAgICAgICAgICAgICAgaWYgKGtleSA9PT0gJ3N0YXJ0RGF0ZScgJiYgdmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlID49IGZpbHRlclZhbHVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChrZXkgPT09ICdlbmREYXRlJyAmJiB2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgPD0gZmlsdGVyVmFsdWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBIYW5kbGUgZXhhY3QgbWF0Y2hlc1xuICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgPT09IGZpbHRlclZhbHVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IGNvbGxlY3Rpb24udG9BcnJheSgpO1xuICAgICAgcmV0dXJuIHJlc3VsdHMgYXMgVFtdO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gcXVlcnkgJHt0YWJsZX06YCwgZXJyb3IpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBEYXRhYmFzZSBxdWVyeSBmYWlsZWQ6ICR7ZXJyb3J9YCk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgdXBkYXRlPFQ+KHRhYmxlOiBzdHJpbmcsIGlkOiBzdHJpbmcsIGRhdGE6IFBhcnRpYWw8VD4pOiBQcm9taXNlPFQ+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZGJUYWJsZSA9IHRoaXMuZ2V0VGFibGUodGFibGUpO1xuXG4gICAgICAvLyBHZXQgZXhpc3RpbmcgcmVjb3JkXG4gICAgICBjb25zdCBleGlzdGluZyA9IGF3YWl0IGRiVGFibGUuZ2V0KGlkKTtcbiAgICAgIGlmICghZXhpc3RpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZWNvcmQgd2l0aCBpZCAke2lkfSBub3QgZm91bmQgaW4gJHt0YWJsZX1gKTtcbiAgICAgIH1cblxuICAgICAgLy8gTWVyZ2UgdXBkYXRlc1xuICAgICAgY29uc3QgdXBkYXRlZCA9IHsgLi4uZXhpc3RpbmcsIC4uLmRhdGEsIHVwZGF0ZWRBdDogbmV3IERhdGUoKSB9O1xuXG4gICAgICAvLyBVcGRhdGUgaW4gZGF0YWJhc2VcbiAgICAgIGF3YWl0IGRiVGFibGUudXBkYXRlKGlkLCB1cGRhdGVkKTtcblxuICAgICAgcmV0dXJuIHVwZGF0ZWQgYXMgVDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIHVwZGF0ZSAke3RhYmxlfTpgLCBlcnJvcik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYERhdGFiYXNlIHVwZGF0ZSBmYWlsZWQ6ICR7ZXJyb3J9YCk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZGVsZXRlKHRhYmxlOiBzdHJpbmcsIGlkOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZGJUYWJsZSA9IHRoaXMuZ2V0VGFibGUodGFibGUpO1xuICAgICAgYXdhaXQgZGJUYWJsZS5kZWxldGUoaWQpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gZGVsZXRlIGZyb20gJHt0YWJsZX06YCwgZXJyb3IpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBEYXRhYmFzZSBkZWxldGUgZmFpbGVkOiAke2Vycm9yfWApO1xuICAgIH1cbiAgfVxuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBBbmFseXRpY3MgUXVlcmllc1xuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICBhc3luYyBnZXRDYXRlZ29yeVNwZW5kaW5nKHVzZXJJZDogc3RyaW5nLCBzdGFydERhdGU6IERhdGUsIGVuZERhdGU6IERhdGUpOiBQcm9taXNlPENhdGVnb3J5VG90YWxbXT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBHZXQgdXNlcidzIHRyYW5zYWN0aW9ucyBpbiBkYXRlIHJhbmdlXG4gICAgICBjb25zdCB0cmFuc2FjdGlvbnMgPSBhd2FpdCB0aGlzLmRiLnRyYW5zYWN0aW9uc1xuICAgICAgICAud2hlcmUoJ2RhdGUnKVxuICAgICAgICAuYmV0d2VlbihzdGFydERhdGUsIGVuZERhdGUsIHRydWUsIHRydWUpXG4gICAgICAgIC5maWx0ZXIodCA9PiB7XG4gICAgICAgICAgLy8gV2UgbmVlZCB0byBjaGVjayBpZiB0aGUgYWNjb3VudCBiZWxvbmdzIHRvIHRoZSB1c2VyXG4gICAgICAgICAgLy8gVGhpcyB3b3VsZCBub3JtYWxseSBiZSBhIEpPSU4gb3BlcmF0aW9uXG4gICAgICAgICAgcmV0dXJuIHRydWU7IC8vIFNpbXBsaWZpZWQgZm9yIG5vd1xuICAgICAgICB9KVxuICAgICAgICAudG9BcnJheSgpO1xuXG4gICAgICAvLyBHZXQgdXNlcidzIGNhdGVnb3JpZXNcbiAgICAgIGNvbnN0IGNhdGVnb3JpZXMgPSBhd2FpdCB0aGlzLmRiLmNhdGVnb3JpZXNcbiAgICAgICAgLndoZXJlKCd1c2VySWQnKVxuICAgICAgICAuZXF1YWxzKHVzZXJJZClcbiAgICAgICAgLnRvQXJyYXkoKTtcblxuICAgICAgLy8gQ2FsY3VsYXRlIHNwZW5kaW5nIGJ5IGNhdGVnb3J5XG4gICAgICBjb25zdCBjYXRlZ29yeU1hcCA9IG5ldyBNYXA8c3RyaW5nLCBDYXRlZ29yeVRvdGFsPigpO1xuXG4gICAgICAvLyBJbml0aWFsaXplIGNhdGVnb3JpZXNcbiAgICAgIGNhdGVnb3JpZXMuZm9yRWFjaChjYXQgPT4ge1xuICAgICAgICBjYXRlZ29yeU1hcC5zZXQoY2F0LmlkLCB7XG4gICAgICAgICAgY2F0ZWdvcnlJZDogY2F0LmlkLFxuICAgICAgICAgIGNhdGVnb3J5TmFtZTogY2F0Lm5hbWUsXG4gICAgICAgICAgdG90YWxBbW91bnQ6IDAsXG4gICAgICAgICAgdHJhbnNhY3Rpb25Db3VudDogMCxcbiAgICAgICAgICBwZXJjZW50YWdlOiAwXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIEFnZ3JlZ2F0ZSB0cmFuc2FjdGlvbiBhbW91bnRzXG4gICAgICBsZXQgdG90YWxTcGVuZGluZyA9IDA7XG5cbiAgICAgIGZvciAoY29uc3QgdHJhbnNhY3Rpb24gb2YgdHJhbnNhY3Rpb25zKSB7XG4gICAgICAgIGlmICh0cmFuc2FjdGlvbi5jYXRlZ29yeUlkKSB7XG4gICAgICAgICAgY29uc3QgY2F0ZWdvcnkgPSBjYXRlZ29yeU1hcC5nZXQodHJhbnNhY3Rpb24uY2F0ZWdvcnlJZCk7XG4gICAgICAgICAgaWYgKGNhdGVnb3J5KSB7XG4gICAgICAgICAgICBjYXRlZ29yeS50b3RhbEFtb3VudCArPSBNYXRoLmFicyh0cmFuc2FjdGlvbi5vcmlnaW5hbEFtb3VudCk7XG4gICAgICAgICAgICBjYXRlZ29yeS50cmFuc2FjdGlvbkNvdW50ICs9IDE7XG4gICAgICAgICAgICB0b3RhbFNwZW5kaW5nICs9IE1hdGguYWJzKHRyYW5zYWN0aW9uLm9yaWdpbmFsQW1vdW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBIYW5kbGUgc3BsaXRzXG4gICAgICAgIGNvbnN0IHNwbGl0cyA9IGF3YWl0IHRoaXMuZGIudHJhbnNhY3Rpb25fc3BsaXRzXG4gICAgICAgICAgLndoZXJlKCd0cmFuc2FjdGlvbklkJylcbiAgICAgICAgICAuZXF1YWxzKHRyYW5zYWN0aW9uLmlkKVxuICAgICAgICAgIC50b0FycmF5KCk7XG5cbiAgICAgICAgc3BsaXRzLmZvckVhY2goc3BsaXQgPT4ge1xuICAgICAgICAgIGNvbnN0IGNhdGVnb3J5ID0gY2F0ZWdvcnlNYXAuZ2V0KHNwbGl0LmNhdGVnb3J5SWQpO1xuICAgICAgICAgIGlmIChjYXRlZ29yeSkge1xuICAgICAgICAgICAgY2F0ZWdvcnkudG90YWxBbW91bnQgKz0gTWF0aC5hYnMoc3BsaXQuYW1vdW50KTtcbiAgICAgICAgICAgIHRvdGFsU3BlbmRpbmcgKz0gTWF0aC5hYnMoc3BsaXQuYW1vdW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBDYWxjdWxhdGUgcGVyY2VudGFnZXNcbiAgICAgIGNhdGVnb3J5TWFwLmZvckVhY2goY2F0ZWdvcnkgPT4ge1xuICAgICAgICBpZiAodG90YWxTcGVuZGluZyA+IDApIHtcbiAgICAgICAgICBjYXRlZ29yeS5wZXJjZW50YWdlID0gKGNhdGVnb3J5LnRvdGFsQW1vdW50IC8gdG90YWxTcGVuZGluZykgKiAxMDA7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gQXJyYXkuZnJvbShjYXRlZ29yeU1hcC52YWx1ZXMoKSlcbiAgICAgICAgLmZpbHRlcihjYXQgPT4gY2F0LnRvdGFsQW1vdW50ID4gMClcbiAgICAgICAgLnNvcnQoKGEsIGIpID0+IGIudG90YWxBbW91bnQgLSBhLnRvdGFsQW1vdW50KTtcblxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZ2V0IGNhdGVnb3J5IHNwZW5kaW5nOicsIGVycm9yKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQW5hbHl0aWNzIHF1ZXJ5IGZhaWxlZDogJHtlcnJvcn1gKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBnZXRCdWRnZXRQcm9ncmVzcyh1c2VySWQ6IHN0cmluZyk6IFByb21pc2U8QnVkZ2V0U3RhdHVzW10+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgYnVkZ2V0cyA9IGF3YWl0IHRoaXMuZGIuYnVkZ2V0c1xuICAgICAgICAud2hlcmUoJ3VzZXJJZCcpXG4gICAgICAgIC5lcXVhbHModXNlcklkKVxuICAgICAgICAuZmlsdGVyKGIgPT4gYi5pc0FjdGl2ZSlcbiAgICAgICAgLnRvQXJyYXkoKTtcblxuICAgICAgY29uc3QgYnVkZ2V0U3RhdHVzOiBCdWRnZXRTdGF0dXNbXSA9IFtdO1xuXG4gICAgICBmb3IgKGNvbnN0IGJ1ZGdldCBvZiBidWRnZXRzKSB7XG4gICAgICAgIC8vIENhbGN1bGF0ZSBwZXJpb2Qgc3RhcnQvZW5kIGRhdGVzXG4gICAgICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XG4gICAgICAgIGxldCBwZXJpb2RTdGFydCA9IG5ldyBEYXRlKGJ1ZGdldC5zdGFydERhdGUpO1xuICAgICAgICBsZXQgcGVyaW9kRW5kID0gbmV3IERhdGUoYnVkZ2V0LnN0YXJ0RGF0ZSk7XG5cbiAgICAgICAgaWYgKGJ1ZGdldC5wZXJpb2QgPT09ICdtb250aGx5Jykge1xuICAgICAgICAgIHBlcmlvZFN0YXJ0ID0gbmV3IERhdGUobm93LmdldEZ1bGxZZWFyKCksIG5vdy5nZXRNb250aCgpLCAxKTtcbiAgICAgICAgICBwZXJpb2RFbmQgPSBuZXcgRGF0ZShub3cuZ2V0RnVsbFllYXIoKSwgbm93LmdldE1vbnRoKCkgKyAxLCAwKTtcbiAgICAgICAgfSBlbHNlIGlmIChidWRnZXQucGVyaW9kID09PSAneWVhcmx5Jykge1xuICAgICAgICAgIHBlcmlvZFN0YXJ0ID0gbmV3IERhdGUobm93LmdldEZ1bGxZZWFyKCksIDAsIDEpO1xuICAgICAgICAgIHBlcmlvZEVuZCA9IG5ldyBEYXRlKG5vdy5nZXRGdWxsWWVhcigpLCAxMSwgMzEpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHNwZW5kaW5nIGZvciB0aGlzIGNhdGVnb3J5IGluIHRoZSBwZXJpb2RcbiAgICAgICAgY29uc3QgY2F0ZWdvcnlTcGVuZGluZyA9IGF3YWl0IHRoaXMuZ2V0Q2F0ZWdvcnlTcGVuZGluZyh1c2VySWQsIHBlcmlvZFN0YXJ0LCBwZXJpb2RFbmQpO1xuICAgICAgICBjb25zdCBzcGVudCA9IGNhdGVnb3J5U3BlbmRpbmcuZmluZChjID0+IGMuY2F0ZWdvcnlJZCA9PT0gYnVkZ2V0LmNhdGVnb3J5SWQpPy50b3RhbEFtb3VudCB8fCAwO1xuXG4gICAgICAgIC8vIEdldCBjYXRlZ29yeSBkZXRhaWxzXG4gICAgICAgIGNvbnN0IGNhdGVnb3J5ID0gYXdhaXQgdGhpcy5kYi5jYXRlZ29yaWVzLmdldChidWRnZXQuY2F0ZWdvcnlJZCk7XG5cbiAgICAgICAgYnVkZ2V0U3RhdHVzLnB1c2goe1xuICAgICAgICAgIGJ1ZGdldElkOiBidWRnZXQuaWQsXG4gICAgICAgICAgY2F0ZWdvcnlJZDogYnVkZ2V0LmNhdGVnb3J5SWQsXG4gICAgICAgICAgY2F0ZWdvcnlOYW1lOiBjYXRlZ29yeT8ubmFtZSB8fCAnVW5rbm93biBDYXRlZ29yeScsXG4gICAgICAgICAgYnVkZ2V0QW1vdW50OiBidWRnZXQuYW1vdW50LFxuICAgICAgICAgIHNwZW50QW1vdW50OiBzcGVudCxcbiAgICAgICAgICByZW1haW5pbmdBbW91bnQ6IGJ1ZGdldC5hbW91bnQgLSBzcGVudCxcbiAgICAgICAgICBwZXJjZW50YWdlVXNlZDogKHNwZW50IC8gYnVkZ2V0LmFtb3VudCkgKiAxMDAsXG4gICAgICAgICAgcGVyaW9kOiBidWRnZXQucGVyaW9kIGFzICdtb250aGx5JyB8ICd5ZWFybHknLFxuICAgICAgICAgIGlzT3ZlckJ1ZGdldDogc3BlbnQgPiBidWRnZXQuYW1vdW50XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYnVkZ2V0U3RhdHVzO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZ2V0IGJ1ZGdldCBwcm9ncmVzczonLCBlcnJvcik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEJ1ZGdldCBwcm9ncmVzcyBxdWVyeSBmYWlsZWQ6ICR7ZXJyb3J9YCk7XG4gICAgfVxuICB9XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIEV4cG9ydC9JbXBvcnQgT3BlcmF0aW9uc1xuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICBhc3luYyBleHBvcnRBbGwoKTogUHJvbWlzZTxhbnk+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZGF0YTogYW55ID0ge307XG5cbiAgICAgIC8vIEV4cG9ydCBhbGwgdGFibGVzXG4gICAgICBjb25zdCB0YWJsZXMgPSBbXG4gICAgICAgICd1c2VycycsICdhY2NvdW50cycsICdjYXRlZ29yaWVzJywgJ3RyYW5zYWN0aW9ucycsXG4gICAgICAgICd0cmFuc2FjdGlvbl9zcGxpdHMnLCAnYnVkZ2V0cycsICdjdXJyZW5jaWVzJyxcbiAgICAgICAgJ2ludmVzdG1lbnRzJywgJ3BvcnRmb2xpb3MnLCAnbmV0X3dvcnRoX3NuYXBzaG90cydcbiAgICAgIF07XG5cbiAgICAgIGZvciAoY29uc3QgdGFibGVOYW1lIG9mIHRhYmxlcykge1xuICAgICAgICBjb25zdCB0YWJsZSA9IHRoaXMuZ2V0VGFibGUodGFibGVOYW1lKTtcbiAgICAgICAgZGF0YVt0YWJsZU5hbWVdID0gYXdhaXQgdGFibGUudG9BcnJheSgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB2ZXJzaW9uOiAxLFxuICAgICAgICBleHBvcnRlZEF0OiBuZXcgRGF0ZSgpLFxuICAgICAgICBkYXRhXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZXhwb3J0IGRhdGE6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBEYXRhIGV4cG9ydCBmYWlsZWQ6ICR7ZXJyb3J9YCk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgaW1wb3J0RGF0YShpbXBvcnREYXRhOiBhbnkpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFpbXBvcnREYXRhLmRhdGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGltcG9ydCBkYXRhIGZvcm1hdCcpO1xuICAgICAgfVxuXG4gICAgICAvLyBDbGVhciBleGlzdGluZyBkYXRhIChvcHRpb25hbCAtIG1pZ2h0IHdhbnQgdG8gbWVyZ2UgaW5zdGVhZClcbiAgICAgIGF3YWl0IHRoaXMuZGIudHJhbnNhY3Rpb24oJ3J3JywgW1xuICAgICAgICB0aGlzLmRiLnVzZXJzLCB0aGlzLmRiLmFjY291bnRzLCB0aGlzLmRiLmNhdGVnb3JpZXMsXG4gICAgICAgIHRoaXMuZGIudHJhbnNhY3Rpb25zLCB0aGlzLmRiLnRyYW5zYWN0aW9uX3NwbGl0cyxcbiAgICAgICAgdGhpcy5kYi5idWRnZXRzLCB0aGlzLmRiLmN1cnJlbmNpZXMsIHRoaXMuZGIuaW52ZXN0bWVudHMsXG4gICAgICAgIHRoaXMuZGIucG9ydGZvbGlvcywgdGhpcy5kYi5uZXRfd29ydGhfc25hcHNob3RzXG4gICAgICBdLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIC8vIEltcG9ydCBkYXRhIHRhYmxlIGJ5IHRhYmxlXG4gICAgICAgIGNvbnN0IHRhYmxlcyA9IFtcbiAgICAgICAgICAndXNlcnMnLCAnYWNjb3VudHMnLCAnY2F0ZWdvcmllcycsICd0cmFuc2FjdGlvbnMnLFxuICAgICAgICAgICd0cmFuc2FjdGlvbl9zcGxpdHMnLCAnYnVkZ2V0cycsICdjdXJyZW5jaWVzJyxcbiAgICAgICAgICAnaW52ZXN0bWVudHMnLCAncG9ydGZvbGlvcycsICduZXRfd29ydGhfc25hcHNob3RzJ1xuICAgICAgICBdO1xuXG4gICAgICAgIGZvciAoY29uc3QgdGFibGVOYW1lIG9mIHRhYmxlcykge1xuICAgICAgICAgIGlmIChpbXBvcnREYXRhLmRhdGFbdGFibGVOYW1lXSkge1xuICAgICAgICAgICAgY29uc3QgdGFibGUgPSB0aGlzLmdldFRhYmxlKHRhYmxlTmFtZSk7XG4gICAgICAgICAgICBhd2FpdCB0YWJsZS5idWxrQWRkKGltcG9ydERhdGEuZGF0YVt0YWJsZU5hbWVdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBpbXBvcnQgZGF0YTonLCBlcnJvcik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYERhdGEgaW1wb3J0IGZhaWxlZDogJHtlcnJvcn1gKTtcbiAgICB9XG4gIH1cblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gVXRpbGl0eSBNZXRob2RzXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIHByaXZhdGUgZ2V0VGFibGUodGFibGVOYW1lOiBzdHJpbmcpOiBUYWJsZSB7XG4gICAgY29uc3QgdGFibGUgPSAodGhpcy5kYiBhcyBhbnkpW3RhYmxlTmFtZV07XG4gICAgaWYgKCF0YWJsZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUYWJsZSAke3RhYmxlTmFtZX0gbm90IGZvdW5kYCk7XG4gICAgfVxuICAgIHJldHVybiB0YWJsZTtcbiAgfVxuXG4gIC8vIEluaXRpYWxpemUgd2l0aCBkZWZhdWx0IGRhdGFcbiAgYXN5bmMgaW5pdGlhbGl6ZSh1c2VySWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZyhgU3RhcnRpbmcgSW5kZXhlZERCIGluaXRpYWxpemF0aW9uIGZvciB1c2VyOiAke3VzZXJJZH1gKTtcblxuICAgICAgLy8gQ2hlY2sgaWYgYWxyZWFkeSBpbml0aWFsaXplZFxuICAgICAgY29uc3QgdXNlciA9IGF3YWl0IHRoaXMuZGIudXNlcnMuZ2V0KHVzZXJJZCk7XG4gICAgICBpZiAodXNlcikge1xuICAgICAgICBjb25zb2xlLmxvZyhgVXNlciAke3VzZXJJZH0gYWxyZWFkeSBpbml0aWFsaXplZGApO1xuICAgICAgICByZXR1cm47IC8vIEFscmVhZHkgaW5pdGlhbGl6ZWRcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5sb2coYENyZWF0aW5nIG5ldyB1c2VyIHByb2ZpbGUgZm9yOiAke3VzZXJJZH1gKTtcblxuICAgICAgLy8gQ3JlYXRlIHVzZXIgcmVjb3JkXG4gICAgICBjb25zdCBuZXdVc2VyID0ge1xuICAgICAgICBpZDogdXNlcklkLFxuICAgICAgICBjb2duaXRvSWQ6IHVzZXJJZCwgLy8gVXNpbmcgdXNlcklkIGFzIGNvZ25pdG9JZCBmb3IgZGVtbyBhY2NvdW50c1xuICAgICAgICBlbWFpbDogYCR7dXNlcklkfUBtb25leXF1ZXN0LmNvbWAsXG4gICAgICAgIHByZWZlcmVuY2VzOiBKU09OLnN0cmluZ2lmeSh7IHRoZW1lOiAnbGlnaHQnLCBjdXJyZW5jeTogJ1VTRCcgfSksXG4gICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKSxcbiAgICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpXG4gICAgICB9O1xuXG4gICAgICAvLyBDcmVhdGUgZGVmYXVsdCBjdXJyZW5jaWVzXG4gICAgICBjb25zdCBkZWZhdWx0Q3VycmVuY2llcyA9IFtcbiAgICAgICAge1xuICAgICAgICAgIGlkOiAndXNkJyxcbiAgICAgICAgICBjb2RlOiAnVVNEJyxcbiAgICAgICAgICBuYW1lOiAnVVMgRG9sbGFyJyxcbiAgICAgICAgICBzeW1ib2w6ICckJyxcbiAgICAgICAgICBpc0FjdGl2ZTogdHJ1ZSxcbiAgICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCksXG4gICAgICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBpZDogJ2V1cicsXG4gICAgICAgICAgY29kZTogJ0VVUicsXG4gICAgICAgICAgbmFtZTogJ0V1cm8nLFxuICAgICAgICAgIHN5bWJvbDogJ+KCrCcsXG4gICAgICAgICAgaXNBY3RpdmU6IHRydWUsXG4gICAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLFxuICAgICAgICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKVxuICAgICAgICB9XG4gICAgICBdO1xuXG4gICAgICAvLyBDcmVhdGUgZGVmYXVsdCBjYXRlZ29yaWVzXG4gICAgICBjb25zdCBkZWZhdWx0Q2F0ZWdvcmllcyA9IFtcbiAgICAgICAgeyBuYW1lOiAnR3JvY2VyaWVzJywgdHlwZTogJ2V4cGVuc2UnLCBjb2xvcjogJyMxMEI5ODEnIH0sXG4gICAgICAgIHsgbmFtZTogJ1RyYW5zcG9ydGF0aW9uJywgdHlwZTogJ2V4cGVuc2UnLCBjb2xvcjogJyMzQjgyRjYnIH0sXG4gICAgICAgIHsgbmFtZTogJ0hvdXNpbmcnLCB0eXBlOiAnZXhwZW5zZScsIGNvbG9yOiAnIzhCNUNGNicgfSxcbiAgICAgICAgeyBuYW1lOiAnVXRpbGl0aWVzJywgdHlwZTogJ2V4cGVuc2UnLCBjb2xvcjogJyNGNTlFMEInIH0sXG4gICAgICAgIHsgbmFtZTogJ0VudGVydGFpbm1lbnQnLCB0eXBlOiAnZXhwZW5zZScsIGNvbG9yOiAnI0VGNDQ0NCcgfSxcbiAgICAgICAgeyBuYW1lOiAnSGVhbHRoY2FyZScsIHR5cGU6ICdleHBlbnNlJywgY29sb3I6ICcjRUM0ODk5JyB9LFxuICAgICAgICB7IG5hbWU6ICdTYWxhcnknLCB0eXBlOiAnaW5jb21lJywgY29sb3I6ICcjMDU5NjY5JyB9LFxuICAgICAgICB7IG5hbWU6ICdJbnZlc3RtZW50JywgdHlwZTogJ2luY29tZScsIGNvbG9yOiAnIzA4OTFCMicgfVxuICAgICAgXS5tYXAoY2F0ID0+ICh7XG4gICAgICAgIGlkOiBgJHt1c2VySWR9LSR7Y2F0Lm5hbWUudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9cXHMrL2csICctJyl9YCxcbiAgICAgICAgdXNlcklkLFxuICAgICAgICAuLi5jYXQsXG4gICAgICAgIGlzRGVmYXVsdDogdHJ1ZSxcbiAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLFxuICAgICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKClcbiAgICAgIH0pKTtcblxuICAgICAgLy8gQ3JlYXRlIHNvbWUgZGVtbyBhY2NvdW50cyBmb3IgbmV3IHVzZXJzXG4gICAgICBjb25zdCBkZWZhdWx0QWNjb3VudHMgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICBpZDogYCR7dXNlcklkfS1jaGVja2luZ2AsXG4gICAgICAgICAgdXNlcklkLFxuICAgICAgICAgIG5hbWU6ICdDaGVja2luZyBBY2NvdW50JyxcbiAgICAgICAgICB0eXBlOiAnY2hlY2tpbmcnLFxuICAgICAgICAgIGJhbGFuY2U6IDI1MDAuMDAsXG4gICAgICAgICAgY3VycmVuY3lJZDogJ3VzZCcsXG4gICAgICAgICAgaXNBY3RpdmU6IHRydWUsXG4gICAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLFxuICAgICAgICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgaWQ6IGAke3VzZXJJZH0tc2F2aW5nc2AsXG4gICAgICAgICAgdXNlcklkLFxuICAgICAgICAgIG5hbWU6ICdTYXZpbmdzIEFjY291bnQnLFxuICAgICAgICAgIHR5cGU6ICdzYXZpbmdzJyxcbiAgICAgICAgICBiYWxhbmNlOiAxMjUwMC4wMCxcbiAgICAgICAgICBjdXJyZW5jeUlkOiAndXNkJyxcbiAgICAgICAgICBpc0FjdGl2ZTogdHJ1ZSxcbiAgICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCksXG4gICAgICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpXG4gICAgICAgIH1cbiAgICAgIF07XG5cbiAgICAgIC8vIEluaXRpYWxpemUgZGF0YWJhc2Ugd2l0aCB0cmFuc2FjdGlvblxuICAgICAgYXdhaXQgdGhpcy5kYi50cmFuc2FjdGlvbigncncnLCBbXG4gICAgICAgIHRoaXMuZGIudXNlcnMsXG4gICAgICAgIHRoaXMuZGIuY3VycmVuY2llcyxcbiAgICAgICAgdGhpcy5kYi5jYXRlZ29yaWVzLFxuICAgICAgICB0aGlzLmRiLmFjY291bnRzXG4gICAgICBdLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdDcmVhdGluZyB1c2VyIHJlY29yZC4uLicpO1xuICAgICAgICBhd2FpdCB0aGlzLmRiLnVzZXJzLmFkZChuZXdVc2VyKTtcblxuICAgICAgICBjb25zb2xlLmxvZygnQWRkaW5nIGRlZmF1bHQgY3VycmVuY2llcy4uLicpO1xuICAgICAgICAvLyBBZGQgY3VycmVuY2llcyAob25seSBpZiBub3QgZXhpc3QpXG4gICAgICAgIGZvciAoY29uc3QgY3VycmVuY3kgb2YgZGVmYXVsdEN1cnJlbmNpZXMpIHtcbiAgICAgICAgICBjb25zdCBleGlzdGluZyA9IGF3YWl0IHRoaXMuZGIuY3VycmVuY2llcy5nZXQoY3VycmVuY3kuaWQpO1xuICAgICAgICAgIGlmICghZXhpc3RpbmcpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuZGIuY3VycmVuY2llcy5hZGQoY3VycmVuY3kpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnNvbGUubG9nKCdBZGRpbmcgZGVmYXVsdCBjYXRlZ29yaWVzLi4uJyk7XG4gICAgICAgIGF3YWl0IHRoaXMuZGIuY2F0ZWdvcmllcy5idWxrQWRkKGRlZmF1bHRDYXRlZ29yaWVzKTtcblxuICAgICAgICBjb25zb2xlLmxvZygnQWRkaW5nIGRlZmF1bHQgYWNjb3VudHMuLi4nKTtcbiAgICAgICAgYXdhaXQgdGhpcy5kYi5hY2NvdW50cy5idWxrQWRkKGRlZmF1bHRBY2NvdW50cyk7XG4gICAgICB9KTtcblxuICAgICAgY29uc29sZS5sb2coYFN1Y2Nlc3NmdWxseSBpbml0aWFsaXplZCBkYXRhYmFzZSBmb3IgdXNlcjogJHt1c2VySWR9YCk7XG5cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGluaXRpYWxpemUgZGF0YWJhc2U6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBEYXRhYmFzZSBpbml0aWFsaXphdGlvbiBmYWlsZWQ6ICR7ZXJyb3J9YCk7XG4gICAgfVxuICB9XG59Il0sIm5hbWVzIjpbIkRleGllIiwiTW9uZXlRdWVzdERCIiwiY29uc3RydWN0b3IiLCJ2ZXJzaW9uIiwic3RvcmVzIiwidXNlcnMiLCJhY2NvdW50cyIsImNhdGVnb3JpZXMiLCJ0cmFuc2FjdGlvbnMiLCJ0cmFuc2FjdGlvbl9zcGxpdHMiLCJidWRnZXRzIiwiY3VycmVuY2llcyIsImludmVzdG1lbnRzIiwicG9ydGZvbGlvcyIsIm5ldF93b3J0aF9zbmFwc2hvdHMiLCJJbmRleGVkREJXcmFwcGVyIiwiaW5zZXJ0IiwidGFibGUiLCJkYXRhIiwiZGJUYWJsZSIsImdldFRhYmxlIiwiaWQiLCJhZGQiLCJ1bmRlZmluZWQiLCJlcnJvciIsImNvbnNvbGUiLCJFcnJvciIsInF1ZXJ5IiwiZmlsdGVyIiwiY29sbGVjdGlvbiIsInRvQ29sbGVjdGlvbiIsImdldCIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwia2V5IiwiaXRlbSIsInZhbHVlIiwiZmlsdGVyVmFsdWUiLCJEYXRlIiwicmVzdWx0cyIsInRvQXJyYXkiLCJ1cGRhdGUiLCJleGlzdGluZyIsInVwZGF0ZWQiLCJ1cGRhdGVkQXQiLCJkZWxldGUiLCJnZXRDYXRlZ29yeVNwZW5kaW5nIiwidXNlcklkIiwic3RhcnREYXRlIiwiZW5kRGF0ZSIsImRiIiwid2hlcmUiLCJiZXR3ZWVuIiwidCIsImVxdWFscyIsImNhdGVnb3J5TWFwIiwiTWFwIiwiY2F0Iiwic2V0IiwiY2F0ZWdvcnlJZCIsImNhdGVnb3J5TmFtZSIsIm5hbWUiLCJ0b3RhbEFtb3VudCIsInRyYW5zYWN0aW9uQ291bnQiLCJwZXJjZW50YWdlIiwidG90YWxTcGVuZGluZyIsInRyYW5zYWN0aW9uIiwiY2F0ZWdvcnkiLCJNYXRoIiwiYWJzIiwib3JpZ2luYWxBbW91bnQiLCJzcGxpdHMiLCJzcGxpdCIsImFtb3VudCIsIkFycmF5IiwiZnJvbSIsInZhbHVlcyIsInNvcnQiLCJhIiwiYiIsImdldEJ1ZGdldFByb2dyZXNzIiwiaXNBY3RpdmUiLCJidWRnZXRTdGF0dXMiLCJidWRnZXQiLCJjYXRlZ29yeVNwZW5kaW5nIiwibm93IiwicGVyaW9kU3RhcnQiLCJwZXJpb2RFbmQiLCJwZXJpb2QiLCJnZXRGdWxsWWVhciIsImdldE1vbnRoIiwic3BlbnQiLCJmaW5kIiwiYyIsInB1c2giLCJidWRnZXRJZCIsImJ1ZGdldEFtb3VudCIsInNwZW50QW1vdW50IiwicmVtYWluaW5nQW1vdW50IiwicGVyY2VudGFnZVVzZWQiLCJpc092ZXJCdWRnZXQiLCJleHBvcnRBbGwiLCJ0YWJsZXMiLCJ0YWJsZU5hbWUiLCJleHBvcnRlZEF0IiwiaW1wb3J0RGF0YSIsImJ1bGtBZGQiLCJpbml0aWFsaXplIiwibG9nIiwidXNlciIsIm5ld1VzZXIiLCJjb2duaXRvSWQiLCJlbWFpbCIsInByZWZlcmVuY2VzIiwiSlNPTiIsInN0cmluZ2lmeSIsInRoZW1lIiwiY3VycmVuY3kiLCJjcmVhdGVkQXQiLCJkZWZhdWx0Q3VycmVuY2llcyIsImNvZGUiLCJzeW1ib2wiLCJkZWZhdWx0Q2F0ZWdvcmllcyIsInR5cGUiLCJjb2xvciIsIm1hcCIsInRvTG93ZXJDYXNlIiwicmVwbGFjZSIsImlzRGVmYXVsdCIsImRlZmF1bHRBY2NvdW50cyIsImJhbGFuY2UiLCJjdXJyZW5jeUlkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/database/IndexedDBWrapper.ts\n"));

/***/ })

});