"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/pricing/page",{

/***/ "(app-pages-browser)/./hooks/useSubscription.ts":
/*!**********************************!*\
  !*** ./hooks/useSubscription.ts ***!
  \**********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useSubscription: () => (/* binding */ useSubscription)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/../../node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_auth_react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next-auth/react */ \"(app-pages-browser)/../../node_modules/next-auth/react/index.js\");\n/* harmony import */ var next_auth_react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(next_auth_react__WEBPACK_IMPORTED_MODULE_1__);\n\n\n// Import types and utilities without initializing Stripe\nconst SUBSCRIPTION_TIERS = {\n    FREE: {\n        name: 'Free',\n        price: 0,\n        features: [\n            'Manual transaction entry',\n            'Basic budgeting',\n            'Local data storage',\n            'PDF/Excel reports',\n            'Up to 3 accounts'\n        ],\n        limits: {\n            users: 1,\n            accounts: 3,\n            transactions: 1000,\n            budgets: 5,\n            categories: 20\n        }\n    },\n    PLUS: {\n        name: 'Plus',\n        price: 2.99,\n        features: [\n            'Everything in Free',\n            'Multi-user collaboration',\n            'OCR receipt processing',\n            'Enhanced analytics',\n            'Up to 5 accounts',\n            'Priority support'\n        ],\n        limits: {\n            users: 5,\n            accounts: 5,\n            transactions: 10000,\n            budgets: 20,\n            categories: 50\n        }\n    },\n    PREMIUM: {\n        name: 'Premium',\n        price: 9.99,\n        features: [\n            'Everything in Plus',\n            'Bank account connections',\n            'Automatic transaction import',\n            'Investment account sync',\n            'Advanced automation',\n            'Tax optimization',\n            'Unlimited accounts'\n        ],\n        limits: {\n            users: 10,\n            accounts: 999,\n            transactions: 999999,\n            budgets: 999,\n            categories: 999\n        }\n    }\n};\nconst canAccessFeature = (currentTier, requiredTier)=>{\n    const tierOrder = [\n        'FREE',\n        'PLUS',\n        'PREMIUM'\n    ];\n    const currentIndex = tierOrder.indexOf(currentTier);\n    const requiredIndex = tierOrder.indexOf(requiredTier);\n    return currentIndex >= requiredIndex;\n};\nconst checkUsageLimit = (tier, resource, currentCount)=>{\n    const tierConfig = SUBSCRIPTION_TIERS[tier];\n    if (!tierConfig) return false;\n    const limit = tierConfig.limits[resource];\n    return currentCount < limit;\n};\nconst getUpgradeMessage = (currentTier, requiredTier)=>{\n    if (requiredTier === 'PLUS') {\n        return 'Upgrade to Plus ($2.99/month) to access this feature';\n    }\n    if (requiredTier === 'PREMIUM') {\n        return 'Upgrade to Premium ($9.99/month) to access this feature';\n    }\n    return 'Please upgrade to access this feature';\n};\nconst FEATURE_TIER_MAP = {\n    multiUser: 'PLUS',\n    ocrReceipts: 'PLUS',\n    prioritySync: 'PLUS',\n    enhancedInvestments: 'PLUS',\n    bankConnections: 'PREMIUM',\n    investmentSync: 'PREMIUM'\n};\nfunction useSubscription() {\n    var _session_user;\n    const { data: session } = (0,next_auth_react__WEBPACK_IMPORTED_MODULE_1__.useSession)();\n    const [subscription, setSubscription] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const fetchSubscriptionStatus = async ()=>{\n        var _session_user;\n        if (!(session === null || session === void 0 ? void 0 : (_session_user = session.user) === null || _session_user === void 0 ? void 0 : _session_user.email)) {\n            // Default to free tier for unauthenticated users\n            setSubscription({\n                tier: 'FREE',\n                tierName: 'Free',\n                price: 0,\n                features: SUBSCRIPTION_TIERS.FREE.features,\n                limits: SUBSCRIPTION_TIERS.FREE.limits,\n                isActive: true\n            });\n            setIsLoading(false);\n            return;\n        }\n        try {\n            setError(null);\n            // Check localStorage first for demo mode subscription overrides\n            const localSubscriptionKey = \"demo_subscription_\".concat(session.user.email);\n            const localSubscription = localStorage.getItem(localSubscriptionKey);\n            if (localSubscription) {\n                const parsedSubscription = JSON.parse(localSubscription);\n                console.log('Loading demo subscription from localStorage:', parsedSubscription);\n                setSubscription(parsedSubscription);\n                setIsLoading(false);\n                return;\n            }\n            const response = await fetch('/api/subscriptions/status');\n            if (!response.ok) {\n                throw new Error(\"HTTP error! status: \".concat(response.status));\n            }\n            const data = await response.json();\n            setSubscription(data);\n        } catch (err) {\n            console.error('Failed to fetch subscription status:', err);\n            setError('Failed to load subscription status');\n            // Fallback to free tier\n            const fallbackSubscription = {\n                tier: 'FREE',\n                tierName: 'Free',\n                price: 0,\n                features: SUBSCRIPTION_TIERS.FREE.features,\n                limits: SUBSCRIPTION_TIERS.FREE.limits,\n                isActive: true\n            };\n            setSubscription(fallbackSubscription);\n        } finally{\n            setIsLoading(false);\n        }\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useSubscription.useEffect\": ()=>{\n            fetchSubscriptionStatus();\n        }\n    }[\"useSubscription.useEffect\"], [\n        session === null || session === void 0 ? void 0 : (_session_user = session.user) === null || _session_user === void 0 ? void 0 : _session_user.email\n    ]);\n    const canAccess = (requiredTier)=>{\n        if (!subscription) return false;\n        return canAccessFeature(subscription.tier, requiredTier);\n    };\n    const canUseFeature = (feature)=>{\n        const requiredTier = FEATURE_TIER_MAP[feature];\n        return canAccess(requiredTier);\n    };\n    const canAddResource = (resource, currentCount)=>{\n        if (!subscription) return false;\n        return checkUsageLimit(subscription.tier, resource, currentCount);\n    };\n    const getResourceLimit = (resource)=>{\n        if (!subscription) return SUBSCRIPTION_TIERS.FREE.limits[resource];\n        return subscription.limits[resource];\n    };\n    const needsUpgrade = (requiredTier)=>{\n        return !canAccess(requiredTier);\n    };\n    const getUpgradeMessageForTier = (requiredTier)=>{\n        if (!subscription) return 'Please sign in to access this feature';\n        return getUpgradeMessage(subscription.tier, requiredTier);\n    };\n    const upgrade = async (tier)=>{\n        try {\n            const response = await fetch('/api/subscriptions/create-checkout', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify({\n                    tier\n                })\n            });\n            if (response.ok) {\n                const { checkoutUrl } = await response.json();\n                window.location.href = checkoutUrl;\n            } else {\n                // Handle demo mode gracefully\n                try {\n                    const errorData = await response.json();\n                    if (errorData.isDemoMode) {\n                        console.log('Demo mode: Simulating upgrade to', tier);\n                        // Show notification about what would normally happen\n                        const confirmed = window.confirm(\"\\uD83D\\uDED2 Demo Mode Simulation\\n\\n\" + \"In a real environment, this would:\\n\" + \"• Redirect you to Stripe checkout\\n\" + \"• Process payment for \".concat(tier, \" ($\").concat(SUBSCRIPTION_TIERS[tier].price, \"/month)\\n\") + \"• Update your subscription\\n\\n\" + \"For this demo, we'll simulate the upgrade locally.\\n\\n\" + \"Proceed with demo upgrade to \".concat(tier, \"?\"));\n                        if (confirmed) {\n                            var _session_user;\n                            // Simulate the tier upgrade locally\n                            const newSubscription = {\n                                tier: tier,\n                                tierName: SUBSCRIPTION_TIERS[tier].name,\n                                price: SUBSCRIPTION_TIERS[tier].price,\n                                features: SUBSCRIPTION_TIERS[tier].features,\n                                limits: SUBSCRIPTION_TIERS[tier].limits,\n                                isActive: true\n                            };\n                            setSubscription(newSubscription);\n                            // Save to localStorage for persistence across navigation\n                            if (session === null || session === void 0 ? void 0 : (_session_user = session.user) === null || _session_user === void 0 ? void 0 : _session_user.email) {\n                                const localSubscriptionKey = \"demo_subscription_\".concat(session.user.email);\n                                localStorage.setItem(localSubscriptionKey, JSON.stringify(newSubscription));\n                                console.log('Saved demo subscription to localStorage:', newSubscription);\n                            }\n                            // Show success message\n                            alert(\"✅ Demo upgrade successful!\\n\\nYou are now on the \".concat(tier, \" plan ($\").concat(SUBSCRIPTION_TIERS[tier].price, \"/month).\\n\\nThis is a local simulation - no actual billing occurred.\"));\n                            return; // Success, don't throw error\n                        } else {\n                            throw new Error('Upgrade cancelled by user');\n                        }\n                    } else {\n                        throw new Error(errorData.error || 'Failed to create checkout session');\n                    }\n                } catch (parseError) {\n                    throw new Error(\"Demo Mode: Stripe not configured. Would upgrade to \".concat(tier, \" ($\").concat(SUBSCRIPTION_TIERS[tier].price, \"/month)\"));\n                }\n            }\n        } catch (err) {\n            console.error('Error starting upgrade:', err);\n            throw err;\n        }\n    };\n    const manageBilling = async ()=>{\n        try {\n            const response = await fetch('/api/subscriptions/create-portal', {\n                method: 'POST'\n            });\n            if (response.ok) {\n                const { portalUrl } = await response.json();\n                window.location.href = portalUrl;\n            } else {\n                // Handle demo mode gracefully\n                console.log('Demo mode: Billing management requested');\n                // Show demo billing management options\n                const options = \"Demo Billing Management\\n\\nAvailable options:\\n• Downgrade to Free (cancel subscription)\\n• View current plan details\\n• Simulate plan changes\";\n                if ((subscription === null || subscription === void 0 ? void 0 : subscription.tier) !== 'FREE') {\n                    const confirmed = window.confirm(\"\".concat(options, \"\\n\\nWould you like to downgrade to the Free plan?\\n\\n(This simulates canceling your subscription)\"));\n                    if (confirmed) {\n                        // Simulate downgrade to free\n                        setSubscription({\n                            tier: 'FREE',\n                            tierName: SUBSCRIPTION_TIERS.FREE.name,\n                            price: SUBSCRIPTION_TIERS.FREE.price,\n                            features: SUBSCRIPTION_TIERS.FREE.features,\n                            limits: SUBSCRIPTION_TIERS.FREE.limits,\n                            isActive: true\n                        });\n                        alert(\"✅ Demo downgrade successful!\\n\\nYou are now on the Free plan.\\n\\nThis is a local simulation - no actual billing changes occurred.\");\n                        return; // Success, don't throw error\n                    }\n                } else {\n                    alert('Demo Mode: You are already on the Free plan.\\n\\nIn a real environment, this would open the Stripe billing portal.');\n                }\n                throw new Error('Demo Mode: Billing portal simulation completed');\n            }\n        } catch (err) {\n            console.error('Error opening billing portal:', err);\n            throw err;\n        }\n    };\n    const refresh = async ()=>{\n        setIsLoading(true);\n        await fetchSubscriptionStatus();\n    };\n    return {\n        subscription,\n        isLoading,\n        error,\n        canAccess,\n        canUseFeature,\n        canAddResource,\n        getResourceLimit,\n        getUpgradeMessage: getUpgradeMessageForTier,\n        needsUpgrade,\n        refresh,\n        upgrade,\n        manageBilling\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2hvb2tzL3VzZVN1YnNjcmlwdGlvbi50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUE0QztBQUNDO0FBRTdDLHlEQUF5RDtBQUN6RCxNQUFNRyxxQkFBcUI7SUFDekJDLE1BQU07UUFDSkMsTUFBTTtRQUNOQyxPQUFPO1FBQ1BDLFVBQVU7WUFDUjtZQUNBO1lBQ0E7WUFDQTtZQUNBO1NBQ0Q7UUFDREMsUUFBUTtZQUNOQyxPQUFPO1lBQ1BDLFVBQVU7WUFDVkMsY0FBYztZQUNkQyxTQUFTO1lBQ1RDLFlBQVk7UUFDZDtJQUNGO0lBQ0FDLE1BQU07UUFDSlQsTUFBTTtRQUNOQyxPQUFPO1FBQ1BDLFVBQVU7WUFDUjtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7U0FDRDtRQUNEQyxRQUFRO1lBQ05DLE9BQU87WUFDUEMsVUFBVTtZQUNWQyxjQUFjO1lBQ2RDLFNBQVM7WUFDVEMsWUFBWTtRQUNkO0lBQ0Y7SUFDQUUsU0FBUztRQUNQVixNQUFNO1FBQ05DLE9BQU87UUFDUEMsVUFBVTtZQUNSO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1NBQ0Q7UUFDREMsUUFBUTtZQUNOQyxPQUFPO1lBQ1BDLFVBQVU7WUFDVkMsY0FBYztZQUNkQyxTQUFTO1lBQ1RDLFlBQVk7UUFDZDtJQUNGO0FBQ0Y7QUFFQSxNQUFNRyxtQkFBbUIsQ0FBQ0MsYUFBcUJDO0lBQzdDLE1BQU1DLFlBQVk7UUFBQztRQUFRO1FBQVE7S0FBVTtJQUM3QyxNQUFNQyxlQUFlRCxVQUFVRSxPQUFPLENBQUNKO0lBQ3ZDLE1BQU1LLGdCQUFnQkgsVUFBVUUsT0FBTyxDQUFDSDtJQUN4QyxPQUFPRSxnQkFBZ0JFO0FBQ3pCO0FBRUEsTUFBTUMsa0JBQWtCLENBQUNDLE1BQWNDLFVBQWtCQztJQUN2RCxNQUFNQyxhQUFheEIsa0JBQWtCLENBQUNxQixLQUF3QztJQUM5RSxJQUFJLENBQUNHLFlBQVksT0FBTztJQUN4QixNQUFNQyxRQUFRRCxXQUFXbkIsTUFB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QU02QixVQUFVO1FBQ2RwRCxhQUFhO1FBQ2IsTUFBTUc7SUFDUjtJQUVBLE9BQU87UUFDTE47UUFDQUU7UUFDQUU7UUFDQXdCO1FBQ0FDO1FBQ0FFO1FBQ0FDO1FBQ0EzQyxtQkFBbUI2QztRQUNuQkQ7UUFDQXNCO1FBQ0FwQjtRQUNBaUI7SUFDRjtBQUNGIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXG5hdGhhXFxPbmVEcml2ZVxcRGVza3RvcFxcTW9uZXlRdWVzdFYzXFxwYWNrYWdlc1xcd2Vic2l0ZVxcaG9va3NcXHVzZVN1YnNjcmlwdGlvbi50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlU2Vzc2lvbiB9IGZyb20gJ25leHQtYXV0aC9yZWFjdCc7XG5cbi8vIEltcG9ydCB0eXBlcyBhbmQgdXRpbGl0aWVzIHdpdGhvdXQgaW5pdGlhbGl6aW5nIFN0cmlwZVxuY29uc3QgU1VCU0NSSVBUSU9OX1RJRVJTID0ge1xuICBGUkVFOiB7XG4gICAgbmFtZTogJ0ZyZWUnLFxuICAgIHByaWNlOiAwLFxuICAgIGZlYXR1cmVzOiBbXG4gICAgICAnTWFudWFsIHRyYW5zYWN0aW9uIGVudHJ5JyxcbiAgICAgICdCYXNpYyBidWRnZXRpbmcnLFxuICAgICAgJ0xvY2FsIGRhdGEgc3RvcmFnZScsXG4gICAgICAnUERGL0V4Y2VsIHJlcG9ydHMnLFxuICAgICAgJ1VwIHRvIDMgYWNjb3VudHMnXG4gICAgXSxcbiAgICBsaW1pdHM6IHtcbiAgICAgIHVzZXJzOiAxLFxuICAgICAgYWNjb3VudHM6IDMsXG4gICAgICB0cmFuc2FjdGlvbnM6IDEwMDAsXG4gICAgICBidWRnZXRzOiA1LFxuICAgICAgY2F0ZWdvcmllczogMjBcbiAgICB9XG4gIH0sXG4gIFBMVVM6IHtcbiAgICBuYW1lOiAnUGx1cycsXG4gICAgcHJpY2U6IDIuOTksXG4gICAgZmVhdHVyZXM6IFtcbiAgICAgICdFdmVyeXRoaW5nIGluIEZyZWUnLFxuICAgICAgJ011bHRpLXVzZXIgY29sbGFib3JhdGlvbicsXG4gICAgICAnT0NSIHJlY2VpcHQgcHJvY2Vzc2luZycsXG4gICAgICAnRW5oYW5jZWQgYW5hbHl0aWNzJyxcbiAgICAgICdVcCB0byA1IGFjY291bnRzJyxcbiAgICAgICdQcmlvcml0eSBzdXBwb3J0J1xuICAgIF0sXG4gICAgbGltaXRzOiB7XG4gICAgICB1c2VyczogNSxcbiAgICAgIGFjY291bnRzOiA1LFxuICAgICAgdHJhbnNhY3Rpb25zOiAxMDAwMCxcbiAgICAgIGJ1ZGdldHM6IDIwLFxuICAgICAgY2F0ZWdvcmllczogNTBcbiAgICB9XG4gIH0sXG4gIFBSRU1JVU06IHtcbiAgICBuYW1lOiAnUHJlbWl1bScsXG4gICAgcHJpY2U6IDkuOTksXG4gICAgZmVhdHVyZXM6IFtcbiAgICAgICdFdmVyeXRoaW5nIGluIFBsdXMnLFxuICAgICAgJ0JhbmsgYWNjb3VudCBjb25uZWN0aW9ucycsXG4gICAgICAnQXV0b21hdGljIHRyYW5zYWN0aW9uIGltcG9ydCcsXG4gICAgICAnSW52ZXN0bWVudCBhY2NvdW50IHN5bmMnLFxuICAgICAgJ0FkdmFuY2VkIGF1dG9tYXRpb24nLFxuICAgICAgJ1RheCBvcHRpbWl6YXRpb24nLFxuICAgICAgJ1VubGltaXRlZCBhY2NvdW50cydcbiAgICBdLFxuICAgIGxpbWl0czoge1xuICAgICAgdXNlcnM6IDEwLFxuICAgICAgYWNjb3VudHM6IDk5OSxcbiAgICAgIHRyYW5zYWN0aW9uczogOTk5OTk5LFxuICAgICAgYnVkZ2V0czogOTk5LFxuICAgICAgY2F0ZWdvcmllczogOTk5XG4gICAgfVxuICB9XG59IGFzIGNvbnN0O1xuXG5jb25zdCBjYW5BY2Nlc3NGZWF0dXJlID0gKGN1cnJlbnRUaWVyOiBzdHJpbmcsIHJlcXVpcmVkVGllcjogc3RyaW5nKTogYm9vbGVhbiA9PiB7XG4gIGNvbnN0IHRpZXJPcmRlciA9IFsnRlJFRScsICdQTFVTJywgJ1BSRU1JVU0nXTtcbiAgY29uc3QgY3VycmVudEluZGV4ID0gdGllck9yZGVyLmluZGV4T2YoY3VycmVudFRpZXIpO1xuICBjb25zdCByZXF1aXJlZEluZGV4ID0gdGllck9yZGVyLmluZGV4T2YocmVxdWlyZWRUaWVyKTtcbiAgcmV0dXJuIGN1cnJlbnRJbmRleCA+PSByZXF1aXJlZEluZGV4O1xufTtcblxuY29uc3QgY2hlY2tVc2FnZUxpbWl0ID0gKHRpZXI6IHN0cmluZywgcmVzb3VyY2U6IHN0cmluZywgY3VycmVudENvdW50OiBudW1iZXIpOiBib29sZWFuID0+IHtcbiAgY29uc3QgdGllckNvbmZpZyA9IFNVQlNDUklQVElPTl9USUVSU1t0aWVyIGFzIGtleW9mIHR5cGVvZiBTVUJTQ1JJUFRJT05fVElFUlNdO1xuICBpZiAoIXRpZXJDb25maWcpIHJldHVybiBmYWxzZTtcbiAgY29uc3QgbGltaXQgPSB0aWVyQ29uZmlnLmxpbWl0c1tyZXNvdXJjZSBhcyBrZXlvZiB0eXBlb2YgdGllckNvbmZpZy5saW1pdHNdO1xuICByZXR1cm4gY3VycmVudENvdW50IDwgbGltaXQ7XG59O1xuXG5jb25zdCBnZXRVcGdyYWRlTWVzc2FnZSA9IChjdXJyZW50VGllcjogc3RyaW5nLCByZXF1aXJlZFRpZXI6IHN0cmluZyk6IHN0cmluZyA9PiB7XG4gIGlmIChyZXF1aXJlZFRpZXIgPT09ICdQTFVTJykge1xuICAgIHJldHVybiAnVXBncmFkZSB0byBQbHVzICgkMi45OS9tb250aCkgdG8gYWNjZXNzIHRoaXMgZmVhdHVyZSc7XG4gIH1cbiAgaWYgKHJlcXVpcmVkVGllciA9PT0gJ1BSRU1JVU0nKSB7XG4gICAgcmV0dXJuICdVcGdyYWRlIHRvIFByZW1pdW0gKCQ5Ljk5L21vbnRoKSB0byBhY2Nlc3MgdGhpcyBmZWF0dXJlJztcbiAgfVxuICByZXR1cm4gJ1BsZWFzZSB1cGdyYWRlIHRvIGFjY2VzcyB0aGlzIGZlYXR1cmUnO1xufTtcblxuZXhwb3J0IGludGVyZmFjZSBTdWJzY3JpcHRpb25TdGF0dXMge1xuICB0aWVyOiAnRlJFRScgfCAnUExVUycgfCAnUFJFTUlVTSc7XG4gIHRpZXJOYW1lOiBzdHJpbmc7XG4gIHByaWNlOiBudW1iZXI7XG4gIGZlYXR1cmVzOiBzdHJpbmdbXTtcbiAgbGltaXRzOiB7XG4gICAgdXNlcnM6IG51bWJlcjtcbiAgICBhY2NvdW50czogbnVtYmVyO1xuICAgIHRyYW5zYWN0aW9uczogbnVtYmVyO1xuICAgIGJ1ZGdldHM6IG51bWJlcjtcbiAgICBjYXRlZ29yaWVzOiBudW1iZXI7XG4gIH07XG4gIGlzQWN0aXZlOiBib29sZWFuO1xuICBzdHJpcGVTdWJzY3JpcHRpb24/OiB7XG4gICAgaWQ6IHN0cmluZztcbiAgICBzdGF0dXM6IHN0cmluZztcbiAgICBjdXJyZW50UGVyaW9kU3RhcnQ6IERhdGU7XG4gICAgY3VycmVudFBlcmlvZEVuZDogRGF0ZTtcbiAgICBjYW5jZWxBdFBlcmlvZEVuZDogYm9vbGVhbjtcbiAgfTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VTdWJzY3JpcHRpb25SZXR1cm4ge1xuICBzdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvblN0YXR1cyB8IG51bGw7XG4gIGlzTG9hZGluZzogYm9vbGVhbjtcbiAgZXJyb3I6IHN0cmluZyB8IG51bGw7XG5cbiAgLy8gRmVhdHVyZSBhY2Nlc3MgY2hlY2tzXG4gIGNhbkFjY2VzczogKHJlcXVpcmVkVGllcjogJ0ZSRUUnIHwgJ1BMVVMnIHwgJ1BSRU1JVU0nKSA9PiBib29sZWFuO1xuICBjYW5Vc2VGZWF0dXJlOiAoZmVhdHVyZTogJ211bHRpVXNlcicgfCAnb2NyUmVjZWlwdHMnIHwgJ3ByaW9yaXR5U3luYycgfCAnZW5oYW5jZWRJbnZlc3RtZW50cycgfCAnYmFua0Nvbm5lY3Rpb25zJyB8ICdpbnZlc3RtZW50U3luYycpID0+IGJvb2xlYW47XG5cbiAgLy8gVXNhZ2UgbGltaXQgY2hlY2tzXG4gIGNhbkFkZFJlc291cmNlOiAocmVzb3VyY2U6ICd1c2VycycgfCAnYWNjb3VudHMnIHwgJ2J1ZGdldHMnIHwgJ2NhdGVnb3JpZXMnLCBjdXJyZW50Q291bnQ6IG51bWJlcikgPT4gYm9vbGVhbjtcbiAgZ2V0UmVzb3VyY2VMaW1pdDogKHJlc291cmNlOiAndXNlcnMnIHwgJ2FjY291bnRzJyB8ICdidWRnZXRzJyB8ICdjYXRlZ29yaWVzJykgPT4gbnVtYmVyO1xuXG4gIC8vIFVwZ3JhZGUgaGVscGVyc1xuICBnZXRVcGdyYWRlTWVzc2FnZTogKHJlcXVpcmVkVGllcjogJ0ZSRUUnIHwgJ1BMVVMnIHwgJ1BSRU1JVU0nKSA9PiBzdHJpbmc7XG4gIG5lZWRzVXBncmFkZTogKHJlcXVpcmVkVGllcjogJ0ZSRUUnIHwgJ1BMVVMnIHwgJ1BSRU1JVU0nKSA9PiBib29sZWFuO1xuXG4gIC8vIEFjdGlvbnNcbiAgcmVmcmVzaDogKCkgPT4gUHJvbWlzZTx2b2lkPjtcbiAgdXBncmFkZTogKHRpZXI6ICdQTFVTJyB8ICdQUkVNSVVNJykgPT4gUHJvbWlzZTx2b2lkPjtcbiAgbWFuYWdlQmlsbGluZzogKCkgPT4gUHJvbWlzZTx2b2lkPjtcbn1cblxuY29uc3QgRkVBVFVSRV9USUVSX01BUCA9IHtcbiAgbXVsdGlVc2VyOiAnUExVUycsXG4gIG9jclJlY2VpcHRzOiAnUExVUycsXG4gIHByaW9yaXR5U3luYzogJ1BMVVMnLFxuICBlbmhhbmNlZEludmVzdG1lbnRzOiAnUExVUycsXG4gIGJhbmtDb25uZWN0aW9uczogJ1BSRU1JVU0nLFxuICBpbnZlc3RtZW50U3luYzogJ1BSRU1JVU0nLFxufSBhcyBjb25zdDtcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVN1YnNjcmlwdGlvbigpOiBVc2VTdWJzY3JpcHRpb25SZXR1cm4ge1xuICBjb25zdCB7IGRhdGE6IHNlc3Npb24gfSA9IHVzZVNlc3Npb24oKTtcbiAgY29uc3QgW3N1YnNjcmlwdGlvbiwgc2V0U3Vic2NyaXB0aW9uXSA9IHVzZVN0YXRlPFN1YnNjcmlwdGlvblN0YXR1cyB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbaXNMb2FkaW5nLCBzZXRJc0xvYWRpbmddID0gdXNlU3RhdGUodHJ1ZSk7XG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG5cbiAgY29uc3QgZmV0Y2hTdWJzY3JpcHRpb25TdGF0dXMgPSBhc3luYyAoKSA9PiB7XG4gICAgaWYgKCFzZXNzaW9uPy51c2VyPy5lbWFpbCkge1xuICAgICAgLy8gRGVmYXVsdCB0byBmcmVlIHRpZXIgZm9yIHVuYXV0aGVudGljYXRlZCB1c2Vyc1xuICAgICAgc2V0U3Vic2NyaXB0aW9uKHtcbiAgICAgICAgdGllcjogJ0ZSRUUnLFxuICAgICAgICB0aWVyTmFtZTogJ0ZyZWUnLFxuICAgICAgICBwcmljZTogMCxcbiAgICAgICAgZmVhdHVyZXM6IFNVQlNDUklQVElPTl9USUVSUy5GUkVFLmZlYXR1cmVzLFxuICAgICAgICBsaW1pdHM6IFNVQlNDUklQVElPTl9USUVSUy5GUkVFLmxpbWl0cyxcbiAgICAgICAgaXNBY3RpdmU6IHRydWUsXG4gICAgICB9KTtcbiAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHNldEVycm9yKG51bGwpO1xuXG4gICAgICAvLyBDaGVjayBsb2NhbFN0b3JhZ2UgZmlyc3QgZm9yIGRlbW8gbW9kZSBzdWJzY3JpcHRpb24gb3ZlcnJpZGVzXG4gICAgICBjb25zdCBsb2NhbFN1YnNjcmlwdGlvbktleSA9IGBkZW1vX3N1YnNjcmlwdGlvbl8ke3Nlc3Npb24udXNlci5lbWFpbH1gO1xuICAgICAgY29uc3QgbG9jYWxTdWJzY3JpcHRpb24gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShsb2NhbFN1YnNjcmlwdGlvbktleSk7XG5cbiAgICAgIGlmIChsb2NhbFN1YnNjcmlwdGlvbikge1xuICAgICAgICBjb25zdCBwYXJzZWRTdWJzY3JpcHRpb24gPSBKU09OLnBhcnNlKGxvY2FsU3Vic2NyaXB0aW9uKTtcbiAgICAgICAgY29uc29sZS5sb2coJ0xvYWRpbmcgZGVtbyBzdWJzY3JpcHRpb24gZnJvbSBsb2NhbFN0b3JhZ2U6JywgcGFyc2VkU3Vic2NyaXB0aW9uKTtcbiAgICAgICAgc2V0U3Vic2NyaXB0aW9uKHBhcnNlZFN1YnNjcmlwdGlvbik7XG4gICAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2FwaS9zdWJzY3JpcHRpb25zL3N0YXR1cycpO1xuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCBlcnJvciEgc3RhdHVzOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIHNldFN1YnNjcmlwdGlvbihkYXRhKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBmZXRjaCBzdWJzY3JpcHRpb24gc3RhdHVzOicsIGVycik7XG4gICAgICBzZXRFcnJvcignRmFpbGVkIHRvIGxvYWQgc3Vic2NyaXB0aW9uIHN0YXR1cycpO1xuXG4gICAgICAvLyBGYWxsYmFjayB0byBmcmVlIHRpZXJcbiAgICAgIGNvbnN0IGZhbGxiYWNrU3Vic2NyaXB0aW9uID0ge1xuICAgICAgICB0aWVyOiAnRlJFRScsXG4gICAgICAgIHRpZXJOYW1lOiAnRnJlZScsXG4gICAgICAgIHByaWNlOiAwLFxuICAgICAgICBmZWF0dXJlczogU1VCU0NSSVBUSU9OX1RJRVJTLkZSRUUuZmVhdHVyZXMsXG4gICAgICAgIGxpbWl0czogU1VCU0NSSVBUSU9OX1RJRVJTLkZSRUUubGltaXRzLFxuICAgICAgICBpc0FjdGl2ZTogdHJ1ZSxcbiAgICAgIH07XG4gICAgICBzZXRTdWJzY3JpcHRpb24oZmFsbGJhY2tTdWJzY3JpcHRpb24pO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgIH1cbiAgfTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGZldGNoU3Vic2NyaXB0aW9uU3RhdHVzKCk7XG4gIH0sIFtzZXNzaW9uPy51c2VyPy5lbWFpbF0pO1xuXG4gIGNvbnN0IGNhbkFjY2VzcyA9IChyZXF1aXJlZFRpZXI6ICdGUkVFJyB8ICdQTFVTJyB8ICdQUkVNSVVNJyk6IGJvb2xlYW4gPT4ge1xuICAgIGlmICghc3Vic2NyaXB0aW9uKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIGNhbkFjY2Vzc0ZlYXR1cmUoc3Vic2NyaXB0aW9uLnRpZXIsIHJlcXVpcmVkVGllcik7XG4gIH07XG5cbiAgY29uc3QgY2FuVXNlRmVhdHVyZSA9IChmZWF0dXJlOiBrZXlvZiB0eXBlb2YgRkVBVFVSRV9USUVSX01BUCk6IGJvb2xlYW4gPT4ge1xuICAgIGNvbnN0IHJlcXVpcmVkVGllciA9IEZFQVRVUkVfVElFUl9NQVBbZmVhdHVyZV07XG4gICAgcmV0dXJuIGNhbkFjY2VzcyhyZXF1aXJlZFRpZXIpO1xuICB9O1xuXG4gIGNvbnN0IGNhbkFkZFJlc291cmNlID0gKHJlc291cmNlOiAndXNlcnMnIHwgJ2FjY291bnRzJyB8ICdidWRnZXRzJyB8ICdjYXRlZ29yaWVzJywgY3VycmVudENvdW50OiBudW1iZXIpOiBib29sZWFuID0+IHtcbiAgICBpZiAoIXN1YnNjcmlwdGlvbikgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBjaGVja1VzYWdlTGltaXQoc3Vic2NyaXB0aW9uLnRpZXIsIHJlc291cmNlLCBjdXJyZW50Q291bnQpO1xuICB9O1xuXG4gIGNvbnN0IGdldFJlc291cmNlTGltaXQgPSAocmVzb3VyY2U6ICd1c2VycycgfCAnYWNjb3VudHMnIHwgJ2J1ZGdldHMnIHwgJ2NhdGVnb3JpZXMnKTogbnVtYmVyID0+IHtcbiAgICBpZiAoIXN1YnNjcmlwdGlvbikgcmV0dXJuIFNVQlNDUklQVElPTl9USUVSUy5GUkVFLmxpbWl0c1tyZXNvdXJjZV07XG4gICAgcmV0dXJuIHN1YnNjcmlwdGlvbi5saW1pdHNbcmVzb3VyY2VdO1xuICB9O1xuXG4gIGNvbnN0IG5lZWRzVXBncmFkZSA9IChyZXF1aXJlZFRpZXI6ICdGUkVFJyB8ICdQTFVTJyB8ICdQUkVNSVVNJyk6IGJvb2xlYW4gPT4ge1xuICAgIHJldHVybiAhY2FuQWNjZXNzKHJlcXVpcmVkVGllcik7XG4gIH07XG5cbiAgY29uc3QgZ2V0VXBncmFkZU1lc3NhZ2VGb3JUaWVyID0gKHJlcXVpcmVkVGllcjogJ0ZSRUUnIHwgJ1BMVVMnIHwgJ1BSRU1JVU0nKTogc3RyaW5nID0+IHtcbiAgICBpZiAoIXN1YnNjcmlwdGlvbikgcmV0dXJuICdQbGVhc2Ugc2lnbiBpbiB0byBhY2Nlc3MgdGhpcyBmZWF0dXJlJztcbiAgICByZXR1cm4gZ2V0VXBncmFkZU1lc3NhZ2Uoc3Vic2NyaXB0aW9uLnRpZXIsIHJlcXVpcmVkVGllcik7XG4gIH07XG5cbiAgY29uc3QgdXBncmFkZSA9IGFzeW5jICh0aWVyOiAnUExVUycgfCAnUFJFTUlVTScpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2FwaS9zdWJzY3JpcHRpb25zL2NyZWF0ZS1jaGVja291dCcsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IHRpZXIgfSksXG4gICAgICB9KTtcblxuICAgICAgaWYgKHJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IHsgY2hlY2tvdXRVcmwgfSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBjaGVja291dFVybDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEhhbmRsZSBkZW1vIG1vZGUgZ3JhY2VmdWxseVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICBpZiAoZXJyb3JEYXRhLmlzRGVtb01vZGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdEZW1vIG1vZGU6IFNpbXVsYXRpbmcgdXBncmFkZSB0bycsIHRpZXIpO1xuXG4gICAgICAgICAgICAvLyBTaG93IG5vdGlmaWNhdGlvbiBhYm91dCB3aGF0IHdvdWxkIG5vcm1hbGx5IGhhcHBlblxuICAgICAgICAgICAgY29uc3QgY29uZmlybWVkID0gd2luZG93LmNvbmZpcm0oXG4gICAgICAgICAgICAgIGDwn5uSIERlbW8gTW9kZSBTaW11bGF0aW9uXFxuXFxuYCArXG4gICAgICAgICAgICAgIGBJbiBhIHJlYWwgZW52aXJvbm1lbnQsIHRoaXMgd291bGQ6XFxuYCArXG4gICAgICAgICAgICAgIGDigKIgUmVkaXJlY3QgeW91IHRvIFN0cmlwZSBjaGVja291dFxcbmAgK1xuICAgICAgICAgICAgICBg4oCiIFByb2Nlc3MgcGF5bWVudCBmb3IgJHt0aWVyfSAoJCR7U1VCU0NSSVBUSU9OX1RJRVJTW3RpZXJdLnByaWNlfS9tb250aClcXG5gICtcbiAgICAgICAgICAgICAgYOKAoiBVcGRhdGUgeW91ciBzdWJzY3JpcHRpb25cXG5cXG5gICtcbiAgICAgICAgICAgICAgYEZvciB0aGlzIGRlbW8sIHdlJ2xsIHNpbXVsYXRlIHRoZSB1cGdyYWRlIGxvY2FsbHkuXFxuXFxuYCArXG4gICAgICAgICAgICAgIGBQcm9jZWVkIHdpdGggZGVtbyB1cGdyYWRlIHRvICR7dGllcn0/YFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgaWYgKGNvbmZpcm1lZCkge1xuICAgICAgICAgICAgICAvLyBTaW11bGF0ZSB0aGUgdGllciB1cGdyYWRlIGxvY2FsbHlcbiAgICAgICAgICAgICAgY29uc3QgbmV3U3Vic2NyaXB0aW9uID0ge1xuICAgICAgICAgICAgICAgIHRpZXI6IHRpZXIsXG4gICAgICAgICAgICAgICAgdGllck5hbWU6IFNVQlNDUklQVElPTl9USUVSU1t0aWVyXS5uYW1lLFxuICAgICAgICAgICAgICAgIHByaWNlOiBTVUJTQ1JJUFRJT05fVElFUlNbdGllcl0ucHJpY2UsXG4gICAgICAgICAgICAgICAgZmVhdHVyZXM6IFNVQlNDUklQVElPTl9USUVSU1t0aWVyXS5mZWF0dXJlcyxcbiAgICAgICAgICAgICAgICBsaW1pdHM6IFNVQlNDUklQVElPTl9USUVSU1t0aWVyXS5saW1pdHMsXG4gICAgICAgICAgICAgICAgaXNBY3RpdmU6IHRydWUsXG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgc2V0U3Vic2NyaXB0aW9uKG5ld1N1YnNjcmlwdGlvbik7XG5cbiAgICAgICAgICAgICAgLy8gU2F2ZSB0byBsb2NhbFN0b3JhZ2UgZm9yIHBlcnNpc3RlbmNlIGFjcm9zcyBuYXZpZ2F0aW9uXG4gICAgICAgICAgICAgIGlmIChzZXNzaW9uPy51c2VyPy5lbWFpbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsU3Vic2NyaXB0aW9uS2V5ID0gYGRlbW9fc3Vic2NyaXB0aW9uXyR7c2Vzc2lvbi51c2VyLmVtYWlsfWA7XG4gICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0obG9jYWxTdWJzY3JpcHRpb25LZXksIEpTT04uc3RyaW5naWZ5KG5ld1N1YnNjcmlwdGlvbikpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdTYXZlZCBkZW1vIHN1YnNjcmlwdGlvbiB0byBsb2NhbFN0b3JhZ2U6JywgbmV3U3Vic2NyaXB0aW9uKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIFNob3cgc3VjY2VzcyBtZXNzYWdlXG4gICAgICAgICAgICAgIGFsZXJ0KGDinIUgRGVtbyB1cGdyYWRlIHN1Y2Nlc3NmdWwhXFxuXFxuWW91IGFyZSBub3cgb24gdGhlICR7dGllcn0gcGxhbiAoJCR7U1VCU0NSSVBUSU9OX1RJRVJTW3RpZXJdLnByaWNlfS9tb250aCkuXFxuXFxuVGhpcyBpcyBhIGxvY2FsIHNpbXVsYXRpb24gLSBubyBhY3R1YWwgYmlsbGluZyBvY2N1cnJlZC5gKTtcbiAgICAgICAgICAgICAgcmV0dXJuOyAvLyBTdWNjZXNzLCBkb24ndCB0aHJvdyBlcnJvclxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVcGdyYWRlIGNhbmNlbGxlZCBieSB1c2VyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEuZXJyb3IgfHwgJ0ZhaWxlZCB0byBjcmVhdGUgY2hlY2tvdXQgc2Vzc2lvbicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAocGFyc2VFcnJvcikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRGVtbyBNb2RlOiBTdHJpcGUgbm90IGNvbmZpZ3VyZWQuIFdvdWxkIHVwZ3JhZGUgdG8gJHt0aWVyfSAoJCR7U1VCU0NSSVBUSU9OX1RJRVJTW3RpZXJdLnByaWNlfS9tb250aClgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3Igc3RhcnRpbmcgdXBncmFkZTonLCBlcnIpO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBtYW5hZ2VCaWxsaW5nID0gYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL3N1YnNjcmlwdGlvbnMvY3JlYXRlLXBvcnRhbCcsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICB9KTtcblxuICAgICAgaWYgKHJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IHsgcG9ydGFsVXJsIH0gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gcG9ydGFsVXJsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSGFuZGxlIGRlbW8gbW9kZSBncmFjZWZ1bGx5XG4gICAgICAgIGNvbnNvbGUubG9nKCdEZW1vIG1vZGU6IEJpbGxpbmcgbWFuYWdlbWVudCByZXF1ZXN0ZWQnKTtcblxuICAgICAgICAvLyBTaG93IGRlbW8gYmlsbGluZyBtYW5hZ2VtZW50IG9wdGlvbnNcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IGBEZW1vIEJpbGxpbmcgTWFuYWdlbWVudFxcblxcbkF2YWlsYWJsZSBvcHRpb25zOlxcbuKAoiBEb3duZ3JhZGUgdG8gRnJlZSAoY2FuY2VsIHN1YnNjcmlwdGlvbilcXG7igKIgVmlldyBjdXJyZW50IHBsYW4gZGV0YWlsc1xcbuKAoiBTaW11bGF0ZSBwbGFuIGNoYW5nZXNgO1xuXG4gICAgICAgIGlmIChzdWJzY3JpcHRpb24/LnRpZXIgIT09ICdGUkVFJykge1xuICAgICAgICAgIGNvbnN0IGNvbmZpcm1lZCA9IHdpbmRvdy5jb25maXJtKFxuICAgICAgICAgICAgYCR7b3B0aW9uc31cXG5cXG5Xb3VsZCB5b3UgbGlrZSB0byBkb3duZ3JhZGUgdG8gdGhlIEZyZWUgcGxhbj9cXG5cXG4oVGhpcyBzaW11bGF0ZXMgY2FuY2VsaW5nIHlvdXIgc3Vic2NyaXB0aW9uKWBcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgaWYgKGNvbmZpcm1lZCkge1xuICAgICAgICAgICAgLy8gU2ltdWxhdGUgZG93bmdyYWRlIHRvIGZyZWVcbiAgICAgICAgICAgIHNldFN1YnNjcmlwdGlvbih7XG4gICAgICAgICAgICAgIHRpZXI6ICdGUkVFJyxcbiAgICAgICAgICAgICAgdGllck5hbWU6IFNVQlNDUklQVElPTl9USUVSUy5GUkVFLm5hbWUsXG4gICAgICAgICAgICAgIHByaWNlOiBTVUJTQ1JJUFRJT05fVElFUlMuRlJFRS5wcmljZSxcbiAgICAgICAgICAgICAgZmVhdHVyZXM6IFNVQlNDUklQVElPTl9USUVSUy5GUkVFLmZlYXR1cmVzLFxuICAgICAgICAgICAgICBsaW1pdHM6IFNVQlNDUklQVElPTl9USUVSUy5GUkVFLmxpbWl0cyxcbiAgICAgICAgICAgICAgaXNBY3RpdmU6IHRydWUsXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgYWxlcnQoYOKchSBEZW1vIGRvd25ncmFkZSBzdWNjZXNzZnVsIVxcblxcbllvdSBhcmUgbm93IG9uIHRoZSBGcmVlIHBsYW4uXFxuXFxuVGhpcyBpcyBhIGxvY2FsIHNpbXVsYXRpb24gLSBubyBhY3R1YWwgYmlsbGluZyBjaGFuZ2VzIG9jY3VycmVkLmApO1xuICAgICAgICAgICAgcmV0dXJuOyAvLyBTdWNjZXNzLCBkb24ndCB0aHJvdyBlcnJvclxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhbGVydCgnRGVtbyBNb2RlOiBZb3UgYXJlIGFscmVhZHkgb24gdGhlIEZyZWUgcGxhbi5cXG5cXG5JbiBhIHJlYWwgZW52aXJvbm1lbnQsIHRoaXMgd291bGQgb3BlbiB0aGUgU3RyaXBlIGJpbGxpbmcgcG9ydGFsLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZW1vIE1vZGU6IEJpbGxpbmcgcG9ydGFsIHNpbXVsYXRpb24gY29tcGxldGVkJyk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBvcGVuaW5nIGJpbGxpbmcgcG9ydGFsOicsIGVycik7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IHJlZnJlc2ggPSBhc3luYyAoKSA9PiB7XG4gICAgc2V0SXNMb2FkaW5nKHRydWUpO1xuICAgIGF3YWl0IGZldGNoU3Vic2NyaXB0aW9uU3RhdHVzKCk7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBzdWJzY3JpcHRpb24sXG4gICAgaXNMb2FkaW5nLFxuICAgIGVycm9yLFxuICAgIGNhbkFjY2VzcyxcbiAgICBjYW5Vc2VGZWF0dXJlLFxuICAgIGNhbkFkZFJlc291cmNlLFxuICAgIGdldFJlc291cmNlTGltaXQsXG4gICAgZ2V0VXBncmFkZU1lc3NhZ2U6IGdldFVwZ3JhZGVNZXNzYWdlRm9yVGllcixcbiAgICBuZWVkc1VwZ3JhZGUsXG4gICAgcmVmcmVzaCxcbiAgICB1cGdyYWRlLFxuICAgIG1hbmFnZUJpbGxpbmcsXG4gIH07XG59Il0sIm5hbWVzIjpbInVzZVN0YXRlIiwidXNlRWZmZWN0IiwidXNlU2Vzc2lvbiIsIlNVQlNDUklQVElPTl9USUVSUyIsIkZSRUUiLCJuYW1lIiwicHJpY2UiLCJmZWF0dXJlcyIsImxpbWl0cyIsInVzZXJzIiwiYWNjb3VudHMiLCJ0cmFuc2FjdGlvbnMiLCJidWRnZXRzIiwiY2F0ZWdvcmllcyIsIlBMVVMiLCJQUkVNSVVNIiwiY2FuQWNjZXNzRmVhdHVyZSIsImN1cnJlbnRUaWVyIiwicmVxdWlyZWRUaWVyIiwidGllck9yZGVyIiwiY3VycmVudEluZGV4IiwiaW5kZXhPZiIsInJlcXVpcmVkSW5kZXgiLCJjaGVja1VzYWdlTGltaXQiLCJ0aWVyIiwicmVzb3VyY2UiLCJjdXJyZW50Q291bnQiLCJ0aWVyQ29uZmlnIiwibGltaXQiLCJnZXRVcGdyYWRlTWVzc2FnZSIsIkZFQVRVUkVfVElFUl9NQVAiLCJtdWx0aVVzZXIiLCJvY3JSZWNlaXB0cyIsInByaW9yaXR5U3luYyIsImVuaGFuY2VkSW52ZXN0bWVudHMiLCJiYW5rQ29ubmVjdGlvbnMiLCJpbnZlc3RtZW50U3luYyIsInVzZVN1YnNjcmlwdGlvbiIsInNlc3Npb24iLCJkYXRhIiwic3Vic2NyaXB0aW9uIiwic2V0U3Vic2NyaXB0aW9uIiwiaXNMb2FkaW5nIiwic2V0SXNMb2FkaW5nIiwiZXJyb3IiLCJzZXRFcnJvciIsImZldGNoU3Vic2NyaXB0aW9uU3RhdHVzIiwidXNlciIsImVtYWlsIiwidGllck5hbWUiLCJpc0FjdGl2ZSIsImxvY2FsU3Vic2NyaXB0aW9uS2V5IiwibG9jYWxTdWJzY3JpcHRpb24iLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwicGFyc2VkU3Vic2NyaXB0aW9uIiwiSlNPTiIsInBhcnNlIiwiY29uc29sZSIsImxvZyIsInJlc3BvbnNlIiwiZmV0Y2giLCJvayIsIkVycm9yIiwic3RhdHVzIiwianNvbiIsImVyciIsImZhbGxiYWNrU3Vic2NyaXB0aW9uIiwiY2FuQWNjZXNzIiwiY2FuVXNlRmVhdHVyZSIsImZlYXR1cmUiLCJjYW5BZGRSZXNvdXJjZSIsImdldFJlc291cmNlTGltaXQiLCJuZWVkc1VwZ3JhZGUiLCJnZXRVcGdyYWRlTWVzc2FnZUZvclRpZXIiLCJ1cGdyYWRlIiwibWV0aG9kIiwiaGVhZGVycyIsImJvZHkiLCJzdHJpbmdpZnkiLCJjaGVja291dFVybCIsIndpbmRvdyIsImxvY2F0aW9uIiwiaHJlZiIsImVycm9yRGF0YSIsImlzRGVtb01vZGUiLCJjb25maXJtZWQiLCJjb25maXJtIiwibmV3U3Vic2NyaXB0aW9uIiwic2V0SXRlbSIsImFsZXJ0IiwicGFyc2VFcnJvciIsIm1hbmFnZUJpbGxpbmciLCJwb3J0YWxVcmwiLCJvcHRpb25zIiwicmVmcmVzaCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/useSubscription.ts\n"));

/***/ })

});